<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo原理及其常用命令</title>
    <url>/2017/04/02/aboutHexo/</url>
    <content><![CDATA[<h3 id="Hexo原理"><a href="#Hexo原理" class="headerlink" title="Hexo原理"></a>Hexo原理</h3><p>2017年4月1日使用Hexo+GitHub创建了自己的博客，主要用于生活和学习总结，经过两天的折腾，基本的博客雏形已经出来了，不得不说GitHub Pages真是个好东西。给赞。</p>
<p>对于Hexo，<a href="https://hexo.io/docs/" target="_blank" rel="noopener">官网文档</a> 解释为：</p>
<blockquote>
<p>Hexo is a fast, simple and powerful blog framework. You write posts in <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a> (or other languages) and Hexo generates static files with a beautiful theme in seconds.</p>
</blockquote>
<p><strong>generates static files</strong> 这就是Hexo的作用所在，我们都知道GitHub给了广大程序设计人员一个存放开源项目的平台，每个人都可以迭代更新自己的项目或参与开发其他人的项目，而GitHub Pages就是给你提供了一个平台来显示你博客的静态页面，注意是<strong>静态页面</strong>，因为GitHub Pages不支持动态语言，只能使用 html 拼合成博客。</p>
<p>Hexo就是这个生成静态页面的框架，流程如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">markdown**.md -&gt; hexo -&gt; **.html -&gt; github -&gt; update website</span><br></pre></td></tr></table></figure>
<p>你在本地编写并用Hexo生成了静态页面，存储在/public 目录下，然后push到GitHub上，GitHub展示了你的页面而已。</p>
<p>根据<a href="https://www.zhihu.com/question/51588481" target="_blank" rel="noopener">Hexo的原理是什么</a> 问题中<a href="https://www.zhihu.com/people/kong-chen-hao" target="_blank" rel="noopener">孔晨皓</a> 的回答：</p>
<blockquote>
<p>如果要做博客 wordpress 的思路是 php + MySql 而 gitpages 不支持动态语言，因此只能使用 html 拼合成博客</p>
<p>首先自己本地文件夹的 source 就是数据库，以 .md(markdown) 格式存储文章，</p>
<p>theme 文件夹是主题文件，以 .yml 等类型，决定了页面如何“组装”</p>
<p>每次运行 hexo g 命令，hexo(node.js程序)会遍历你的 source 目录，建立索引，根据你 theme 文件夹的主题生成页面到 public 文件夹。这时 public 文件夹就是一个纯由 html javascript css 等内容制作的博客，而这些恰好能在 git pages 识别</p>
</blockquote>
<p>而我们直接打开/public 目录中的**.html 是不能直接显示的，需要在命令行中执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>这条命令相当于hexo通过nide.js启动了一个本地服务器。</p>
<h3 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h3><p>详见<a href="https://segmentfault.com/a/1190000002632530" target="_blank" rel="noopener">hexo常用命令笔记</a> </p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>原理</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache2.4配置虚拟主机</title>
    <url>/2017/04/18/apachevirtualhost/</url>
    <content><![CDATA[<p>在开发项目的时候，每个项目对应的工程目录是不同的，想直接用一个自定义主机名来分别对应，这样就不用每次敲目录名了。Apache的虚拟主机可以实现这种功能。</p>
<p>配置虚拟主机有三种方式：</p>
<ul>
<li>基于IP地址</li>
<li>基于主机名</li>
<li>基于端口号</li>
</ul>
<p>本文主要介绍 <strong>基于主机名</strong> 和 <strong>基于端口号</strong> 这两种方式。</p>
<h3 id="基于主机名"><a href="#基于主机名" class="headerlink" title="基于主机名"></a>基于主机名</h3><p>我们安装好Apache后，如果成功安装，在浏览器中中输入 localhost 即可显示出欢迎界面，Apache 默认的监听端口是80端口，这里不用输入80端口号就可以。</p>
<p>首先修改 <em>C:\Windows\System32\drivers\etc</em> 目录下的 hosts 文件，如果修改时保存失败，第一种方式是可以修改 hosts 文件的安全属性，右键-&gt;属性-&gt;安全，赋予相应用户的权限即可；第二种方式是，使用管理员身份打开记事本，然后在记事本中打开 hosts 文件，进行如下修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Copyright (c) 1993-2009 Microsoft Corp.</span><br><span class="line">#</span><br><span class="line"># This is a sample HOSTS file used by Microsoft TCP/IP for Windows.</span><br><span class="line">#</span><br><span class="line"># This file contains the mappings of IP addresses to host names. Each</span><br><span class="line"># entry should be kept on an individual line. The IP address should</span><br><span class="line"># be placed in the first column followed by the corresponding host name.</span><br><span class="line"># The IP address and the host name should be separated by at least one</span><br><span class="line"># space.</span><br><span class="line">#</span><br><span class="line"># Additionally, comments (such as these) may be inserted on individual</span><br><span class="line"># lines or following the machine name denoted by a &apos;#&apos; symbol.</span><br><span class="line">#</span><br><span class="line"># For example:</span><br><span class="line">#</span><br><span class="line">#      102.54.94.97     rhino.acme.com          # source server</span><br><span class="line">#       38.25.63.10     x.acme.com              # x client host</span><br><span class="line"></span><br><span class="line"># localhost name resolution is handled within DNS itself.</span><br><span class="line">#	127.0.0.1       localhost</span><br><span class="line">#	::1             localhost</span><br><span class="line">192.168.1.105 windows10.microdone.cn</span><br><span class="line">127.0.0.1       myapp.com			// 自定义的主机名，名称不能与网上的域名冲突</span><br></pre></td></tr></table></figure>
<p>hosts 文件配置好后，打开 <em>\Apache24\conf</em> 目录下的 httpd.conf 文件，修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Virtual hosts</span><br><span class="line"># Include conf/extra/httpd-vhosts.conf</span><br><span class="line"></span><br><span class="line">将 # 去掉</span><br><span class="line"></span><br><span class="line"># Virtual hosts</span><br><span class="line">Include conf/extra/httpd-vhosts.conf</span><br></pre></td></tr></table></figure>
<p>然后打开 <em>\Apache24\conf\extra</em> 目录下的 httpd-vhosts.conf 文件，修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">    ServerAdmin YourName</span><br><span class="line">    DocumentRoot &quot;$&#123;SRVROOT&#125;/htdocs/laravel/public&quot;</span><br><span class="line">    ServerName myapp.com</span><br><span class="line">    ErrorLog &quot;$&#123;SRVROOT&#125;/htdocs/laravel/myapp.com-error.log&quot;</span><br><span class="line">    CustomLog &quot;$&#123;SRVROOT&#125;/htdocs/laravel/myapp.com-access.log&quot; common</span><br><span class="line">    &lt;Directory &quot;$&#123;SRVROOT&#125;/htdocs/laravel/public&quot;&gt;</span><br><span class="line">    	Options Indexes FollowSymLinks MultiViews</span><br><span class="line">		AllowOverride None</span><br><span class="line">		Require all granted</span><br><span class="line">	&lt;/Directory&gt;</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>
<p>DocumentRoot 对应虚拟主机主目录；<br>ServerName 对应主机名；<br>ErrorLog 对应错误日志存放路径；<br>CustomLog 对应访问日志存放路径；<br>其中的&lt; Directory &gt;&lt; Directory /&gt;对应相应地设置信息。</p>
<p>最后，在浏览器中输入 mapp.com/index.php 就可以访问不同目录了。</p>
<h3 id="基于端口号"><a href="#基于端口号" class="headerlink" title="基于端口号"></a>基于端口号</h3><p>打开 <em>\Apache24\conf</em> 目录下的 httpd.conf 文件，修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># Listen: Allows you to bind Apache to specific IP addresses and/or</span><br><span class="line"># ports, instead of the default. See also the &lt;VirtualHost&gt;</span><br><span class="line"># directive.</span><br><span class="line">#</span><br><span class="line"># Change this to Listen on specific IP addresses as shown below to </span><br><span class="line"># prevent Apache from glomming onto all bound IP addresses.</span><br><span class="line">#</span><br><span class="line">#Listen 12.34.56.78:80</span><br><span class="line">Listen 80</span><br><span class="line">Listen 8090		// 添加的apache监听的另一端口号，确保未被占用</span><br></pre></td></tr></table></figure>
<p>然后打开 <em>\Apache24\conf\extra</em> 目录下的 httpd-vhosts.conf 文件，修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;VirtualHost *:8090&gt;</span><br><span class="line">    ServerAdmin YourName</span><br><span class="line">    DocumentRoot &quot;$&#123;SRVROOT&#125;/htdocs/laravel/public&quot;</span><br><span class="line">    ServerName myapp.com</span><br><span class="line">    ErrorLog &quot;$&#123;SRVROOT&#125;/htdocs/laravel/myapp.com-error.log&quot;</span><br><span class="line">    CustomLog &quot;$&#123;SRVROOT&#125;/htdocs/laravel/myapp.com-access.log&quot; common</span><br><span class="line">    &lt;Directory &quot;$&#123;SRVROOT&#125;/htdocs/laravel/public&quot;&gt;</span><br><span class="line">    	Options Indexes FollowSymLinks MultiViews</span><br><span class="line">		AllowOverride None</span><br><span class="line">		Require all granted</span><br><span class="line">	&lt;/Directory&gt;</span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>
<p>以上通过两种方式实现了通过访问不同的主机名来访问不同目录，基于IP地址的方式请访问  <a href="http://www.cnblogs.com/hi-bazinga/archive/2012/04/23/2466605.html" target="_blank" rel="noopener">Apache 配置虚拟主机三种方式</a>  </p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Apache</tag>
        <tag>虚拟主机</tag>
      </tags>
  </entry>
  <entry>
    <title>重构改善既有代码的设计-代码的坏味道</title>
    <url>/2017/05/20/badtasteofcode/</url>
    <content><![CDATA[<p>《重构，改善既有代码的设计》一书中，将重构时机用味道来形容，“代码的坏味道”顾名思义就是我们的程序中存在一些不合理、难以理解、难以扩展的设计，本文参考书中的“坏味道条款”列举程序设计中可能遇到的可重构代码。</p>
<h4 id="Alternative-Class-with-Different-Interfaces"><a href="#Alternative-Class-with-Different-Interfaces" class="headerlink" title="Alternative Class with Different Interfaces"></a>Alternative Class with Different Interfaces</h4><p>说明：异曲同工的类。如果两个函数做同一件事儿，却有着不同的签名。</p>
<p>拟可重构方法：Rename Method(函数重命名)，Move Method(搬移函数)</p>
<h4 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h4><p>说明：过多的注释。并不是说不该写注释，但是过多无谓的注释，不如几行简洁的代码，毕竟代码说明了一切。</p>
<p>拟可重构方法：Extract Method(提炼函数)，Introduce Assertion(引入断言)</p>
<h4 id="Data-Class"><a href="#Data-Class" class="headerlink" title="Data Class"></a>Data Class</h4><p>说明：纯稚的类。某个类拥有一些字段，已经用于访问这些字段的函数。</p>
<p>拟可重构方法：Move Method(搬移函数)，Encapsulate Filed(封装字段)，Encapsulate Collection(封装集合)</p>
<h4 id="Data-Clumps"><a href="#Data-Clumps" class="headerlink" title="Data Clumps"></a>Data Clumps</h4><p>说明：数据泥团。比如多个类中有相同的字段，几个函数签名中有相同的参数。</p>
<p>拟可重构方法：Extract Class(提炼类)，Introduce Parameter Object(引入参数对象)，Preserve Whole Object(保持对象完整)</p>
<h4 id="Divergent-Change"><a href="#Divergent-Change" class="headerlink" title="Divergent Change"></a>Divergent Change</h4><p>说明：发散式变化。比如我们在一个类中，如果换一种数据库，需要修改这三个函数，如果出现一种新的解决办法，需要修改那四个函数。</p>
<p>拟可重构方法：Extract Class(提炼类)</p>
<h4 id="Duplicated-Code"><a href="#Duplicated-Code" class="headerlink" title="Duplicated Code"></a>Duplicated Code</h4><p>说明：重复代码。有重复就会有重构。</p>
<p>拟可重构方法：Extract Method(提炼函数)，Extract Class(提炼类)，Pull Up Method(函数上移)，Form Template Method(塑造模板函数)</p>
<h4 id="Feature-Envy"><a href="#Feature-Envy" class="headerlink" title="Feature Envy"></a>Feature Envy</h4><p>说明：依赖情结。某个函数对另一个类的依赖高于其所处的类。</p>
<p>拟可重构方法：Move Method(搬移函数)，Move Filed(搬移字段)，Extract Method(提炼函数)</p>
<h4 id="Inappropriate-Intimacy"><a href="#Inappropriate-Intimacy" class="headerlink" title="Inappropriate Intimacy"></a>Inappropriate Intimacy</h4><p>说明：狎昵关系。如果某一个类过渡访问另一个类的private字段，这就需要将这种关系拆散。</p>
<p>拟可重构方法：Move Method(搬移函数)，Move Filed(搬移字段)，Change Bidirectional Association to Unidirectional(将双向关联改为单向关联)，Replace Inheritance with Delegation(以委托取代继承)，Hide Delegation(隐藏委托关系)</p>
<h4 id="Incomplete-Library"><a href="#Incomplete-Library" class="headerlink" title="Incomplete Library"></a>Incomplete Library</h4><p>说明：不完美的库类。类库中提供的函数不足以我们的程序设计。</p>
<p>拟可重构方法：Introduce Foreign Method(引入外加函数)，Introduce Local Extension(引入本地扩展)</p>
<h4 id="Large-Class"><a href="#Large-Class" class="headerlink" title="Large Class"></a>Large Class</h4><p>说明：过大的类。</p>
<p>拟可重构方法：Extract Class(提炼类)，Extract Subclass(提炼子类)，Extract Interface(提炼接口)，Replace Data Value with Object(以对象取代数值)</p>
<h4 id="Lazy-Class"><a href="#Lazy-Class" class="headerlink" title="Lazy Class"></a>Lazy Class</h4><p>说明：冗赘类。如果某一个类的功能过于简单或者根本没有必要，我们去除这个类可以使代码更加简洁明了。</p>
<p>拟可重构方法：Inline Class(将类内联化)，Collapse Hierarchy(折叠继承关系)</p>
<h4 id="Long-Method"><a href="#Long-Method" class="headerlink" title="Long Method"></a>Long Method</h4><p>说明：过长的函数。程序越长越难理解，并且不易于维护。</p>
<p>拟可重构方法：Move Method(搬移函数)，Replace Temp with Query(以查询取代临时变量)，Replace Method with Method Object(以函数对象取代函数)，Decompose Conditional(分解条件表达式)</p>
<h4 id="Long-Parameter-List"><a href="#Long-Parameter-List" class="headerlink" title="Long Parameter List"></a>Long Parameter List</h4><p>说明：过长参数列。太长的参数列难以理解，可能造成前后不一致，不易使用。</p>
<p>拟可重构方法：Replace Parameter with Method(以函数取代参数)，Introduce Parameter Object(引入参数对象)，Preserve Whole Object(保持对象完整)</p>
<h4 id="Message-Chains"><a href="#Message-Chains" class="headerlink" title="Message Chains"></a>Message Chains</h4><p>说明：过度耦合的消息链。对象A请求对象B，对象B请求对象C……无穷无尽。</p>
<p>拟可重构方法：Hide Delegate(隐藏委托关系)</p>
<h4 id="Middle-Man"><a href="#Middle-Man" class="headerlink" title="Middle Man"></a>Middle Man</h4><p>说明：中间人。滥用委托的结果，某个类接口有一半的函数都委托给其他类。</p>
<p>拟可重构方法：Remove Middle Man(移除中间人)，Inline Method(内联函数)，Replace Delegation with Inheritance(以继承取代委托)</p>
<h4 id="Parallel-Inheritance-Hierarchies"><a href="#Parallel-Inheritance-Hierarchies" class="headerlink" title="Parallel Inheritance Hierarchies"></a>Parallel Inheritance Hierarchies</h4><p>说明：平行继承体系。为某一个类添加一个子类时，必须也为另一个类增加相应的子类。</p>
<p>拟可重构方法：Move Method(搬移函数)，Move Filed(搬移字段)</p>
<h4 id="Primitive-Obsession"><a href="#Primitive-Obsession" class="headerlink" title="Primitive Obsession"></a>Primitive Obsession</h4><p>说明：基本类型偏执 。一个很大的类中可能含有许多基本类型数据，或者一个函数参数列表由数个基本类型构成。完全可以用对象来代替这些基本类型。比如结合数值和币种的money类。</p>
<p>拟可重构方法：Replace Data Value with Object(以对象取代数据值)，Extract Class(提炼类)，Introduce Parameter Object(引入参数对象)，Replace Array with Object(以对象取代数组)，Replace Type Code with Class(以类取代类型码)，Replace Type Code with Subclass(以子类取代类型码)，Replace Type Code with State/Strategy(以State/Strategy取代类型码)</p>
<h4 id="Refuse-Bequest"><a href="#Refuse-Bequest" class="headerlink" title="Refuse Bequest"></a>Refuse Bequest</h4><p>说明：被拒绝的遗赠。子类不想继承父类的函数和数据。</p>
<p>拟可重构方法：Replace Interface with Delegation(以委托取代继承)</p>
<h4 id="Shotgun-Surgery"><a href="#Shotgun-Surgery" class="headerlink" title="Shotgun Surgery"></a>Shotgun Surgery</h4><p>说明：散弹式修改。我们希望软件发生变化时，只修改程序中的一个地方，而不是各个角落。</p>
<p>拟可重构方法：Move Method(搬移函数)，Move Filed(搬移字段)，Inline Class(将类内联化)</p>
<h4 id="Speculative-Generality"><a href="#Speculative-Generality" class="headerlink" title="Speculative Generality"></a>Speculative Generality</h4><p>说明：夸夸其谈未来性。我们在项目设计的时候总想着以后会有什么新的需要，所以企图以各种各式各样的钩子和特殊情况处理一些给必要的事情，这就导致了系统更加难以理解和维护。</p>
<p>拟可重构方法：Collapse Hierarchy(折叠继承体系)，Inline Class(将类内联化)，Remove Parameter(移除参数)，Rename Method(重命名函数)</p>
<h4 id="Switch-Statements"><a href="#Switch-Statements" class="headerlink" title="Switch Statements"></a>Switch Statements</h4><p>说明：switch惊悚现身。switch语句的问题就在于重复，有重复就可以重构。</p>
<p>拟可重构方法：Replace Conditional with Polymorphism(以多态取代条件表达式)，Replace Type Code with Subclass(以子类取代类型码)，Replace Type Code with State/Strategy(以State/Strategy取代类型码)，Replace Parameter with Explicit Methods(以明确函数取代参数)，Introduce Null Object(引入Null对象)</p>
<h4 id="Temporary-Field"><a href="#Temporary-Field" class="headerlink" title="Temporary Field"></a>Temporary Field</h4><p>说明：令人迷惑的暂时字段。某个类的实例变量只是服务于某种特殊情况，这会给阅读者造成理解障碍。</p>
<p>拟可重构方法：Extract Class(提炼类)，Introduce Null Object(引入Null对象)</p>
<p>Read More:</p>
<blockquote>
<p>《重构—改善既有代码的设计》</p>
</blockquote>
]]></content>
      <categories>
        <category>重构</category>
      </categories>
      <tags>
        <tag>重构</tag>
        <tag>代码的坏味道</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS编译安装Python3</title>
    <url>/2018/06/26/centosinstallpython3/</url>
    <content><![CDATA[<p>Linux 下大部分系统默认自带 python2.x 的版本，最常见的是 python2.6 或 python2.7 版本，默认的python 被系统很多程序所依赖，比如 CentOS 下的 yum 就是 python2.x 写的，所以默认版本不要轻易删除，否则会有一些问题。如果需要使用最新的 Python3 那么我们可以编译安装源码包到独立目录，这和系统默认环境之间是没有任何影响的，Python3 和 Python2 两个环境并存即可。</p>
<p>首先去 Python 官网下载 Python3 的源码包，<a href="https://www.python.org/" target="_blank" rel="noopener">传送门</a> </p>
<p>进去之后点击导航栏的 Downloads，也可以鼠标放到 Downloads 上弹出菜单选择 Source code，表示源码包，这里选择最新版本 3.6.5，当然下面也有很多其他历史版本，点进去之后页面下方可以看到下载链接，包括源码包、Mac OSX 安装包、Windows 安装包等。Linux 系统可以直接使用以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz</span><br></pre></td></tr></table></figure>
<p>接下来，如果是全新的 Linux 系统，可能需要安装一些 Python 的依赖，如 openssl、readline等模块。需要的依赖主要如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install zlib zlib-devel</span><br><span class="line">yum -y install bzip2 bzip2-devel</span><br><span class="line">yum -y install ncurses ncurses-devel</span><br><span class="line">yum -y install readline readline-devel</span><br><span class="line">yum -y install openssl openssl-devel</span><br><span class="line">yum -y install openssl-static</span><br><span class="line">yum -y install xz lzma xz-devel</span><br><span class="line">yum -y install sqlite sqlite-devel</span><br><span class="line">yum -y install gdbm gdbm-devel</span><br><span class="line">yum -y install tk tk-devel</span><br></pre></td></tr></table></figure>
<p>如果不是全新的 Linux 系统，可以查看是否安装了以上依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list installed | grep zlib</span><br><span class="line">yum list installed | grep zlib-devel</span><br><span class="line">yum list installed | grep bzip2</span><br><span class="line">yum list installed | grep bzip2-devel</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>解压文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf Python-3.6.5.tgz</span><br></pre></td></tr></table></figure>
<p>进入目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd Python-3.6.5/</span><br></pre></td></tr></table></figure>
<p>配置编译：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./configure --prefix=/usr/local/python3.6.5 --enable-shared CFLAGS=-fPIC</span><br></pre></td></tr></table></figure>
<p>因为上面依赖包是用 yum 安装而不是自己编译的，所以都是安装在系统默认目录下，因此各种选项不用加默认即可生效。<code>--enable-shared</code> 和 <code>-fPIC</code> 之后可以将 Python3 的动态链接库编译出来，默认情况编译完 lib 下面只有 Python3.xm.a 这样的文件，python本身可以正常使用，但是如果编译第三方库需要python 接口的比如 caffe 等，则会报错；所以这里建议按照上面的方式配置。</p>
<p>然后编译并安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>整个过程大约5分钟，安装成功之后，安装目录就在 <code>/usr/local/python3.6.5/</code> 。</p>
<p>一般为了系统环境的干净，不需要将 python3、pip3 加入到系统环境变量中，使用全路径运行 Python 文件或安装第三方库即可，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/local/python3.6.5/bin/python3.6 xxx.py</span><br><span class="line">/usr/local/python3.6.5/bin/pip3.6 install twisted</span><br></pre></td></tr></table></figure>
<p>但是一般在开发机上时，加入环境变量会更加方便，建立软连接如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln -s /usr/python3.6.5/bin/python3.6 /usr/bin/python36</span><br><span class="line">ln -s /usr/python3.6.5/bin/pip3 /usr/bin/pip3</span><br></pre></td></tr></table></figure>
<p>然后可以直接使用软连接运行 Python 文件或安装第三方库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python36 xxx.py</span><br><span class="line">pip3 install twisted</span><br></pre></td></tr></table></figure>
<p>如上在 CentOS 上安装 Python3 就完成了，安装其他版本的 Python 解释器同理。</p>
<p>Read More:</p>
<blockquote>
<p><a href="https://www.cnblogs.com/freeweb/p/5181764.html" target="_blank" rel="noopener">Linux下编译安装python3</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux/Unix</category>
      </categories>
      <tags>
        <tag>Linux/Unix</tag>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP初级算法系列 - 1</title>
    <url>/2017/06/21/bdphp1/</url>
    <content><![CDATA[<p>给定一个数组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$arr = array(&apos;b&apos; =&gt; &apos;a&apos;, &apos;c&apos; =&gt; &apos;a&apos;, &apos;e&apos; =&gt; &apos;b&apos;, &apos;d&apos; =&gt; &apos;b&apos;, &apos;f&apos; =&gt; &apos;c&apos;, &apos;g&apos; =&gt; &apos;e&apos;, &apos;h&apos; =&gt; &apos;f&apos;);</span><br></pre></td></tr></table></figure>
<p>给出可以完成以下格式转换的算法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array</span><br><span class="line">(</span><br><span class="line">    [a] =&gt; Array</span><br><span class="line">        (</span><br><span class="line">            [b] =&gt; Array</span><br><span class="line">                (</span><br><span class="line">                    [e] =&gt; Array</span><br><span class="line">                        (</span><br><span class="line">                            [0] =&gt; g</span><br><span class="line">                        )</span><br><span class="line"></span><br><span class="line">                    [0] =&gt; d</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">            [c] =&gt; Array</span><br><span class="line">                (</span><br><span class="line">                    [f] =&gt; Array</span><br><span class="line">                        (</span><br><span class="line">                            [0] =&gt; h</span><br><span class="line">                        )</span><br><span class="line"></span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>算法实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BDphp1</span><br><span class="line">&#123;</span><br><span class="line">    private function php1($tmp_array, $start)</span><br><span class="line">    &#123;</span><br><span class="line">        $result = array();</span><br><span class="line">        if ($ret = array_keys($tmp_array, $start)) &#123;</span><br><span class="line">            foreach ($ret as $v) &#123;</span><br><span class="line">                if ($rev = $this-&gt;php1($tmp_array, $v)) &#123;</span><br><span class="line">                    $result[$v] = $rev;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    $result[] = $v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return $result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function bd_php1($tmp_array, $start = &apos;&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">        $tmp = array();</span><br><span class="line">        if ($start == null) &#123;</span><br><span class="line">            $start = array_shift(array_values($tmp_array));</span><br><span class="line">        &#125;</span><br><span class="line">        $ret = $this-&gt;php1($tmp_array, $start);</span><br><span class="line">        $tmp[$start] = $ret;</span><br><span class="line">        return $tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法说明：主要使用 <code>array_shift(),array_values(),array_keys()</code> 函数和递归思想。  </p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析FCGI与PHP-FPM</title>
    <url>/2017/06/07/cgifcgiphpfpm/</url>
    <content><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h4><p><strong>通用网关接口</strong>（Common Gateway Interface/CGI）是一种重要的互联网技术，可以让一个客户端，从网页浏览器向执行在网络服务器上的程序请求数据。CGI 描述了服务器和请求处理程序之间传输数据的一种标准。</p>
<h4 id="FCGI"><a href="#FCGI" class="headerlink" title="FCGI"></a>FCGI</h4><p><strong>快速通用网关接口</strong>（Fast Common Gateway Interface/FastCGI）是一种让交互程序与 Web 服务器通信的协议。多数流行的 HTTP server 都支持 FastCGI，包括 Apache、Nginx 和 lighttpd 等，同时，FastCGI 也被许多脚本语言所支持，其中就有 PHP。FastCGI 是早期通用网关接口（CGI）的增强版本。</p>
<p>FastCGI 致力于减少网页服务器与 CGI 程序之间互动的开销，从而使服务器可以同时处理更多的网页请求。</p>
<blockquote>
<p> CGI 和 FastCGI 是一种通信协议规范，不是一个实体。</p>
</blockquote>
<p>在平时讨论中我们应该用词规范。有些人说 CGI ，其实指的是实现 CGI 协议的程序，我们称之为 CGI 程序；有些人说 FCGI ，其实指的是实现 FCGI 协议的程序，我们称之为 FCGI 程序。</p>
<h3 id="CGI-程序"><a href="#CGI-程序" class="headerlink" title="CGI 程序"></a>CGI 程序</h3><p>web server（比如说 Nginx）只是内容的分发者。比如，如果请求 <code>/index.html</code>，那么 web server 会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。如果现在请求的是 <code>/index.php</code>，根据配置文件，Nginx 知道这个不是静态文件，需要去找 PHP 解析器来处理，那么他会把这个请求简单处理后交给 PHP 解析器。Nginx 会传哪些数据给 PHP 解析器呢？比如：URL、查询字符串、POST 数据、HTTP header等。CGI 就是规定要传哪些数据、以什么样的格式传递给后方处理这个请求的协议。</p>
<p>当 web server 收到 <code>/index.php</code> 这个请求后，会启动对应的 CGI 程序，这里就是 PHP 的解析器。接下来 PHP 解析器会解析 php.ini 文件，初始化执行环境，然后处理请求，再以规定 CGI 规定的格式返回处理后的结果，退出进程。web server 再把结果返回给浏览器。</p>
<p>CGI 程序运行在独立的进程中，并对每个 Web 请求建立一个进程（每个请求都会解析 php.ini、初始化执行环境、处理请求），这种方法非常容易实现，但效率很差，难以扩展。面对大量请求，进程的大量建立和消亡使操作系统性能大大下降。此外，由于地址空间无法共享，也限制了资源重用。</p>
<h3 id="FCGI-程序"><a href="#FCGI-程序" class="headerlink" title="FCGI 程序"></a>FCGI 程序</h3><p>FCGI 协议是 CGI 协议的增强版本，是为了提高 CGI 程序的性能。那么CGI 程序的性能问题在哪呢？</p>
<p>就是”PHP解析器解析php.ini文件，初始化执行环境”这个工作。标准的CGI 程序对每个请求都会执行这些步骤，所以处理每个时间的时间会比较长。</p>
<p>那么 FCGI 程序是怎么做的呢？首先，FCGI 程序会先启一个 master，解析配置文件，初始化执行环境，然后再启动多个worker。当请求过来时，master 会传递给一个 worker，然后立即可以接受下一个请求。这样就避免了重复的劳动，效率自然是高。而且当 worker 不够用时，master 可以根据配置预先启动几个 worker 等着；当然空闲 worker 太多时，也会停掉一些，这样就提高了性能，也节约了资源。这就是 FCGI 程序的对进程的管理。</p>
<h3 id="PHP-CGI-与-PHP-FPM"><a href="#PHP-CGI-与-PHP-FPM" class="headerlink" title="PHP-CGI 与 PHP-FPM"></a>PHP-CGI 与 PHP-FPM</h3><p><strong>PHP-CGI 和 PHP-FPM 都是实现 FastCGI 协议 的程序，并且提供了进程管理的功能</strong></p>
<p>PHP-FPM 是一个 PHP 进程管理器，包含 master 进程和 worker 进程两种进程：master 进程只有一个，负责监听端口，接收来自 Web Server 的请求，而 worker 进程则一般有多个 (具体数量根据实际需要配置)，每个进程内部都嵌入了一个 PHP 解释器，是 PHP 代码真正执行的地方。</p>
<p>PHP-CGI 的问题在于 ：</p>
<ul>
<li>PHP-CGI 变更 php.ini 配置后需重启 PHP-CGI 才能让新的 php-ini 生效，不可以平滑重启 </li>
<li>直接杀死 PHP-CGI 进程，PHP 就不能运行了。(PHP-FPM和Spawn-FCGI就没有这个问题，守护进程会平滑从新生成新的子进程。） </li>
</ul>
<p>针对 PHP-CGI 的不足，PHP-FPM（PHP-Fast CGI Process Manager） 应运而生。PHP-FPM 的管理对象是 PHP-CGI。使用 PHP-FPM 来控制 PHP-CGI 的 FastCGI 进程。</p>
<h3 id="FCGI运行模式分析"><a href="#FCGI运行模式分析" class="headerlink" title="FCGI运行模式分析"></a>FCGI运行模式分析</h3><p>FastCGI 的工作原理是：</p>
<ol>
<li>Web Server 启动时载入 FastCGI 进程管理器（PHP-FPM）；</li>
<li>FastCGI 进程管理器自身初始化，启动多个 CGI 解释器进程 (在任务管理器中可见多个 php-cgi.exe )并等待来自 Web Server 的连接；</li>
<li>当客户端请求到达 Web Server 时，FastCGI 进程管理器选择并连接到一个 CGI 解释器。Web server 将 CGI 环境变量和标准输入发送到 FastCGI 子进程 php-cgi.exe；</li>
<li>FastCGI 子进程完成处理后将标准输出和错误信息从同一连接返回 Web Server。当 FastCGI 子进程关闭连接时，请求便告处理完成。FastCGI 子进程接着等待并处理来自 FastCGI 进程管理器（运行在 WebServer中）的下一个连接。 在正常的CGI模式中，php-cgi.exe 在此便退出了。</li>
</ol>
<p>如果使用正常的 CGI 协议，你可以想象请求处理有多慢。每一个 Web 请求 PHP 都必须重新解析 php.ini、重新载入全部 dll 扩展并重初始化全部数据结构。使用 FastCGI，所有这些 都只在进程启动时发生一次。一个额外的好处是，持续数据库连接可以工作。</p>
<p>FastCGI 的主要优点是把动态语言和 HTTP Server 分离开来，所以 Nginx 与 PHP/PHP-FPM 经常被部署在不同的服务器上，以分担前端 Nginx 服务器的压力，使 Nginx 专一处理静 态请求和转发动态请求，而 PHP/PHP-FPM 服务器专一解析PHP动态请求。</p>
<h3 id="给张图"><a href="#给张图" class="headerlink" title="给张图"></a>给张图</h3><p><img src="/images/2017-6-7 194822.png" alt="2017-6-7 194822"></p>
<p>图中表示了 Nginx、FCGI、Wrapper、PHP 之间的关系。其中 fastcgi_pass 指定了 FastCGI 服务器监听端口与地址，Wrapper 是调用其他程序的一段辅助程序，整个的执行流程是：</p>
<ul>
<li>用户将 HTTP 请求发送给 Nginx 服务器；</li>
<li>Nginx  会根据用户访问的 URL 和后缀对请求进行判断，如果请求的是静态资源（HTML页面）会直接返回，如果请求的是动态资源，执行下一步；</li>
<li>Nginx  会将请求交给 fastcgi 客户端，通过 fastcgi_pass 将用户的请求发送给 PHP-FPM；</li>
<li>fastcgi_pass 将动态资源交给 PHP-FPM 后，PHP-FPM 会将资源转给 PHP 脚本解析服务器的 Wrapper；</li>
<li>Wrapper 收到 PHP-FPM 转过来的请求后，Wrapper 会生成一个新的线程调用 PHP 动态程序解析服务器；</li>
<li>PHP 会将查询到的结果返回给 Nginx ；</li>
<li>Nginx  构造一个响应报文将结果返回给用户。</li>
</ul>
<p>Read More:</p>
<blockquote>
<p><a href="http://www.cnblogs.com/JohnABC/p/3529786.html" target="_blank" rel="noopener">PHP-FastCGI详解</a>   <a href="https://segmentfault.com/q/1010000000256516" target="_blank" rel="noopener">搞不清FastCgi与PHP-fpm之间是个什么样的关系</a>  <a href="http://www.cleey.com/blog/single/id/848.html" target="_blank" rel="noopener">关于CGI 和 PHP-FPM需要弄清的</a>  <a href="http://blog.csdn.net/fan2012huan/article/details/53020064" target="_blank" rel="noopener">理解CGI、FCGI、php-cgi、php-fpm的概念</a>  <a href="http://www.cnblogs.com/mangguoxiansheng/p/5967745.html" target="_blank" rel="noopener">Nginx–&gt;进阶–&gt;原理–&gt;Nginx+php+fastcgi的原理与关系</a>  <a href="https://segmentfault.com/a/1190000007322358" target="_blank" rel="noopener">Nginx+Php-fpm运行原理详解</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>CGI</tag>
        <tag>FCGI</tag>
        <tag>PHP-FPM</tag>
        <tag>PHP-CGI</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP初级算法系列 - 2</title>
    <url>/2017/06/21/bdphp2/</url>
    <content><![CDATA[<p>算法功能：返回数组中最小的 <code>k</code> 个数。</p>
<p>算法实现1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BDphp3</span><br><span class="line">&#123;</span><br><span class="line">    public function bd_php3($tmp_array, $k)</span><br><span class="line">    &#123;</span><br><span class="line">        $count = 0;</span><br><span class="line">        $length = count($tmp_array);</span><br><span class="line">        if ($length &lt; $k) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for ($i = 0; $i &lt; $length; $i++) &#123;</span><br><span class="line">            $min = $i;</span><br><span class="line">            for ($j = $i + 1; $j &lt; $length; $j++) &#123;</span><br><span class="line">                if ($tmp_array[$j] &lt; $tmp_array[$min]) &#123;</span><br><span class="line">                    $min = $j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            $tmp = $tmp_array[$i];</span><br><span class="line">            $tmp_array[$i] = $tmp_array[$min];</span><br><span class="line">            $tmp_array[$min] = $tmp;</span><br><span class="line">            $count++;</span><br><span class="line">            if ($count &gt; $k) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return array_slice($tmp_array, 0, $k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法实现2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BDphp3</span><br><span class="line">&#123;</span><br><span class="line">    private function replaceMaxValue($arr, $otherNum)</span><br><span class="line">    &#123;</span><br><span class="line">        $max = $arr[0];</span><br><span class="line">        for ($i = 1; $i &lt; count($arr); $i++) &#123;</span><br><span class="line">            if ($arr[$i] &gt; $max) &#123;</span><br><span class="line">                $max = &amp;$arr[$i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if ($otherNum &lt; $max) &#123;</span><br><span class="line">            $max = $otherNum;</span><br><span class="line">        &#125;</span><br><span class="line">        return $arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function getTop($arr, $topNum)</span><br><span class="line">    &#123;</span><br><span class="line">        $topK = array_slice($arr, 0, $topNum);</span><br><span class="line">        $other = array_slice($arr, $topNum);</span><br><span class="line">        foreach ($other as $value) &#123;</span><br><span class="line">            $topK = $this-&gt;replaceMaxValue($topK, $value);</span><br><span class="line">        &#125;</span><br><span class="line">        return $topK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法说明：第一种方式中改进了直接插入排序算法，只是将数组排序 k 次，然后返回数组的前 k 个数。第二种方式将数组分割成两部分，前 k 个数值为第一部分，其余数值为第二部分，对于第二部分的每个数值，如果存在小于第一部分最大值的数值，将第一部分的最大值替换，最后返回第一部分。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>GO系列 - 学习资料</title>
    <url>/2020/10/26/go-series-0/</url>
    <content><![CDATA[<h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p><a href="https://github.com/golang/go" target="_blank" rel="noopener">github.com/golang/go</a></p>
<p><a href="https://learnku.com/docs/gobyexample/2020" target="_blank" rel="noopener">Go 编程实例 Go by Example</a></p>
<p><a href="https://learnku.com/docs/the-way-to-go" target="_blank" rel="noopener">Go 入门指南</a></p>
<h4 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h4><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><h5 id="Go-Frame"><a href="#Go-Frame" class="headerlink" title="Go Frame"></a>Go Frame</h5><ul>
<li><a href="https://goframe.org/index" target="_blank" rel="noopener">框架介绍</a></li>
</ul>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>GO系列 - 数据类型</title>
    <url>/2021/06/29/go-datatype/</url>
    <content><![CDATA[<p>Go 语言按类别有以下几种数据类型：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">类型和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>布尔型</strong> <br>布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>数字类型</strong> <br>整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>字符串类型</strong> <br>字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>派生类型</strong> <br>包括：(a) 指针类型 (b) 数组类型 (c) 结构化类型 (d) Channel 类型 (e) 函数类型 (f) 切片类型 (g) 接口类型 (h) Map 类型</td>
</tr>
</tbody>
</table>
<h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">类型和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>uint8</strong> <br>无符号 8 位整型 (0 到 255)</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>uint16</strong> <br>无符号 16 位整型 (0 到 65535)</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>uint32</strong> <br>无符号 32 位整型 (0 到 4294967295)</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>uint64</strong> <br>无符号 64 位整型 (0 到 18446744073709551615)</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>int8</strong> <br>有符号 8 位整型 (-128 到 127)</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><strong>int16</strong> <br>有符号 16 位整型 (-32768 到 32767)</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><strong>int32</strong> <br>有符号 32 位整型 (-2147483648 到 2147483647)</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><strong>int64</strong> <br>有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</td>
</tr>
</tbody>
</table>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">类型和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>float32</strong> <br>IEEE-754 32位浮点型数</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>float64</strong> <br>IEEE-754 64位浮点型数</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>complex64</strong> <br>32 位实数和虚数</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>complex128</strong> <br>64 位实数和虚数</td>
</tr>
</tbody>
</table>
<h3 id="其他数字类型"><a href="#其他数字类型" class="headerlink" title="其他数字类型"></a>其他数字类型</h3><table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">类型和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><strong>byte</strong> <br>类似 uint8</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><strong>rune</strong> <br>类似 int32</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><strong>uint</strong> <br>32 或 64 位</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><strong>int</strong> <br>与 uint 一样大小</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><strong>uintptr</strong> <br>无符号整型，用于存放一个指针</td>
</tr>
</tbody>
</table>
<p>Read More:</p>
<blockquote>
<p><a href="https://www.tutorialspoint.com/go/go_data_types.htm" target="_blank" rel="noopener">Go - Data Types</a></p>
<p><a href="https://www.runoob.com/go/go-data-types.html" target="_blank" rel="noopener">Go 语言数据类型</a></p>
</blockquote>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>GO</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用命令的简单使用</title>
    <url>/2017/10/09/gitcommand/</url>
    <content><![CDATA[<h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><p><code>git add</code> 命令将文件内容添加到索引（将修改添加到暂存区）。也就是将要提交的文件的信息添加到索引库中。</p>
<h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>将要提交的文件的信息添加到索引库中（将修改添加到暂存区），以准备为下一次提交分段的内容。 它通常将现有路径的当前内容作为一个整体添加，但是通过一些选项，它也可以用于添加内容，只对所应用的工作树文件进行一些更改，或删除工作树中不存在的路径了。</p>
<p>该命令可以在提交之前多次执行。它只在运行 <code>git add</code> 命令时添加指定文件的内容; 如果希望随后的更改包含在下一个提交中，那么必须再次运行 <code>git add</code> 将新的内容添加到索引。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .             # 将所有修改添加到暂存区</span><br><span class="line">git add *             # Ant风格添加修改</span><br><span class="line">git add *Controller   # 将以Controller结尾的文件的所有修改添加到暂存区</span><br><span class="line">git add Hello*        # 将所有以Hello开头的文件的修改添加到暂存区</span><br><span class="line">git add Hello?        # 将以Hello开头后面只有一位的文件的修改提交到暂存区 例如:Hello1.txt,HelloA.java</span><br></pre></td></tr></table></figure>
<h3 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h3><p><code>git commit</code> 命令用于将更改记录提交到存储库。将索引的当前内容与描述更改的用户和日志消息一起存储在新的提交中。</p>
<h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p><code>git commit</code> 命令将索引的当前内容与描述更改的用户和日志消息一起存储在新的提交中。</p>
<p>要添加的内容可以通过以下几种方式指定：</p>
<ol>
<li>在使用 <code>git commit</code> 命令之前，通过使用 <code>git add</code> 对索引进行递增的“添加”更改（注意：修改后的文件的状态必须为<code>added</code>）；</li>
<li>通过使用 <code>git rm</code> 从工作树和索引中删除文件，再次使用 <code>git commit</code> 命令;</li>
<li>通过将文件作为参数列出到 <code>git commit</code> 命令（不使用 <code>--interactive</code> 或 <code>--patch</code> 选项），在这种情况下，提交将忽略索引中分段的更改，而是记录列出的文件的当前内容（必须已知到Git的内容）；</li>
<li>通过使用带有 <code>-a</code> 选项的 <code>git commit</code> 命令来自动从所有已知文件（即所有已经在索引中列出的文件）中添加“更改”，并自动从已从工作树中删除索引中的 <code>rm</code> 文件 ，然后执行实际提交；</li>
<li>通过使用 <code>--interactive</code> 或 <code>--patch</code> 选项与 <code>git commit</code> 命令一起确定除了索引中的内容之外哪些文件应该是提交的一部分，然后才能完成操作。</li>
</ol>
<p>如果提交后立即发现错误，可以使用 <code>git reset</code> 命令恢复。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -m &quot;the commit message&quot; # git add 存储到暂存区之后将内容提交</span><br></pre></td></tr></table></figure>
<h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p><code>git push</code> 命令用于将本地分支的更新，推送到远程主机。</p>
<h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>使用本地引用更新远程引用，同时发送完成给定引用所需的对象。可以在每次推入存储库时，通过在那里设置挂钩触发一些事件。当命令行不指定使用 <code>&lt;repository&gt;</code> 参数推送的位置时，将查询当前分支的 <code>branch.*.remote</code> 配置以确定要在哪里推送。 如果配置丢失，则默认为<code>origin</code>。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin master # 将本地的master分支推送到origin主机的master分支。如果master不存在，则会被新建。</span><br><span class="line">git push origin # 将当前分支推送到origin主机的对应分支。如果当前分支只有一个追踪分支，那么主机名都可以省略。</span><br><span class="line">git push -u origin master # 将本地的master分支推送到origin主机，同时指定origin为默认主机。</span><br><span class="line">git push --all origin # 将所有本地分支都推送到origin主机。</span><br></pre></td></tr></table></figure>
<h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p><code>git clone</code> 命令将存储库克隆到新目录中。</p>
<h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><p>将存储库克隆到新创建的目录中，为克隆的存储库中的每个分支创建远程跟踪分支，并从克隆检出的存储库作为当前活动分支的初始分支。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone &lt;版本库的网址&gt;</span><br><span class="line">如：git clone http://github.com/jquery/jquery.git</span><br></pre></td></tr></table></figure>
<p>该命令会在本地主机生成一个目录，与远程主机的版本库同名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</span><br></pre></td></tr></table></figure>
<p>该命令可指定不同的目录名。</p>
<h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p><code>git fetch</code> 命令用于从另一个存储库下载对象和引用。</p>
<h4 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h4><p>从一个或多个其他存储库中获取分支或标签以及完成其历史所必需的对象。远程跟踪分支已更新，需要将这些更新取回本地，这时就要用到<code>git fetch</code> 命令。</p>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><p>更新远程代码到本地仓库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方式一：</span><br><span class="line">1. 查看远程仓库：git remote -v</span><br><span class="line">2. 从远程origin仓库的master分支获取最新版本到本地：git fetch origin master</span><br><span class="line">3. 比较本地仓库和远程仓库的区别：git log -p master.. origin/master</span><br><span class="line">4. 远程仓库和本地仓库的合并：git merge origin/master</span><br><span class="line"></span><br><span class="line">方式二：</span><br><span class="line">1. 查看远程仓库：git remote -v</span><br><span class="line">2. 从远程的origin仓库的master分支下载到本地并新建一个分支temp：git fetch origin master:temp</span><br><span class="line">3. 比较本地仓库和远程仓库的区别：git diff temp</span><br><span class="line">4. 合并temp分支到master分支：git merge temp</span><br><span class="line">5. 删除temp分支：git branch -d temp</span><br><span class="line">注意：如果该分支没有合并到主分支会报错，可以用以下命令强制删除 git branch -D &lt;分支名&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>GF-CLI学习系列</title>
    <url>/2020/10/27/gf-cli-series-0-md/</url>
    <content><![CDATA[<h4 id="gen"><a href="#gen" class="headerlink" title="gen"></a>gen</h4><p>该命令用以自动化从数据库直接生成模型文件。</p>
<p>该命令将会根据数据表名（注意：所以要先在数据里建好表）生成对应的目录，该目录名称即数据表包名。</p>
<p>目录下自动生成3个文件：</p>
<ul>
<li>数据表名.go 自定义文件，开发者可以自由定义填充的代码文件，仅会生成一次，每一次模型生成不会覆盖</li>
<li>数据表名_entity.go 表结构文件，根据数据表结构生成的结构体定义文件，包含字段注释。数据表在外部变更后，可使用gen命令重复生成更新该文件</li>
<li>数据表名_model.go 表模型文件，为数据表提供了许多便捷的CURD操作方法，并可直接查询返回该表的结构体对象。数据表在外部变更后，可使用gen命令重复生成更新该文件</li>
</ul>
<p>使用方式：<code>gf gen model ./app/model -c config/config.toml -p sys_ -t sys_users</code></p>
<p>命令说明：</p>
<ul>
<li>./app/model：在model生成的路径</li>
<li>-c config/config.toml：在这个配置里找database数据库连接配置 需要写好mysql的配置信息</li>
<li>-p sys_：去除生成文件目录的sys前缀 如果不加这个参数就会按数据库名生成目录和文件名 如：sys_users</li>
<li>-t sys_users：要生成model的数据表文件名</li>
</ul>
]]></content>
      <categories>
        <category>gf-cli</category>
      </categories>
      <tags>
        <tag>gf</tag>
        <tag>gf-cli</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo应用NexT主题</title>
    <url>/2017/04/01/hexoNexT/</url>
    <content><![CDATA[<h3 id="Hexo主题"><a href="#Hexo主题" class="headerlink" title="Hexo主题"></a>Hexo主题</h3><p>Hexo 为我们提供了很多<a href="&quot;https://hexo.io/themes/">主题</a>，本博客的主题使用的是<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">NexT</a>主题，是目前Github上Star最高的Hexo主题，支持几种不同的风格。所以本文以NexT为例，介绍Hexo主题的配置及使用。</p>
<h3 id="安装NexT主题"><a href="#安装NexT主题" class="headerlink" title="安装NexT主题"></a>安装NexT主题</h3><p>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。</p>
<p>为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。比如我的电脑下的 D:\Hexo 目录下的称为站点配置文件，D:\Hexo\themes\next 目录下的成为主题配置文件。</p>
<p>在终端窗口下，定位到 Hexo 站点目录下。运行下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<h3 id="启用NexT主题"><a href="#启用NexT主题" class="headerlink" title="启用NexT主题"></a>启用NexT主题</h3><p>与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开 站点配置文件， 找到 theme 字段，并将其值更改为 next。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<p>到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 执行以下代码清除 Hexo 的缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<h3 id="验证主题"><a href="#验证主题" class="headerlink" title="验证主题"></a>验证主题</h3><p>首先启动 Hexo 本地站点，并开启调试模式（即加上 –debug），整个命令是 hexo s –debug。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：</p>
<blockquote>
<p>INFO Hexo is running at <a href="http://0.0.0.0:4000/" target="_blank" rel="noopener">http://0.0.0.0:4000/</a>. Press Ctrl+C to stop.</p>
</blockquote>
<p>若运行成功，NexT 默认的 Scheme —— Muse</p>
<h3 id="主题设定"><a href="#主题设定" class="headerlink" title="主题设定"></a>主题设定</h3><p>Scheme 是 NexT 提供的一种特性，借助于 Scheme，NexT 为你提供多种不同的外观。同时，几乎所有的配置都可以 在 Scheme 之间共用。目前 NexT 支持三种 Scheme</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</span><br><span class="line">Mist - Muse 的紧凑版本，整洁有序的单栏外观</span><br><span class="line">Pisces - 双栏 Scheme，小家碧玉似的清新</span><br></pre></td></tr></table></figure>
<p>将不需要启用的主题注释 # 掉即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># scheme: Muse</span><br><span class="line"># scheme: Mist</span><br><span class="line">scheme: Pisces</span><br></pre></td></tr></table></figure>
<h3 id="设置语言"><a href="#设置语言" class="headerlink" title="设置语言"></a>设置语言</h3><p>编辑 站点配置文件， 将 language 设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">language: zh-Hans</span><br></pre></td></tr></table></figure>
<h3 id="其他主题设置"><a href="#其他主题设置" class="headerlink" title="其他主题设置"></a>其他主题设置</h3><p>访问 <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">NexT官方设置文档</a> 进行设置</p>
<p>如果想要在“站点概览”页面显示“友情链接”，需要在站点配置文件中加入以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># title, chinese available</span><br><span class="line">links_title: 友情链接 </span><br><span class="line"># # links</span><br><span class="line">links:</span><br><span class="line">   显示名称: 链接地址</span><br></pre></td></tr></table></figure>
<h3 id="集成三方工具"><a href="#集成三方工具" class="headerlink" title="集成三方工具"></a>集成三方工具</h3><h4 id="添加文章阅读量功能"><a href="#添加文章阅读量功能" class="headerlink" title="添加文章阅读量功能"></a>添加文章阅读量功能</h4><p>参考 <a href="https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="noopener">为NexT主题添加文章阅读量统计功能</a> 进行设置，该博客只是针对NexT主题，其他主题请寻找其他解决办法。</p>
<h4 id="添加站内搜索能"><a href="#添加站内搜索能" class="headerlink" title="添加站内搜索能"></a>添加站内搜索能</h4><p>NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia,Swiftype和Algolia都只有一段时间的试用期，可以采用Hexo提供的Local Search,原理是通过hexo-generator-search插件在本地生成一个search.xml文件，搜索的时候从这个文件中根据关键字检索出相应的链接。</p>
<p>安装 hexo-generator-search</p>
<p>在站点的根目录下执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure>
<p>安装 hexo-generator-searchdb</p>
<p>在站点的根目录下执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>启用搜索</p>
<p>编辑 站点配置文件，新增以下内容到任意位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">	path: search.xml</span><br><span class="line">  	field: post</span><br><span class="line">  	format: html</span><br><span class="line">  	limit: 10000</span><br></pre></td></tr></table></figure>
<p>最后不要忘了将站点配置文件的local_search改成true。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>
<h4 id="给博客添加feed"><a href="#给博客添加feed" class="headerlink" title="给博客添加feed"></a>给博客添加feed</h4><p>安装hexo-generator-feed</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>
<p>配置到站点配置文件_config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: http://hexo.io/plugins/</span><br><span class="line">#RSS订阅</span><br><span class="line">plugin:</span><br><span class="line">- hexo-generator-feed</span><br><span class="line">#Feed Atom</span><br><span class="line">feed:</span><br><span class="line">type: atom</span><br><span class="line">path: atom.xml</span><br><span class="line">limit: 20</span><br></pre></td></tr></table></figure>
<p>最后，在你next主题下的_config.yml下，添加RSS订阅链接即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rss: /atom.xml</span><br></pre></td></tr></table></figure>
<h4 id="给博客生成一个站点地图"><a href="#给博客生成一个站点地图" class="headerlink" title="给博客生成一个站点地图"></a>给博客生成一个站点地图</h4><p>安装hexo-generator-seo-friendly-sitemap</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-seo-friendly-sitemap --save</span><br></pre></td></tr></table></figure>
<p>在站点配置文件_config.yml 中添加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sitemap:</span><br><span class="line">	path: sitemap.xml</span><br></pre></td></tr></table></figure>
<h4 id="头像圆形旋转"><a href="#头像圆形旋转" class="headerlink" title="头像圆形旋转"></a>头像圆形旋转</h4><p>把完整的 <a href="https://github.com/ehlxr/useful-code/blob/master/resources/sidebar-author.styl" target="_blank" rel="noopener">sidebar-author.styl</a> 文件内容复制替换到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">..hexo/themes/next/source/css/_common/components/sidebar/sidebar-author.styl</span><br></pre></td></tr></table></figure>
<p>Read More:</p>
<blockquote>
<p><a href="http://www.ezlippi.com/blog/2017/02/hexo-search.html" target="_blank" rel="noopener">Hexo博客添加站内搜索</a><br><a href="https://superbsco.coding.me/2017/01/13/new-article/" target="_blank" rel="noopener">记录Hexo+Github免费搭建个人博客</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
        <tag>主题</tag>
      </tags>
  </entry>
  <entry>
    <title>Heox主题的其他配置</title>
    <url>/2017/04/01/hexoOthers/</url>
    <content><![CDATA[<h3 id="Hexo页面底部次数显示"><a href="#Hexo页面底部次数显示" class="headerlink" title="Hexo页面底部次数显示"></a>Hexo页面底部次数显示</h3><p>很多网站中都有访问人数和总访问量，也就是下图所示的功能：</p>
<p><img src="/images/2017-4-2 102013.png" alt="截图20170402095045"></p>
<p>我们可以通过在主题配置文件中添加以下代码来实现此功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">busuanzi_count:</span><br><span class="line">  # count values only if the other configs are false</span><br><span class="line">  enable: true</span><br><span class="line">  # custom uv span for the whole site</span><br><span class="line">  site_uv: true</span><br><span class="line">  site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 访问人数</span><br><span class="line">  site_uv_footer:</span><br><span class="line">  # custom pv span for the whole site</span><br><span class="line">  site_pv: true</span><br><span class="line">  site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; 总访问量</span><br><span class="line">  site_pv_footer: 次</span><br><span class="line">  # custom pv span for one page only</span><br><span class="line">  page_pv: true</span><br><span class="line">  page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; 浏览</span><br><span class="line">  page_pv_footer: 次</span><br></pre></td></tr></table></figure>
<h3 id="添加社交链接"><a href="#添加社交链接" class="headerlink" title="添加社交链接"></a>添加社交链接</h3><p>如果希望试下下图显示的功能：</p>
<p><img src="/images/2017-4-2 102023.png" alt="截图20170402095414"></p>
<p>可以在主题配置文件中添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">social:</span><br><span class="line">  #LinkLabel: Link</span><br><span class="line">  GitHub: 链接地址</span><br><span class="line">  weibo: 链接地址</span><br><span class="line">  zhihu: 链接地址</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Social Links Icons</span><br><span class="line"># Icon Mapping:</span><br><span class="line">#   Map a menu item to a specific FontAwesome icon name.</span><br><span class="line">#   Key is the name of the item and value is the name of FontAwesome icon. Key is case-senstive.</span><br><span class="line">#   When an globe mask icon presenting up means that the item has no mapping icon.</span><br><span class="line">social_icons:</span><br><span class="line">  enable: true</span><br><span class="line">  # Icon Mappings.</span><br><span class="line">  # KeyMapsToSocialItemKey: NameOfTheIconFromFontAwesome</span><br><span class="line">  GitHub: github</span><br><span class="line">  weibo: weibo</span><br><span class="line">  zhihu: hand-o-right</span><br></pre></td></tr></table></figure>
<p>Hexo主题使用的图标都在 <a href="http://fontawesome.io/" target="_blank" rel="noopener">FontAwesome</a> 上，你可以根据自己需要选择，我发现这是一个很不错的网站，各种图标很漂亮，PPT中也可以用。</p>
<h3 id="分类、归档、关于页面的创建"><a href="#分类、归档、关于页面的创建" class="headerlink" title="分类、归档、关于页面的创建"></a>分类、归档、关于页面的创建</h3><p>安装完成Hexo之后，我们点击“分类”、“关于”、“标签”页面都会显示GitH的404页面，这是因为我们还没有创建每个功能对应的文件，使用如下方法创建：</p>
<p>分类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;categories&quot;</span><br></pre></td></tr></table></figure>
<p>关于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;about&quot;</span><br></pre></td></tr></table></figure>
<p>标签：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;tags&quot;</span><br></pre></td></tr></table></figure>
<p>使用以上hexo命令会在Hexo根目录的source文件夹下创建各个对应的文件夹，每个文件夹中都有index.md文件，这就成功了，文件中的内容不用修改。</p>
<p>创建完成之后，我们在编辑文章时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标题</span><br><span class="line">date: 2017-04-01 21:34:40</span><br><span class="line">tags:</span><br><span class="line"> - Hexo</span><br><span class="line"> - 主题</span><br><span class="line"> - 博客</span><br><span class="line">categories:</span><br><span class="line"> - Hexo</span><br></pre></td></tr></table></figure>
<p>“tags”、“categories”是对文章打的标签和分类，默认文章是可以评论的，如果不希望评论，可以加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">comments： false</span><br></pre></td></tr></table></figure>
<h3 id="首页文章显示摘要"><a href="#首页文章显示摘要" class="headerlink" title="首页文章显示摘要"></a>首页文章显示摘要</h3><p>第一种方式：在主题配置文件中，找到auto_excerpt，修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Automatically Excerpt. Not recommend.</span><br><span class="line"># Please use &lt;!-- more --&gt; in the post to control excerpt accurately.</span><br><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure>
<p>第二种方式：根据文章的内容，自己在合适的位置添加<code>&lt;!--more--&gt;</code>标签，使用灵活，也是Hexo推荐的方法</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2352140-ec93f0ac69d07b21.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
<p>第三种方式：在文章中的<code>front-matter</code>中添加description，并提供文章摘录。这种方式只会在首页列表中显示文章的摘要内容，进入文章详情后不会再显示。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2352140-67c6e1edb5695035.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>主题</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Github搭建个人博客</title>
    <url>/2017/04/01/hexogithub/</url>
    <content><![CDATA[<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>促使我建立自己博客的动机很简单，其他的博客平台太丑了！简直不能看啊，然而我并没有在说CSDN、CNBLOG等等。还有一个原因就是，我有一颗向往技术大神的心，所以需要靠自己一点点的积累。在过滤各种博客平台的时候，看到某乎大神建议使用GitHub搭建自己的博客，So，心动不如行动，于是搜集各种资料，搭建了自己博客，本文主要是记录搭建的过程以及可能遇到的问题及解决办法。  </p>
<blockquote>
<p><strong>本教程只适用于windows操作系统</strong></p>
</blockquote>
<h3 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h3><ul>
<li><a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>账户配置  </li>
<li>安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>环境  </li>
<li>安装<a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a>环境</li>
</ul>
<h4 id="GitHub账户配置"><a href="#GitHub账户配置" class="headerlink" title="GitHub账户配置"></a>GitHub账户配置</h4><p><a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>账户申请：  </p>
<ul>
<li>如果已经拥有GitHub账户，请进行第二步注册结束后，一定前往自己的注册邮箱，点开GitHub发送给你的注册确认信，确认注册，结束注册流程。否则无法使用gh-pages。</li>
</ul>
<p>创建代码库：</p>
<ul>
<li>登陆之后，点击页面右上角的加号，选择New repository新建代码库；<br>进入代码库创建页面，在Repository name下填写yourname.github.io，Description (可选)下填写一些简单的描述（不写也可以）；</li>
<li><strong>注意</strong>：比如我的github名称是runnerliu,这里就填 <a href="runnerliu.github.io">runnerliu.github.io</a>；</li>
</ul>
<p>代码库设置:</p>
<ul>
<li>开启gh-pages功能，正确创建代码库后，点击界面右侧的Settings，你将会打开这个库的setting页面，向下拖动，直到看见GitHub Pages；</li>
<li>点击Automatic page generator，Github将会自动替你创建出一个gh-pages的页面。 如果配置没有问题，那么大约15分钟之后，yourname.github.io这个网址就可以正常访问了；<strong>注意</strong>：我自己在操作过程中并没有这一步，可能是GitHub升级了？</li>
</ul>
<h4 id="安装Node-js环境"><a href="#安装Node-js环境" class="headerlink" title="安装Node.js环境"></a>安装Node.js环境</h4><p>根据自己操作系统的版本前往<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>下载相应的Node.js，可以根据所需选择安装路径，默认安装的话一路next就可以。  </p>
<p>验证安装：</p>
<ul>
<li>打开控制台（Win+R输入cmd，回车）；</li>
<li>输入<code>node -v</code>查看是否输出版本号；</li>
<li>输入<code>npm -v</code>查看是否输出版本号；</li>
<li>如果全部输出成功，证明安装成功，否则检查系统环境变量是否配置。</li>
</ul>
<h4 id="安装Git环境"><a href="#安装Git环境" class="headerlink" title="安装Git环境"></a>安装Git环境</h4><p>前往<a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a>官网下载相应版本的Git；  </p>
<p>和Node.js一样，根据需要选择安装路径，可以一路默认安装；  </p>
<p>安装完成后，在控制台中输入<code>git --version</code>查看是否添加了系统环境变量，这样就可以直接在dos中使用git命令了；  如果输出有误，检查git环境变量的设置。    </p>
<blockquote>
<p>完成以上步骤，准备阶段的工作就完成了。</p>
</blockquote>
<h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><ul>
<li>安装Hexo</li>
<li>配置Hexo</li>
<li>将Hexo与github page绑定</li>
<li>Hexo的使用设置</li>
</ul>
<h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><p>在合适的地方创建一个文件夹，这里我以D：/hexo 为例讲解，首先在D盘目录下创建Hexo文件夹，并在命令行的窗口进入到该目录；</p>
<p>在命令行中输入<code>npm install hexo-cli -g</code>，如果看到WARN也别担心，不影响使用；</p>
<p>继续输入<code>npm install hexo --save</code>；</p>
<p>稍等安装完成后，输入<code>hexo -v</code>查看Hexo是否安装成功。如果安装成功会显示出hexo的版本号以及其他信息；</p>
<h4 id="配置Hexo"><a href="#配置Hexo" class="headerlink" title="配置Hexo"></a>配置Hexo</h4><p>初始化Hexo：</p>
<ul>
<li>在DOS中输入<code>hexo init</code>；</li>
<li>然后输入<code>npm install</code>，npm将会自动安装你需要的组件，只需要等待npm操作即可。</li>
</ul>
<p>体验Hexo：</p>
<ul>
<li>在DOS中输入<code>hexo g</code>，等待完成；</li>
<li>然后输入<code>hexo s</code>，如果提示<code>INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code>，证明Hexo启动成功；</li>
<li>在浏览器中打开<a href="http://localhost:4000/，会看到Hexo的效果。" target="_blank" rel="noopener">http://localhost:4000/，会看到Hexo的效果。</a>  </li>
</ul>
<h4 id="将Hexo与github-page绑定"><a href="#将Hexo与github-page绑定" class="headerlink" title="将Hexo与github page绑定"></a>将Hexo与github page绑定</h4><p>配置Git个人信息</p>
<ul>
<li>设置Git的user name和email：(如果是第一次的话)</li>
<li>运行<code>git config --global user.name &quot;zhangsan&quot;</code>，”zhangsan”是你GitHub账户名；</li>
<li>运行<code>git config --global user.email &quot;zhangsan@163.com&quot;</code>，”<a href="mailto:zhangsan@163.com" target="_blank" rel="noopener">zhangsan@163.com</a>“是你注册GitHub的邮箱。</li>
</ul>
<p>使用SSH远程连接GitHub库（本部分命令都在Git Bash中执行）</p>
<ul>
<li><strong>注意</strong>：配置SSH主要是用于本地远程更新GitHub代码库，在搜集资料的时候看到有人说可以用https url的方式，但是我实践过程中是不行的，而且https url的方式在fetch和push代码都需要输入账号和密码，这是比较麻烦的。建议使用SSH-Key方式。</li>
<li>打开Git Bash，输入<code>ssh-keygen -t rsa -C &quot;zhangsan@163.com&quot; -f &quot;filename&quot;</code>生成密钥，”<a href="mailto:zhangsan@163.com" target="_blank" rel="noopener">zhangsan@163.com</a>“是你注册GitHub的邮箱，然后<strong>连续三个回车</strong>；</li>
<li>最后得到了两个文件：id_rsa和id_rsa.pub，默认存数在<code>C:\Users\电脑名称\.ssh</code>；</li>
<li>添加密钥到ssh-agent：输入 <code>eval &quot;$(ssh-agent -s)&quot;</code> ，输入 <code>ssh-add ~/.ssh/id_rsa</code> ；</li>
<li>登录GitHub，点击自己头像选择”Settings”，选择”SSH and GPG keys”，选择”New SSH key”，将id_rsa.pub中的内容copy过去；</li>
<li>在Git Bash终端中输入 <code>ssh -T git@github.com</code> 验证SSH-key是否配置成功，如果出现 <code>Hi zhagnsan! You’ve successfully authenticated, but GitHub does not provide shell access.</code> 表明配置成功；</li>
</ul>
<p>配置Deployment</p>
<ul>
<li><p>在Hexo根目录下的_config.yml文件中，找到Deployment，然后按照如下修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">	type: git</span><br><span class="line">	repo: git@github.com:yourname/yourname.github.io.git</span><br><span class="line">	branch: master</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Hexo的使用设置"><a href="#Hexo的使用设置" class="headerlink" title="Hexo的使用设置"></a>Hexo的使用设置</h4><p>首先安装扩展： <code>npm install hexo-deployer-git --save</code> ；</p>
<p>新建一篇博客，执行下面的命令： <code>hexo new post &quot;article title&quot;</code> ，这时候在电脑的目录下 D:\Hexo\source_posts 将会看到 article title.md 文件；</p>
<p>用MarDown编辑器打开就可以编辑文章了。文章编辑好之后，运行生成、部署命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g   // 生成</span><br><span class="line">hexo d   // 部署 </span><br><span class="line"></span><br><span class="line">或者 hexo d -g //在部署前先生成</span><br></pre></td></tr></table></figure>
<p>然后访问 <a href="https://yourName.github.io/" target="_blank" rel="noopener">https://yourName.github.io/</a> 查看生成的博客。  </p>
<h4 id="站点配置信息"><a href="#站点配置信息" class="headerlink" title="站点配置信息"></a>站点配置信息</h4><p>在Hexo根目录下的_config.yml文件中，根据需要配置各项信息:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">博客名称</span><br><span class="line">title: 我的博客</span><br><span class="line">副标题</span><br><span class="line">subtitle: 一天进步一点</span><br><span class="line">简介</span><br><span class="line">description: 记录生活点滴</span><br><span class="line">博客作者</span><br><span class="line">author: John Doe</span><br><span class="line">博客语言</span><br><span class="line">language: zh-CN</span><br><span class="line">时区</span><br><span class="line">timezone:</span><br><span class="line">博客地址,与申请的GitHub一致</span><br><span class="line">url: http://zhangsan.github.io</span><br><span class="line">root: /</span><br><span class="line">博客链接格式</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line">source_dir: source</span><br><span class="line">public_dir: public</span><br><span class="line">tag_dir: tags</span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line">new_post_name: :title.md # File name of new posts</span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: false # Transform title into titlecase</span><br><span class="line">external_link: true # Open external links in new tab</span><br><span class="line">filename_case: 0</span><br><span class="line">render_drafts: false</span><br><span class="line">post_asset_folder: false</span><br><span class="line">relative_link: false</span><br><span class="line">future: true</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  line_number: true</span><br><span class="line">  auto_detect: true</span><br><span class="line">  tab_replace:</span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line">日期格式</span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line">分页，每页文章数量</span><br><span class="line">per_page: 10</span><br><span class="line">pagination_dir: page</span><br><span class="line">博客主题</span><br><span class="line">theme: </span><br><span class="line">发布设置</span><br><span class="line">deploy: </span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/zhangsan/zhangsan.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>Read More:</p>
<blockquote>
<p><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53576018" target="_blank" rel="noopener">手把手教你用Hexo+Github 搭建属于自己的博客</a><br><a href="http://blog.csdn.net/gdutxiaoxu/article/details/53573399" target="_blank" rel="noopener">Git ssh 配置及使用</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP常用状态码详解</title>
    <url>/2017/04/04/httpstatecode/</url>
    <content><![CDATA[<p>HTTP状态码（HTTP Status Code）是用以表示网页服务器HTTP响应状态的3位数字代码。它由 RFC 2616 规范定义的，并得到RFC 2518、RFC 2817、RFC 2295、RFC 2774、RFC 4918等规范扩展。</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1xx</td>
<td>请求收到，继续处理</td>
</tr>
<tr>
<td>2xx</td>
<td>操作成功收到，分析、接受</td>
</tr>
<tr>
<td>3xx</td>
<td>完成此请求必须进一步处理</td>
</tr>
<tr>
<td>4xx</td>
<td>请求包含一个错误语法或不能完成</td>
</tr>
<tr>
<td>5xx</td>
<td>服务器执行一个完全有效请求失败</td>
</tr>
</tbody>
</table>
<h3 id="1xx：请求收到，继续处理"><a href="#1xx：请求收到，继续处理" class="headerlink" title="1xx：请求收到，继续处理"></a>1xx：请求收到，继续处理</h3><table>
<thead>
<tr>
<th>状态码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>100</td>
<td>客户端必须继续发送请求</td>
</tr>
<tr>
<td>101</td>
<td>服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求</td>
</tr>
<tr>
<td>102</td>
<td>处理将被继续执行</td>
</tr>
</tbody>
</table>
<h3 id="2xx：操作成功收到，分析、接受"><a href="#2xx：操作成功收到，分析、接受" class="headerlink" title="2xx：操作成功收到，分析、接受"></a>2xx：操作成功收到，分析、接受</h3><table>
<thead>
<tr>
<th>状态码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>请求已成功，请求所希望的响应头或数据体将随此响应返回</td>
</tr>
<tr>
<td>201</td>
<td>请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回</td>
</tr>
<tr>
<td>202</td>
<td>服务器已接受请求，但尚未处理</td>
</tr>
<tr>
<td>203</td>
<td>返回信息不确定或不完整</td>
</tr>
<tr>
<td>204</td>
<td>请求收到，但返回信息为空</td>
</tr>
<tr>
<td>205</td>
<td>服务器完成了请求，用户代理必须复位当前已经浏览过的文件</td>
</tr>
<tr>
<td>206</td>
<td>服务器已经完成了部分用户的GET请求</td>
</tr>
<tr>
<td>207</td>
<td>之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码</td>
</tr>
</tbody>
</table>
<h3 id="3xx：完成此请求必须进一步处理"><a href="#3xx：完成此请求必须进一步处理" class="headerlink" title="3xx：完成此请求必须进一步处理"></a>3xx：完成此请求必须进一步处理</h3><table>
<thead>
<tr>
<th>状态码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>300</td>
<td>请求的资源可在多处得到</td>
</tr>
<tr>
<td>301</td>
<td>删除请求数据</td>
</tr>
<tr>
<td>302</td>
<td>在其他地址发现了请求数据</td>
</tr>
<tr>
<td>303</td>
<td>建议客户访问其他URL或访问方式</td>
</tr>
<tr>
<td>304</td>
<td>客户端已经执行了GET，但文件未变化</td>
</tr>
<tr>
<td>305</td>
<td>请求的资源必须从服务器指定的地址得到</td>
</tr>
<tr>
<td>306</td>
<td>前一版本HTTP中使用的代码，现行版本中不再使用</td>
</tr>
<tr>
<td>307</td>
<td>申明请求的资源临时性删除</td>
</tr>
</tbody>
</table>
<h3 id="4xx：请求包含一个错误语法或不能完成"><a href="#4xx：请求包含一个错误语法或不能完成" class="headerlink" title="4xx：请求包含一个错误语法或不能完成"></a>4xx：请求包含一个错误语法或不能完成</h3><table>
<thead>
<tr>
<th>状态码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>400</td>
<td>错误请求，如语法错误</td>
</tr>
<tr>
<td>401</td>
<td>请求授权失败</td>
</tr>
<tr>
<td>402</td>
<td>保留有效ChargeTo头响应</td>
</tr>
<tr>
<td>403</td>
<td>请求不允许</td>
</tr>
<tr>
<td>404</td>
<td>没有发现文件、查询或URl</td>
</tr>
<tr>
<td>405</td>
<td>用户在Request-Line字段定义的方法不允许</td>
</tr>
<tr>
<td>406</td>
<td>根据用户发送的Accept拖，请求资源不可访问</td>
</tr>
<tr>
<td>407</td>
<td>类似401，用户必须首先在代理服务器上得到授权</td>
</tr>
<tr>
<td>408</td>
<td>客户端没有在用户指定的饿时间内完成请求</td>
</tr>
<tr>
<td>409</td>
<td>对当前资源状态，请求不能完成</td>
</tr>
<tr>
<td>410</td>
<td>服务器上不再有此资源且无进一步的参考地址</td>
</tr>
<tr>
<td>411</td>
<td>服务器拒绝用户定义的Content-Length属性请求</td>
</tr>
<tr>
<td>412</td>
<td>一个或多个请求头字段在当前请求中错误</td>
</tr>
<tr>
<td>413</td>
<td>请求的资源大于服务器允许的大小</td>
</tr>
<tr>
<td>414</td>
<td>请求的资源URL长于服务器允许的长度</td>
</tr>
<tr>
<td>415</td>
<td>请求资源不支持请求项目格式</td>
</tr>
<tr>
<td>416</td>
<td>请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段</td>
</tr>
<tr>
<td>417</td>
<td>服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求</td>
</tr>
<tr>
<td>422</td>
<td>请求格式正确，但是由于含有语义错误，无法响应</td>
</tr>
<tr>
<td>423</td>
<td>当前资源被锁定</td>
</tr>
<tr>
<td>424</td>
<td>由于之前的某个请求发生的错误，导致当前请求失败</td>
</tr>
<tr>
<td>425</td>
<td>在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中</td>
</tr>
<tr>
<td>426</td>
<td>客户端应当切换到TLS/1.0</td>
</tr>
<tr>
<td>427</td>
<td>请求应当在执行完适当的操作后进行重试</td>
</tr>
</tbody>
</table>
<h3 id="5xx：服务器执行一个完全有效请求失败"><a href="#5xx：服务器执行一个完全有效请求失败" class="headerlink" title="5xx：服务器执行一个完全有效请求失败"></a>5xx：服务器执行一个完全有效请求失败</h3><table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>500</td>
<td>服务器产生内部错误</td>
</tr>
<tr>
<td>501</td>
<td>服务器不支持请求的函数</td>
</tr>
<tr>
<td>502</td>
<td>服务器作为网关或代理，从上游服务器收到无效响应</td>
</tr>
<tr>
<td>503</td>
<td>服务器目前无法使用(由于超载或停机维护)</td>
</tr>
<tr>
<td>504</td>
<td>关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长</td>
</tr>
<tr>
<td>505</td>
<td>服务器不支持或拒绝支请求头中指定的HTTP版本</td>
</tr>
<tr>
<td>506</td>
<td>服务器存在内部配置错误</td>
</tr>
<tr>
<td>507</td>
<td>服务器无法存储完成请求所必须的内容</td>
</tr>
<tr>
<td>509</td>
<td>服务器达到带宽限制</td>
</tr>
<tr>
<td>510</td>
<td>获取资源所需要的策略并没有没满足</td>
</tr>
</tbody>
</table>
<p>Read More:</p>
<blockquote>
<p><a href="http://www.cnblogs.com/jinjiangongzuoshi/p/3778883.html" target="_blank" rel="noopener">HTTP 返回状态值详解</a></p>
</blockquote>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>状态码</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP POST提交数据分常见方式</title>
    <url>/2018/05/13/httppostmethod/</url>
    <content><![CDATA[<p><a href="http://www.ietf.org/rfc/rfc2616.txt" target="_blank" rel="noopener">HTTP/1.1协议</a> 规定的 HTTP 请求方法有 OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT这几种。其中 POST 一般用来向服务端提交数据，我们在写类似接口文档这种被业务方调用的服务时，涉及到 POST 的默认提交方式基本都是：<code>application/x-www-form-urlencoded</code> 。本 文主要讨论 POST 提交数据的几种方式。</p>
<p>我们知道，HTTP 协议是以 <strong>ASCII</strong> 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。类似于下面这样：</p>
<blockquote>
<p><method> <request-url> <version></version></request-url></method></p>
<headers>

<p><entity-body></entity-body></p>
</headers></blockquote>
<p>协议规定 POST 提交的数据必须放在消息主体（<code>entity-body</code>）中，但协议并没有规定数据必须使用什么编码方式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。</p>
<p>但是，数据发送出去，还要服务端解析成功才有意义。一般服务端语言如 java php python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 <code>Content-Type</code>字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 POST 提交数据方案，包含了 <code>Content-Type</code> 和消息主体编码方式两部分。下面进入正题。</p>
<h3 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application/x-www-form-urlencoded"></a>application/x-www-form-urlencoded</h3><p>这种方式是最常见的 POST 提交数据的方式。浏览器的原生 <code>&lt;form&gt;</code> 表单，如果不设置 <code>enctype</code> 属性，那么最终就会以 <code>application/x-www-form-urlencoded</code> 方式提交数据。请求类似于下面这样（无关的请求头在本文中都省略掉了）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST http://www.example.com HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded;charset=utf-8</span><br><span class="line">title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3</span><br></pre></td></tr></table></figure>
<p>首先，Content-Type 被指定为 <code>application/x-www-form-urlencoded</code> ；其次，提交的数据按照 <code>key1=val1&amp;key2=val2</code> 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。</p>
<p>通常，我们用 Ajax 提交数据时，也是使用这种方式。例如 <a href="http://jquery.com/" target="_blank" rel="noopener">JQuery</a> 和 <a href="http://www.qwrap.com/" target="_blank" rel="noopener">QWrap</a> 的 Ajax，<code>Content-Type</code> 默认值都是 <code>application/x-www-form-urlencoded;charset=utf-8</code> 。</p>
<h3 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a>multipart/form-data</h3><p>在使用表单上传文件时，必须让 <code>&lt;form&gt;</code> 表单的 <code>enctype</code> 等于 <code>multipart/form-data</code>。直接来看一个请求示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST http://www.example.com HTTP/1.1</span><br><span class="line">Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line">Content-Disposition: form-data; name=&quot;text&quot;</span><br><span class="line"></span><br><span class="line">title</span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;</span><br><span class="line">Content-Type: image/png</span><br><span class="line"></span><br><span class="line">PNG ... content of chrome.png ...</span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA--</span><br></pre></td></tr></table></figure>
<p>这个例子稍微复杂点。首先生成了一个 <code>boundary</code> 用于分割不同的字段，为了避免与正文内容重复，<code>boundary</code> 很长很复杂。然后 <code>Content-Type</code> 里指明了数据是以 <code>multipart/form-data</code> 来编码，本次请求的 <code>boundary</code> 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 <code>--boundary</code> 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 <code>--boundary--</code> 标示结束。关于 <code>multipart/form-data</code> 的详细定义，请前往 <a href="http://www.ietf.org/rfc/rfc1867.txt" target="_blank" rel="noopener">rfc1867</a> 查看。这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。</p>
<p>以上提到的两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 \&lt;form> 表单也 <a href="http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4" target="_blank" rel="noopener">只支持这两种方式</a>（通过 <code>&lt;form&gt;</code> 元素的 <code>enctype</code> 属性指定，默认为 <code>application/x-www-form-urlencoded</code>。其实 <code>enctype</code> 还支持 <code>text/plain</code>，不过用得非常少）。</p>
<p>随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，给开发带来更多便利。</p>
<h3 id="application-json"><a href="#application-json" class="headerlink" title="application/json"></a>application/json</h3><p><code>application/json</code> 这个 <code>Content-Type</code> 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。JSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用。</p>
<p>Google 的 <a href="http://angularjs.org/" target="_blank" rel="noopener">AngularJS</a> 中的 Ajax 功能，默认就是提交 JSON 字符串。例如下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var data = &#123;&apos;title&apos;:&apos;test&apos;, &apos;sub&apos; : [1,2,3]&#125;;</span><br><span class="line">$http.post(url, data).success(function(result) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>最终发送的请求是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST http://www.example.com HTTP/1.1 </span><br><span class="line">Content-Type: application/json;charset=utf-8</span><br><span class="line"></span><br><span class="line">&#123;&quot;title&quot;:&quot;test&quot;,&quot;sub&quot;:[1,2,3]&#125;</span><br></pre></td></tr></table></figure>
<p>这种方案，可以方便的提交复杂的结构化数据，特别适合 RESTful 的接口。各大抓包工具如 Chrome 自带的开发者工具、Firebug、Fiddler，都会以树形结构展示 JSON 数据，非常友好。但也有些服务端语言还没有支持这种方式，例如 php 就无法通过 $_POST 对象从上面的请求中获得内容。这时候，需要自己动手处理下：在请求头中 <code>Content-Type</code> 为 <code>application/json</code> 时，从 <code>php://input</code> 里获得原始输入流，再 <code>json_decode</code> 成对象。一些 php 框架已经开始这么做了。</p>
<p>当然 AngularJS 也可以配置为使用 <code>x-www-form-urlencoded</code> 方式提交数据。如有需要，可以参考 <a href="http://victorblog.com/2012/12/20/make-angularjs-http-service-behave-like-jquery-ajax/" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="text-xml"><a href="#text-xml" class="headerlink" title="text/xml"></a>text/xml</h3><p>这种方式目前几乎很少在用，因为 JSON 方式更加灵活方便，而 xml 方式显得比较臃肿和繁琐。<code>XML-RPC（XML Remote Procedure Call）</code> 协议是一套允许运行在不同操作系统、不同环境的程序实现基于 Internet 过程调用的规范和一系列的实现。这种远程过程调用使用 HTTP 作为传输协议，XML 作为传送信息的编码格式。</p>
<p>典型的 <code>XML-RPC</code> 请求是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST http://www.example.com HTTP/1.1 </span><br><span class="line">Content-Type: text/xml</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;methodCall&gt;</span><br><span class="line">    &lt;methodName&gt;examples.getStateName&lt;/methodName&gt;</span><br><span class="line">    &lt;params&gt;</span><br><span class="line">        &lt;param&gt;</span><br><span class="line">            &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt;</span><br><span class="line">        &lt;/param&gt;</span><br><span class="line">    &lt;/params&gt;</span><br><span class="line">&lt;/methodCall&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>POST</tag>
      </tags>
  </entry>
  <entry>
    <title>愚人节</title>
    <url>/2017/04/01/heyliuxiaoyang/</url>
    <content><![CDATA[<p>今天是愚人节，我的个人博客上线了。</p>
]]></content>
      <categories>
        <category>生活日志</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>Python系列 - 计算密集型任务和I/O密集型任务</title>
    <url>/2017/07/15/jsmjiomj/</url>
    <content><![CDATA[<h3 id="I-O密集型任务-VS-计算密集型任务"><a href="#I-O密集型任务-VS-计算密集型任务" class="headerlink" title="I/O密集型任务 VS 计算密集型任务"></a>I/O密集型任务 VS 计算密集型任务</h3><p>所谓 I/O 密集型任务，是指磁盘 I/O、网络 I/O 占主要的任务，计算量很小。比如请求网页、读写文件等。当然我们在Python中可以利用 sleep 达到 I/O 密集型任务的目的。</p>
<p>所谓计算密集型任务，是指 CPU 计算占主要的任务，CPU 一直处于满负荷状态。比如在一个很大的列表中查找元素（当然这不合理），复杂的加减乘除等。</p>
<h3 id="多线程-VS-多进程"><a href="#多线程-VS-多进程" class="headerlink" title="多线程 VS 多进程"></a>多线程 VS 多进程</h3><p>Python中比较常见的并发方式主要有两种：多线程和多进程。</p>
<h4 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h4><p>GIL 的全称是 Global Interpreter Lock (全局解释器锁)，来源是 python 设计之初的考虑，为了数据安全所做的决定。在Python多线程下，每个线程的执行方式：</p>
<ul>
<li>获取GIL ；</li>
<li>执行代码直到sleep或者是python虚拟机将其挂起；</li>
<li>释放GIL。</li>
</ul>
<p>可见，某个线程想要执行，必须先拿到 GIL，我们可以把 GIL 看作是“通行证”，并且在一个 Python 进程中，GIL 只有一个。拿不到通行证的线程，就不允许进入 CPU 执行。</p>
<p><strong>注意：</strong>多核多线程不一定比单核多线程更好。原因是单核下多线程，每次释放 GIL，唤醒的那个线程都能获取到 GIL 锁，所以能够无缝执行，但多核下，CPU0 释放 GIL 后，其他 CPU 上的线程都会进行竞争，但 GIL 可能会马上又被 CPU0 拿到，导致其他几个 CPU 上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸，导致效率更低。</p>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>多线程即在一个进程中启动多个线程执行任务。一般来说使用多线程可以达到并行的目的，但由于 Python 中使用了全局解释锁 GIL 的概念，导致 Python 中的多线程并不是并行执行，而是“交替执行”。类似于下图：（图片转自网络，侵删）</p>
<p><img src="/images/2017-7-15 160518.png" alt="2017-7-15 160518"></p>
<p>所以 Python 中的多线程适合 I/O 密集型任务，而不适合计算密集型任务。</p>
<p>Python 提供两组多线程接口，一是 thread 模块 _thread，提供低等级接口。二是 threading 模块，提供更容易使用的基于对象的接口，可以继承 Thread 对象来实现线程，此外其还提供了其它线程相关的对象，例如 Timer，Lock 等。</p>
<h4 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h4><p>由于 Python 中 GIL 的原因，对于计算密集型任务，Python 下比较好的并行方式是使用多进程，这样可以非常有效的使用CPU 资源。当然同一时间执行的进程数量取决你电脑的 CPU 核心数。</p>
<p><img src="/images/2017-7-15 160641.png" alt="2017-7-15 160641"></p>
<p>Python 中的进程模块为 mutliprocess 模块，提供了很多容易使用的基于对象的接口。另外它提供了封装好的管道和队列，可以方便的在进程间传递消息。Python 还提供了进程池 Pool 对象，可以方便的管理和控制线程。</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>这里通过一个实例，说明多线程适合IO密集型任务，多进程适合计算密集型任务。</p>
<p>首先定义一个队列，并定义初始化队列的函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 定义全局变量Queue，与Queue.Queue()的不同之处在于，multiprocessing.Queue()支持跨进程使用</span><br><span class="line">g_queue = multiprocessing.Queue()</span><br><span class="line"></span><br><span class="line">def init_queue():</span><br><span class="line">    print(&quot;init g_queue start&quot;)</span><br><span class="line">    while not g_queue.empty():</span><br><span class="line">        g_queue.get()</span><br><span class="line">    for _index in range(10):</span><br><span class="line">        g_queue.put(_index)</span><br><span class="line">    print(&quot;init g_queue end&quot;)</span><br><span class="line">    return</span><br></pre></td></tr></table></figure>
<p>然后定义 I/O 密集型任务和计算密集型任务，分别从队列中获取任务数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 定义一个IO密集型任务：利用time.sleep()</span><br><span class="line">def task_io(task_id):</span><br><span class="line">    print(&quot;IOTask[%s] start&quot; % task_id)</span><br><span class="line">    while not g_queue.empty():</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        try:</span><br><span class="line">            data = g_queue.get(block=True, timeout=1)</span><br><span class="line">            print(&quot;IOTask[%s] get data: %s&quot; % (task_id, data))</span><br><span class="line">        except Exception as ex:</span><br><span class="line">            print(&quot;IOTask[%s] error: %s&quot; % (task_id, str(ex)))</span><br><span class="line">    print(&quot;IOTask[%s] end&quot; % task_id)</span><br><span class="line">    return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g_search_list = list(range(10000))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 定义一个计算密集型任务：利用一些复杂加减乘除、列表查找等</span><br><span class="line">def task_cpu(task_id):</span><br><span class="line">    print(&quot;CPUTask[%s] start&quot; % task_id)</span><br><span class="line">    while not g_queue.empty():</span><br><span class="line">        count = 0</span><br><span class="line">        for i in range(10000):</span><br><span class="line">            count += pow(3 * 2, 3 * 2) if i in g_search_list else 0</span><br><span class="line">        try:</span><br><span class="line">            data = g_queue.get(block=True, timeout=1)</span><br><span class="line">            print(&quot;CPUTask[%s] get data: %s&quot; % (task_id, data))</span><br><span class="line">        except Exception as excep:</span><br><span class="line">            print(&quot;CPUTask[%s] error: %s&quot; % (task_id, str(excep)))</span><br><span class="line">    print(&quot;CPUTask[%s] end&quot; % task_id)</span><br><span class="line">    return task_id</span><br></pre></td></tr></table></figure>
<p>准备完上述代码之后，进行试验：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    print(&quot;cpu count:&quot;, multiprocessing.cpu_count(), &quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">    print(&quot;========== 直接执行IO密集型任务 ==========&quot;)</span><br><span class="line">    init_queue()</span><br><span class="line">    time_0 = time.time()</span><br><span class="line">    task_io(0)</span><br><span class="line">    print(&quot;结束：&quot;, time.time() - time_0, &quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">    print(&quot;========== 多线程执行IO密集型任务 ==========&quot;)</span><br><span class="line">    init_queue()</span><br><span class="line">    time_0 = time.time()</span><br><span class="line">    thread_list = [threading.Thread(target=task_io, args=(i,)) for i in range(4)]</span><br><span class="line">    for t in thread_list:</span><br><span class="line">        t.start()</span><br><span class="line">    for t in thread_list:</span><br><span class="line">        if t.is_alive():</span><br><span class="line">            t.join()</span><br><span class="line">    print(&quot;结束：&quot;, time.time() - time_0, &quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">    print(&quot;========== 多进程执行IO密集型任务 ==========&quot;)</span><br><span class="line">    init_queue()</span><br><span class="line">    time_0 = time.time()</span><br><span class="line">    process_list = [multiprocessing.Process(target=task_io, args=(i,)) for i in range(multiprocessing.cpu_count())]</span><br><span class="line">    for p in process_list:</span><br><span class="line">        p.start()</span><br><span class="line">    for p in process_list:</span><br><span class="line">        if p.is_alive():</span><br><span class="line">            p.join()</span><br><span class="line">    print(&quot;结束：&quot;, time.time() - time_0, &quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">    print(&quot;========== 直接执行计算密集型任务 ==========&quot;)</span><br><span class="line">    init_queue()</span><br><span class="line">    time_0 = time.time()</span><br><span class="line">    task_cpu(0)</span><br><span class="line">    print(&quot;结束：&quot;, time.time() - time_0, &quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">    print(&quot;========== 多线程执行计算密集型任务 ==========&quot;)</span><br><span class="line">    init_queue()</span><br><span class="line">    time_0 = time.time()</span><br><span class="line">    thread_list = [threading.Thread(target=task_cpu, args=(i,)) for i in range(4)]</span><br><span class="line">    for t in thread_list:</span><br><span class="line">        t.start()</span><br><span class="line">    for t in thread_list:</span><br><span class="line">        if t.is_alive():</span><br><span class="line">            t.join()</span><br><span class="line">    print(&quot;结束：&quot;, time.time() - time_0, &quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">    print(&quot;========== 多进程执行计算密集型任务 ==========&quot;)</span><br><span class="line">    init_queue()</span><br><span class="line">    time_0 = time.time()</span><br><span class="line">    process_list = [multiprocessing.Process(target=task_cpu, args=(i,)) for i in range(multiprocessing.cpu_count())]</span><br><span class="line">    for p in process_list:</span><br><span class="line">        p.start()</span><br><span class="line">    for p in process_list:</span><br><span class="line">        if p.is_alive():</span><br><span class="line">            p.join()</span><br><span class="line">    print(&quot;结束：&quot;, time.time() - time_0, &quot;\n&quot;)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">========== 直接执行IO密集型任务 ==========</span><br><span class="line">结束： 10.041141033172607 </span><br><span class="line">========== 多线程执行IO密集型任务 ==========</span><br><span class="line">结束： 5.073023557662964 </span><br><span class="line">========== 多进程执行IO密集型任务 ==========</span><br><span class="line">结束： 1.1165637969970703 </span><br><span class="line"></span><br><span class="line">========== 直接执行计算密集型任务 ==========</span><br><span class="line">结束： 36.41951608657837 </span><br><span class="line">========== 多线程执行计算密集型任务 ==========</span><br><span class="line">结束： 47.48710823059082 </span><br><span class="line">========== 多进程执行计算密集型任务 ==========</span><br><span class="line">结束： 0.82016921043396</span><br></pre></td></tr></table></figure>
<p>在执行计算密集型任务时，多进程的方式明显比多线程更好。</p>
<p>Read More:</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/24283040" target="_blank" rel="noopener">Python进阶：聊聊IO密集型任务、计算密集型任务，以及多线程、多进程</a>  <a href="http://blog.chinaunix.net/uid-12014716-id-5691776.html" target="_blank" rel="noopener">为什么在python里推荐使用多进程而不是多线程？–转同事的一篇文章</a>  <a href="https://zhuanlan.zhihu.com/p/20167077?columnSlug=auxten" target="_blank" rel="noopener">Python编程（二）：Python进程、线程那点事儿</a>  </p>
</blockquote>
]]></content>
      <categories>
        <category>进程/线程</category>
      </categories>
      <tags>
        <tag>计算密集型任务</tag>
        <tag>I/O密集型任务</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>约瑟夫环问题</title>
    <url>/2017/04/06/josephring/</url>
    <content><![CDATA[<p>约瑟夫环（约瑟夫问题）是一个数学的应用问题：已知n个人（以编号1，2，3…n分别表示）围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列（或者求最后一个出列的人的编号）。</p>
<p>这里提供了三种方法：</p>
<p>逻辑去除法；</p>
<p>递归法；</p>
<p>线性表法。</p>
<p>这个问题我觉得应该也可以用循环队列来解决，这种方法以后再加上。</p>
<h3 id="逻辑去除法"><a href="#逻辑去除法" class="headerlink" title="逻辑去除法"></a>逻辑去除法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 逻辑去除法</span><br><span class="line">    * @param $n</span><br><span class="line">    * @param $m</span><br><span class="line">    * @return int</span><br><span class="line">    */</span><br><span class="line">   public function ExJosephRing_Logic($n, $m)</span><br><span class="line">   &#123;</span><br><span class="line">       $tmp_array = array();</span><br><span class="line">       // $left_over记录数组中不为0的个数</span><br><span class="line">       $left_over = $n;</span><br><span class="line">       // $ret_value记录最后返回的数字</span><br><span class="line">       $ret_value = 0;</span><br><span class="line">       // 记录开始循环查找的起点</span><br><span class="line">       $start = 0;</span><br><span class="line">       // 初始化数组</span><br><span class="line">       for ($i = 0; $i &lt;= $n; $i++) &#123;</span><br><span class="line">           $tmp_array[$i] = $i;</span><br><span class="line">       &#125;</span><br><span class="line">       $array_length = count($tmp_array);</span><br><span class="line">       while ($left_over != 1) &#123;</span><br><span class="line">           for ($j = 1; $j &lt;= $m; $j++) &#123;</span><br><span class="line">               $start++;</span><br><span class="line">               // $tmp_array[$start] == 0检测数组越界</span><br><span class="line">               if ($start != $array_length &amp;&amp; $tmp_array[$start] == 0) &#123;</span><br><span class="line">                   for ($k = $start; $k &lt; $array_length; $k++) &#123;</span><br><span class="line">                       if ($tmp_array[$k] == 0) &#123;</span><br><span class="line">                           $start++;</span><br><span class="line">                       &#125; elseif ($tmp_array[$k] &gt; 0) &#123;</span><br><span class="line">                           break;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               // 循环到头，重新开始</span><br><span class="line">               if ($start == $array_length) &#123;</span><br><span class="line">                   $start = 0;</span><br><span class="line">               &#125;</span><br><span class="line">               if ($tmp_array[$start] == 0) &#123;</span><br><span class="line">                   for ($k = $start; $k &lt; $array_length; $k++) &#123;</span><br><span class="line">                       if ($tmp_array[$k] == 0) &#123;</span><br><span class="line">                           $start++;</span><br><span class="line">                       &#125; elseif ($tmp_array[$k] &gt; 0) &#123;</span><br><span class="line">                           break;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           $tmp_array[$start] = 0;</span><br><span class="line"></span><br><span class="line">           // 循环遍历，记录数组中不为0的元素的个数</span><br><span class="line">           $left_over = 0;</span><br><span class="line">           foreach ($tmp_array as $key =&gt; $value) &#123;</span><br><span class="line">               if ($value != 0) &#123;</span><br><span class="line">                   $left_over++;</span><br><span class="line">                   $ret_value = $value;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return $ret_value;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="递归方法"><a href="#递归方法" class="headerlink" title="递归方法"></a>递归方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 递归方法</span><br><span class="line">    * @param $tmp_array</span><br><span class="line">    * @param $m</span><br><span class="line">    * @param int $current</span><br><span class="line">    * @return int</span><br><span class="line">    */</span><br><span class="line">   public function ExJosephRing_Recursive($tmp_array, $m, $current = 0)</span><br><span class="line">   &#123;</span><br><span class="line">       $array_length = count($tmp_array);</span><br><span class="line">       $num = 1;</span><br><span class="line">       if (count($tmp_array) == 1) &#123;</span><br><span class="line">           return $tmp_array[0];</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           while ($num++ &lt; $m) &#123;</span><br><span class="line">               $current++;</span><br><span class="line">               $current = $current % $array_length;</span><br><span class="line">           &#125;</span><br><span class="line">           array_splice($tmp_array, $current, 1);</span><br><span class="line">           // 如果需要返回数据，这里必须加上return，否则不会返回结果</span><br><span class="line">           return $this-&gt;ExJosephRing_Recursive($tmp_array, $m, $current);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="线性表法"><a href="#线性表法" class="headerlink" title="线性表法"></a>线性表法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 线性表法</span><br><span class="line">    * @param $n</span><br><span class="line">    * @param $m</span><br><span class="line">    * @return int</span><br><span class="line">    */</span><br><span class="line">   public function ExJosephRing_Linear($n, $m)</span><br><span class="line">   &#123;</span><br><span class="line">       $r = 0;</span><br><span class="line">       for ($i = 2; $i &lt;= $n; $i++) &#123;</span><br><span class="line">           $r = ($r + $m) % $i;</span><br><span class="line">       &#125;</span><br><span class="line">       return $r + 1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>对于线性表法的解释：每个人出列后，剩下的人又组成了另一个子问题。只是他们的编号变化了。第一个出列的人肯定是a[1] = m(mod)n（m/n的余数），他除去后剩下的人编号是a[1]+1、a[1]+2、…、n、1、2、…a[1]-2、a[1]-1，对应的新编号是1，2，3…n-1。设此时某个人的新编号是i，他原来的编号就是(i+a[1])%n。于是，这便形成了一个递归问题。假如知道了这个子问题（n-1个人）的解是x，那么原问题（n个人）的解便是：(x+m%n)%n = (x+m)%n。问题的起始条件：如果n=1,那么结果就是1。</p>
<p>Read More:</p>
<blockquote>
<p><a href="http://9iphp.com/web/php/1112.html" target="_blank" rel="noopener">用PHP解决“约瑟夫环”的几种方法</a></p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>约瑟夫环</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux CentOS 系统时间校对</title>
    <url>/2020/10/27/linux-centos-sys-time/</url>
    <content><![CDATA[<h4 id="CentOS系统时间、时区查看"><a href="#CentOS系统时间、时区查看" class="headerlink" title="CentOS系统时间、时区查看"></a>CentOS系统时间、时区查看</h4><p>查看系统时间：date</p>
<p>查看硬件时间：hwclock</p>
<p>查看系统详细时间：timedatectl</p>
<p>查看系统所有时区：timedatectl list-timezones</p>
<p>将硬件时钟调整为与本地时钟一致：timedatectl set-local-rtc 1（其中 0 表示UTC时间）</p>
<p>设置系统时区为上海：timedatectl set-timezone Asia/Shanghai</p>
<h4 id="校正系统时间"><a href="#校正系统时间" class="headerlink" title="校正系统时间"></a>校正系统时间</h4><p>确认是否安装utpdate工具：<code>yum list installed|grep ntpdate</code></p>
<p>如未安装，需执行 <code>yum -y install ntpdate</code> </p>
<p>执行 <code>ntpdate -u  pool.ntp.org</code> 进行时间校正</p>
]]></content>
      <categories>
        <category>Linux/Unix</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>系统时间</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令 - cd</title>
    <url>/2018/04/15/linuxcd/</url>
    <content><![CDATA[<p>Linux cd命令用于切换当前工作目录至目标目录。其中目标目录表示法可为绝对路径或相对路径，若目录名称省略，则变换至使用者的 <code>home</code> 目录。</p>
<p>另外，”~” 也表示为 <code>home</code> 目录的意思，”.” 则是表示当前所在的目录，”..” 则表示目前目录位置的上一层目录。</p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd [dir](dir表示要切换的目录)</span><br></pre></td></tr></table></figure>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>切换当前目录至dir。</p>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><p>暂无</p>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><ul>
<li><code>cd / | cd //</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt local]# pwd</span><br><span class="line">/root/usr/local</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt local]# cd /</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt /]# pwd</span><br><span class="line">/</span><br></pre></td></tr></table></figure>
<p>进入系统根目录</p>
<ul>
<li><code>cd ..</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt local]# pwd</span><br><span class="line">/root/usr/local</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt local]# cd ..</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt usr]# pwd</span><br><span class="line">/root/usr</span><br></pre></td></tr></table></figure>
<p>切换到父目录</p>
<ul>
<li><code>cd -</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt local]# pwd</span><br><span class="line">/root/usr/local</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt local]# cd -</span><br><span class="line">/root/usr</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt usr]# cd</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt ~]# cd -</span><br><span class="line">/root/usr</span><br></pre></td></tr></table></figure>
<p>切换到上次使用的目录</p>
<ul>
<li><code>cd</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt local]# pwd</span><br><span class="line">/root/usr/local</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt local]# cd</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt ~]# pwd</span><br><span class="line">/root</span><br></pre></td></tr></table></figure>
<p>切换到当前用户主目录</p>
<ul>
<li><code>cd ~</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt ~]# cd /root/usr/local/</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt local]# cd ~</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt ~]# pwd</span><br><span class="line">/root</span><br></pre></td></tr></table></figure>
<p>切换到当前用户主目录</p>
<ul>
<li><code>cd /root/usr/local/</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt ~]# cd /root/usr/local/</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt local]# pwd</span><br><span class="line">/root/usr/local</span><br></pre></td></tr></table></figure>
<p>切换到指定目录</p>
<ul>
<li><code>cd !$</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt ~]# cd /root/usr/local/</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt local]# cd -</span><br><span class="line">/root</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt ~]# cd !$</span><br><span class="line">cd -</span><br><span class="line">/root/usr/local</span><br></pre></td></tr></table></figure>
<p>将上一命令得参数作为 <code>cd</code> 参数使用</p>
<p>Read More: </p>
<blockquote>
<p><a href="http://www.cnblogs.com/peida/archive/2012/10/24/2736501.html" target="_blank" rel="noopener">每天一个linux命令(2)：cd命令</a> <a href="http://www.runoob.com/linux/linux-comm-cd.html" target="_blank" rel="noopener">Linux cd命令</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>Linux/Unix</category>
      </categories>
      <tags>
        <tag>命令</tag>
        <tag>Linux</tag>
        <tag>cd</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令 - cp</title>
    <url>/2018/01/04/linuxcp/</url>
    <content><![CDATA[<p>Linux cp命令主要用于复制文件或目录，一般情况下，shell会设置一个别名，在命令行下复制文件时，如果目标文件已经存在，就会询问是否覆盖，不管你是否使用-i参数。但是如果是在shell脚本中执行cp时，没有-i参数时不会询问是否覆盖。这说明命令行和shell脚本的执行方式有些不同。 </p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp [options] source dest</span><br><span class="line">cp [options] source... directory</span><br></pre></td></tr></table></figure>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>将源文件复制至目标文件，或将多个源文件复制至目标目录。</p>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容</td>
</tr>
<tr>
<td>-b</td>
<td>为每个已存在的目标文件创建备份</td>
</tr>
<tr>
<td>-d</td>
<td>复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式</td>
</tr>
<tr>
<td>-f</td>
<td>覆盖已经存在的目标文件而不给出提示</td>
</tr>
<tr>
<td>-i</td>
<td>与-f选项相反，在覆盖目标文件之前给出提示</td>
</tr>
<tr>
<td>-H</td>
<td>跟随源文件中的命令行符号链接</td>
</tr>
<tr>
<td>-l</td>
<td>不复制文件，只是生成链接文件</td>
</tr>
<tr>
<td>-L</td>
<td>总是跟随符号链接</td>
</tr>
<tr>
<td>-n</td>
<td>不要覆盖已存在的文件</td>
</tr>
<tr>
<td>-P</td>
<td>不跟随源文件中的符号链接</td>
</tr>
<tr>
<td>-p</td>
<td>除复制文件的内容外，还把修改时间和访问权限也复制到新文件中</td>
</tr>
<tr>
<td>-R / -r</td>
<td>若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件</td>
</tr>
<tr>
<td>-s</td>
<td>复制时创建新的链接，类似于Windows系统中的快捷方式</td>
</tr>
</tbody>
</table>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><ul>
<li>cp cplog.log test1/</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制前：</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testcp]# ll</span><br><span class="line">total 12</span><br><span class="line">-rw-r--r-- 1 root root   28 Jan  3 20:00 cplog.log</span><br><span class="line">drwxr-xr-x 2 root root 4096 Jan  3 20:00 test1</span><br><span class="line">drwxr-xr-x 2 root root 4096 Jan  3 20:00 test2</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testcp]# ll test1/</span><br><span class="line">total 0</span><br><span class="line"></span><br><span class="line">复制后：</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testcp]# ll test1/</span><br><span class="line">total 4</span><br><span class="line">-rw-r--r-- 1 root root 28 Jan  3 20:01 cplog.log</span><br></pre></td></tr></table></figure>
<p>在没有带-a参数时，两个文件的时间是不一样的。在带了-a参数时，两个文件的时间是一致的。  </p>
<ul>
<li>cp cplog.log test1/</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt testcp]# cp cplog.log test1/</span><br><span class="line">cp: overwrite `test1/cplog.log&apos;? y</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testcp]# ll test1/</span><br><span class="line">total 4</span><br><span class="line">-rw-r--r-- 1 root root 28 Jan  3 20:04 cplog.log</span><br></pre></td></tr></table></figure>
<p>在目标目录中存在同名文件时，会询问是否覆盖，这是因为cp是cp -i的别名。目标文件存在时，即使加了-f标志，也还会询问是否覆盖。</p>
<ul>
<li>cp -a test1 test2</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">目的目录存在：</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testcp]# ll</span><br><span class="line">total 12</span><br><span class="line">-rw-r--r-- 1 root root   28 Jan  3 20:00 cplog.log</span><br><span class="line">drwxr-xr-x 2 root root 4096 Jan  3 20:01 test1</span><br><span class="line">drwxr-xr-x 3 root root 4096 Jan  3 20:06 test2</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testcp]# ll test1</span><br><span class="line">total 4</span><br><span class="line">-rw-r--r-- 1 root root 28 Jan  3 20:04 cplog.log</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testcp]# ll test2</span><br><span class="line">total 4</span><br><span class="line">drwxr-xr-x 2 root root 4096 Jan  3 20:01 test1</span><br><span class="line"></span><br><span class="line">目的目录不存在：</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testcp]# cp -a test1 test3</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testcp]# ll</span><br><span class="line">total 16</span><br><span class="line">-rw-r--r-- 1 root root   28 Jan  3 20:00 cplog.log</span><br><span class="line">drwxr-xr-x 2 root root 4096 Jan  3 20:01 test1</span><br><span class="line">drwxr-xr-x 3 root root 4096 Jan  3 20:06 test2</span><br><span class="line">drwxr-xr-x 2 root root 4096 Jan  3 20:01 test3</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testcp]# ll test3/</span><br><span class="line">total 4</span><br><span class="line">-rw-r--r-- 1 root root 28 Jan  3 20:04 cplog.log</span><br></pre></td></tr></table></figure>
<p>注意目标目录存在与否结果是不一样的。目标目录存在时，整个源目录被复制到目标目录里面。</p>
<ul>
<li>cp -s cplog.log cplog-1.log</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt testcp]# cp -s cplog.log cplog-1.log </span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testcp]# ll</span><br><span class="line">total 16</span><br><span class="line">lrwxrwxrwx 1 root root    9 Jan  3 20:09 cplog-1.log -&gt; cplog.log</span><br><span class="line">-rw-r--r-- 1 root root   28 Jan  3 20:00 cplog.log</span><br><span class="line">drwxr-xr-x 2 root root 4096 Jan  3 20:01 test1</span><br><span class="line">drwxr-xr-x 3 root root 4096 Jan  3 20:06 test2</span><br><span class="line">drwxr-xr-x 2 root root 4096 Jan  3 20:01 test3</span><br></pre></td></tr></table></figure>
<p>cplog-1.log是由 -s 的参数造成的，建立的是一个快捷方式，所以会看到在文件的最右边，显示这个文件是连结到的目的地。</p>
<p>Read More: </p>
<blockquote>
<p><a href="http://www.cnblogs.com/peida/archive/2012/10/29/2744185.html" target="_blank" rel="noopener">每天一个linux命令（8）：cp 命令</a> <a href="http://www.runoob.com/linux/linux-comm-cp.html" target="_blank" rel="noopener">Linux cp命令</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>Linux/Unix</category>
      </categories>
      <tags>
        <tag>命令</tag>
        <tag>Linux</tag>
        <tag>cp</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令 - ln</title>
    <url>/2018/01/04/linuxln/</url>
    <content><![CDATA[<p>Linux ln命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ln [参数] [源文件或目录] [目标文件或目录]</span><br></pre></td></tr></table></figure>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>Linux文件系统中，有所谓的链接（link），我们可以将其视为档案的别名，而链接又可分为两种：硬链接（hard link）与软链接（symbolic link），硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。</p>
<p>不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。</p>
<p>软链接</p>
<ul>
<li>软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式</li>
<li>软链接可以 跨文件系统 ，硬链接不可以</li>
<li>软链接可以对一个不存在的文件名进行链接</li>
<li>软链接可以对目录进行链接</li>
</ul>
<p>硬链接</p>
<ul>
<li>硬链接，以文件副本的形式存在。但不占用实际空间</li>
<li>不允许给目录创建硬链接</li>
<li>硬链接只有在同一个文件系统中才能创建</li>
</ul>
<p>注意</p>
<ul>
<li>ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；</li>
<li>ln的链接又分软链接和硬链接两种，软链接就是<code>ln –s 源文件 目标文件</code>，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接<code>ln 源文件 目标文件</code>，没有参数-s，它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化；</li>
<li>ln指令用在链接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。</li>
</ul>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-b</td>
<td>删除，覆盖以前建立的链接</td>
</tr>
<tr>
<td>-d</td>
<td>允许超级用户制作目录的硬链接</td>
</tr>
<tr>
<td>-f</td>
<td>强制执行</td>
</tr>
<tr>
<td>-i</td>
<td>交互模式，文件存在则提示用户是否覆盖</td>
</tr>
<tr>
<td>-n</td>
<td>把符号链接视为一般目录</td>
</tr>
<tr>
<td>-s</td>
<td>软链接(符号链接)</td>
</tr>
<tr>
<td>-v</td>
<td>显示详细的处理过程</td>
</tr>
<tr>
<td>-S</td>
<td>“-S&lt;字尾备份字符串&gt; “或 “–suffix=&lt;字尾备份字符串&gt;”</td>
</tr>
<tr>
<td>-V</td>
<td>“-V&lt;备份方式&gt;”或”–version-control=&lt;备份方式&gt;”</td>
</tr>
<tr>
<td>–help</td>
<td>显示帮助信息</td>
</tr>
<tr>
<td>–version</td>
<td>显示版本信息</td>
</tr>
</tbody>
</table>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><ul>
<li>ln -s cplog.log cplog-link.log</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt testln]# ln -s cplog.log cplog-link.log </span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testln]# ll</span><br><span class="line">total 4</span><br><span class="line">lrwxrwxrwx 1 root root  9 Jan  3 20:25 cplog-link.log -&gt; cplog.log</span><br><span class="line">-rw-r--r-- 1 root root 28 Jan  3 20:00 cplog.log</span><br></pre></td></tr></table></figure>
<p>为cplog.log文件创建软链接cplog-link.log，如果cplog.log丢失，其软链接cplog-link.log也将失效。</p>
<ul>
<li>ln cplog.log cplog-hard.log </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt testln]# ln cplog.log cplog-hard.log </span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testln]# ll</span><br><span class="line">total 8</span><br><span class="line">-rw-r--r-- 2 root root 28 Jan  3 20:00 cplog-hard.log</span><br><span class="line">lrwxrwxrwx 1 root root  9 Jan  3 20:25 cplog-link.log -&gt; cplog.log</span><br><span class="line">-rw-r--r-- 2 root root 28 Jan  3 20:00 cplog.log</span><br></pre></td></tr></table></figure>
<p>为cplog.log创建硬链接cplog-hard.log，cplog.log与cplog-hard.log的各项属性相同。</p>
<ul>
<li>ln cplog.log test/</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt testln]# ln cplog.log test/</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testln]# ll</span><br><span class="line">total 12</span><br><span class="line">-rw-r--r-- 3 root root   28 Jan  3 20:00 cplog-hard.log</span><br><span class="line">lrwxrwxrwx 1 root root    9 Jan  3 20:25 cplog-link.log -&gt; cplog.log</span><br><span class="line">-rw-r--r-- 3 root root   28 Jan  3 20:00 cplog.log</span><br><span class="line">drwxr-xr-x 2 root root 4096 Jan  3 20:31 test</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testln]# vi cplog.log </span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testln]# ll</span><br><span class="line">total 12</span><br><span class="line">-rw-r--r-- 3 root root   72 Jan  3 20:31 cplog-hard.log</span><br><span class="line">lrwxrwxrwx 1 root root    9 Jan  3 20:25 cplog-link.log -&gt; cplog.log</span><br><span class="line">-rw-r--r-- 3 root root   72 Jan  3 20:31 cplog.log</span><br><span class="line">drwxr-xr-x 2 root root 4096 Jan  3 20:31 test</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testln]# ll test/</span><br><span class="line">total 4</span><br><span class="line">-rw-r--r-- 3 root root 72 Jan  3 20:31 cplog.log</span><br></pre></td></tr></table></figure>
<p>将文件cplog.log创建硬链接到当前目录中已存在的目录，当修改./test/cplog.log文件时，会同步到源文件中。</p>
<ul>
<li>ln -sv /root/testln/test /root/testln/test2</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt testln]# ll test/</span><br><span class="line">total 0</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testln]# ll test2/</span><br><span class="line">total 0</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testln]# ln -sv test test2</span><br><span class="line">`test2/test&apos; -&gt; `test&apos;</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testln]# ll test2</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 4 Jan  3 20:38 test -&gt; test</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testln]# rm -rf test2/test </span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testln]# ll test2</span><br><span class="line">total 0</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testln]# ln -sv /root/testln/test /root/testln/test2</span><br><span class="line">`/root/testln/test2/test&apos; -&gt; `/root/testln/test&apos;</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testln]# ll test2</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx 1 root root 17 Jan  3 20:39 test -&gt; /root/testln/test</span><br></pre></td></tr></table></figure>
<p>创建test目录到test2目录的软链接时，必须使用绝对路径，如果使用相对路径，则目的路径中的链接不断闪烁，表示链接失败。</p>
<p>目录链接只能是软链接，在链接目标目录中修改文件都会在源文件目录中同步变化。</p>
<p>Read More: </p>
<blockquote>
<p><a href="http://www.cnblogs.com/peida/archive/2012/12/11/2812294.html" target="_blank" rel="noopener">每天一个linux命令（35）：ln 命令</a> <a href="http://www.runoob.com/linux/linux-comm-ln.html" target="_blank" rel="noopener">Linux ln命令</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>Linux/Unix</category>
      </categories>
      <tags>
        <tag>命令</tag>
        <tag>Linux</tag>
        <tag>ln</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令 - jq</title>
    <url>/2020/11/12/linuxjq/</url>
    <content><![CDATA[<p>jq可以对json数据进行分片、过滤、映射和转换，和sed、awk、grep等命令一样，都可以让你轻松地把玩文本。它能轻松地把你拥有的数据转换成你期望的格式，而且需要写的程序通常也比你期望的更加简短。github地址：<a href="https://stedolan.github.io/jq/" target="_blank" rel="noopener">https://stedolan.github.io/jq/</a></p>
<p>json示例文件jq.txt为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#123;&quot;name&quot;:&quot;站长工具&quot;,&quot;url&quot;:&quot;http://tool.chinaz.com&quot;,&quot;address&quot;:&#123;&quot;city&quot;:&quot;厦门&quot;,&quot;country&quot;:&quot;中国&quot;&#125;,&quot;arrayBrowser&quot;:[&#123;&quot;name&quot;:&quot;Google&quot;,&quot;url&quot;:&quot;http://www.google.com&quot;&#125;,&#123;&quot;name&quot;:&quot;Baidu&quot;,&quot;url&quot;&quot;http://www.baidu.com&quot;&#125;]&#125;,&#123;&quot;name&quot;:&quot;站长之家&quot;,&quot;url&quot;:&quot;http://tool.zzhome.com&quot;,&quot;address&quot;:&#123;&quot;city&quot;:&quot;大连&quot;,&quot;country&quot;:&quot;中国&quot;&#125;,&quot;arrayBrowser&quot;:[&#123;&quot;name&quot;:&quot;360&quot;,&quot;url&quot;:&quot;http://www.so.com&quot;&#125;,&#123;&quot;nme&quot;:&quot;bing&quot;,&quot;url&quot;:&quot;http://www.bing.com&quot;&#125;]&#125;]</span><br></pre></td></tr></table></figure>
<p>命令：<code>cat jq.txt|jq &#39;.&#39;</code></p>
<p>效果如下：</p>
<p><img src="/images/2020-11-15T103330.png" alt="2020-11-15T103330.png"></p>
<p>输出列表中的第一个元素，可以使用[index]：</p>
<p>命令：<code>cat jq.txt|jq &#39;.[0]&#39;</code></p>
<p>效果如下：</p>
<p><img src="/images/2020-11-15T103331.png" alt="2020-11-15T103331.png"></p>
<p>jq支持管道线<code>|</code>，它如同linux命令中的管道线——把前面命令的输出当作是后面命令的输入。如下命令把<code>.[0]</code>作为<code>{...}</code>的输入，进而访问嵌套的属性，如<code>.name</code>和<code>.address.city</code>。</p>
<p>命令：<code>cat jq.txt |jq &#39;.[0] | {name:.name,address:.address}&#39;</code></p>
<p>效果如下：</p>
<p><img src="/images/2020-11-15T103332.png" alt="2020-11-15T103332.png"></p>
<p>命令：<code>cat jq.txt |jq &#39;.[0] | {name:.name,city:.address.city}&#39;</code></p>
<p>效果如下：</p>
<p><img src="/images/2020-11-15T103333.png" alt="2020-11-15T103333.png"></p>
<p>命令：<code>cat jq.txt |jq &#39;.[0] | {name:.arrayBrowser[1],city:.address.city}&#39;</code></p>
<p>效果如下：</p>
<p><img src="/images/2020-11-15T103334.png" alt="2020-11-15T103334.png"></p>
<p>如果希望把jq的输出当作一个数组，可以在前后加上<code>[]</code>：</p>
<p>命令：<code>cat jq.txt |jq &quot;[.[] |{name:.arrayBrowser[1].name,city:.address.city}]&quot;</code></p>
<p>效果如下：</p>
<p><img src="/images/2020-11-15T103336.png" alt="2020-11-15T103336.png"></p>
<p>在{}中，冒号前面的名字是映射的名称，你可以任意修改，如： </p>
<p>命令：<code>cat jq.txt |jq &quot;[.[] |{name_001:.arrayBrowser[1].name,city_002:.address.city}]&quot;</code></p>
<p>效果如下：</p>
<p><img src="/images/2020-11-15T103335.png" alt="2020-11-15T103335.png"></p>
<p>Read More:</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/6de3cfdbdb0e" target="_blank" rel="noopener">给力的linux命令–jq简易教程</a></p>
<p><a href="http://einverne.github.io/post/2018/12/jq-command-line-json-processor.html" target="_blank" rel="noopener">每天学习一个命令：jq 命令行下处理 JSON</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux/Unix</category>
      </categories>
      <tags>
        <tag>命令</tag>
        <tag>Linux</tag>
        <tag>jq</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令 - ping</title>
    <url>/2018/01/02/linuxping/</url>
    <content><![CDATA[<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ping [参数] [主机名称或IP地址]</span><br></pre></td></tr></table></figure>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>ping命令用来测试主机之间网络的连通性。执行ping指令会使用ICMP传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息，因而得知该主机运作正常。</p>
<p>ping 命令每秒发送一个数据报并且为每个接收到的响应打印一行输出。ping 命令计算信号往返时间和（信息）包丢失情况的统计信息，并且在完成之后显示一个简要总结。</p>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>使用Socket的SO_DEBUG功能</td>
</tr>
<tr>
<td>-c &lt;完成次数&gt;</td>
<td>设置完成要求回应的次数</td>
</tr>
<tr>
<td>-f</td>
<td>极限检测</td>
</tr>
<tr>
<td>-i &lt;间隔秒数&gt;</td>
<td>指定收发信息的间隔时间</td>
</tr>
<tr>
<td>-l &lt;网络界面&gt;</td>
<td>使用指定的网络界面送出数据包</td>
</tr>
<tr>
<td>-l &lt;前置载入&gt;</td>
<td>设置在送出要求信息之前，先行发出的数据包</td>
</tr>
<tr>
<td>-n</td>
<td>只输出数值</td>
</tr>
<tr>
<td>-p</td>
<td>设置填满数据包的范本样式</td>
</tr>
<tr>
<td>-q</td>
<td>不显示指令执行过程，开头和结尾的相关信息除外</td>
</tr>
<tr>
<td>-r</td>
<td>忽略普通的Routing Table，直接将数据包送到远端主机上</td>
</tr>
<tr>
<td>-R</td>
<td>记录路由过程</td>
</tr>
<tr>
<td>-s &lt;数据包大小&gt;</td>
<td>设置数据包的大小</td>
</tr>
<tr>
<td>-t &lt;存活时间&gt;</td>
<td>设置存活数值TTL的大小</td>
</tr>
<tr>
<td>-v</td>
<td>详细显示指令的执行过程</td>
</tr>
</tbody>
</table>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><ul>
<li>ping 10.3.14.6</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PING 10.3.14.62 (10.3.14.62) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.3.14.62: icmp_seq=1 ttl=119 time=1.00 ms</span><br><span class="line">64 bytes from 10.3.14.62: icmp_seq=2 ttl=119 time=0.921 ms</span><br><span class="line">64 bytes from 10.3.14.62: icmp_seq=3 ttl=119 time=0.848 ms</span><br><span class="line">64 bytes from 10.3.14.62: icmp_seq=4 ttl=119 time=0.862 ms</span><br><span class="line">64 bytes from 10.3.14.62: icmp_seq=5 ttl=119 time=0.912 ms</span><br><span class="line">^C</span><br><span class="line">--- 10.3.14.62 ping statistics ---</span><br><span class="line">5 packets transmitted, 5 received, 0% packet loss, time 4990ms</span><br><span class="line">rtt min/avg/max/mdev = 0.848/0.909/1.004/0.061 ms</span><br><span class="line"></span><br><span class="line">需要手动Ctrl+c终止</span><br></pre></td></tr></table></figure>
<p>ping通主机</p>
<ul>
<li>ping 10.3.14.6</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PING 10.3.14.6 (10.3.14.6) 56(84) bytes of data.</span><br><span class="line">From 10.13.41.63 icmp_seq=1 Destination Host Unreachable</span><br><span class="line">From 10.13.41.634 icmp_seq=2 Destination Host Unreachable</span><br><span class="line">From 10.13.41.63 icmp_seq=3 Destination Host Unreachable</span><br><span class="line">From 10.13.41.63 icmp_seq=4 Destination Host Unreachable</span><br><span class="line">From 10.13.41.63 icmp_seq=5 Destination Host Unreachable</span><br><span class="line">From 10.13.41.63 icmp_seq=6 Destination Host Unreachable</span><br><span class="line"></span><br><span class="line">--- 10.3.14.6 ping statistics ---</span><br><span class="line">8 packets transmitted, 0 received, +6 errors, 100% packet loss, time 7005ms</span><br><span class="line">, pipe 4</span><br></pre></td></tr></table></figure>
<p>ping不通主机</p>
<ul>
<li>ping -c 10 10.3.14.62</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PING 10.3.14.62 (10.3.14.62) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.3.14.62: icmp_seq=1 ttl=119 time=0.914 ms</span><br><span class="line">64 bytes from 10.3.14.62: icmp_seq=2 ttl=119 time=0.525 ms</span><br><span class="line">64 bytes from 10.3.14.62: icmp_seq=3 ttl=119 time=1.09 ms</span><br><span class="line">64 bytes from 10.3.14.62: icmp_seq=4 ttl=119 time=1.01 ms</span><br><span class="line">64 bytes from 10.3.14.62: icmp_seq=5 ttl=119 time=0.956 ms</span><br><span class="line">64 bytes from 10.3.14.62: icmp_seq=6 ttl=119 time=1.11 ms</span><br><span class="line">64 bytes from 10.3.14.62: icmp_seq=7 ttl=119 time=0.870 ms</span><br><span class="line">64 bytes from 10.3.14.62: icmp_seq=8 ttl=119 time=0.891 ms</span><br><span class="line">64 bytes from 10.3.14.62: icmp_seq=9 ttl=119 time=0.922 ms</span><br><span class="line">64 bytes from 10.3.14.62: icmp_seq=10 ttl=119 time=1.02 ms</span><br><span class="line"></span><br><span class="line">--- 10.3.14.62 ping statistics ---</span><br><span class="line">10 packets transmitted, 10 received, 0% packet loss, time 9005ms</span><br><span class="line">rtt min/avg/max/mdev = 0.525/0.932/1.115/0.158 ms</span><br></pre></td></tr></table></figure>
<p>ping指定次数</p>
<ul>
<li>ping -c 10 -i 0.5 10.3.14.62</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PING 10.3.14.62 (10.3.14.62) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.3.14.62: icmp_seq=1 ttl=119 time=1.00 ms</span><br><span class="line">64 bytes from 10.3.14.62: icmp_seq=2 ttl=119 time=0.889 ms</span><br><span class="line">64 bytes from 10.3.14.62: icmp_seq=3 ttl=119 time=0.893 ms</span><br><span class="line">64 bytes from 10.3.14.62: icmp_seq=4 ttl=119 time=0.865 ms</span><br><span class="line">64 bytes from 10.3.14.62: icmp_seq=5 ttl=119 time=0.893 ms</span><br><span class="line">64 bytes from 10.3.14.62: icmp_seq=6 ttl=119 time=0.868 ms</span><br><span class="line">64 bytes from 10.3.14.62: icmp_seq=7 ttl=119 time=0.881 ms</span><br><span class="line">64 bytes from 10.3.14.62: icmp_seq=8 ttl=119 time=0.885 ms</span><br><span class="line">64 bytes from 10.3.14.62: icmp_seq=9 ttl=119 time=0.605 ms</span><br><span class="line">64 bytes from 10.3.14.62: icmp_seq=10 ttl=119 time=0.569 ms</span><br><span class="line"></span><br><span class="line">--- 10.3.14.62 ping statistics ---</span><br><span class="line">10 packets transmitted, 10 received, 0% packet loss, time 4506ms</span><br><span class="line">rtt min/avg/max/mdev = 0.569/0.835/1.003/0.130 ms</span><br></pre></td></tr></table></figure>
<p>ping指定次数和时间间隔</p>
<ul>
<li>ping -c 5 <a href="http://www.zhihu.com" target="_blank" rel="noopener">www.zhihu.com</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PING 6ej19t5k0le6q937.alicloudlayer.com (47.95.51.100) 56(84) bytes of data.</span><br><span class="line">64 bytes from 47.95.51.100: icmp_seq=1 ttl=45 time=3.08 ms</span><br><span class="line">64 bytes from 47.95.51.100: icmp_seq=2 ttl=45 time=3.02 ms</span><br><span class="line">64 bytes from 47.95.51.100: icmp_seq=3 ttl=45 time=3.01 ms</span><br><span class="line">64 bytes from 47.95.51.100: icmp_seq=4 ttl=45 time=3.05 ms</span><br><span class="line">64 bytes from 47.95.51.100: icmp_seq=5 ttl=45 time=3.03 ms</span><br><span class="line"></span><br><span class="line">--- 6ej19t5k0le6q937.alicloudlayer.com ping statistics ---</span><br><span class="line">5 packets transmitted, 5 received, 0% packet loss, time 4006ms</span><br><span class="line">rtt min/avg/max/mdev = 3.012/3.042/3.088/0.074 ms</span><br></pre></td></tr></table></figure>
<p>通过域名ping公网地址</p>
<ul>
<li>ping -i 3 -s 1024 -t 255 10.3.14.62</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PING 10.3.14.62 (10.3.14.62) 1024(1052) bytes of data.</span><br><span class="line">1032 bytes from 10.3.14.62: icmp_seq=1 ttl=119 time=1.18 ms</span><br><span class="line">1032 bytes from 10.3.14.62: icmp_seq=2 ttl=119 time=1.21 ms</span><br><span class="line">1032 bytes from 10.3.14.62: icmp_seq=3 ttl=119 time=1.22 ms</span><br><span class="line">1032 bytes from 10.3.14.62: icmp_seq=4 ttl=119 time=1.19 ms</span><br><span class="line">1032 bytes from 10.3.14.62: icmp_seq=5 ttl=119 time=1.20 ms</span><br><span class="line">1032 bytes from 10.3.14.62: icmp_seq=6 ttl=119 time=1.23 ms</span><br><span class="line">1032 bytes from 10.3.14.62: icmp_seq=7 ttl=119 time=1.22 ms</span><br><span class="line">1032 bytes from 10.3.14.62: icmp_seq=8 ttl=119 time=1.22 ms</span><br><span class="line">1032 bytes from 10.3.14.62: icmp_seq=9 ttl=119 time=1.21 ms</span><br><span class="line">1032 bytes from 10.3.14.62: icmp_seq=10 ttl=119 time=1.21 ms</span><br><span class="line">1032 bytes from 10.3.14.62: icmp_seq=11 ttl=119 time=1.19 ms</span><br><span class="line">1032 bytes from 10.3.14.62: icmp_seq=12 ttl=119 time=1.28 ms</span><br><span class="line">1032 bytes from 10.3.14.62: icmp_seq=13 ttl=119 time=1.20 ms</span><br><span class="line">1032 bytes from 10.3.14.62: icmp_seq=14 ttl=119 time=1.23 ms</span><br><span class="line">1032 bytes from 10.3.14.62: icmp_seq=15 ttl=119 time=1.21 ms</span><br><span class="line">1032 bytes from 10.3.14.62: icmp_seq=16 ttl=119 time=1.21 ms</span><br><span class="line">1032 bytes from 10.3.14.62: icmp_seq=17 ttl=119 time=1.18 ms</span><br><span class="line">^C</span><br><span class="line">--- 10.3.14.62 ping statistics ---</span><br><span class="line">17 packets transmitted, 17 received, 0% packet loss, time 48798ms</span><br><span class="line">rtt min/avg/max/mdev = 1.187/1.215/1.285/0.038 ms</span><br></pre></td></tr></table></figure>
<p>ping多参数使用</p>
<p>Read More：</p>
<blockquote>
<p><a href="http://www.cnblogs.com/peida/archive/2013/03/06/2945407.html" target="_blank" rel="noopener">每天一个linux命令（54）：ping命令</a> <a href="http://www.runoob.com/linux/linux-comm-ping.html" target="_blank" rel="noopener">Linux ping命令</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>Linux/Unix</category>
      </categories>
      <tags>
        <tag>命令</tag>
        <tag>Linux</tag>
        <tag>ping</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux的用户态和内核态</title>
    <url>/2017/07/16/linuxyhtnht/</url>
    <content><![CDATA[<p><strong>内核态</strong>:：CPU 可以访问内存所有数据，包括外围设备：硬盘、网卡。CPU 也可以将自己从一个程序切换到另一个程序。</p>
<p><strong>用户态</strong>：只能受限的访问内存，且不允许访问外围设备。占用 CPU 的能力被剥夺，CPU 资源可以被其他程序获取。</p>
<h3 id="Unix-Linux的体系架构"><a href="#Unix-Linux的体系架构" class="headerlink" title="Unix/Linux的体系架构"></a>Unix/Linux的体系架构</h3><p><img src="/images/2017-7-16 152145.png" alt="2017-7-16 152145"></p>
<p>如上图所示，从宏观上来看，Linux 操作系统的体系架构分为用户态和内核态（或者用户空间和内核）。</p>
<p><strong>内核从本质上看是一种软件—控制计算机的硬件资源，并提供上层应用程序运行的环境</strong>。</p>
<p>用户态即上层应用程序的活动空间，应用程序的执行必须依托于内核提供的资源，包括 CPU 资源、存储资源、I/O 资源等。为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用。</p>
<p><strong>系统调用是操作系统的最小功能单位</strong>，这些系统调用根据不同的应用场景可以进行扩展和裁剪，现在各种版本的Unix实现都提供了不同数量的系统调用，如 Linux 的不同版本提供了 240-260 个系统调用，FreeBSD 大约提供了 320 个（reference：UNIX环境高级编程）。我们可以把系统调用看成是一种不能再化简的操作（类似于原子操作，但是不同概念），有人把它比作一个汉字的一个“笔画”，而一个“汉字”就代表一个上层应用。因此，有时候如果要实现一个完整的汉字（给某个变量分配内存空间），就必须调用很多的系统调用。如果从实现者（程序员）的角度来看，这势必会加重程序员的负担，良好的程序设计方法是：重视上层的业务逻辑操作，而尽可能避免底层复杂的实现细节。库函数正是为了将程序员从复杂的细节中解脱出来而提出的一种有效方法。它实现对系统调用的封装，将简单的业务逻辑接口呈现给用户，方便用户调用，从这个角度上看，库函数就像是组成汉字的“偏旁”。这样的一种组成方式极大增强了程序设计的灵活性，对于简单的操作，我们可以直接调用系统调用来访问资源，如“人”，对于复杂操作，我们借助于库函数来实现，如“仁”。</p>
<p>Shell 是一个特殊的应用程序，俗称命令行，本质上是一个命令解释器，它下通系统调用，上通各种应用，通常充当着一种“胶水”的角色，来连接各个小功能程序，让不同程序能够以一个清晰的接口协同工作，从而增强各个程序的功能。同时，Shell 是可编程的，它可以执行符合 Shell 语法的文本，这样的文本称为Shell 脚本，通常短短的几行 Shell 脚本就可以实现一个非常大的功能，原因就是这些 Shell 语句通常都对系统调用做了一层封装。为了方便用户和系统交互，一般，一个 Shell对应一个终端，终端是一个硬件设备，呈现给用户的是一个图形化窗口。我们可以通过这个窗口输入或者输出文本。这个文本直接传递给shell进行分析解释，然后执行。</p>
<p>用户态的应用程序可以通过三种方式来访问内核态的资源：</p>
<ul>
<li>系统调用；</li>
<li>库函数；</li>
<li>Shell 脚本。</li>
</ul>
<p>下图是对上图的一个细分结构，从这个图上可以更进一步对内核所做的事有一个“全景式”的印象。</p>
<p>主要表现为：</p>
<ul>
<li>向下控制硬件资源；</li>
<li>向内管理操作系统资源：包括进程的调度和管理、内存的管理、文件系统的管理、设备驱动程序的管理以及网络资源的管理；</li>
<li>向上则向应用程序提供系统调用的接口。</li>
</ul>
<p>从整体上来看，整个操作系统分为两层：用户态和内核态，这种分层的架构极大地提高了资源管理的可扩展性和灵活性，而且方便用户对资源的调用和集中式的管理，带来一定的安全性。</p>
<p><img src="/images/2017-7-16 152540.jpg" alt="2017-7-16 152540"></p>
<h3 id="用户态和内核态的切换"><a href="#用户态和内核态的切换" class="headerlink" title="用户态和内核态的切换"></a>用户态和内核态的切换</h3><p>因为操作系统的资源是有限的，如果访问资源的操作过多，必然会消耗过多的资源，而且如果不对这些操作加以区分，很可能造成资源访问的冲突。所以，为了减少有限资源的访问和使用冲突，Unix/Linux 的设计哲学之一就是：对不同的操作赋予不同的执行等级，就是所谓特权的概念。简单说就是有多大能力做多大的事，与系统相关的一些特别关键的操作必须由最高特权的程序来完成。</p>
<p>Intel 的 X86 架构的 CPU 提供了 0 到 3 四个特权级，数字越小，特权越高，Linux 操作系统中主要采用了 0 和 3 两个特权级，分别对应的就是内核态和用户态。运行于用户态的进程可以执行的操作和访问的资源都会受到极大的限制，而运行在内核态的进程则可以执行任何操作并且在资源的使用上没有限制。很多程序开始时运行于用户态，但在执行的过程中，一些操作需要在内核权限下才能执行，这就涉及到一个从用户态切换到内核态的过程。比如 C 函数库中的内存分配函数 malloc()，它具体是使用 sbrk() 系统调用来分配内存，当 malloc 调用 sbrk() 的时候就涉及一次从用户态到内核态的切换，类似的函数还有 printf()，调用的是 wirte() 系统调用来输出字符串，等等。</p>
<p>用户态到内核态的切换方式：</p>
<ul>
<li>系统调用；</li>
<li>异常事件： 当 CPU 正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，这个时候就会触发从当前用户态执行的进程转向内核态执行相关的异常事件，典型的如缺页异常。</li>
<li>外围设备的中断：当外围设备完成用户的请求操作后，会像 CPU 发出中断信号，此时，CPU 就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。</li>
</ul>
<p><strong>注意</strong>：系统调用的本质其实也是中断，相对于外围设备的硬中断，这种中断称为软中断，这是操作系统为用户特别开放的一种中断，如 Linux int 80h 中断。所以，从触发方式和效果上来看，这三种切换方式是完全一样的，都相当于是执行了一个中断响应的过程。但是从触发的对象来看，系统调用是进程主动请求切换的，而异常和硬中断则是被动的。</p>
<p>Read More:</p>
<blockquote>
<p><a href="http://www.cnblogs.com/zemliu/p/3695503.html" target="_blank" rel="noopener">内核态(Kernel Mode)与用户态(User Mode)</a></p>
<p><a href="http://www.cnblogs.com/bakari/p/5520860.html" target="_blank" rel="noopener">Linux探秘之用户态与内核态</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux/Unix</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>用户态</tag>
        <tag>内核态</tag>
      </tags>
  </entry>
  <entry>
    <title>秒杀系统设计01 - 秒杀系统架构设计都有哪些关键点？</title>
    <url>/2021/07/04/miaosha01/</url>
    <content><![CDATA[<p>你好，我是许令波，花名“君山”。说起来我的职业生涯算是比较简单，2009 年大学毕业后就进入了淘宝，一直工作了七年多。这七年多的时间里，我有幸看到了淘宝业务的快速增长，并且以开发者的身份参与其中。</p>
<p>说实话，作为一名程序员，我的技术能力也在公司业务的快速增长过程中得到了历练，并积累了一些大流量高并发网站架构设计和优化的经验，尤其是针对“秒杀”这个场景。因为我确信，那个时候我们肯定是对系统做了足够多的极致优化，才能扛住当时洪峰般的流量请求。</p>
<p>记得早期的时候，淘宝商品详情系统的 PV 还差不多是 1 亿的样子，但是到 2016 年差不多已经升至 50 亿了。尤其是 2012 年到 2014 年那个时间段，“秒杀”活动特别流行，用户的参与热情一浪高过一浪，系统要面对的流量也是成倍增长。</p>
<p>而每一次的秒杀活动对技术团队来说都是一次考验。现在想起来，那个时候我们整个团队，无所畏惧，逐步迭代创新，然后解决一个个难题的过程，也是极具挑战性和成就感的事情。</p>
<p>记得有一年，为了应对“双十一”，我们整个商品详情团队对系统做了很多优化，我们自认为已经是整个公司最牛的系统了，性能也已经是“业界之巅”。</p>
<p>但是那年“双十一”的晚上，我们的系统还是遇到了瓶颈。当时老大就跑过来盯着我们，问我们什么时候能够恢复，我们整个团队都承担着巨大的心理压力。</p>
<p>事后我们复盘宕机的原因，发现当时的秒杀流量远远超过了我们的预想，我们根本没想到大家的参与热情能有那么高。于是我们按照这个增长率去预估下一年的流量和服务器，粗算下来，我记得差不多要增加 2000 台服务器，简直不可思议。</p>
<p>怎么可能真正增加这么多机器，所以这也就倒逼我们必须找出一些特殊的手段来优化系统。后面，经过一段时间的调研和分析，我们想到了把整个系统进行动静分离改造的解决方案。</p>
<p>秒杀系统也差不多那个时候才从商品详情系统独立出来成为一个独立产品的。因为我见证了秒杀系统的建设过程，所以也有颇多感慨。秒杀系统的迭代又是一个升级打怪的过程，我们也都是遇到问题解决问题，逐一优化。</p>
<p>那么，如何才能更好地理解秒杀系统呢？我觉得作为一个程序员，你首先需要从高维度出发，从整体上思考问题。在我看来，<strong>秒杀其实主要解决两个问题，一个是并发读，一个是并发写</strong>。并发读的核心优化理念是尽量减少用户到服务端来“读”数据，或者让他们读更少的数据；并发写的处理原则也一样，它要求我们在数据库层面独立出来一个库，做特殊的处理。另外，我们还要针对秒杀系统做一些保护，针对意料之外的情况设计兜底方案，以防止最坏的情况发生。</p>
<p>而从一个架构师的角度来看，要想打造并维护一个超大流量并发读写、高性能、高可用的系统，在整个用户请求路径上从浏览器到服务端我们要遵循几个原则，就是要保证用户请求的数据尽量少、请求数尽量少、路径尽量短、依赖尽量少，并且不要有单点。这些关键点我会在后面的文章里重点讲解。</p>
<p><strong>其实，秒杀的整体架构可以概括为“稳、准、快”几个关键字。</strong></p>
<p>所谓“稳”，就是整个系统架构要满足高可用，流量符合预期时肯定要稳定，就是超出预期时也同样不能掉链子，你要保证秒杀活动顺利完成，即秒杀商品顺利地卖出去，这个是最基本的前提。</p>
<p>然后就是“准”，就是秒杀 10 台 iPhone，那就只能成交 10 台，多一台少一台都不行。一旦库存不对，那平台就要承担损失，所以“准”就是要求保证数据的一致性。</p>
<p>最后再看“快”，“快”其实很好理解，它就是说系统的性能要足够高，否则你怎么支撑这么大的流量呢？不光是服务端要做极致的性能优化，而且在整个请求链路上都要做协同的优化，每个地方快一点，整个系统就完美了。</p>
<p>所以从技术角度上看“稳、准、快”，就对应了我们架构上的高可用、一致性和高性能的要求，我们的专栏也将主要围绕这几个方面来展开，具体如下。</p>
<ul>
<li><strong>高性能。</strong> 秒杀涉及大量的并发读和并发写，因此支持高并发访问这点非常关键。本专栏将从设计数据的动静分离方案、热点的发现与隔离、请求的削峰与分层过滤、服务端的极致优化这 4 个方面重点介绍。</li>
<li><strong>一致性。</strong> 秒杀中商品减库存的实现方式同样关键。可想而知，有限数量的商品在同一时刻被很多倍的请求同时来减库存，减库存又分为“拍下减库存”“付款减库存”以及预扣等几种，在大并发更新的过程中都要保证数据的准确性，其难度可想而知。因此，我将用一篇文章来专门讲解如何设计秒杀减库存方案。</li>
<li><strong>高可用。</strong> 虽然我介绍了很多极致的优化思路，但现实中总难免出现一些我们考虑不到的情况，所以要保证系统的高可用和正确性，我们还要设计一个 PlanB 来兜底，以便在最坏情况发生时仍然能够从容应对。专栏的最后，我将带你思考可以从哪些环节来设计兜底方案。</li>
</ul>
<p>Read More:</p>
<blockquote>
<p><a href="https://d.shikey.com/jike/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E5%B7%B2%E5%AE%8C%E7%BB%93/20%20%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F-%E8%AE%B8%E4%BB%A4%E6%B3%A2/180925-%E5%BC%80%E7%AF%87%E8%AF%8D%20_%20%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%85%B3%E9%94%AE%E7%82%B9%EF%BC%9F.html" target="_blank" rel="noopener">开篇词 | 秒杀系统架构设计都有哪些关键点？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
      <tags>
        <tag>秒杀系统</tag>
        <tag>架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql系列 - InnoDB与MyISAM</title>
    <url>/2017/07/15/myisaminnodb/</url>
    <content><![CDATA[<h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>MyISAM：每个MyISAM在磁盘上存储成三个文件。第一个文件的名字以表的名字开始，扩展名指出文件类型。.frm文件存储表定义。数据文件的扩展名为 .MYD  (MYData)。索引文件的扩展名是 .MYI  (MYIndex)；</p>
<p>InnoDB：所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。</p>
<h3 id="存储空间"><a href="#存储空间" class="headerlink" title="存储空间"></a>存储空间</h3><p>MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表；</p>
<p>InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。</p>
<h3 id="事务支持"><a href="#事务支持" class="headerlink" title="事务支持"></a>事务支持</h3><p>MyISAM：强调的是性能，每次查询具有原子性，其执行数度比 InnoDB 类型更快，但是不提供事务支持；</p>
<p>InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务、回滚和崩溃修复能力的事务安全型表。</p>
<h3 id="CURD操作"><a href="#CURD操作" class="headerlink" title="CURD操作"></a>CURD操作</h3><p>MyISAM：如果执行大量的 SELECT，MyISAM 是更好的选择。(因为没有支持行级锁)，在增删的时候需要锁定整个表格，效率会低一些。相关的是 InnoDB 支持行级锁，删除插入的时候只需要锁定该行就行，效率较高；</p>
<p>InnoDB：如果你的数据执行大量的 INSERT 或 UPDATE，出于性能方面的考虑，应该使用 InnoDB 表。DELETE 从性能上InnoDB 更优，但 DELETE FROM table 时，InnoDB 不会重新建立表，而是一行一行的删除，在 InnoDB 上如果要清空保存有大量数据的表，最好使用<code>truncate table</code> 这个命令。</p>
<h3 id="外键"><a href="#外键" class="headerlink" title="外键"></a>外键</h3><p>MyISAM：不支持；InnoDB：支持。</p>
<h3 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h3><p>InnoDB 支持数据行锁定，MyISAM 不支持行锁定，只支持锁定整个表。即 MyISAM 同一个表上的读锁和写锁是互斥的，</p>
<p>MyISAM 并发读写时如果等待队列中既有读请求又有写请求，默认写请求的优先级高，即使读请求先到，所以 MyISAM 不适合于有大量查询和修改并存的情况，那样查询进程会长时间阻塞。因为 MyISAM 是锁表，所以某项读操作比较耗时会使其他写进程饿死。</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>InnoDB 从5.6.4才开始支持全文索引，而 MyISAM 一直支持。全文索引是指对 char、varchar 和 text 中的每个词（停用词除外）建立倒排序索引。MyISAM的全文索引其实很简单，因为它不支持中文分词，必须由使用者分词后加入空格再写到数据表里，而且少于4个汉字的词会和停用词一样被忽略掉。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>MyISAM 支持 GIS 数据，InnoDB 不支持。即 MyISAM 支持以下空间数据对象：Point，Line，Polygon，Surface等。</p>
<p>对于AUTO_INCREMENT 类型的字段，InnoDB 中必须包含只有该字段的索引，但是在 MyISAM 表中，可以和其他字段一起建立联合索引。</p>
<p>InnoDB 中不保存表的具体行数，也就是说，执行 <code>select count(*) from table</code> 时，InnoDB 要扫描一遍整个表来计算有多少行，但是 MyISAM 只要简单的读出保存好的行数即可。注意的是，当 <code>count(*)</code> 语句包含 where 条件时，两种表的操作是一样的。</p>
<p>InnoDB 表的行锁也不是绝对的，假如在执行一个 SQL 语句时 MySQL 不能确定要扫描的范围，InnoDB 表同样会锁全表，例如 <code>update table set num=1 where name like &#39;%aaa%&#39;</code> </p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>InnoDB</tag>
        <tag>MyISAM</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql系列 - 数据类型</title>
    <url>/2021/06/29/mysql-datatype/</url>
    <content><![CDATA[<p>MySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串（字符）类型。</p>
<h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">存储字节数</th>
<th style="text-align:left">范围（有符号）</th>
<th style="text-align:left">范围（无符号）</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">TINYINT</td>
<td style="text-align:left">1</td>
<td style="text-align:left">-2^7 ~ 2^7 - 1</td>
<td style="text-align:left">0 ~ 2^8 - 1</td>
<td style="text-align:left">小整数值</td>
</tr>
<tr>
<td style="text-align:left">SMALLINT</td>
<td style="text-align:left">2</td>
<td style="text-align:left">-2^15 ~ 2^15 - 1</td>
<td style="text-align:left">0 ~ 2^16 - 1</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMINT</td>
<td style="text-align:left">3</td>
<td style="text-align:left">-2^23 ~ 2^23 - 1</td>
<td style="text-align:left">0 ~ 2^24 - 1</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">INT或INTEGER</td>
<td style="text-align:left">4</td>
<td style="text-align:left">-2^31 ~ 2^31 - 1</td>
<td style="text-align:left">0 ~ 2^32 - 1</td>
<td style="text-align:left">大整数值</td>
</tr>
<tr>
<td style="text-align:left">BIGINT</td>
<td style="text-align:left">8</td>
<td style="text-align:left">-2^63 ~ 2^63 - 1</td>
<td style="text-align:left">0 ~ 2^64 - 1</td>
<td style="text-align:left">极大整数值</td>
</tr>
<tr>
<td style="text-align:left">FLOAT</td>
<td style="text-align:left">4</td>
<td style="text-align:left">-3.402823466E+38 ~ -1.175494 351E-38)<br>0<br>1.175494351E-38 ~ 3.402823466351E+38</td>
<td style="text-align:left">0<br>1.175494351E-38 ~ 3.402823466E+38</td>
<td style="text-align:left">单精度 浮点数值</td>
</tr>
<tr>
<td style="text-align:left">DOUBLE</td>
<td style="text-align:left">8</td>
<td style="text-align:left">-1.7976931348623157E+308 ~ -2.225073858507201 4E-308<br>0<br>2.2250738585072014E-308 ~ 1.7976931348623157E+308</td>
<td style="text-align:left">0<br>2.2250738585072014E-308 ~ 1.7976931348623157E+308</td>
<td style="text-align:left">双精度 浮点数值</td>
</tr>
<tr>
<td style="text-align:left">DECIMAL</td>
<td style="text-align:left">DECIMAL(M,D) ，如果M&gt;D，为M+2，否则为D+2</td>
<td style="text-align:left">依赖于M和D的值</td>
<td style="text-align:left">依赖于M和D的值</td>
<td style="text-align:left">小数值</td>
</tr>
</tbody>
</table>
<p><strong>Double 和 Float 彼此的区别：</strong></p>
<ul>
<li><p>在内存中占有的字节数不同，单精度内存占4个字节，双精度内存占8个字节</p>
</li>
<li><p>有效数字位数不同（尾数），单精度小数点后有效位数7位,  双精度小数点后有效位数16位</p>
</li>
<li><p>数值取值范围不同，根据IEEE标准来计算</p>
</li>
<li><p>在程序中处理速度不同，一般来说，CPU处理单精度浮点数的速度比处理双精度浮点数快</p>
</li>
</ul>
<p><strong>Double 和 Float 彼此的优缺点：</strong></p>
<ul>
<li><p>Float单精度</p>
<ul>
<li>优点：Float单精度在一些处理器上比Double双精度更快而且只占用Double双精度一半的空间</li>
<li>缺点：但是当值很大或很小的时候，它将变得不精确</li>
</ul>
</li>
<li><p>Double双精度</p>
<ul>
<li>优点：Double 跟 Float比较, 必然是 Double 精度高，尾数可以有 16 位，而  Float 尾数精度只有 7 位</li>
<li>缺点：Double 双精度是消耗内存的，并且是 Float 单精度的两倍，Double 的运算速度比 Float 慢得多，因为Double 尾数比Float  的尾数多，所以计算起来必然是有开销的</li>
</ul>
</li>
</ul>
<h3 id="日期-时间类型"><a href="#日期-时间类型" class="headerlink" title="日期/时间类型"></a>日期/时间类型</h3><table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">存储字节数</th>
<th style="text-align:left">范围</th>
<th style="text-align:left">格式</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DATE</td>
<td style="text-align:left">3</td>
<td style="text-align:left">1000-01-01 ~ 9999-12-31</td>
<td style="text-align:left">YYYY-MM-DD</td>
<td style="text-align:left">日期值</td>
</tr>
<tr>
<td style="text-align:left">TIME</td>
<td style="text-align:left">3</td>
<td style="text-align:left">-838:59:59 ~ 838:59:59</td>
<td style="text-align:left">HH:MM:SS</td>
<td style="text-align:left">时间值或持续时间</td>
</tr>
<tr>
<td style="text-align:left">YEAR</td>
<td style="text-align:left">1</td>
<td style="text-align:left">1901 ~ 2155</td>
<td style="text-align:left">YYYY</td>
<td style="text-align:left">年份值</td>
</tr>
<tr>
<td style="text-align:left">DATETIME</td>
<td style="text-align:left">8</td>
<td style="text-align:left">1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td>
<td style="text-align:left">YYYY-MM-DD HH:MM:SS</td>
<td style="text-align:left">混合日期和时间值</td>
</tr>
<tr>
<td style="text-align:left">TIMESTAMP</td>
<td style="text-align:left">4</td>
<td style="text-align:left">1970-01-01 00:00:01 UTC ~2038-01-19 03:14:07 UTC</td>
<td style="text-align:left">YYYYMMDD HHMMSS</td>
<td style="text-align:left">混合日期和时间值，时间戳</td>
</tr>
</tbody>
</table>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">存储字节数</th>
<th style="text-align:left">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CHAR</td>
<td style="text-align:left">0 ~ 255</td>
<td style="text-align:left">定长字符串</td>
</tr>
<tr>
<td style="text-align:left">VARCHAR</td>
<td style="text-align:left">0 ~ 65535</td>
<td style="text-align:left">变长字符串</td>
</tr>
<tr>
<td style="text-align:left">TINYBLOB</td>
<td style="text-align:left">0 ~ 255</td>
<td style="text-align:left">不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td style="text-align:left">TINYTEXT</td>
<td style="text-align:left">0 ~ 255</td>
<td style="text-align:left">短文本字符串</td>
</tr>
<tr>
<td style="text-align:left">BLOB</td>
<td style="text-align:left">0 ~ 65535</td>
<td style="text-align:left">二进制形式的长文本数据</td>
</tr>
<tr>
<td style="text-align:left">TEXT</td>
<td style="text-align:left">0 ~ 65535</td>
<td style="text-align:left">长文本数据</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMBLOB</td>
<td style="text-align:left">0 ~ 16777215</td>
<td style="text-align:left">二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td style="text-align:left">MEDIUMTEXT</td>
<td style="text-align:left">0 ~ 16777 215</td>
<td style="text-align:left">中等长度文本数据</td>
</tr>
<tr>
<td style="text-align:left">LONGBLOB</td>
<td style="text-align:left">0 ~ 4294967295</td>
<td style="text-align:left">二进制形式的极大文本数据</td>
</tr>
<tr>
<td style="text-align:left">LONGTEXT</td>
<td style="text-align:left">0 ~ 4294967295</td>
<td style="text-align:left">极大文本数据</td>
</tr>
<tr>
<td style="text-align:left">ENUM</td>
<td style="text-align:left">0 ~ 65535</td>
<td style="text-align:left">枚举类型，只能存一个枚举字符串值</td>
</tr>
</tbody>
</table>
<p>Read More:</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/672049b65691" target="_blank" rel="noopener">MySQL 之数据类型</a></p>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/data-types.html" target="_blank" rel="noopener">Chapter 11 Data Types</a></p>
<p><a href="https://www.runoob.com/mysql/mysql-data-types.html" target="_blank" rel="noopener">MySQL 数据类型</a></p>
</blockquote>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql系列 - explain</title>
    <url>/2021/02/20/mysql-explain/</url>
    <content><![CDATA[<p>通常我们在优化Mysql语句时会使用explain关键字，它是MySQL 提供的对 SELECT 语句进行分析并输出 SELECT 执行的详细信息的命令，其输出结果如下图：</p>
<p><img src="/images/2021-2-20T121509.png" alt="2021-2-20T121509.png"></p>
<h3 id="explain结果"><a href="#explain结果" class="headerlink" title="explain结果"></a>explain结果</h3><table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>SELECT 查询的标识符，每个 SELECT 都会自动分配一个唯一的标识符</td>
<td>id大的先执行，id相等由上到下执行</td>
</tr>
<tr>
<td>select_type</td>
<td>SELECT 查询的类型</td>
<td></td>
</tr>
<tr>
<td>table</td>
<td>查询的表名</td>
<td></td>
</tr>
<tr>
<td>partitions</td>
<td>匹配的分区</td>
<td>分库时使用</td>
</tr>
<tr>
<td>type</td>
<td>join 类型</td>
<td></td>
</tr>
<tr>
<td>possible_keys</td>
<td>此次查询中可能选用的索引</td>
<td></td>
</tr>
<tr>
<td>key</td>
<td>此次查询中确切使用到的索引</td>
<td></td>
</tr>
<tr>
<td>key_len</td>
<td>实际选择的索引的长度</td>
<td></td>
</tr>
<tr>
<td>ref</td>
<td>哪个字段或常数与 key 一起被使用</td>
<td></td>
</tr>
<tr>
<td>rows</td>
<td>显示此查询共扫描了多少行，估计值</td>
<td></td>
</tr>
<tr>
<td>filtered</td>
<td>表示此查询条件所过滤的数据的百分比</td>
<td></td>
</tr>
<tr>
<td>Extra</td>
<td>额外的信息</td>
</tr>
</tbody>
</table>
<h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>SIMPLE</td>
<td>此查询不包含 UNION 查询或子查询</td>
</tr>
<tr>
<td>PRIMARY</td>
<td>此查询是最外层的查询</td>
</tr>
<tr>
<td>UNION</td>
<td>此查询是 UNION 的第二或随后的查询</td>
</tr>
<tr>
<td>DEPENDENT UNION</td>
<td>UNION 中的第二个或后面的查询语句，取决于外面的查询</td>
</tr>
<tr>
<td>UNION RESULT</td>
<td>UNION 的结果</td>
</tr>
<tr>
<td>SUBQUERY</td>
<td>子查询中的第一个 SELECT</td>
</tr>
<tr>
<td>DEPENDENT SUBQUERY</td>
<td>子查询中的第一个 SELECT，取决于外面的查询，即子查询依赖于外层查询的结果</td>
</tr>
</tbody>
</table>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>system</td>
<td>表中只有一条数据，这个类型是特殊的 <code>const</code> 类型</td>
</tr>
<tr>
<td>const</td>
<td>针对主键或唯一索引的等值查询扫描，最多只返回一行数据。const 查询速度非常快，因为它仅仅读取一次即可</td>
</tr>
<tr>
<td>eq_ref</td>
<td>此类型通常出现在多表的 join 查询，表示对于前表的每一个结果，都只能匹配到后表的一行结果，并且查询的比较操作通常是 <code>=</code>，查询效率较高</td>
</tr>
<tr>
<td>ref</td>
<td>此类型通常出现在多表的 join 查询，针对于非唯一或非主键索引，或者是使用了最左前缀规则索引的查询</td>
</tr>
<tr>
<td>range</td>
<td>使用索引范围查询，通过索引字段范围获取表中部分数据记录。这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中（当 <code>type</code> 是 <code>range</code> 时, 那么 EXPLAIN 输出的 <code>ref</code> 字段为 NULL，并且 <code>key_len</code> 字段是此次查询中使用到的索引的最长的那个）</td>
</tr>
<tr>
<td>index</td>
<td>全索引扫描(full index scan)，和 ALL 类型类似，只不过 ALL 类型是全表扫描，而 index 类型则仅仅扫描所有的索引，而不扫描数据</td>
</tr>
<tr>
<td>all</td>
<td>全表扫描, 这个类型的查询是性能最差的查询之一</td>
</tr>
</tbody>
</table>
<p>效率比较：all&lt; index &lt; range&lt; ref &lt; eq_ref &lt; const &lt; system</p>
<h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示查询优化器使用了索引的字节数。这个字段可以评估组合索引是否完全被使用，或只有最左部分字段被使用到，key_len 的计算规则如下：</p>
<ul>
<li>字符串<ul>
<li>char(n)：n 字节长度</li>
<li>varchar(n)：如果是 utf8 编码, 则是 3 *n + 2字节; 如果是 utf8mb4 编码, 则是 4* n + 2 字节.</li>
</ul>
</li>
<li>数值类型:<ul>
<li>TINYINT：1字节</li>
<li>SMALLINT：2字节</li>
<li>MEDIUMINT：3字节</li>
<li>INT：4字节</li>
<li>BIGINT：8字节</li>
</ul>
</li>
<li>时间类型<ul>
<li>DATE：3字节</li>
<li>TIMESTAMP：4字节</li>
<li>DATETIME：8字节</li>
</ul>
</li>
<li>字段属性：NULL 属性占用一个字节，如果一个字段是 NOT NULL 的，则没有此属性。</li>
</ul>
<h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>MySQL 查询优化器根据统计信息估算 SQL 要查找到结果集需要扫描读取的数据行数。这个值非常直观显示 SQL 的效率好坏，原则上 rows 越少越好。</p>
<p><strong>Extra</strong></p>
<table>
<thead>
<tr>
<th>取值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Using index</td>
<td>查询在索引树中就可查找所需数据, 不用扫描表数据文件</td>
</tr>
<tr>
<td>Using index condition</td>
<td>使用索引下推，延迟回表，且减少了需要回表的结果集</td>
</tr>
<tr>
<td>Using temporary</td>
<td>查询有使用临时表，一般出现于排序，分组和多表 join 的情况，查询效率不高</td>
</tr>
<tr>
<td>Using filesort</td>
<td>MySQL 需额外的排序操作，不能通过索引顺序达到排序效果。数量小时使用内存排序，数量大时使用磁盘排序</td>
</tr>
<tr>
<td>Using where</td>
<td>在存储引擎层检索出记录后，在server利用where条件进行过滤，并返回给客户端</td>
</tr>
</tbody>
</table>
<p>Read More:</p>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000008131735" target="_blank" rel="noopener">MySQL 性能优化神器 Explain 使用分析</a></p>
<p><a href="http://weikeqin.com/2020/02/05/mysql-explain/" target="_blank" rel="noopener">mysql explain 详解</a></p>
</blockquote>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>explain</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql系列 - 回表查询和覆盖索引</title>
    <url>/2021/05/23/mysql-huibiao/</url>
    <content><![CDATA[<h4 id="回表查询"><a href="#回表查询" class="headerlink" title="回表查询"></a>回表查询</h4><p>通俗的讲就是，如果索引的列在 Select 所需获得的列中或者根据一次索引查询就能获得记录就不需要回表，如果 Select 所需获得列中有大量的非索引列，索引就需要到表中找到相应的列的信息，这就叫回表查询。</p>
<p>InnoDB聚集（聚簇）索引的叶子节点存储行记录，非叶子节点存储主键索引，因此， InnoDB必须要有且只有一个聚集索引：</p>
<p>（1）如果表定义了主键，则PK就是聚集索引；<br>（2）如果表没有定义主键，则第一个非空唯一索引（not NULL unique）列是聚集索引；<br>（3）否则，InnoDB会创建一个隐藏的row-id作为聚集索引；</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>建表如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table user(</span><br><span class="line">    -&gt; id int(10) auto_increment,</span><br><span class="line">    -&gt; name varchar(30),</span><br><span class="line">    -&gt; age tinyint(4),</span><br><span class="line">    -&gt; primary key (id),</span><br><span class="line">    -&gt; index idx_age (age)</span><br><span class="line">    -&gt; )engine=innodb charset=utf8mb4;</span><br></pre></td></tr></table></figure>
<p>其中，id 字段是聚簇索引（主键索引），age 字段是普通索引（二级索引）</p>
<p>表中数据如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from user;</span><br><span class="line">+----+--------+------+</span><br><span class="line">| id | name  | age |</span><br><span class="line">+----+--------+------+</span><br><span class="line">| 1 | 张三  |  30 |</span><br><span class="line">| 2 | 李四  |  20 |</span><br><span class="line">| 3 | 王五  |  40 |</span><br><span class="line">| 4 | 刘八  |  10 |</span><br><span class="line">+----+--------+------+</span><br></pre></td></tr></table></figure>
<p>索引存储结构如下：</p>
<p>id是主键，聚簇索引结构如下</p>
<p><img src="/images/2021-5-23T161315.png" alt="2021-5-23T161315.png"></p>
<p>age是普通索引，非聚簇索引结构如下</p>
<p><img src="/images/2021-5-23T161415.png" alt="2021-5-23T161415.png"></p>
<p>如果查询条件为主键，则只需扫描一次B+树即可通过聚簇索引定位到要查找的行记录数据。如：<code>select * from user where id = 1</code></p>
<p><img src="/images/2021-5-23T161516.png" alt="2021-5-23T161516.png"></p>
<p>如果查询条件为普通索引（非聚簇索引），需要扫描两次B+树，第一次扫描通过普通索引定位到聚簇索引的值，然后第二次扫描通过聚簇索引的值定位到要查找的行记录数据。 如：<code>select * from user where age = 30</code></p>
<blockquote>
<p>先通过普通索引 age=30 定位到主键值 id=1</p>
<p>再通过聚集索引 id=1 定位到行记录数据</p>
</blockquote>
<p><img src="/images/2021-5-23T161626.png" alt="2021-5-23T161626.png"></p>
<p><img src="/images/2021-5-23T161710.png" alt="2021-5-23T161710.png"></p>
<h4 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h4><p>只需要在一棵索引树上就能获取SQL所需的所有列数据，无需回表，速度更快。</p>
<p>常见的方法是将被查询的字段建立到联合索引里去。</p>
<p>实现：<code>select id,age from user where age = 10</code></p>
<p>explain分析：因为age是普通索引，使用到了age索引，通过一次扫描B+树即可查询到相应的结果，这样就实现了覆盖索引</p>
<p><img src="/images/2021-5-23T161927.png" alt="2021-5-23T161927.png"></p>
<p>实现：<code>select id,age,name from user where age = 10</code></p>
<p>explain分析：age是普通索引，但name列不在索引树上，所以通过age索引在查询到id和age的值后，需要进行回表再查询name的值。此时的Extra列的NULL表示进行了回表查询</p>
<p><img src="/images/2021-5-23T162010.png" alt="2021-5-23T162010.png"></p>
<p>因此，为了实现索引覆盖，需要建组合索引 <code>idx_age_name(age,name)</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drop index idx_age on user;</span><br><span class="line">create index idx_age_name on user(`age`,`name`);</span><br></pre></td></tr></table></figure>
<p>explain分析：此时字段age和name是组合索引idx_age_name，查询的字段id、age、name的值刚刚都在索引树上，只需扫描一次组合索引B+树即可，这就是实现了索引覆盖，此时的Extra字段为Using index表示使用了索引覆盖。</p>
<p><img src="/images/2021-5-23T162101.png" alt="2021-5-23T162101.png"></p>
<p>Read More:</p>
<blockquote>
<p><a href="https://juejin.cn/post/6844904062329028621" target="_blank" rel="noopener">MySQL 的覆盖索引与回表</a></p>
<p><a href="https://www.jianshu.com/p/d0d3de6832b9" target="_blank" rel="noopener">回表与覆盖索引，索引下推</a></p>
<p><a href="https://blog.csdn.net/CPLASF_/article/details/108799381" target="_blank" rel="noopener">mysql-回表查询是什么</a></p>
</blockquote>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx 开机启动</title>
    <url>/2017/09/03/nginxstartpoweron/</url>
    <content><![CDATA[<p>Nginx 是一个很强大的高性能 Web 和反向代理服务器。虽然使用命令行可以对 nginx 进行各种操作，比如启动等，但是还是根据不太方便。下面介绍在 Linux 下安装后，如何设置开机自启动。</p>
<p>首先，在 Linux 系统的 <code>/etc/init.d/</code> 目录下创建 nginx 文件，使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /etc/init.d/nginx</span><br></pre></td></tr></table></figure>
<p>在脚本中添加如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># nginx Startup script for the Nginx HTTP Server</span><br><span class="line"># it is v.0.0.2 version.</span><br><span class="line"># chkconfig: - 85 15</span><br><span class="line"># description: Nginx is a high-performance web and proxy server.</span><br><span class="line">#              It has a lot of features, but it&apos;s not for everyone.</span><br><span class="line"># processname: nginx</span><br><span class="line"># pidfile: /var/run/nginx.pid</span><br><span class="line"># config: /usr/local/nginx/conf/nginx.conf</span><br><span class="line"># 启动 nginx 需要执行的命令</span><br><span class="line">nginxd=/usr/local/nginx/sbin/nginx</span><br><span class="line"># nginx 的配置文件路径</span><br><span class="line">nginx_config=/usr/local/nginx/conf/nginx.conf</span><br><span class="line">nginx_pid=/var/run/nginx.pid</span><br><span class="line">RETVAL=0</span><br><span class="line">prog=&quot;nginx&quot;</span><br><span class="line"># Source function library.</span><br><span class="line">. /etc/rc.d/init.d/functions</span><br><span class="line"># Source networking configuration.</span><br><span class="line">. /etc/sysconfig/network</span><br><span class="line"># Check that networking is up.</span><br><span class="line">[ $&#123;NETWORKING&#125; = &quot;no&quot; ] &amp;&amp; exit 0</span><br><span class="line">[ -x $nginxd ] || exit 0</span><br><span class="line"># Start nginx daemons functions.</span><br><span class="line">start() &#123;</span><br><span class="line">if [ -e $nginx_pid ];then</span><br><span class="line">   echo &quot;nginx already running....&quot;</span><br><span class="line">   exit 1</span><br><span class="line">fi</span><br><span class="line">   echo -n $&quot;Starting $prog: &quot;</span><br><span class="line">   daemon $nginxd -c $&#123;nginx_config&#125;</span><br><span class="line">   RETVAL=$?</span><br><span class="line">   echo</span><br><span class="line">   [ $RETVAL = 0 ] &amp;&amp; touch /var/lock/subsys/nginx</span><br><span class="line">   return $RETVAL</span><br><span class="line">&#125;</span><br><span class="line"># Stop nginx daemons functions.</span><br><span class="line">stop() &#123;</span><br><span class="line">        echo -n $&quot;Stopping $prog: &quot;</span><br><span class="line">        killproc $nginxd</span><br><span class="line">        RETVAL=$?</span><br><span class="line">        echo</span><br><span class="line">        [ $RETVAL = 0 ] &amp;&amp; rm -f /var/lock/subsys/nginx /var/run/nginx.pid</span><br><span class="line">&#125;</span><br><span class="line"># reload nginx service functions.</span><br><span class="line">reload() &#123;</span><br><span class="line">    echo -n $&quot;Reloading $prog: &quot;</span><br><span class="line">    #kill -HUP `cat $&#123;nginx_pid&#125;`</span><br><span class="line">    killproc $nginxd -HUP</span><br><span class="line">    RETVAL=$?</span><br><span class="line">    echo</span><br><span class="line">&#125;</span><br><span class="line"># See how we were called.</span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">start)</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">stop)</span><br><span class="line">        stop</span><br><span class="line">        ;;</span><br><span class="line">reload)</span><br><span class="line">        reload</span><br><span class="line">        ;;</span><br><span class="line">restart)</span><br><span class="line">        stop</span><br><span class="line">        start</span><br><span class="line">        ;;</span><br><span class="line">status)</span><br><span class="line">        status $prog</span><br><span class="line">        RETVAL=$?</span><br><span class="line">        ;;</span><br><span class="line">*)</span><br><span class="line">        echo $&quot;Usage: $prog &#123;start|stop|restart|reload|status|help&#125;&quot;</span><br><span class="line">        exit 1</span><br><span class="line">esac</span><br><span class="line">exit $RETVAL</span><br></pre></td></tr></table></figure>
<p>以下是根据 nginx 具体安装路径填写的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 启动 nginx 需要执行的命令</span><br><span class="line">nginxd=/usr/local/nginx/sbin/nginx</span><br><span class="line"># nginx 的配置文件路径</span><br><span class="line">nginx_config=/usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>
<p>保存脚本文件后设置文件的执行权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod a+x /etc/init.d/nginx</span><br></pre></td></tr></table></figure>
<p>然后，就可以通过该脚本对 nginx 服务进行管理了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/etc/init.d/nginx start</span><br><span class="line">/etc/init.d/nginx stop</span><br></pre></td></tr></table></figure>
<p>上面的方法完成了用脚本管理 nginx 服务的功能，但是还是不太方便，比如要设置 nginx 开机启动等。这时可以使用 chkconfig 来设置。</p>
<blockquote>
<p>chkconfig 命令主要用来更新（启动或停止）和查询系统服务的运行级信息。谨记 chkconfig 不是立即自动禁止或激活一个服务，它只是简单的改变了符号连接。</p>
</blockquote>
<p>先将 nginx 服务加入 chkconfig 管理列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chkconfig --add /etc/init.d/nginx</span><br></pre></td></tr></table></figure>
<p>加完这个之后，就可以使用 service 对 nginx 进行启动，重启等操作了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service nginx start</span><br><span class="line">service nginx stop</span><br></pre></td></tr></table></figure>
<p>设置终端模式开机启动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chkconfig nginx on</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP基础知识 - $_SERVER</title>
    <url>/2017/06/26/php-server/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>$_SERVER[‘PHP_SELF’]</td>
<td>当前执行脚本的文件名，与 document root 有关</td>
</tr>
<tr>
<td>$_SERVER[‘argv’]</td>
<td>传递给该脚本的参数的数组</td>
</tr>
<tr>
<td>$_SERVER[‘argc’]</td>
<td>包含命令行模式下传递给该脚本的参数的数目(如果运行在命令行模式下)</td>
</tr>
<tr>
<td>$_SERVER[‘ GATEWAY_INTERFACE</td>
<td>服务器使用的 CGI 规范的版本</td>
</tr>
<tr>
<td>$_SERVER[‘ SERVER_ADDR’]</td>
<td>当前运行脚本所在的服务器的 IP 地址</td>
</tr>
<tr>
<td>$_SERVER[‘ SERVER_NAME’]</td>
<td>当前运行脚本所在的服务器的主机名</td>
</tr>
<tr>
<td>$_SERVER[‘SERVER_SOFTWARE’]</td>
<td>服务器标识字符串，在响应请求时的头信息中给出</td>
</tr>
<tr>
<td>$_SERVER[‘SERVER_PROTOCOL’]</td>
<td>请求页面时通信协议的名称和版本</td>
</tr>
<tr>
<td>$_SERVER[‘REQUEST_METHOD’]</td>
<td>访问页面使用的请求方法。 例如，“<em>GET</em>”、“<em>HEAD</em>”、“<em>POST</em>”、“<em>PUT</em>”</td>
</tr>
<tr>
<td>$_SERVER[‘REQUEST_TIME’]</td>
<td>请求开始时的时间戳</td>
</tr>
<tr>
<td>$_SERVER[‘REQUEST_TIME_FLOAT’]</td>
<td>请求开始时的时间戳，微秒级别的精准度</td>
</tr>
<tr>
<td>$_SERVER[‘QUERY_STRING’]</td>
<td>查询字符串，如果有的话，通过它进行页面访问</td>
</tr>
<tr>
<td>$_SERVER[‘DOCUMENT_ROOT’]</td>
<td>当前运行脚本所在的文档根目录</td>
</tr>
<tr>
<td>$_SERVER[‘HTTP_ACCEPT’]</td>
<td>当前请求头中 <em>Accept:</em> 项的内容</td>
</tr>
<tr>
<td>$_SERVER[‘HTTP_ACCEPT_CHARSET’]</td>
<td>当前请求头中 <em>Accept-Charset:</em> 项的内容</td>
</tr>
<tr>
<td>$_SERVER[‘HTTP_ACCEPT_ENCODING’]</td>
<td>当前请求头中 <em>Accept-Encoding:</em> 项的内容</td>
</tr>
<tr>
<td>$_SERVER[‘HTTP_ACCEPT_LANGUAGE’]</td>
<td>当前请求头中 <em>Accept-Language:</em> 项的内容</td>
</tr>
<tr>
<td>$_SERVER[‘HTTP_CONNECTION’]</td>
<td>当前请求头中 <em>Connection:</em> 项的内容</td>
</tr>
<tr>
<td>$_SERVER[‘HTTP_HOST’]</td>
<td>当前请求头中 <em>Host:</em> 项的内容</td>
</tr>
<tr>
<td>$_SERVER[‘HTTP_REFERER’]</td>
<td>引导用户代理到当前页的前一页的地址</td>
</tr>
<tr>
<td>$_SERVER[‘HTTP_USER_AGENT’]</td>
<td>当前请求头中 <em>User-Agent:</em> 项的内容， 该字符串表明了访问该页面的用户代理的信息</td>
</tr>
<tr>
<td>$_SERVER[‘HTTPS’]</td>
<td>如果脚本是通过 HTTPS 协议被访问，则被设为一个非空的值</td>
</tr>
<tr>
<td>$_SERVER[‘REMOTE_ADDR’]</td>
<td>浏览当前页面的用户的 IP 地址</td>
</tr>
<tr>
<td>$_SERVER[‘REMOTE_HOST’]</td>
<td>浏览当前页面的用户的主机名</td>
</tr>
<tr>
<td>$_SERVER[‘REMOTE_PORT’]</td>
<td>用户机器上连接到 Web 服务器所使用的端口号</td>
</tr>
<tr>
<td>$_SERVER[‘REMOTE_USER’]</td>
<td>经验证的用户</td>
</tr>
<tr>
<td>$_SERVER[‘REDIRECT_REMOTE_USER’]</td>
<td>验证的用户，如果请求已在内部重定向</td>
</tr>
<tr>
<td>$_SERVER[‘SCRIPT_FILENAME’]</td>
<td>当前执行脚本的绝对路径</td>
</tr>
<tr>
<td>$_SERVER[‘SERVER_ADMIN’]</td>
<td>该值指明了 Apache 服务器配置文件中的 SERVER_ADMIN 参数</td>
</tr>
<tr>
<td>$_SERVER[‘SERVER_PORT’]</td>
<td>Web 服务器使用的端口</td>
</tr>
<tr>
<td>$_SERVER[‘SERVER_SIGNATURE’]</td>
<td>包含了服务器版本和虚拟主机名的字符串</td>
</tr>
<tr>
<td>$_SERVER[‘PATH_TRANSLATED’]</td>
<td>当前脚本所在文件系统（非文档根目录）的基本路径</td>
</tr>
<tr>
<td>$_SERVER[‘SCRIPT_NAME’]</td>
<td>包含当前脚本的路径</td>
</tr>
<tr>
<td>$_SERVER[‘REQUEST_URI’]</td>
<td>URI 用来指定要访问的页面</td>
</tr>
<tr>
<td>$_SERVER[‘PHP_AUTH_DIGEST’]</td>
<td>当作为 Apache 模块运行时，进行 HTTP Digest 认证的过程中，此变量被设置成客户端发送的“Authorization” HTTP 头内容</td>
</tr>
<tr>
<td>$_SERVER[‘PHP_AUTH_USER’]</td>
<td>当 PHP 运行在 Apache 或 IIS（PHP 5 是 ISAPI）模块方式下，并且正在使用 HTTP 认证功能，这个变量便是用户输入的用户名</td>
</tr>
<tr>
<td>$_SERVER[‘PHP_AUTH_PW’]</td>
<td>当 PHP 运行在 Apache 或 IIS（PHP 5 是 ISAPI）模块方式下，并且正在使用 HTTP 认证功能，这个变量便是用户输入的密码</td>
</tr>
<tr>
<td>$_SERVER[‘AUTH_TYPE’]</td>
<td>当 PHP 运行在 Apache 模块方式下，并且正在使用 HTTP 认证功能，这个变量便是认证的类型</td>
</tr>
<tr>
<td>$_SERVER[‘ PATH_INFO’]</td>
<td>包含由客户端提供的、跟在真实脚本名称之后并且在查询语句（query string）之前的路径信息</td>
</tr>
<tr>
<td>$_SERVER[‘ORIG_PATH_INFO’]</td>
<td>在被 PHP 处理之前，“PATH_INFO” 的原始版本</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>$_SERVER</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP内核探索：变量的内部存储（值和类型）</title>
    <url>/2017/04/15/phpvarinternstore1/</url>
    <content><![CDATA[<p>在翻看  <a href="http://php.net/docs.php" target="_blank" rel="noopener">PHP手册</a>  的时候，看到了  <a href="http://php.net/manual/zh/features.gc.php" target="_blank" rel="noopener">垃圾回收机制</a>  ，介绍了PHP 5.3新的垃圾回收机制（GC）的特点，里面涉及到了PHP变量内部存储的知识，如果你想对PHP变量存储结构有一个了解或想对PHP变量加深理解的话，本文是适合你的，比较深入的去看源代码吧。</p>
<p>PHP是一种<strong>弱类型</strong>的脚本语言，弱类型不表示PHP的变量没有类型区分，PHP变量有8种原始类型。</p>
<p>四种标量类型：</p>
<ul>
<li>Boolean（布尔型）</li>
<li>Integer（整型）</li>
<li>Float（浮点型）</li>
<li>String（字符串）</li>
</ul>
<p>两种复合类型：</p>
<ul>
<li>Array（数组）</li>
<li>Object（对象）</li>
</ul>
<p>两种特殊类型：</p>
<ul>
<li>Resource（资源）</li>
<li>NULL</li>
</ul>
<p>我们都知道，在PHP程序运行中，可以将变量从一种类型转换为另一种类型，那么PHP是怎么实现这个过程的呢？</p>
<p>在PHP引擎（Zend）内部，变量都是用如下的结构体来表示的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct _zval_struct &#123;  </span><br><span class="line">    /* Variable information */  </span><br><span class="line">    zvalue_value value;     /* value */  </span><br><span class="line">    zend_uint refcount__gc;  </span><br><span class="line">    zend_uchar type;    	/* active type */  </span><br><span class="line">    zend_uchar is_ref__gc;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<p>value：存储变量的值；</p>
<p>refcount__gc：引用计数；</p>
<p>type：变量的动态类型；</p>
<p>is_ref__gc：是否为引用。</p>
<p>type的各种类型都被定义成了宏：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define IS_NULL     0  </span><br><span class="line">#define IS_LONG     1  </span><br><span class="line">#define IS_DOUBLE   2  </span><br><span class="line">#define IS_BOOL     3  </span><br><span class="line">#define IS_ARRAY    4  </span><br><span class="line">#define IS_OBJECT   5  </span><br><span class="line">#define IS_STRING   6  </span><br><span class="line">#define IS_RESOURCE 7  </span><br><span class="line">#define IS_CONSTANT 8  </span><br><span class="line">#define IS_CONSTANT_ARRAY   9</span><br></pre></td></tr></table></figure>
<p>zvalue_value 是真正保存数据的关键部分，定义为一个联合：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef union _zvalue_value &#123;  </span><br><span class="line">    long lval;                  /* long value */  </span><br><span class="line">    double dval;                /* double value */  </span><br><span class="line">    struct &#123;  </span><br><span class="line">        char *val;  </span><br><span class="line">        int len;  </span><br><span class="line">    &#125; str;  </span><br><span class="line">    HashTable *ht;              /* hash table value */  </span><br><span class="line">    zend_object_value obj;  </span><br><span class="line">&#125; zvalue_value;</span><br></pre></td></tr></table></figure>
<p>PHP根据 zval 中的 type 字段来储存一个变量的真正类型，然后根据 type 来选择如何获取 zvalue_value 的值，比如对于整型和bool值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zval.type = IS_LONG;	//整型</span><br><span class="line">zval.type = IS_BOOL;	//布尔型</span><br></pre></td></tr></table></figure>
<p>就去取 zval.value.lval，对于 bool 值来说 lval∈(0|1)；如果是双精度，或者 float 则会去取 zval.value 的 dval。而如果是字符串，那么：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zval.type = IS_STRING	//字符串</span><br></pre></td></tr></table></figure>
<p>这个时候，就会取 zval.value.str 而这个也是个结构，存有C类型的字符串和字符串的长度。</p>
<p>而对于数组和对象，则type分别对应IS_ARRAY、 IS_OBJECT,，相对应的则分别取 zval.value.ht 和 obj。</p>
<p>比较特别的是资源，在PHP中，资源是个很特别的变量，任何不属于PHP内建的变量类型的变量，都会被看作成资源来进行保存，比如，数据库句柄、打开的文件句柄等等。 对于资源：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type = IS_RESOURCE		//资源</span><br></pre></td></tr></table></figure>
<p>这个时候，会去取 zval.value.lval， 此时的 lval 是个整型的指示器， 然后 PHP 会再根据这个指示器在 PHP 内建的一个资源列表中查询相对应的资源，此时的 lval 就好像是对应于资源链表的偏移值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ZEND_FETCH_RESOURCE(con, type, zval *, default, resource_name, resource_type);</span><br></pre></td></tr></table></figure>
<p>借用这样的机制，PHP就实现了弱类型，因为对于ZE（Zend）的来说，它所面对的永远都是同一种类型，那就是 zval。</p>
<p>在了解了 PHP 变量的内部存储后，新的问题就来了，ZE是如何把用户自定义变量和内部结构 zval 联系起来的呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">  $var = &quot;laruence&quot;;</span><br><span class="line">  echo $var;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>PHP内部都是使用 zval 来表示变量的，但是对于上面的脚本，我们的变量是有名字的\$var。而 zval 中并没有相应的字段来体现变量名。在PHP中，所有的变量都会存储在一个数组中（确切的说是hash table）。</p>
<p>当你创建一个变量的时候，PHP会为这个变量分配一个 zval，填入相应的变量值，然后将这个变量的名字、和指向这个zval的指针填入一个数组中。然后，当你获取这个变量的时候，PHP会通过查找这个数组，获得对应的 zval。</p>
<p>查看_zend_executor_globals结构（这个结构在PHP的执行器保存一些执行相关的上下文信息）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct _zend_executor_globals &#123;</span><br><span class="line">     ....</span><br><span class="line">    HashTable *active_symbol_table;	/*活动符号表*/</span><br><span class="line">    HashTable symbol_table;     	/*全局符号表*/</span><br><span class="line"> </span><br><span class="line">    HashTable included_files;   </span><br><span class="line"> </span><br><span class="line">    jmp_buf *bailout;</span><br><span class="line">    int error_reporting;</span><br><span class="line">     .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上只是对PHP变量内部存储的简单介绍，如果想深入了解，建议研究PHP的源码。</p>
<p>Read More:</p>
<blockquote>
<p><a href="http://blog.csdn.net/wenzhou1219/article/details/16832067" target="_blank" rel="noopener">深入PHP变量存储结构</a>  <a href="http://blog.csdn.net/phpkernel/article/details/5718003" target="_blank" rel="noopener">变量的内部存储：值和类型</a></p>
</blockquote>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>变量的内部存储</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统中的进程调度算法</title>
    <url>/2017/04/02/processscheduling/</url>
    <content><![CDATA[<p>无论是在批处理系统还是分时系统中，用户进程数一般都多于处理机数、这将导致它们互相争夺处理机。另外，系统进程也同样需要使用处理机。这就要求进程调度程序按一定的策略，动态地把处理机分配给处于就绪队列中的某一个进程，以使之执行。</p>
<h3 id="处理机"><a href="#处理机" class="headerlink" title="处理机"></a>处理机</h3><p>高级、中级和低级调度作业从提交开始直到完成，往往要经历下述三级调度：<br>高级调度：又称为作业调度，它决定把后备作业调入内存运行；<br>低级调度：又称为进程调度，它决定把就绪队列的某进程获得CPU；<br>中级调度：又称为在虚拟存储器中引入，在内、外存对换区进行进程对换。</p>
<h3 id="占用CPU的方式"><a href="#占用CPU的方式" class="headerlink" title="占用CPU的方式"></a>占用CPU的方式</h3><h4 id="非剥夺方式"><a href="#非剥夺方式" class="headerlink" title="非剥夺方式"></a>非剥夺方式</h4><p>分派程序一旦把处理机分配给某进程后便让它一直运行下去，直到进程完成或某事件而阻塞时，才把处理机分配给另一个进程。</p>
<p>即使在就绪队列存在有优先级高于当前执行进程时，当前进程仍将占用处理机直到该进程自己因调用原语操作或等待I/O而进入阻塞、睡眠状态，或时间片用完时才重新发生调度让出处理机。</p>
<h4 id="剥夺方式"><a href="#剥夺方式" class="headerlink" title="剥夺方式"></a>剥夺方式</h4><p>当一个进程正在运行时，系统可以基于某种原则，剥夺已分配给它的处理机，将之分配给其它进程。</p>
<p>剥夺原则有：优先权原则、短进程优先原则、时间片原则。</p>
<h3 id="引起进程调度的原因"><a href="#引起进程调度的原因" class="headerlink" title="引起进程调度的原因"></a>引起进程调度的原因</h3><ul>
<li>正在执行的进程执行完毕。这时，如果不选择新的就绪进程执行，将浪费处理机资源；</li>
<li>执行中进程自己调用阻塞原语将自己阻塞起来进入睡眠等状态；</li>
<li>执行中进程调用了P原语操作，从而因资源不足而被阻塞；或调用了v原语操作激活了等待资源的进程队列；</li>
<li>执行中进程提出I/O请求后被阻塞；</li>
<li>在分时系统中时间片已经用完；</li>
<li>在执行完系统调用等系统程序后返回用户进程时，这时可看作系统进程执行完毕，从而可调度选择一新的用户进程执行；</li>
<li>就绪队列中的某进程的优先级变得高于当前执行进程的优先级，从而也将引发进程调度。</li>
</ul>
<h3 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h3><h4 id="先来先服务调度算法-FCFS"><a href="#先来先服务调度算法-FCFS" class="headerlink" title="先来先服务调度算法(FCFS)"></a>先来先服务调度算法(FCFS)</h4><p>根据进程到达的先后顺序执行进程，不考虑等待时间和执行时间，会产生饥饿现象。属于非抢占式调度，优点是公平，实现简单；缺点是不利于短作业。</p>
<h4 id="短进程优先调度算法-SPF"><a href="#短进程优先调度算法-SPF" class="headerlink" title="短进程优先调度算法(SPF)"></a>短进程优先调度算法(SPF)</h4><p>就是优先调度并处理短作业，所谓短是指作业的运行时间短。而在作业未投入运行时，并不能知道它实际的运行时间的长短，因此需要用户在提交作业时同时提交作业运行时间的估计值。</p>
<h4 id="时间片轮转调度算法-RR"><a href="#时间片轮转调度算法-RR" class="headerlink" title="时间片轮转调度算法(RR)"></a>时间片轮转调度算法(RR)</h4><p>前两种算法主要用于批处理系统中，不能作为分时系统中的主调度算法，在分时系统中，都采用时间片轮转法。<br>简单轮转法：系统将所有就绪进程按FIFO规则排队，按一定的时间间隔把处理机分配给队列中的进程。这样，就绪队列中所有进程均可获得一个时间片的处理机而运行。多级队列方法：将系统中所有进程分成若干类，每类为一级。</p>
<p>具体调度过程是：内核从Ready队列中选取第一个进程，将CPU资源分配给它，并且设置一个定时器在一个时间片后中断该进程，调度Ready队列中的下一进程。</p>
<p>很明显，RR调度算法是抢占式的，并且在该算法的调度下，没有一个进程能够连续占用CPU超过一个时间片，从而达到了分时的目的。</p>
<p>给每个进程固定的执行时间，根据进程到达的先后顺序让进程在单位时间片内执行，执行完成后便调度下一个进程执行，时间片轮转调度不考虑进程等待时间和执行时间，属于抢占式调度。优点是兼顾长短作业；缺点是平均等待时间较长，上下文切换较费时。适用于分时系统。</p>
<h4 id="优先级调度算法-HPF"><a href="#优先级调度算法-HPF" class="headerlink" title="优先级调度算法(HPF)"></a>优先级调度算法(HPF)</h4><p>在优先级调度算法中，每个进程都关联一个优先级，内核将CPU分配给最高优先级的进程。具有相同优先级的进程，按照先来先服务的原则进行调度。</p>
<h4 id="高响应比优先调度算法-HRN"><a href="#高响应比优先调度算法-HRN" class="headerlink" title="高响应比优先调度算法(HRN)"></a>高响应比优先调度算法(HRN)</h4><p>根据  <strong>响应比 = （进程执行时间 + 进程等待时间） / 进程执行时间</strong>  这个公式得到的响应比来进行调度。高响应比优先算法在等待时间相同的情况下，作业执行的时间越短，响应比越高，满足段任务优先，同时响应比会随着等待时间增加而变大，优先级会提高，能够避免饥饿现象。优点是兼顾长短作业，缺点是计算响应比开销大，适用于批处理系统。</p>
<h4 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h4><p>多级反馈队列方式是在系统中设置多个就绪队列，并赋予各队列以不同的优先权。</p>
<h3 id="进程-数据库也适用-死锁"><a href="#进程-数据库也适用-死锁" class="headerlink" title="进程(数据库也适用)死锁"></a>进程(数据库也适用)死锁</h3><h4 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h4><ul>
<li>系统资源不足；</li>
<li>资源分配不当；</li>
<li>进程运行推进顺序不合适。</li>
</ul>
<h4 id="产生进程死锁的必要条件"><a href="#产生进程死锁的必要条件" class="headerlink" title="产生进程死锁的必要条件"></a>产生进程死锁的必要条件</h4><ol>
<li>互斥条件：线程在某一时间内独占资源；</li>
<li>不剥夺条件：线程已获得资源，在末使用完之前，不能强行剥夺；</li>
<li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放；</li>
<li>循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><p>加锁顺序：确保所有的进程都是按照相同的顺序获得锁；</p>
<p>加锁限时：在尝试获取锁的时候加一个超时时间，若超过了这个时限该进程则放弃对该锁请求；</p>
<p>银行家算法，每次在分配资源之前，先判断资源分配后，系统是否会进入不安全的状态，会则不分配，不会则分配；</p>
<p>死锁检测：检测如果发生死锁，通过外边破坏产生死锁的四个必要条件，打破死锁。</p>
<h4 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h4><ul>
<li>破坏互斥条件；</li>
<li>破坏不剥夺条件；</li>
<li>破坏请求和保持条件；</li>
<li>破坏循环等待条件。</li>
</ul>
<h3 id="饥饿进程"><a href="#饥饿进程" class="headerlink" title="饥饿进程"></a>饥饿进程</h3><p>当进程的等待时间过长，给进程推进和响应带来明显影响时，称发生了进程“饥饿”。当“饥饿”到一定程度的进程被赋予的任务即使完成也不再具有实际意义时称该进程被“饿死”。</p>
<h4 id="饥饿产生的原因"><a href="#饥饿产生的原因" class="headerlink" title="饥饿产生的原因"></a>饥饿产生的原因</h4><p>进程所请求的资源（可以是CPU资源）长时间得不到满足，从而长时间处于阻塞或就绪状态。</p>
<h4 id="饥饿与死锁的区别"><a href="#饥饿与死锁的区别" class="headerlink" title="饥饿与死锁的区别"></a>饥饿与死锁的区别</h4><ol>
<li>进入饥饿的进程可以只有一个，而死锁的进程至少有两个；</li>
<li>饥饿状态的进程可以是就绪状态和阻塞状态，而处于死锁的进程一定是阻塞状态。</li>
</ol>
]]></content>
      <categories>
        <category>进程/线程</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>进程调度</tag>
      </tags>
  </entry>
  <entry>
    <title>Python常见异常</title>
    <url>/2020/11/10/python-except-enum/</url>
    <content><![CDATA[<h4 id="TypeError"><a href="#TypeError" class="headerlink" title="TypeError"></a>TypeError</h4><p><code>&#39;builtin_function_or_method&#39; object is not subscriptable</code></p>
<p>此异常一般是上下文代码中有语法错误，缺少()。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python上下文管理器</title>
    <url>/2018/01/02/pythoncontextmanager/</url>
    <content><![CDATA[<h4 id="何为上下文管理器"><a href="#何为上下文管理器" class="headerlink" title="何为上下文管理器"></a>何为上下文管理器</h4><p>上下文管理器是管理上下文的，负责冲锋和垫后，而让开发人员专心完成自己的事情。我们在编写程序的时候，通常会将一系列操作放到一个语句块中，当某一条件为真时执行该语句快。有时候，我们需要再执行一个语句块时保持某种状态，并且在离开语句块后结束这种状态。</p>
<p>例如对文件的操作，我们在打开一个文件进行读写操作时需要保持文件处于打开状态，而等操作完成之后要将文件关闭。所以，上下文管理器的任务是：代码块执行前准备，代码块执行后收拾。上下文管理器是在Python2.5加入的功能，它能够让你的代码可读性更强并且错误更少。</p>
<h4 id="需求的产生"><a href="#需求的产生" class="headerlink" title="需求的产生"></a>需求的产生</h4><p>在正常的管理各种系统资源（文件、锁定和连接），在涉及到异常时通常是个棘手的问题。异常很可能导致控制流跳过负责释放关键资源的语句。例如打开一个文件进行操作时，如果意外情况发生（磁盘已满、特殊的终端信号让其终止等），就会抛出异常，这样可能最后的文件关闭操作就不会执行。如果这样的问题频繁出现，则可能耗尽系统资源。</p>
<p>在没有接触到上下文管理器之前，我们可以用”try/finally”语句来解决这样的问题。或许在有些人看来，”try/finally”语句显得有些繁琐。上下文管理器就是被设计用来简化”try/finally”语句的，这样可以让程序更加简洁。</p>
<h4 id="上下文管理协议"><a href="#上下文管理协议" class="headerlink" title="上下文管理协议"></a>上下文管理协议</h4><p>那么在Python中怎么实现一个上下文管理器呢？主要依靠<code>__enter__</code>、<code>__exit__</code>这两个”魔术方法”。</p>
<blockquote>
<p><code>__enter__(self)</code> </p>
<p>Defines what the context manager should do at the beginning of the block created by the with statement. Note that the return value of __enter__ is bound to the target of the with statement, or the name after the as.</p>
<p><code>__exit__(self, exception_type, exception_value, traceback)</code> </p>
<p>Defines what the context manager should do after its block has been executed (or terminates). It can be used to handle exceptions, perform cleanup, or do something always done immediately after the action in the block. If the block executes successfully, exception_type, exception_value, and traceback will be None. Otherwise, you can choose to handle the exception or let the user handle it; if you want to handle it, make sure __exit__ returns True after all is said and done. If you don’t want the exception to be handled by the context manager, just let it happen.</p>
</blockquote>
<p>也就是说，当我们需要创建一个上下文管理器类型的时候，就需要实现<code>__enter__</code>和<code>__exit__</code>方法，这对方法就称为上下文管理协议（Context Manager Protocol），定义了一种运行时上下文环境。</p>
<h4 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h4><p>在Python中，可以通过with语句来方便的使用上下文管理器，with语句可以在代码块运行前进入一个运行时上下文（执行__enter__方法），并在代码块结束后退出该上下文（执行__exit__方法）。</p>
<p>with语句的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with context_expr [as var]:</span><br><span class="line">    with_suite</span><br></pre></td></tr></table></figure>
<ul>
<li>context_expr: 支持上下文管理协议的对象，也就是上下文管理器对象，负责维护上下文环境</li>
<li>as var: 可选部分，通过变量方式保存上下文管理器对象</li>
<li>with_suite: 需要放在上下文环境中执行的语句块</li>
</ul>
<p>在Python的内置类型中，很多类型都是支持上下文管理协议的，例如file、thread.LockType、threading.Lock等等。这里我们就以file类型为例，看看with语句的使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with File(&apos;demo.txt&apos;, &apos;w&apos;) as opened_file:</span><br><span class="line">    opened_file.write(&apos;Hola!&apos;)</span><br></pre></td></tr></table></figure>
<p> with语句先暂存了File类的<code>__exit__()</code>方法，然后它调用File类的<code>__enter__()</code>方方法，<code>__enter__</code>方法打开文件并返回给with语句，打开的文件句柄被传递给<code>opened_file</code>参数，然后使用<code>.write()</code>来写文件，with语句调用之前暂存的<code>__exit__</code>方法关闭了文件。</p>
<h4 id="自定义上下文管理器"><a href="#自定义上下文管理器" class="headerlink" title="自定义上下文管理器"></a>自定义上下文管理器</h4><p>了解上下文管理器的执行流程和方法后，我们可以通过实现<code>__enter__()</code>、<code>__exit__()</code>函数来自定义上下文管理器，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filename = &apos;my_file.txt&apos;</span><br><span class="line">mode = &apos;w&apos; # Mode that allows to write to the file</span><br><span class="line">writer = open(filename, mode)</span><br><span class="line"></span><br><span class="line">class PypixOpen(object):</span><br><span class="line">    def __init__(self, filename, mode):</span><br><span class="line">        self.filename = filename</span><br><span class="line">        self.mode = mode</span><br><span class="line"></span><br><span class="line">    def __enter__(self):</span><br><span class="line">        self.openedFile = open(self.filename, self.mode)</span><br><span class="line">        return self.openedFile</span><br><span class="line"></span><br><span class="line">    def __exit__(self, *unused):</span><br><span class="line">        self.openedFile.close()</span><br><span class="line"></span><br><span class="line"># Script starts from here</span><br><span class="line"></span><br><span class="line">with PypixOpen(filename, mode) as writer:</span><br><span class="line">    writer.write(&quot;Hello World from our new Context Manager!&quot;)</span><br></pre></td></tr></table></figure>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>上下文管理器根据<code>__exit__()</code> 方法的返回值来决定是否抛出异常，如果没有返回值或者返回值为 False ，则异常由上下文管理器处理，如果为 True 则由用户自己处理。</p>
<p><code>__exit__ ()</code>接受三个参数，exception_type、exception_value、traceback，我们可以根据这些值来决定是否处理异常</p>
<p>下面这个例子，捕捉了 AttributeError 的异常，并打印出警告: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Open:</span><br><span class="line">    def __init__(self, file, mode):</span><br><span class="line">        self.open_file = open(file, mode)</span><br><span class="line">    def __enter__(self):</span><br><span class="line">        return self.open_file</span><br><span class="line">    def __exit__(self, type, value, tb):</span><br><span class="line">        self.open_file.close()</span><br><span class="line">        if type is AttributeError:</span><br><span class="line">            print(&apos;handing some exception&apos;)</span><br><span class="line">            return True</span><br><span class="line">            </span><br><span class="line">with Open(&apos;aaa&apos;, &apos;w&apos;) as f:</span><br><span class="line">    f.writeee(&apos;aaaa&apos;)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt; handing some exception</span><br></pre></td></tr></table></figure>
<h4 id="contextmanager"><a href="#contextmanager" class="headerlink" title="contextmanager"></a>contextmanager</h4><p>由于上下文管理非常有用，Python 中有一个专门用于实现上下文管理的标准库，这就是 contextlib。</p>
<p>有了 contextlib 创建上下文管理的最好方式就是使用 contextmanager 装饰器，通过 contextmanager 装饰一个生成器函数，<code>yield</code> 语句前面的部分被认为是<code>__enter__()</code> 方法的代码，后面的部分被认为是 <code>__exit__()</code>方法的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from contextlib import contextmanager</span><br><span class="line">@contextmanager</span><br><span class="line">def file(path, mode):</span><br><span class="line">    open_file = open(path, mode)</span><br><span class="line">    yield open_file</span><br><span class="line">    open_file.close()</span><br></pre></td></tr></table></figure>
<p>Python解释器遇到了<code>yield</code>关键字。因为这个缘故它创建了一个生成器而不是一个普通的函数。因为这个装饰器，contextmanager会被调用并传入函数名（<code>file</code>）作为参数。contextmanager函数返回一个以GeneratorContextManager对象封装过的生成器。这个GeneratorContextManager被赋值给<code>file</code>函数，我们实际上是在调用GeneratorContextManager对象。</p>
<p>Read More: </p>
<blockquote>
<p><a href="https://eastlakeside.gitbooks.io/interpy-zh/content/context_managers/" target="_blank" rel="noopener">上下文管理器(Context managers)</a> <a href="http://kuanghy.github.io/2015/08/08/python-with" target="_blank" rel="noopener">Python上下文管理器与with语句</a> <a href="http://www.cnblogs.com/wilber2013/p/4638967.html" target="_blank" rel="noopener">Python上下文管理器</a> <a href="https://anyisalin.github.io/anyisalin.github.io/2017/03/07/python-context-manager/" target="_blank" rel="noopener">Python - 上下文管理</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>上下文管理器</tag>
      </tags>
  </entry>
  <entry>
    <title>Python库-watchdog</title>
    <url>/2020/11/11/python-lib-watchdog/</url>
    <content><![CDATA[<p>库地址：<a href="https://pypi.org/project/watchdog/" target="_blank" rel="noopener">pypi</a> <a href="https://github.com/gorakhargosh/watchdog" target="_blank" rel="noopener">github</a></p>
<p>库功能：文件监控</p>
<p>使用示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from watchdog.events import FileSystemEventHandler</span><br><span class="line">from watchdog.observers import Observer</span><br><span class="line"></span><br><span class="line">class FileEventHandler(FileSystemEventHandler):</span><br><span class="line">    </span><br><span class="line">    def __init__(self, callback_func):</span><br><span class="line">        super(FileEventHandler, self).__init__()</span><br><span class="line">        self.callback_func = callback_func</span><br><span class="line">	</span><br><span class="line">	def on_moved(self, event):</span><br><span class="line">        what = &apos;directory&apos; if event.is_directory else &apos;file&apos;</span><br><span class="line">        self.callback_func(src_path, what)</span><br><span class="line"></span><br><span class="line">    def on_created(self, event):</span><br><span class="line">        what = &apos;directory&apos; if event.is_directory else &apos;file&apos;</span><br><span class="line">        self.callback_func(src_path, what)</span><br><span class="line"></span><br><span class="line">    def on_deleted(self, event):</span><br><span class="line">        what = &apos;directory&apos; if event.is_directory else &apos;file&apos;</span><br><span class="line">        self.callback_func(src_path, what)</span><br><span class="line"></span><br><span class="line">    def on_modified(self, event):</span><br><span class="line">        what = &apos;directory&apos; if event.is_directory else &apos;file&apos;</span><br><span class="line">        self.callback_func(src_path, what)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TaskHandler(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.file_observer = None</span><br><span class="line">        self.file_observer_path = None</span><br><span class="line"></span><br><span class="line">    def observer_start(self):</span><br><span class="line">        if not os.path.exists(self.file_observer_path):</span><br><span class="line">            os.makedirs(self.file_observer_path)</span><br><span class="line">        event_handler = FileEventHandler(self.callback)</span><br><span class="line">        self.file_observer = Observer()</span><br><span class="line">        self.file_observer.schedule(event_handler, self.file_observer_path)</span><br><span class="line">        self.file_observer.start()</span><br><span class="line"></span><br><span class="line">    def observer_stop(self):</span><br><span class="line">        if self.file_observer:</span><br><span class="line">            self.file_observer.stop()</span><br><span class="line">            self.file_observer.join()</span><br><span class="line">    </span><br><span class="line">    def observer_restart(self):</span><br><span class="line">        self.observer_stop()</span><br><span class="line">        self.observer_start()</span><br><span class="line"></span><br><span class="line">    def callback(self, src_path):</span><br><span class="line">        self.logger.debug(&apos;file changed. &#123;&#125;&apos;.format(src_path))</span><br><span class="line">        </span><br><span class="line">    def run(self):</span><br><span class="line">        self.observer_start()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python系列 - 浅析Python的垃圾回收机制</title>
    <url>/2017/07/16/pythongc/</url>
    <content><![CDATA[<p>之前写过一篇文章分析了 PHP 的垃圾回收机制，今天看了一下Python的GC，感觉大同小异，总结如下。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>Python 语言默认采用的垃圾收集机制是『引用计数法 Reference Counting』，该算法最早 George E. Collins 在1960的时候首次提出，50 年后的今天，该算法依然被很多编程语言使用，『引用计数法』的原理是：每个对象维护一个 ob_refcnt 字段，用来记录该对象当前被引用的次数，每当新的引用指向该对象时，它的引用计数 ob_refcnt  加1，每当该对象的引用失效时计数 ob_refcnt 减 1，一旦对象的引用计数为 0，该对象立即被回收，对象占用的内存空间将被释放。它的缺点是需要额外的空间维护引用计数，这个问题是其次的，不过最主要的问题是它不能解决对象的“循环引用”，因此，也有很多语言比如 Java 并没有采用该算法做来垃圾的收集机制。</p>
<p>python里每一个东西都是对象，它们的核心就是一个结构体：PyObject</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct_object &#123;</span><br><span class="line">	int ob_refcnt;</span><br><span class="line"> 	struct_typeobject *ob_type;</span><br><span class="line">&#125;PyObject;</span><br></pre></td></tr></table></figure>
<p>什么是循环引用？A 和 B 相互引用而再没有外部引用 A 与 B 中的任何一个，它们的引用计数虽然都为 1，但显然应该被回收，例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a = &#123; &#125;     #对象A的引用计数为 1 </span><br><span class="line">b = &#123; &#125;     #对象B的引用计数为 1 </span><br><span class="line">a[&apos;b&apos;] = b  #B的引用计数增1 </span><br><span class="line">b[&apos;a&apos;] = a  #A的引用计数增1 </span><br><span class="line">del a       #A的引用减 1，最后A对象的引用为 1 </span><br><span class="line">del b       #B的引用减 1, 最后B对象的引用为 1</span><br></pre></td></tr></table></figure>
<p><img src="/images/2017-7-16 143933.jpg" alt="2017-7-16 143933"></p>
<p>在这个例子中程序执行完 del 语句后，A、B 对象已经没有任何引用指向这两个对象，但是这两个对象各包含一个对方对象的引用，虽然最后两个对象都无法通过其它变量来引用这两个对象了，这对 GC 来说就是两个非活动对象或者说是垃圾对象，但是他们的引用计数并没有减少到 0。因此如果是使用引用计数法来管理这两对象的话，他们并不会被回收，它会一直驻留在内存中，就会造成了内存泄漏(内存空间在使用完毕后未释放)。为了解决对象的循环引用问题，Python 引入了标记-清除和分代回收两种 GC 机制。</p>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>『标记清除 Mark—Sweep 』算法是一种基于追踪回技术实现的垃圾回收算法。它分为两个阶段：</p>
<p>第一阶段是标记阶段，GC 会把所有的『活动对象』打上标记;</p>
<p>第二阶段是把那些没有标记的对象『非活动对象』进行回收。</p>
<p>那么 GC 又是如何判断哪些是活动对象哪些是非活动对象的呢？</p>
<p>对象之间通过引用(指针)连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象(root object)出发，沿着有向边遍历对象，可达的(reachable)对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。</p>
<p><img src="/images/2017-7-16 144138.jpg" alt="2017-7-16 144138"></p>
<p>在上图中，我们把小黑圈视为全局变量，也就是把它作为 root object，从小黑圈出发，对象1可直达，那么它将被标记，对象2、3可间接到达也会被标记，而 4 和 5 不可达，那么 1、2、3 就是活动对象，4 和 5 是非活动对象会被 GC 回收。</p>
<p>标记清除算法作为 Python 的辅助垃圾收集技术主要处理的是一些容器对象，比如 list、dict、tuple，instance 等，因为对于字符串、数值对象是不可能造成循环引用问题。Python 使用一个双向链表将这些容器对象组织起来。不过，这种简单粗暴的标记清除算法也有明显的缺点：清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象。</p>
<h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3><p>分代回收是一种以空间换时间的操作方式，Python 将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define NUM_GENERATIONS 3</span><br><span class="line">#define GEN_HEAD(n) (&amp;generations[n].head)</span><br><span class="line"></span><br><span class="line">/* linked lists of container objects */</span><br><span class="line">static struct gc_generation generations[NUM_GENERATIONS] = &#123;</span><br><span class="line">    /* PyGC_Head,               threshold,  count */</span><br><span class="line">    &#123;&#123;&#123;GEN_HEAD(0), GEN_HEAD(0), 0&#125;&#125;,   700,    0&#125;,</span><br><span class="line">    &#123;&#123;&#123;GEN_HEAD(1), GEN_HEAD(1), 0&#125;&#125;,   10,     0&#125;,</span><br><span class="line">    &#123;&#123;&#123;GEN_HEAD(2), GEN_HEAD(2), 0&#125;&#125;,   10,     0&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Python 将内存分为了3 代，分别为年轻代(第0代)、中年代(第1代)、老年代(第2代)，他们对应的是 3 个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python 垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，分代回收是建立在标记清除技术基础之上。分代回收同样作为 Python 的辅助垃圾收集技术处理那些容器对象。</p>
<p>Read More:</p>
<blockquote>
<p><a href="http://hbprotoss.github.io/posts/pythonla-ji-hui-shou-ji-zhi.html" target="_blank" rel="noopener">Python垃圾回收机制</a>  </p>
<p><a href="http://developer.51cto.com/art/201706/542251.htm" target="_blank" rel="noopener">Python中的垃圾回收机制</a>  </p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis系列 - 缓存雪崩、击穿、穿透、预热、更新</title>
    <url>/2021/05/23/redis-cachedown/</url>
    <content><![CDATA[<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><h5 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h5><p>在某一时刻缓存出现大规模的key失效，导致大量的请求直接打到了数据库上，进而导致数据库压力巨大，在高并发的情况下，瞬间就会将数据库打死宕机，这时如果运维临时重启数据库，马上又会有新的流量把数据库打死。这就是缓存雪崩。主要有以下两种原因：</p>
<ul>
<li>Redis宕机</li>
<li>缓存的key都在同一时间失效</li>
</ul>
<h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><ul>
<li>均匀过期：设置不同的过期时间，让缓存失效的时间尽量均匀，避免相同的过期时间导致缓存雪崩，造成大量数据库的访问</li>
<li>分级缓存：第一级缓存失效的基础上，访问二级缓存，每一级缓存的失效时间都不同</li>
<li>热点数据缓存永远不过期<ul>
<li>物理不过期，针对热点key不设置过期时间</li>
<li>逻辑过期，把过期时间存在key对应的value里，由后台任务周期性扫描过期时间刷新缓存</li>
</ul>
</li>
<li>保证Redis缓存的高可用，防止Redis宕机导致缓存雪崩的问题。可以使用 主从+ 哨兵，Redis集群来避免 Redis 全盘崩溃的情况。</li>
<li>在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降</li>
<li>使用熔断机制，限流降级。当流量达到一定的阈值，直接返回“系统繁忙”之类的提示，防止过多的请求打在数据库上将数据库击垮，至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果</li>
<li>开启Redis持久化机制，尽快恢复缓存数据，一旦重启，就能从磁盘上自动加载数据恢复内存中的数据</li>
</ul>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><h5 id="产生原因-1"><a href="#产生原因-1" class="headerlink" title="产生原因"></a>产生原因</h5><p>缓存击穿是某个热点的key失效，大并发集中对热点key进行请求，就会造成大量请求读缓存没读到数据，从而导致高并发访问数据库，引起数据库压力剧增。这种现象就叫做缓存击穿。</p>
<h5 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h5><ul>
<li>在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降</li>
<li>热点数据缓存永远不过期<ul>
<li>物理不过期，针对热点key不设置过期时间</li>
<li>逻辑过期，把过期时间存在key对应的value里，由后台任务周期性扫描过期时间刷新缓存</li>
</ul>
</li>
</ul>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><h5 id="产生原因-2"><a href="#产生原因-2" class="headerlink" title="产生原因"></a>产生原因</h5><p>缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍。如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。</p>
<h5 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h5><ul>
<li>将无效的key存放进Redis中：当出现Redis查不到数据，数据库也查不到数据的情况，我们就把这个key保存到Redis中，设置value=”null”，并设置其过期时间较短，后面再出现查询这个key的请求的时候，直接返回null，就不需要再查询数据库了。但这种处理方式是有问题的，假如传进来的这个不存在的Key值每次都是随机的，那存进Redis也没有意义</li>
<li>对用户的请求参数进行合法性检验</li>
<li>使用布隆过滤器：如果布隆过滤器判定某个 key 不存在布隆过滤器中，那么就一定不存在，如果判定某个 key 存在，那么很大可能是存在（存在一定的误判率）。于是我们可以在缓存之前再加一个布隆过滤器，将数据库中的所有key都存储在布隆过滤器中，在查询Redis前先去布隆过滤器查询 key 是否存在，如果不存在就直接返回，不让其访问数据库，从而避免了对底层存储系统的查询压力</li>
</ul>
<h4 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h4><h5 id="产生原因-3"><a href="#产生原因-3" class="headerlink" title="产生原因"></a>产生原因</h5><p>缓存预热是指系统上线后，提前将相关的缓存数据加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。如果不进行预热，那么Redis初始状态数据为空，系统上线初期，对于高并发的流量，都会访问到数据库中， 对数据库造成流量的压力。</p>
<h5 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h5><ul>
<li>数据量不大的时候，工程启动的时候进行加载缓存动作</li>
<li>数据量大的时候，设置一个定时任务脚本，进行缓存的刷新</li>
<li>数据量太大的时候，优先保证热点数据进行提前加载到缓存</li>
</ul>
<h4 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h4><h5 id="产生原因-4"><a href="#产生原因-4" class="headerlink" title="产生原因"></a>产生原因</h5><p>缓存服务（Redis）和数据服务（数据库）是相互独立且异构的系统，在更新缓存或更新数据的时候无法做到原子性的同时更新两边的数据，因此在并发读写或第二步操作异常时会遇到各种数据不一致的问题。</p>
<p>缓存本身就是通过牺牲强一致性来提高性能，因此使用缓存提升性能，就会有数据更新的延迟性。这就需要我们在评估需求和设计阶段根据实际场景去做权衡了。</p>
<h5 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h5><p>缓存更新有四种方式：Cache Aside、Read Through、Write Through、Write Behind Caching。</p>
<h6 id="Cache-Aside"><a href="#Cache-Aside" class="headerlink" title="Cache Aside"></a>Cache Aside</h6><ul>
<li><p>失效：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</p>
</li>
<li><p>命中：应用程序从cache中取数据，取到后返回。</p>
</li>
<li><p>更新：先把数据存到数据库中，成功后，再让缓存失效。</p>
</li>
</ul>
<h6 id="Read-Through"><a href="#Read-Through" class="headerlink" title="Read Through"></a>Read Through</h6><p>在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或LRU换出），Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。</p>
<h6 id="Write-Through"><a href="#Write-Through" class="headerlink" title="Write Through"></a>Write Through</h6><p>当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由Cache自己更新数据库（这是一个同步操作）。</p>
<h6 id="Write-Behind-Caching"><a href="#Write-Behind-Caching" class="headerlink" title="Write Behind Caching"></a>Write Behind Caching</h6><p>又称 Write Back，在更新数据的时候，只更新缓存，不更新数据库，而我们的缓存会异步地批量更新数据库。</p>
<p>Read More:</p>
<blockquote>
<p><a href="https://segmentfault.com/a/1190000022029639" target="_blank" rel="noopener">Redis 缓存雪崩、击穿、穿透</a></p>
<p><a href="https://blog.csdn.net/a745233700/article/details/88088669" target="_blank" rel="noopener">Redis的缓存雪崩、缓存击穿、缓存穿透与缓存预热、缓存降级</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1666384" target="_blank" rel="noopener">Redis系列 | 缓存穿透、击穿、雪崩、预热、更新、降级</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>缓存雪崩</tag>
        <tag>缓存击穿</tag>
        <tag>缓存穿透</tag>
        <tag>缓存预热</tag>
        <tag>缓存更新</tag>
      </tags>
  </entry>
  <entry>
    <title>Requests库 - 会话对象</title>
    <url>/2018/06/10/requests-session/</url>
    <content><![CDATA[<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>一个简单的需求是，向一个 host 地址+端口定时 post 一定量数据，程序使用 <a href="http://www.python-requests.org/en/master/" target="_blank" rel="noopener">requests</a> 的 post 方式，傻瓜式同步执行，因为没有时间限制。但是在执行后出现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TimeoutError: [Errno 110] Connection timed out</span><br></pre></td></tr></table></figure>
<p>显示连接超时了，程序每次运行 post 了大概500条数据，而这个错误只会出现一次，猜测可能是 HTTP 短连接的问题。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>其实对于     向同一主机发送多个请求 这种场景，使用 HTTP 的长连接效率会更高，复用底层的 TCP 连接。Requests 库同样提供了这样的方式，即会话对象 - <a href="http://www.python-requests.org/en/master/user/advanced/#session-objects" target="_blank" rel="noopener">Session</a> ，使用方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s = requests.Session()</span><br><span class="line">r = s.get(&apos;http://www.baidu.com&apos;)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure>
<p><a href="http://docs.python-requests.org/en/master/_modules/requests/adapters/?highlight=HTTPAdapter" target="_blank" rel="noopener">源码</a>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Session(SessionRedirectMixin):</span><br><span class="line"> </span><br><span class="line">    def __init__(self):</span><br><span class="line">        ...</span><br><span class="line">        self.max_redirects = DEFAULT_REDIRECT_LIMIT</span><br><span class="line">        self.cookies = cookiejar_from_dict(&#123;&#125;)</span><br><span class="line">        self.adapters = OrderedDict()</span><br><span class="line">        self.mount(&apos;https://&apos;, HTTPAdapter())</span><br><span class="line">        self.mount(&apos;http://&apos;, HTTPAdapter())</span><br><span class="line">        self.redirect_cache = RecentlyUsedContainer(REDIRECT_CACHE_SIZE)</span><br><span class="line"> </span><br><span class="line">class HTTPAdapter(BaseAdapter):</span><br><span class="line"> </span><br><span class="line">    def __init__(self, pool_connections=DEFAULT_POOLSIZE,</span><br><span class="line">                 pool_maxsize=DEFAULT_POOLSIZE, max_retries=DEFAULT_RETRIES,</span><br><span class="line">                 pool_block=DEFAULT_POOLBLOCK):</span><br><span class="line">        if max_retries == DEFAULT_RETRIES:</span><br><span class="line">            self.max_retries = Retry(0, read=False)</span><br><span class="line">        else:</span><br><span class="line">            self.max_retries = Retry.from_int(max_retries)</span><br><span class="line">        self.config = &#123;&#125;</span><br><span class="line">        self.proxy_manager = &#123;&#125;</span><br><span class="line"> </span><br><span class="line">        super(HTTPAdapter, self).__init__()</span><br><span class="line"> </span><br><span class="line">        self._pool_connections = pool_connections</span><br><span class="line">        self._pool_maxsize = pool_maxsize</span><br><span class="line">        self._pool_block = pool_block</span><br><span class="line">        self.init_poolmanager(pool_connections, pool_maxsize, block=pool_block) </span><br><span class="line"> </span><br><span class="line">DEFAULT_POOLBLOCK = False  #是否阻塞连接池</span><br><span class="line">DEFAULT_POOLSIZE = 10  # 默认连接池</span><br><span class="line">DEFAULT_RETRIES = 0   # 默认重试次数</span><br><span class="line">DEFAULT_POOL_TIMEOUT = None  # 超时时间</span><br></pre></td></tr></table></figure>
<p>默认情况下，Session 连接池大小为10，请求失败重试次数为0，但是一般情况下我们会需要稍大容量的连接池，从源码中可以看到，session 绑定了 <code>HTTPAdapter</code> 对象，所以我们可以自定义一个符合预期参数的 <code>HTTPAdapter</code> 对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def get_http_session(self, pool_connections, pool_maxsize, max_retries):</span><br><span class="line">    session = requests.Session()</span><br><span class="line">    # 创建一个适配器，连接池的数量pool_connections, 最大数量pool_maxsize, 失败重试的次数max_retries</span><br><span class="line">    adapter = requests.adapters.HTTPAdapter(pool_connections = pool_connections,</span><br><span class="line">            pool_maxsize = pool_maxsize, max_retries = max_retries)</span><br><span class="line">    # 告诉requests，http协议和https协议都使用这个适配器</span><br><span class="line">    session.mount(&apos;http://&apos;, adapter)</span><br><span class="line">    session.mount(&apos;https://&apos;, adapter)</span><br><span class="line">    return session</span><br></pre></td></tr></table></figure>
<p>然后就可以使用 session 的各个功能了。So Easy!</p>
<p>Read More:</p>
<blockquote>
<p><a href="http://www.python-requests.org/en/master/user/advanced/#session-objects" target="_blank" rel="noopener">Advanced Usage</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>Python库</category>
      </categories>
      <tags>
        <tag>requests</tag>
        <tag>session</tag>
        <tag>会话对象</tag>
      </tags>
  </entry>
  <entry>
    <title>学习路线 - 2020</title>
    <url>/2020/11/29/roadmap-2020/</url>
    <content><![CDATA[<h3 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h3><p><img src="/images/2020-11-29200200.png" alt="2020-11-29200200.png"></p>
<p><img src="/images/2020-11-29200201.png" alt="2020-11-29200201.png"></p>
<p><img src="/images/2020-11-29200202.png" alt="2020-11-29200202.png"></p>
<p><img src="/images/2020-11-29200203.png" alt="2020-11-29200203.png"></p>
<h3 id="翻译版"><a href="#翻译版" class="headerlink" title="翻译版"></a>翻译版</h3><p><img src="/images/2020-11-29200200-1.png" alt="2020-11-29200200-1.png"></p>
<p><img src="/images/2020-11-29200201-1.png" alt="2020-11-29200201-1.png"></p>
<p><img src="/images/2020-11-29200202-1.png" alt="2020-11-29200202-1.png"></p>
<p><img src="/images/2020-11-29200203-1.png" alt="2020-11-29200203-1.png"></p>
<p>Read More:</p>
<blockquote>
<p><a href="https://github.com/kamranahmedse/developer-roadmap" target="_blank" rel="noopener">https://github.com/kamranahmedse/developer-roadmap</a></p>
<p><a href="https://www.w3cschool.cn/article/3131568.html" target="_blank" rel="noopener">https://www.w3cschool.cn/article/3131568.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>RoadMap</category>
      </categories>
      <tags>
        <tag>RoadMap</tag>
        <tag>学习路线</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ如何处理消息丢失</title>
    <url>/2021/05/18/rocketmq-msglost/</url>
    <content><![CDATA[<h4 id="消息的发送过程"><a href="#消息的发送过程" class="headerlink" title="消息的发送过程"></a>消息的发送过程</h4><p><img src="/images/2021-5-18T223009.png" alt="2021-5-18T223009.png"></p>
<ul>
<li><p>生产阶段：Producer 新建消息，然后通过网络将消息投递给 MQ Broker</p>
</li>
<li><p>存储阶段：消息将会存储在 Broker 端磁盘中</p>
</li>
<li><p>消费阶段：Consumer 将会从 Broker 拉取消息</p>
</li>
</ul>
<p>以上任一阶段都可能会丢失消息，我们只要找到这三个阶段丢失消息原因，采用合理的办法避免丢失，就可以彻底解决消息丢失的问题。</p>
<h4 id="生产阶段"><a href="#生产阶段" class="headerlink" title="生产阶段"></a>生产阶段</h4><p>生产者（Producer） 通过网络发送消息给 Broker，当 Broker 收到之后，将会返回确认响应信息给 Producer。所以生产者只要接收到返回的确认响应，就代表消息在生产阶段未丢失。</p>
<h5 id="同步发送"><a href="#同步发送" class="headerlink" title="同步发送"></a>同步发送</h5><p>有三种Send方法，同步发送、异步发送、单向发送。我们可以采取同步发送的方式进行发送消息，发消息的时候会同步阻塞等待broker返回的结果，如果没成功，则不会收到SendResult，这种是最可靠的。其次是异步发送，在回调方法里可以得知是否发送成功。单向发送是最不靠谱的一种发送方式，我们无法保证消息真正可达。</p>
<h5 id="失败重试"><a href="#失败重试" class="headerlink" title="失败重试"></a>失败重试</h5><p>发送消息如果失败或者超时了，则会自动重试。默认是重试三次，可以根据API进行更改，比如改为10次：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">producer.setRetryTimesWhenSendFailed(10);</span><br></pre></td></tr></table></figure>
<h4 id="存储阶段"><a href="#存储阶段" class="headerlink" title="存储阶段"></a>存储阶段</h4><p>MQ持久化消息分为两种：同步刷盘和异步刷盘。</p>
<h5 id="同步刷盘"><a href="#同步刷盘" class="headerlink" title="同步刷盘"></a>同步刷盘</h5><p>默认情况是异步刷盘，Broker收到消息后会先存到Cache里然后立马通知Producer成功，然后Broker启动异步线程的去持久化到磁盘中，但是Broker还没持久化到磁盘就宕机的话，消息就丢失了。同步刷盘的话是收到消息存到Cache后并不会通知Producer说消息已经OK了，而是会等到持久化到磁盘中后才会通知Producer说消息完事了。这也保障了消息不会丢失，但是性能不如异步高。看业务场景取舍。</p>
<h5 id="主从同步复制"><a href="#主从同步复制" class="headerlink" title="主从同步复制"></a>主从同步复制</h5><p>即使Broker设置了同步刷盘策略，但是Broker刷完盘后磁盘坏了，这会导致盘上的消息全TM丢了。但是如果即使是1主1从了，但是Master刷完盘后还没来得及同步给Slave就磁盘坏了，也会导致消息丢失。所以我们还可以配置不仅是等Master刷完盘就通知Producer，而是等Master和Slave都刷完盘后才去通知Producer说消息OK了。</p>
<h4 id="消费阶段"><a href="#消费阶段" class="headerlink" title="消费阶段"></a>消费阶段</h4><p>消费者从 broker 拉取消息，然后执行相应的业务逻辑。一旦执行成功，将会返回 <code>ConsumeConcurrentlyStatus.CONSUME_SUCCESS</code> 状态给 Broker。如果 Broker 未收到消费确认响应或收到其他状态，消费者下次还会再次拉取到该条消息，进行重试。这样的方式有效避免了消费者消费过程发生异常，或者消息在网络传输中丢失的情况。</p>
<p>Read More:</p>
<blockquote>
<p><a href="https://www.cnblogs.com/goodAndyxublog/p/12563813.html" target="_blank" rel="noopener">面试官再问我如何保证 RocketMQ 不丢失消息,这回我笑了！</a></p>
<p><a href="https://blog.csdn.net/weixin_39601088/article/details/111343167" target="_blank" rel="noopener">udp怎么保证不丢包_从入门到入土（三）RocketMQ 怎么保证的消息不丢失？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>RocketMQ</tag>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2017/08/27/singleinstancepython/</url>
    <content><![CDATA[<p>单例模式属于创建型模式，它提供了一种创建对象的最佳方式。这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。<br>特点：</p>
<ul>
<li>单例类只能有一个实例；</li>
<li>单例类必须自己创建自己的唯一实例；</li>
<li>单例类必须给所有其他对象提供这一实例。</li>
</ul>
<p>使用场景：</p>
<ul>
<li>Python 的 logger 就是一个单例模式，用以日志记录；</li>
<li>Windows 的资源管理器是一个单例模式；</li>
<li>线程池，数据库连接池等资源池一般也用单例模式；</li>
<li>网站计数器。</li>
</ul>
<p>优点：</p>
<ul>
<li>在内存中只有一个对象，节省内存空间；</li>
<li>避免频繁地创建销毁对象，可以提高性能；</li>
<li>避免对共享资源的多重占用；</li>
<li>可以全局访问。</li>
</ul>
<h3 id="非线程安全"><a href="#非线程安全" class="headerlink" title="非线程安全"></a>非线程安全</h3><p>维护类中的共享变量的方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Singleton(object):</span><br><span class="line">    _instance = None</span><br><span class="line">   </span><br><span class="line">    # 这里不能使用__init__，因为__init__是在instance已经生成以后才去调用的</span><br><span class="line">    # __new__负责创建新的实例并返回新的实例，__init__负责新创建实例的初始化工作无返回</span><br><span class="line">    </span><br><span class="line">    def __new__(cls, *args, **kwargs):  </span><br><span class="line">        if cls._instance is None:</span><br><span class="line">            cls._instance = object.__new__(cls, *args, **kwargs)</span><br><span class="line">        return cls._instance</span><br><span class="line">        </span><br><span class="line">class MyClass(Singleton):</span><br><span class="line">	pass</span><br></pre></td></tr></table></figure>
<p>创建实例时把所有实例的<code>__dict__</code>指向同一个字典，这样它们具有相同的属性和方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Singleton(object):</span><br><span class="line">    _state = &#123;&#125;</span><br><span class="line">    def __new__(cls, *args, **kw):</span><br><span class="line">        ob = super(Singleton, cls).__new__(cls, *args, **kw)</span><br><span class="line">        ob.__dict__ = cls._state</span><br><span class="line">        return ob</span><br></pre></td></tr></table></figure>
<p>Python的装饰器方式，每次执行类中方法时，都会先执行装饰器方法，获取类实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def singleton(cls, *args, **kw):</span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line">    def getinstance():</span><br><span class="line">        if cls not in instances:</span><br><span class="line">            instances[cls] = cls(*args, **kw)</span><br><span class="line">        return instances[cls]</span><br><span class="line">    return getinstance</span><br><span class="line"></span><br><span class="line">@singleton</span><br><span class="line">class MyClass:</span><br><span class="line">	pass</span><br></pre></td></tr></table></figure>
<p>使用<code>metaclass</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Singleton(type):</span><br><span class="line">    _instances = &#123;&#125;</span><br><span class="line">    def __call__(cls, *args, **kwargs):</span><br><span class="line">        if cls not in cls._instances:</span><br><span class="line">            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)</span><br><span class="line">        return cls._instances[cls]</span><br><span class="line"></span><br><span class="line">#Python2</span><br><span class="line">class MyClass(BaseClass):</span><br><span class="line">    __metaclass__ = Singleton</span><br><span class="line"></span><br><span class="line">#Python3</span><br><span class="line">class MyClass(metaclass=Singleton):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>使用模块引入的方式，可以将类单独定义在一个模块中，因为在python中，一个模块只能被导入一次，所以类似一个单例。</p>
<p>以上都是非线程安全的方法，一般我们在使用时已经足够。但是在多线程程序中，可能出现多个线程同时访问造成单例失败，我们可以引入锁机制来解决这个问题。</p>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>方式一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line"></span><br><span class="line">class Singleton(object):</span><br><span class="line"></span><br><span class="line">    _instance = None</span><br><span class="line"></span><br><span class="line">    lock = threading.RLock()</span><br><span class="line"></span><br><span class="line">    def __new__(cls):</span><br><span class="line">        cls.lock.acquire()</span><br><span class="line">        if cls._instance is None:</span><br><span class="line">            cls._instance = super(Singleton, cls).__new__(cls)</span><br><span class="line">        cls.lock.release()</span><br><span class="line">        return cls._instance</span><br></pre></td></tr></table></figure>
<p>方式二：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import threading</span><br><span class="line">try:</span><br><span class="line">    from synchronize import make_synchronized</span><br><span class="line">except ImportError:</span><br><span class="line">    def make_synchronized(func):</span><br><span class="line">        import threading</span><br><span class="line">        func.__lock__ = threading.Lock()</span><br><span class="line"></span><br><span class="line">        def synced_func(*args, **kws):</span><br><span class="line">            with func.__lock__:</span><br><span class="line">                return func(*args, **kws)</span><br><span class="line"></span><br><span class="line">        return synced_func</span><br><span class="line"></span><br><span class="line">class Singleton(object):</span><br><span class="line">    instance = None</span><br><span class="line"></span><br><span class="line">    @make_synchronized</span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        if cls.instance is None:</span><br><span class="line">            cls.instance = object.__new__(cls, *args, **kwargs)</span><br><span class="line">        return cls.instance</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br></pre></td></tr></table></figure>
<h3 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h3><table>
<thead>
<tr>
<th>类型</th>
<th>设计模式</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建型</td>
<td>工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式</td>
</tr>
<tr>
<td>结构型</td>
<td>适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式</td>
</tr>
<tr>
<td>行为型</td>
<td>策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式</td>
</tr>
</tbody>
</table>
<h3 id="设计模式的六大原则："><a href="#设计模式的六大原则：" class="headerlink" title="设计模式的六大原则："></a>设计模式的六大原则：</h3><p><strong>总原则</strong>：开闭原则</p>
<p>开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。</p>
<p><strong>单一职责原则</strong></p>
<p>不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。 </p>
<p><strong>里氏替换原则</strong></p>
<p>里氏代换原则面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p>
<p>里氏替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。</p>
<p><strong>依赖倒转原则</strong></p>
<p>这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。</p>
<p><strong>接口隔离原则</strong></p>
<p>这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。</p>
<p><strong>迪米特法则（最少知道原则）</strong></p>
<p>就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。</p>
<p>最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。</p>
<p><strong>合成复用原则</strong></p>
<p>原则是尽量首先使用合成/聚合的方式，而不是使用继承。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>跨服务器Session共享</title>
    <url>/2017/06/07/sharesession/</url>
    <content><![CDATA[<p>默认情况下，PHP 的 session 文件是保存在磁盘文件中。在php.ini配置文件中的配置项如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">session.save_handler = files</span><br><span class="line">session.save_path = &quot;N;/path&quot;</span><br></pre></td></tr></table></figure>
<p>第一个配置项是指定使用 files(文件形式) 存储session数据。</p>
<p>第二个参数指定保存的路径。N 表示生成多少级目录(不放到一个目录下，分散到多个磁盘目录中去)</p>
<p>所以我们可以知道，session 的数据默认是保存在磁盘文件中。</p>
<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>伴随网站业务规模和访问量的逐步发展，原本由单台服务器、单个域名的迷你网站架构已经无法满足发展需要。</p>
<p>此时我们可能会购买更多服务器，并且启用多个二级子域名以频道化的方式，根据业务功能将网站分布部署在独立的服务器上；或通过负载均衡技术（如：DNS轮询、Radware、F5、LVS等）让多个频道共享一组服务器。</p>
<p>OK，头脑中我们已经构思了这样的解决方案，不过进入深入开发后新的技术问题又随之而来：</p>
<p>我们把网站程序分布部署到多台服务器上，而且独立为几个二级域名，由于 session 受实现原理的局限（PHP中session默认以文件的形式保存在本地服务器的硬盘），使得我们的网站用户不得不经常在几个频道间来回输入用户名、密码登入，导致用户体验大打折扣；另外，原本程序可以直接从用户 session 变量中读取的资料（如：昵称、积分、登入时间等），因为无法跨服务器同步更新 session 变量，迫使开发人员必须实时读写数据库，从而增加了数据库的负担。</p>
<p>于是，解决网站跨服务器之间的Session共享方案需求变得迫切起来。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="基于-Cookie-的-Session-共享"><a href="#基于-Cookie-的-Session-共享" class="headerlink" title="基于 Cookie 的 Session 共享"></a>基于 Cookie 的 Session 共享</h4><p>这个方案我们可能比较陌生，但它在大型网站中还是比较普遍被使用。原理是将全站用户的 session 信息加密、序列化后以cookie的方式，统一种植在根域名下（如：.host.com），利用浏览器访问该根域名下的所有二级域名站点时，会传递与之域名对应的所有 cookie 内容的特性，从而实现用户的 cookie 化 session 在多服务间的共享访问。</p>
<p>这个方案的优点无需额外的服务器资源；缺点是由于受 HTTP 协议头信心长度的限制，仅能够存储小部分的用户信息，同时cookie 化的 session 内容需要进行安全加解密（如：采用DES、RSA等进行明文加解密；再由MD5、SHA-1等算法进行防伪认证），另外它也会占用一定的带宽资源，因为浏览器会在请求当前域名下任何资源时将本地 cookie 附加在 HTTP 头中传递到服务器。</p>
<h4 id="基于数据库的-Session-共享"><a href="#基于数据库的-Session-共享" class="headerlink" title="基于数据库的 Session 共享"></a>基于数据库的 Session 共享</h4><p>采用一台 MySQL 服务器做共享服务器，把所有的 session 的数据保存到 MySQL 服务器上，所有 web服务器都来这台MySQL 服务器来获取 session 数据，并且建议使用内存表Heap，提高session操作的读写效率。这个方案的实用性比较强，相信大家普遍在使用，它的缺点在于 session 的并发读写能力取决于 MySQL 数据库的性能，同时需要自己实现 session 淘汰逻辑，以便定时从数据表中更新、删除 session 记录，当并发过高时容易出现表锁，虽然我们可以选择行级锁的表引擎，但不得不否认使用数据库存储 session 还是有些杀鸡用牛刀的架势。</p>
<h4 id="基于-NFS-的-Session-共享"><a href="#基于-NFS-的-Session-共享" class="headerlink" title="基于 NFS 的 Session 共享"></a>基于 NFS 的 Session 共享</h4><p>这种方法和使用数据库类似，采用一台公共的 NFS 服务器做共享服务器，所有的 web服务器都把 session 数据写到共享存储介质上，也都要来这台服务器获取 session 数据，通过这样的方式来实现 session 数据的共享。这个方案实现最为简单，无需做过多的二次开发，仅需将共享目录服务器 mount 到各频道服务器的本地 session 目录即可，缺点是 NFS 依托于复杂的安全机制和文件系统，因此并发效率不高，尤其对于 session 这类高并发读写的小文件，会由于共享目录服务器的 io-wait过高，最终拖累前端 web 应用程序的执行效率。</p>
<h4 id="基于缓存数据库的-Session-共享"><a href="#基于缓存数据库的-Session-共享" class="headerlink" title="基于缓存数据库的 Session 共享"></a>基于缓存数据库的 Session 共享</h4><p>这种方式可能是目前互联网中比较流行的一种用法。所有 web服务器都把 session 写入到 MemCache/Redis ，也都从MemCache/Redis 来获取。MemCache/Redis 本身就是一个分布式缓存，便于扩展。网络开销较小，几乎没有IO。性能也更好。缺点，受制于 MemCache/Redis 的容量，如果用户量突然增多， cache 由于容量的限制会将一些数据挤出缓存，另外 MemCache/Redis 故障或重启 session 会完全丢失掉。</p>
<h4 id="利用组播实现-Session-共享"><a href="#利用组播实现-Session-共享" class="headerlink" title="利用组播实现 Session 共享"></a>利用组播实现 Session 共享</h4><p>通过组播的方式进行集群间的共享，比如 tomcat 目前就具备这样的功能，优点是 web 容器自身支持，配置简单，适合小型网站。缺点是当一台机器的上的 session 变更后会将变更的数据以组播的形式分发给集群间的所有节点，对网络和所有的web 容器都是存在开销。集群越大浪费越严重。不能做到线性的扩展。</p>
<p>Read More:</p>
<blockquote>
<p><a href="http://blog.csdn.net/lamp_yang_3533/article/details/51984201" target="_blank" rel="noopener">如何在多台web服务器上共享session？</a>  <a href="http://www.cnblogs.com/imhaiyang/articles/4949459.html" target="_blank" rel="noopener">多服务器之间Session共享</a>  <a href="https://www.zhihu.com/question/19651970/answer/12534778" target="_blank" rel="noopener">如何解决 cluster 中应用中 session 共享问题？都有那些方案，各有什么优缺点？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>session共享</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLAlchemy bug系列(一)</title>
    <url>/2018/05/13/sqlalchemybug1/</url>
    <content><![CDATA[<p>项目框架采用 Tornado ，SQLAlchemy 作为数据库ORM，简陋的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def query(self, filters, orders=&apos;&apos;):</span><br><span class="line">    try:</span><br><span class="line">        if not isinstance(filters, str) or not isinstance(orders, str):</span><br><span class="line">            return False</span><br><span class="line">        if not len(orders):</span><br><span class="line">            return self.s.query(Node).filter(filters).first()</span><br><span class="line">        else:</span><br><span class="line">            r = self.s.query(Node).filter(filters).order_by(orders).all()</span><br><span class="line">            if len(r):</span><br><span class="line">                return r[0]</span><br><span class="line">            return None</span><br><span class="line">    except Exception as e:</span><br><span class="line">        self.logger.error(traceback.format_exc())</span><br><span class="line">        return None</span><br><span class="line">    finally:</span><br><span class="line">        Session.remove()</span><br></pre></td></tr></table></figure>
<p>但是在跑了一段时间后出现了如下问题：</p>
<blockquote>
<p>(sqlalchemy.exc.InvalidRequestError) Can’t reconnect until invalid transaction is rolled back</p>
</blockquote>
<p>错误中很明显是数据库的连接由于事务某些错误出现了问题，SQLAlchemy 在尝试重新连接时失败了。</p>
<p>几经翻找资料后，问题产生原因如下：</p>
<p>从数据库连接池（pool）中获取的 <code>connection</code> 没有以 <code>session.commit()</code> 或 <code>session.rollback()</code> 或 <code>session.close()</code> 的某一种放回 pool 中。这时 <code>connection</code> 的事务（<code>transaction</code> ）没有完结，而在后续与数据库交互中，由于某些原因（如死锁、超时）数据库连接池中的 <code>connection</code> 又死掉了，当获取到这个连接时，SQLAlchemy 尝试重新连接。但由于 <code>transaction</code> 还没完结，无法重连。就抛出了上述错误。</p>
<p>解决办法：</p>
<ol>
<li><p>显示调用事务结束</p>
<p>使用 <code>try...except...</code> 代码块，<code>except</code> 中捕获到异常时，调用 <code>session.rollback()</code> 回滚事务。</p>
</li>
<li><p>打开 <code>autocommit</code></p>
<p>使用 SQLAlchemy 的初始化方式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Base = declarative_base()</span><br><span class="line">engine = create_engine(</span><br><span class="line">    &quot;mysql+pymysql://&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;/&#123;&#125;&quot;.format(</span><br><span class="line">        mysql_config[&apos;default&apos;][&apos;user&apos;],</span><br><span class="line">        mysql_config[&apos;default&apos;][&apos;password&apos;],</span><br><span class="line">        mysql_config[&apos;default&apos;][&apos;host&apos;],</span><br><span class="line">        mysql_config[&apos;default&apos;][&apos;port&apos;],</span><br><span class="line">        mysql_config[&apos;default&apos;][&apos;name&apos;],</span><br><span class="line">    ),</span><br><span class="line">    encoding=&quot;utf-8&quot;,</span><br><span class="line">    echo=False,</span><br><span class="line">    pool_recycle=mysql_config[&apos;connect_pool&apos;][&apos;pool_recycle&apos;],</span><br><span class="line">    pool_size=mysql_config[&apos;connect_pool&apos;][&apos;pool_size&apos;]</span><br><span class="line">)</span><br><span class="line">Session = scoped_session(sessionmaker(bind=engine))</span><br></pre></td></tr></table></figure>
<p>默认是使用事务操作，我们可以在初始化语句中加上 <code>autocommit=true</code> 关闭事务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">engine = create_engine(</span><br><span class="line">    &quot;mysql+pymysql://&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;/&#123;&#125;?autocommit=true&quot;.format(</span><br><span class="line">        mysql_config[&apos;default&apos;][&apos;user&apos;],</span><br><span class="line">        mysql_config[&apos;default&apos;][&apos;password&apos;],</span><br><span class="line">        mysql_config[&apos;default&apos;][&apos;host&apos;],</span><br><span class="line">        mysql_config[&apos;default&apos;][&apos;port&apos;],</span><br><span class="line">        mysql_config[&apos;default&apos;][&apos;name&apos;],</span><br><span class="line">    ),</span><br><span class="line">    encoding=&quot;utf-8&quot;,</span><br><span class="line">    echo=False,</span><br><span class="line">    pool_recycle=mysql_config[&apos;connect_pool&apos;][&apos;pool_recycle&apos;],</span><br><span class="line">    pool_size=mysql_config[&apos;connect_pool&apos;][&apos;pool_size&apos;]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这样生成的查询语句就会立即执行。<strong>注意：</strong>个人感觉这并不是一个好方法，还是老老实实捕获异常吧。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>SQLAlchemy</category>
      </categories>
      <tags>
        <tag>SQLAlchemy</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>子进程和线程的区别</title>
    <url>/2017/07/15/threadsubprocess/</url>
    <content><![CDATA[<h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul>
<li>二者都具有 ID ，一组寄存器，状态，优先级以及所要遵循的调度策略；</li>
<li>每个进程都有一个进程控制块，线程也拥有一个线程控制块；</li>
<li>线程和子进程共享父进程中的资源；线程和子进程独立于它们的父进程，竞争使用处理器资源；线程和子进程的创建者可以在线程和子进程上实行某些控制，比如，创建者可以取消、挂起、继续和修改线程和子进程的优先级；线程和子进程可以改变其属性并创建新的资源。</li>
</ul>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul>
<li>线程是进程的一部分, 一个没有线程的进程是可以被看作单线程的，如果一个进程内拥有多个进程，进程的执行过程不是一条线（线程）的，而是多条线（线程）共同完成的；</li>
<li>启动一个线程所花费的空间远远小于启动一个进程所花费的空间，而且，线程间彼此切换所需的时间也远远小于进程间切换所需要的时间；</li>
<li>系统在运行的时候会为每个进程分配不同的内存区域，但是不会为线程分配内存（线程所使用的资源是它所属的进程的资源），线程组只能共享资源。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过通信的方式进行，这种方式不仅费时，而且很不方便。而一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便；</li>
<li>与进程的控制表 PCB 相似，线程也有自己的控制表 TCB，但是 TCB 中所保存的线程状态比 PCB 表中少多了；</li>
<li>进程是系统所有资源分配时候的一个基本单位，拥有一个完整的虚拟空间地址，并不依赖线程而独立存在。</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>进程和线程的区别在于粒度不同，进程之间的变量(或者说是内存)是不能直接互相访问的，而线程可以。线程一定会依附在某一个进程上执行.我举个例子，你在 Windows 下开一个 IE 浏览器，这个 IE 浏览器是一个进程，你用浏览器去打开一个pdf，IE 就去调用 Acrobat 去打开，这时 Acrobat 是一个独立的进程，就是 IE 的子进程。而 IE 自己本身同时用同一个进程开了 2 个网页, 并且同时在跑两个网页上的脚本，这两个网页的执行就是 IE 自己通过两个线程实现的。值得注意的是，线程仍然是 IE 的内容，而子进程 Acrobat 严格来说就不属于 IE ，是另外一个程序。之所以是 IE 的子进程，只是受 IE 调用而启动的而已。<br>子进程与父进程之间可以通过动态数据交换、OLE、管道、邮件槽等进行通信，使用内存映射文件是最便利的方法之一。</p>
<p>Read More:</p>
<blockquote>
<p><a href="http://blog.csdn.net/wangkehuai/article/details/7089323" target="_blank" rel="noopener">子进程和线程的区别</a></p>
</blockquote>
]]></content>
      <categories>
        <category>进程/线程</category>
      </categories>
      <tags>
        <tag>子进程</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime Text 3 添加右键菜单</title>
    <url>/2017/10/11/sublimetext3rightclick/</url>
    <content><![CDATA[<p>每次安装 Sublime Text 3 后邮件菜单总是没有，但是 notepad++ 安装后会自动加到邮件菜单，对于 Sublime Text 3 的忠实粉丝来说简直丧心病狂，所以搜罗了一些方法来完成这件事儿。</p>
<h4 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Version]</span><br><span class="line">Signature=&quot;$Windows NT$&quot;</span><br><span class="line"></span><br><span class="line">[DefaultInstall]</span><br><span class="line">AddReg=SublimeText3</span><br><span class="line"></span><br><span class="line">[SublimeText3]</span><br><span class="line">hkcr,&quot;*\\shell\\SublimeText3&quot;,,,&quot;Edit with Sublime Text 3&quot;</span><br><span class="line">hkcr,&quot;*\\shell\\SublimeText3\\command&quot;,,,&quot;&quot;&quot;%1%\sublime_text.exe&quot;&quot; &quot;&quot;%%1&quot;&quot; %%*&quot;</span><br><span class="line">hkcr,&quot;Directory\shell\SublimeText3&quot;,,,&quot;Edit with Sublime Text 3&quot;</span><br><span class="line">hkcr,&quot;*\\shell\\SublimeText3&quot;,&quot;Icon&quot;,0x20000,&quot;%1%\sublime_text.exe, 0&quot;</span><br><span class="line">hkcr,&quot;Directory\shell\SublimeText3\command&quot;,,,&quot;&quot;&quot;%1%\sublime_text.exe&quot;&quot; &quot;&quot;%%1&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>
<p>把以上代码，复制到 Sublime Text 3 的安装目录，然后重命名为：sublime_addright.inf，注意文件编码方式为ANSI，右击安装就可以了。</p>
<blockquote>
<p>重命名文件之前，需要先在 工具-&gt;文件夹选项-&gt;查看，把隐藏已知文件类型的扩展名前边的复选框不勾选。</p>
</blockquote>
<h4 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line">[HKEY_CLASSES_ROOT\*\shell\SublimeText3]</span><br><span class="line">@=&quot;Edit with Sublime Text 3&quot;</span><br><span class="line">&quot;Icon&quot;=&quot;D:\\Sublime Text 3\\sublime_text.exe,0&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\*\shell\SublimeText3\command]</span><br><span class="line">@=&quot;D:\\Sublime Text 3\\sublime_text.exe %1&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\shell\SublimeText3]</span><br><span class="line">@=&quot;Edit with Sublime Text 3&quot;</span><br><span class="line">&quot;Icon&quot;=&quot;D:\\Sublime Text 3\\sublime_text.exe,0&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\shell\SublimeText3\command]</span><br><span class="line">@=&quot;D:\\Sublime Text 3\\sublime_text.exe %1&quot;</span><br></pre></td></tr></table></figure>
<p>把以上代码，复制到 Sublime Text 3 的安装目录，然后重命名为：sublime_addright.reg，注意文件编码方式为ANSI，然后双击就可以了。</p>
<blockquote>
<p>需要把里边的 Sublime 的安装目录，替换成实际的 Sublime 安装目录。</p>
</blockquote>
<p>删除右键菜单脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line">[-HKEY_CLASSES_ROOT\*\shell\SublimeText3]</span><br><span class="line">[-HKEY_CLASSES_ROOT\Directory\shell\SublimeText3]</span><br></pre></td></tr></table></figure>
<p>把以上代码，复制到 Sublime Text 3 的安装目录，然后重命名为：sublime_delright.reg，文件编码方式依然为ANSI，然后双击就可以了。</p>
<p>Read More：</p>
<blockquote>
<p><a href="https://my.oschina.net/adairs/blog/466777" target="_blank" rel="noopener">将Sublime Text3添加到右键菜单中</a></p>
</blockquote>
]]></content>
      <categories>
        <category>辅助研发杂记</category>
      </categories>
      <tags>
        <tag>Sublime Text 3</tag>
      </tags>
  </entry>
  <entry>
    <title>Tornado5.0.2翻译文档 - Queue示例:一个并发网络爬虫</title>
    <url>/2018/06/18/tornado502-concurrentwebspider/</url>
    <content><![CDATA[<p>Tornado的 <a href="http://tornado-zh.readthedocs.io/zh/latest/queues.html#module-tornado.queues" target="_blank" rel="noopener"><code>tornado.queues</code></a> 模块实现了异步生产者/消费者模式的协程，类似于通过Python 标准库的 <a href="https://docs.python.org/3.4/library/queue.html#module-queue" target="_blank" rel="noopener"><code>queue</code></a> 实现线程模式。</p>
<p>一个yields <a href="http://tornado-zh.readthedocs.io/zh/latest/queues.html#tornado.queues.Queue.get" target="_blank" rel="noopener"><code>Queue.get</code></a> 的协程直到队列中有值的时候才会暂停。如果队列设置了最大长度，yields <a href="http://tornado-zh.readthedocs.io/zh/latest/queues.html#tornado.queues.Queue.put" target="_blank" rel="noopener"><code>Queue.put</code></a> 的协程直到队列中有空间才会暂停。</p>
<p>一个 <a href="http://tornado-zh.readthedocs.io/zh/latest/queues.html#tornado.queues.Queue" target="_blank" rel="noopener"><code>Queue</code></a> 从0开始对未完成的任务进行计数， <a href="http://tornado-zh.readthedocs.io/zh/latest/queues.html#tornado.queues.Queue.put" target="_blank" rel="noopener"><code>put</code></a> 加计数； <a href="http://tornado-zh.readthedocs.io/zh/latest/queues.html#tornado.queues.Queue.task_done" target="_blank" rel="noopener"><code>task_done</code></a> 减少计数。</p>
<p>这里的网络爬虫的例子，队列开始的时候只包含 base_url。当一个 worker 抓取到一个页面它会解析链接并把它添加到队列中，然后调用 <a href="http://tornado-zh.readthedocs.io/zh/latest/queues.html#tornado.queues.Queue.task_done" target="_blank" rel="noopener"><code>task_done</code></a> 减少计数一次。最后，当一个 worker 抓取到的页面 URL 都是之前抓取到过的并且队列中没有任务了。于是 worker 调用 <a href="http://tornado-zh.readthedocs.io/zh/latest/queues.html#tornado.queues.Queue.task_done" target="_blank" rel="noopener"><code>task_done</code></a> 把计数减到0。等待 <a href="http://tornado-zh.readthedocs.io/zh/latest/queues.html#tornado.queues.Queue.join" target="_blank" rel="noopener"><code>join</code></a> 的主协程取消暂停并且完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line">from datetime import timedelta</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    from HTMLParser import HTMLParser</span><br><span class="line">    from urlparse import urljoin, urldefrag</span><br><span class="line">except ImportError:</span><br><span class="line">    from html.parser import HTMLParser</span><br><span class="line">    from urllib.parse import urljoin, urldefrag</span><br><span class="line"></span><br><span class="line">from tornado import httpclient, gen, ioloop, queues</span><br><span class="line"></span><br><span class="line">base_url = &apos;http://www.tornadoweb.org/en/stable/&apos;</span><br><span class="line">concurrency = 10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@gen.coroutine</span><br><span class="line">def get_links_from_url(url):</span><br><span class="line">    &quot;&quot;&quot;Download the page at `url` and parse it for links.</span><br><span class="line"></span><br><span class="line">    Returned links have had the fragment after `#` removed, and have been made</span><br><span class="line">    absolute so, e.g. the URL &apos;gen.html#tornado.gen.coroutine&apos; becomes</span><br><span class="line">    &apos;http://www.tornadoweb.org/en/stable/gen.html&apos;.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    try:</span><br><span class="line">        response = yield httpclient.AsyncHTTPClient().fetch(url)</span><br><span class="line">        print(&apos;fetched %s&apos; % url)</span><br><span class="line"></span><br><span class="line">        html = response.body if isinstance(response.body, str) \</span><br><span class="line">            else response.body.decode(errors=&apos;ignore&apos;)</span><br><span class="line">        urls = [urljoin(url, remove_fragment(new_url))</span><br><span class="line">                for new_url in get_links(html)]</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(&apos;Exception: %s %s&apos; % (e, url))</span><br><span class="line">        raise gen.Return([])</span><br><span class="line"></span><br><span class="line">    raise gen.Return(urls)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def remove_fragment(url):</span><br><span class="line">    pure_url, frag = urldefrag(url)</span><br><span class="line">    return pure_url</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_links(html):</span><br><span class="line">    class URLSeeker(HTMLParser):</span><br><span class="line">        def __init__(self):</span><br><span class="line">            HTMLParser.__init__(self)</span><br><span class="line">            self.urls = []</span><br><span class="line"></span><br><span class="line">        def handle_starttag(self, tag, attrs):</span><br><span class="line">            href = dict(attrs).get(&apos;href&apos;)</span><br><span class="line">            if href and tag == &apos;a&apos;:</span><br><span class="line">                self.urls.append(href)</span><br><span class="line"></span><br><span class="line">    url_seeker = URLSeeker()</span><br><span class="line">    url_seeker.feed(html)</span><br><span class="line">    return url_seeker.urls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@gen.coroutine</span><br><span class="line">def main():</span><br><span class="line">    q = queues.Queue()</span><br><span class="line">    start = time.time()</span><br><span class="line">    fetching, fetched = set(), set()</span><br><span class="line"></span><br><span class="line">    @gen.coroutine</span><br><span class="line">    def fetch_url():</span><br><span class="line">        current_url = yield q.get()</span><br><span class="line">        try:</span><br><span class="line">            if current_url in fetching:</span><br><span class="line">                return</span><br><span class="line"></span><br><span class="line">            print(&apos;fetching %s&apos; % current_url)</span><br><span class="line">            fetching.add(current_url)</span><br><span class="line">            urls = yield get_links_from_url(current_url)</span><br><span class="line">            fetched.add(current_url)</span><br><span class="line"></span><br><span class="line">            for new_url in urls:</span><br><span class="line">                # Only follow links beneath the base URL</span><br><span class="line">                if new_url.startswith(base_url):</span><br><span class="line">                    yield q.put(new_url)</span><br><span class="line"></span><br><span class="line">        finally:</span><br><span class="line">            q.task_done()</span><br><span class="line"></span><br><span class="line">    @gen.coroutine</span><br><span class="line">    def worker():</span><br><span class="line">        while True:</span><br><span class="line">            yield fetch_url()</span><br><span class="line"></span><br><span class="line">    q.put(base_url)</span><br><span class="line"></span><br><span class="line">    # Start workers, then wait for the work queue to be empty.</span><br><span class="line">    for _ in range(concurrency):</span><br><span class="line">        worker()</span><br><span class="line">    yield q.join(timeout=timedelta(seconds=300))</span><br><span class="line">    assert fetching == fetched</span><br><span class="line">    print(&apos;Done in %d seconds, fetched %s URLs.&apos; % (</span><br><span class="line">        time.time() - start, len(fetched)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    io_loop = ioloop.IOLoop.current()</span><br><span class="line">    io_loop.run_sync(main)</span><br></pre></td></tr></table></figure>
<p>Read More:</p>
<blockquote>
<p><a href="http://www.tornadoweb.org/en/stable/guide/queues.html" target="_blank" rel="noopener"><code>Queue</code> example - a concurrent web spider</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>Tornado</category>
      </categories>
      <tags>
        <tag>Tornado</tag>
        <tag>翻译文档</tag>
        <tag>并发网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Tornado5.0.2翻译文档 - 介绍</title>
    <url>/2018/06/10/tornado502-introduction/</url>
    <content><![CDATA[<p><a href="http://www.tornadoweb.org/" target="_blank" rel="noopener">Tornado</a> 是一个 Python web 框架和异步网络库，起初由 <a href="http://friendfeed.com/" target="_blank" rel="noopener">FriendFeed</a> 开发。通过使用非阻塞网络 I/O，Tornado 可以支持上万级的连接，处理<a href="http://en.wikipedia.org/wiki/Push_technology#Long_polling" target="_blank" rel="noopener">长连接</a> <a href="http://en.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">WebSockets</a> 和其他需要与每个用户保持长久连接的应用。</p>
<p>Tornado 大体上可以被分为4个主要的部分：</p>
<ul>
<li>web 框架 - 包括创建 web 应用的 <a href><code>RequestHandler</code></a> 类，和其他支持类；</li>
<li>HTTP 客户端和服务端的实现(<a href><code>HTTPServer</code></a> 和 <a href><code>AsyncHTTPClient</code></a>)；</li>
<li>异步网络库(<a href><code>IOLoop</code></a> 和 <a href><code>IOStream</code></a>)，为 HTTP 组件提供构建模块，也可以用来实现其他协议；</li>
<li>协程库 (<a href><code>tornado.gen</code></a>) 允许异步代码写的更直接而不用链式回调的方式。</li>
</ul>
<p>Tornado web 框架和 HTTP server 一起为 <a href="http://www.python.org/dev/peps/pep-3333/" target="_blank" rel="noopener">WSGI</a> 提供了一个全栈式的选择，在 WSGI 容器 (<a href><code>WSGIAdapter</code></a>) 中使用 Tornado web 框架或者使用 Tornado HTTP server 作为一个其他 WSGI 框架(<a href><code>WSGIContainer</code></a>)的容器，这样的组合方式都是有局限性的。为了充分利用Tornado的特性，你需要一起使用 Tornado 的 web 框架和 HTTP server。</p>
<p>Read More:</p>
<blockquote>
<p><a href="http://www.tornadoweb.org/en/stable/guide/intro.html" target="_blank" rel="noopener">Introduction</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>Tornado</category>
      </categories>
      <tags>
        <tag>Tornado</tag>
        <tag>翻译文档</tag>
      </tags>
  </entry>
  <entry>
    <title>Tornado5.0.2翻译文档 - 异步和非阻塞I/O</title>
    <url>/2018/06/10/tornado502-asnon/</url>
    <content><![CDATA[<p>实时web功能需要为每个用户提供一个多数时间被闲置的长连接，在传统的同步 web 服务器中，这意味着要为每个用户提供一个线程，当然每个线程的开销都是很昂贵的。</p>
<p>为了尽量减少并发连接造成的开销，Tornado 使用了一种单线程事件循环的方式。这就意味着所有的应用代码都应该是异步非阻塞的，因为在同一时间只有一个操作是有效的。</p>
<p>异步和非阻塞是非常相关的并且这两个术语经常交换使用，但它们不是完全相同的事情。</p>
<h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>一个函数在等待某些事情返回值的时候会被阻塞，导致函数阻塞的原因有很多：网络 I/O，磁盘 I/O，互斥锁等。事实上每个函数在运行和使用 CPU 的时候都或多或少被阻塞(举个极端的例子来说明为什么对待 CPU 阻塞要和对待一般阻塞一样的严肃：比如密码哈希函数 <a href="http://bcrypt.sourceforge.net/" target="_blank" rel="noopener">bcrypt</a> ，需要消耗几百毫秒的 CPU 时间，这已 经远远超过了一般的网络或者磁盘请求时间了)。</p>
<p>一个函数可以在某个方面被阻塞但在其他方面不被阻塞，在 Tornado 的上下文中，我们一般讨论网络 I/O 上下文的阻塞，尽管各种阻塞已经被最小化。</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>异步函数在会在其完成之前返回，在应用中触发下一个动作之前通常会在后台执行一些工作(和正常的同步函数在返回前就执行完所有的事情不同)。这里列举了几种不同的异步接口：</p>
<ul>
<li>回调参数；</li>
<li>返回一个占位符(<a href><code>Future</code></a> <a href><code>Promise</code></a> <a href><code>Deferred</code></a>)；</li>
<li>传送给一个队列；</li>
<li>回调注册表(POSIX 信号)。</li>
</ul>
<p>不论使用哪种类型的接口，按照定义，异步函数与他们的调用者都有着不同的交互方式；也没有什么对调用者透明的方式使得同步函数变得异步(类似 <a href="http://www.gevent.org/" target="_blank" rel="noopener">gevent</a> 使用轻量级线程的系统性能虽然堪比异步系统，但它们并没有真正的让事情异步)。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>这是一个简单的同步函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from tornado.httpclient import HTTPClient</span><br><span class="line"></span><br><span class="line">def synchronous_fetch(url):</span><br><span class="line">    http_client = HTTPClient()</span><br><span class="line">    response = http_client.fetch(url)</span><br><span class="line">    return response.body</span><br></pre></td></tr></table></figure>
<p>下面是使用回调参数重写的具有同样功能的异步函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from tornado.httpclient import AsyncHTTPClient</span><br><span class="line"></span><br><span class="line">def asynchronous_fetch(url, callback):</span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    def handle_response(response):</span><br><span class="line">        callback(response.body)</span><br><span class="line">    http_client.fetch(url, callback=handle_response)</span><br></pre></td></tr></table></figure>
<p>使用 <a href><code>Future</code></a> 代替回调：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from tornado.concurrent import Future</span><br><span class="line">from tornado.httpclient import AsyncHTTPClient</span><br><span class="line"></span><br><span class="line">def async_fetch_future(url):</span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    my_future = Future()</span><br><span class="line">    fetch_future = http_client.fetch(url)</span><br><span class="line">    fetch_future.add_done_callback(</span><br><span class="line">        lambda f: my_future.set_result(f.result()))</span><br><span class="line">    return my_future</span><br></pre></td></tr></table></figure>
<p><a href><code>Future</code></a> 版本更加复杂，但是 <a href><code>Futures</code></a> 却是 Tornado 中推荐的写法，因为它有两个主要的优势：一是错误处理更加一致，<a href><code>Future.result</code></a> 方法可以简单的抛出异常(相较于常见的回调函数接口中需特别指定错误处理方式)，二是 <a href><code>Futures</code></a> 很适合与协程一起使用。我们稍后会更加深入的讨论协程，以下是例子的协程版本，类似原始的同步版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from tornado import gen</span><br><span class="line"></span><br><span class="line">@gen.coroutine</span><br><span class="line">def fetch_coroutine(url):</span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    response = yield http_client.fetch(url)</span><br><span class="line">    raise gen.Return(response.body)</span><br></pre></td></tr></table></figure>
<p><code>raise gen.Return(response.body)</code> 声明是在 Python 2 环境下人为执行的，因为生成器不允许有返回值，为了解决这个问题，Tornado 的协程抛出了一种称为 <code>Return</code> 的异常，协程捕获这个异常并将其作为返回值。在 Python 3.3+版本，使用 <code>return response.body</code> 可以得到相同的结果。</p>
<p>Read More:</p>
<blockquote>
<p><a href="http://www.tornadoweb.org/en/stable/guide/async.html" target="_blank" rel="noopener">Asynchronous and non-Blocking I/O</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Tornado</category>
      </categories>
      <tags>
        <tag>Tornado</tag>
        <tag>翻译文档</tag>
      </tags>
  </entry>
  <entry>
    <title>Tornado5.0.2翻译文档 - 模板和UI</title>
    <url>/2020/12/19/tornado502-templateui/</url>
    <content><![CDATA[<p>Tornado包含一种简单、快速、灵活的模板语言。本节描述该语言以及相关问题，如国际化。</p>
<p>Tornado还可以与任何其他Python模板语言一起使用，尽管没有将这些系统集成到<code>RequestHandler.render</code>中。只需将模板呈现为一个字符串并将其传递给<code>RequestHandler.write</code>即可。</p>
<h3 id="模板配置"><a href="#模板配置" class="headerlink" title="模板配置"></a>模板配置</h3><p>默认情况下，Tornado会在引用它们的<code>.py</code>文件的同一目录中寻找模板文件。要将模板文件放到不同的目录中，请使用<code>template_path</code>应用程序设置(或覆盖<code>RequestHandler.get_template_path</code>如果不同的处理程序有不同的模板路径)。</p>
<p>要从非文件系统位置加载模板，子类<code>tornado.template.BaseLoader</code>并传递一个实例作为<code>template_loader</code>应用程序设置。</p>
<p>编译后的模板默认缓存;要关闭此缓存并重新加载模板，以便底层文件的更改始终可见，请使用应用程序设置<code>compiled_template_cache=False</code>或<code>debug=True</code>。</p>
<h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><p>Tornado模板只是HTML(或任何其他基于文本的格式)，在标记中嵌入了Python控制序列和表达式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">      &lt;title&gt;&#123;&#123; title &#125;&#125;&lt;/title&gt;</span><br><span class="line">   &lt;/head&gt;</span><br><span class="line">   &lt;body&gt;</span><br><span class="line">     &lt;ul&gt;</span><br><span class="line">       &#123;% for item in items %&#125;</span><br><span class="line">         &lt;li&gt;&#123;&#123; escape(item) &#125;&#125;&lt;/li&gt;</span><br><span class="line">       &#123;% end %&#125;</span><br><span class="line">     &lt;/ul&gt;</span><br><span class="line">   &lt;/body&gt;</span><br><span class="line"> &lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>如果您将此模板保存为“template.html”。然后把它放在与Python文件相同的目录下，你可以用下面的方法来渲染这个模板:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MainHandler(tornado.web.RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        items = [&quot;Item 1&quot;, &quot;Item 2&quot;, &quot;Item 3&quot;]</span><br><span class="line">        self.render(&quot;template.html&quot;, title=&quot;My title&quot;, items=items)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Tornado模板支持控制语句和表达式。控制语句被&#123;%和%&#125;包围，比如：&#123;% if len(items) &gt; 2 %&#125;，表达式由&#123;&#123;和&#125;&#125;包围，比如&#123;&#123; item[0] &#125;&#125;。控制语句或多或少精确地映射到Python语句。我们支持if、for、while和try，它们都以&#123;%end%&#125;结尾，我们还支持使用extends和block语句的模板继承，这些语句都能在tornado.template找到。</span><br></pre></td></tr></table></figure>
<p>表达式可以是任何Python表达式，包括函数调用。模板代码在包含以下对象和函数的命名空间中执行(注意使用此列表呈现的模板<code>RequestHandler.render</code>和<code>render_string</code>。如果你使用<code>tornado.template</code>模块直接位于<code>RequestHandler</code>外部，其中许多条目不存在）</p>
<ul>
<li><p><code>escape</code>: alias for <code>tornado.escape.xhtml_escape</code></p>
</li>
<li><p><code>xhtml_escape</code>: alias for <code>tornado.escape.xhtml_escape</code></p>
</li>
<li><p><code>url_escape</code>: alias for <code>tornado.escape.url_escape</code></p>
</li>
<li><p><code>json_encode</code>: alias for <code>tornado.escape.json_encode</code></p>
</li>
<li><p><code>squeeze</code>: alias for <code>tornado.escape.squeeze</code></p>
</li>
<li><p><code>linkify</code>: alias for <code>tornado.escape.linkify</code></p>
</li>
<li><p><code>datetime</code>: the Python <code>datetime</code>module</p>
</li>
<li><p><code>handler</code>: the current <code>RequestHandler</code> object</p>
</li>
<li><p><code>request</code>: alias for <code>handler.request</code></p>
</li>
<li><p><code>current_user</code>: alias for <code>handler.current_user</code></p>
</li>
<li><p><code>locale</code>: alias for <code>handler.locale</code></p>
</li>
<li><p><code>\_</code>: alias for handler.locale.translate</p>
</li>
<li><p>static_url: alias for <code>handler.static_url</code></p>
</li>
<li><p>xsrf_form_html: alias for <code>handler.xsrf_form_html</code></p>
</li>
<li><p>reverse_url: alias for <code>Application.reverse_url</code></p>
</li>
<li><p>All entries from the <code>ui_methods</code> and <code>ui_modules</code> <code>Application</code> settings</p>
</li>
<li><p>Any keyword arguments passed to <code>render</code> or <code>render_string</code></p>
</li>
</ul>
<p>当您构建一个真正的应用程序时，您需要使用Tornado模板的所有特性，特别是模板继承。请阅读<code>tornado.template</code>部分（一些功能，包括<code>UIModules</code>在<code>tornado.web</code>模块）</p>
<p>Tornado模板直接翻译成Python。模板中包含的表达式将被逐字复制到表示模板的Python函数中。我们不试图阻止模板语言中的任何东西；我们显式地创建它是为了提供其他更严格的模板系统所阻止的灵活性。因此，如果您在模板表达式中编写随机内容，那么在执行模板时，您将得到随机的Python错误。</p>
<p>默认情况下，所有模板输出都是转义的，使用<code>tornado.escape.xhtml_escape</code>函数，可以传递参数 <code>autoescape=None</code> 给Application或者通过<code>tornado.template.Loader</code>来全局改变该属性，此外，在这些地方中的每一个都可以使用替代转义函数的名称来代替<code>None</code>。</p>
<p>请注意，虽然Tornado的自动转义有助于避免XSS漏洞，但它在所有情况下都不够。出现在某些位置（如JavaScript或CSS）中的表达式可能需要额外的转义。此外，必须注意在可能包含不可信内容的HTML属性中始终使用双引号和xhtml_escape，或者必须对属性使用单独的转义函数（参见<a href="https://wonko.com/post/html-escaping" target="_blank" rel="noopener">博客</a>）。</p>
<h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h3><p>参见<a href="https://www.tornadoweb.org/en/stable/guide/templates.html#internationalization" target="_blank" rel="noopener">Internationalization</a></p>
<h3 id="UI模块"><a href="#UI模块" class="headerlink" title="UI模块"></a>UI模块</h3><p>参见<a href="https://www.tornadoweb.org/en/stable/guide/templates.html#ui-modules" target="_blank" rel="noopener">UI modules</a></p>
<p>Read More:</p>
<blockquote>
<p><a href="https://www.tornadoweb.org/en/stable/guide/templates.html" target="_blank" rel="noopener">Templates and UI</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Tornado</category>
      </categories>
      <tags>
        <tag>Tornado</tag>
        <tag>翻译文档</tag>
      </tags>
  </entry>
  <entry>
    <title>Tornado5.0.2翻译文档 - 用户指南</title>
    <url>/2018/06/10/tornado502-userguide/</url>
    <content><![CDATA[<h3 id="用户指南"><a href="#用户指南" class="headerlink" title="用户指南"></a>用户指南</h3><ul>
<li><a href="https://runnerliu.github.io/2018/06/10/tornado502-introduction/">介绍</a></li>
<li><a href="https://runnerliu.github.io/2018/06/10/tornado502-asnon/#more">异步和非阻塞I/O</a><ul>
<li><a href="https://runnerliu.github.io/2018/06/10/tornado502-asnon/#more">阻塞</a></li>
<li><a href="https://runnerliu.github.io/2018/06/10/tornado502-asnon/#more">异步</a></li>
<li><a href="https://runnerliu.github.io/2018/06/10/tornado502-asnon/#more">例子</a></li>
</ul>
</li>
<li><a href="https://runnerliu.github.io/2018/06/18/tornado502-coroutines/#more">协程</a><ul>
<li><a href="https://runnerliu.github.io/2018/06/18/tornado502-coroutines/#more">Python3.5: async 和 await </a></li>
<li><a href="https://runnerliu.github.io/2018/06/18/tornado502-coroutines/#more">它如何工作</a></li>
<li><a href="https://runnerliu.github.io/2018/06/18/tornado502-coroutines/#more">如何调用协程</a></li>
<li><a href="https://runnerliu.github.io/2018/06/18/tornado502-coroutines/#more">协程模式</a><ul>
<li><a href>调用阻塞函数</a></li>
<li><a href>并行</a></li>
<li><a href>交叉存取</a></li>
<li><a href>循环</a></li>
<li><a href>在后台运行</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="https://runnerliu.github.io/2018/06/18/tornado502-concurrentwebspider/#more">Queue 示例-一个并发网络爬虫</a></li>
<li><a href="https://runnerliu.github.io/2020/12/19/tornado502-structureofweb/#more">Tornado Web应用的结构</a><ul>
<li><a href="https://runnerliu.github.io/2020/12/19/tornado502-structureofweb/#more">Application 对象</a></li>
<li><a href="https://runnerliu.github.io/2020/12/19/tornado502-structureofweb/#more">RequestHandler 子类</a></li>
<li><a href="https://runnerliu.github.io/2020/12/19/tornado502-structureofweb/#more">处理输入请求</a></li>
<li><a href="https://runnerliu.github.io/2020/12/19/tornado502-structureofweb/#more">重写 RequestHandler 方法</a></li>
<li><a href="https://runnerliu.github.io/2020/12/19/tornado502-structureofweb/#more">错误处理</a></li>
<li><a href="https://runnerliu.github.io/2020/12/19/tornado502-structureofweb/#more">重定向</a></li>
<li><a href="https://runnerliu.github.io/2020/12/19/tornado502-structureofweb/#more">异步处理</a></li>
</ul>
</li>
<li><a href="https://runnerliu.github.io/2020/12/19/tornado502-templateui/#more">模板和 UI</a><ul>
<li><a href="https://runnerliu.github.io/2020/12/19/tornado502-templateui/#more">配置模板</a></li>
<li><a href="https://runnerliu.github.io/2020/12/19/tornado502-templateui/#more">模板语法</a></li>
<li><a href="https://runnerliu.github.io/2020/12/19/tornado502-templateui/#more">国际化</a></li>
<li><a href="https://runnerliu.github.io/2020/12/19/tornado502-templateui/#more">UI 模块</a></li>
</ul>
</li>
<li><a href>认证和安全</a><ul>
<li><a href>Cookies 和 secure cookies</a></li>
<li><a href>用户认证</a></li>
<li><a href>第三方用户认证</a></li>
<li><a href>跨站请求伪造(防护)</a></li>
<li><a href>DNS 重绑定</a></li>
</ul>
</li>
<li><a href>运行和部署</a><ul>
<li><a href>进程和端口</a></li>
<li><a href>运行在负载均衡器后面</a></li>
<li><a href>静态文件和文件缓存</a></li>
<li><a href>Debug 模式和自动重载</a></li>
<li><a href>WSGI 和 Google App Engine</a></li>
</ul>
</li>
</ul>
<p>Read More:</p>
<blockquote>
<p><a href="http://www.tornadoweb.org/en/stable/guide.html" target="_blank" rel="noopener">User’s guide</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>Tornado</category>
      </categories>
      <tags>
        <tag>Tornado</tag>
        <tag>翻译文档</tag>
        <tag>用户指南</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows查看端口占用并关闭进程</title>
    <url>/2018/01/02/windowskillprocess/</url>
    <content><![CDATA[<p>开始–&gt;运行–&gt;cmd，进入命令提示符输入<code>netstat -ano</code> 即可看到所有连接的PID，然后在任务管理器中找到这个PID所对应的程序，如果任务管理器中没有PID这一项，可以在任务管理器中选”查看” -&gt; “选择列”。</p>
<p>经常，我们在启动应用的时候发现系统需要的端口被别的程序占用，如何知道谁占有了我们需要的端口，下面介绍一种非常简单的方法。</p>
<p>假设我们需要确定哪个进程占用了8083端口。</p>
<h4 id="查看所有端口的占用情况"><a href="#查看所有端口的占用情况" class="headerlink" title="查看所有端口的占用情况"></a>查看所有端口的占用情况</h4><p><code>netstat -ano</code>，结果如图</p>
<p><img src="/images/2017-12-19 161752.png" alt="2017-12-19 161752"></p>
<h4 id="查看指定端口的占用情况"><a href="#查看指定端口的占用情况" class="headerlink" title="查看指定端口的占用情况"></a>查看指定端口的占用情况</h4><p><code>netstat -aon | findstr &quot;9050&quot;</code>，结果如图</p>
<p><img src="/images/2017-12-19 162037.png" alt="2017-12-19 162037"></p>
<p>可以看到8083端口被进程号为2648的进程占用。</p>
<h4 id="查看PID对应的进程"><a href="#查看PID对应的进程" class="headerlink" title="查看PID对应的进程"></a>查看PID对应的进程</h4><p><code>tasklist | findstr &quot;2648&quot;</code>，结果如图</p>
<p><img src="/images/2017-12-19 162446.png" alt="2017-12-19 162446"></p>
<h4 id="杀死相应进程"><a href="#杀死相应进程" class="headerlink" title="杀死相应进程"></a>杀死相应进程</h4><p><code>tasklist|findstr &quot;2016&quot;</code>，结果如图</p>
<p><img src="/images/2017-12-19 162624.png" alt="2017-12-19 162624"></p>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>端口占用</tag>
      </tags>
  </entry>
  <entry>
    <title>Websocket与Socket的区别</title>
    <url>/2021/05/18/websocket-socket/</url>
    <content><![CDATA[<p>WebSocket protocol 是HTML5一种新的协议，同HTTP一样也是应用层的协议，是建立在TCP之上的，它实现了浏览器与服务器全双工通信。客户端与服务端的握手需要借助HTTP请求完成。</p>
<p>Socket其实并不是一个协议，而是为了方便使用TCP或UDP而抽象出来的一层，是位于应用层和传输控制层之间的一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul>
<li>Socket是传输控制层协议，WebSocket是应用层协议</li>
<li>Socket是一组接口，WebSocket是一个与HTTP属于同一层次的应用层协议，可与服务端进行全双工通信</li>
</ul>
<p>欢迎阅读 <a href="http://localhost:4000/2021/05/15/websocket-socketio/" target="_blank" rel="noopener">聊聊WebSocket与Socket.IO</a></p>
]]></content>
      <categories>
        <category>WebSocket</category>
      </categories>
      <tags>
        <tag>WebSocket</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql系列 - UNIQUE KEY与PRIMARY KEY</title>
    <url>/2017/07/15/uniqueprimarykey/</url>
    <content><![CDATA[<p>定义了 UNIQUE 约束的字段中不能包含重复值，可以为一个或多个字段定义 UNIQUE 约束。因此，UNIQUE 即可以在字段级也可以在表级定义， 在 UNIQUED 约束的字段上可以包含空值。UNIQUED 可空，可以在一个表里的一个或多个字段定义；</p>
<p>PRIMARY KEY 不可空不可重复，在一个表里可以定义联合主键；</p>
<p>一般来说，PRIMARY KEY = UNIQUE KEY +  NOT NULL</p>
<p>UNIQUE KEY 就是唯一，当你需要限定你的某个表字段每个值都唯一，没有重复值时使用。比如说，如果你有一个person 表，并且表中有个身份证的 column，那么你就可以指定该字段为UNIQUE KEY。 从技术的角度来看，PRIMARY KEY和UNIQUE KEY有很多相似之处。但还是有以下区别： </p>
<ul>
<li>作为 PRIMARY KEY 的域/域组不能为NULL，而 UNIQUE KEY 可以。 </li>
<li>在一个表中只能有一个PRIMARY KEY，而多个 UNIQUE KEY 可以同时存在。 </li>
</ul>
<p>更大的区别在逻辑设计上。PRIMARY KEY 一般在逻辑设计中用作记录标识，这也是设置 PRIMARY KEY 的本来用意，而UNIQUE KEY 只是为了保证域/域组的唯一性。 </p>
<p>PRIMARY KEY 的语法：alter table name add constraint key name primary key( columns); </p>
<p>UNIQUE KEY 的语法：alter table name add constraint key name unique( columns); </p>
<p>一个表只能有一个主键，但是可以有好多个UNIQUE KEY，而且 UNIQUE KEY 可以为 NULL 值，如员工的电话号码一般就用UNIQUE KEY，因为电话号码肯定是唯一的，但是有的员工可能没有电话。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>UNIQUE KEY</tag>
        <tag>PRIMARY KEY</tag>
      </tags>
  </entry>
  <entry>
    <title>Tornado5.0.2翻译文档 - Tornado</title>
    <url>/2018/06/03/tornado502_start/</url>
    <content><![CDATA[<p><a href="http://www.tornadoweb.org/" target="_blank" rel="noopener">Tornado</a> 是一个 Python 的 Web 框架和异步网络库，最初由 <a href="http://friendfeed.com/" target="_blank" rel="noopener">FriendFeed </a>开发。通过使用非阻塞网络I/O，Tornado 可以支持数以万计的连接，非常适合<a href="http://en.wikipedia.org/wiki/Push_technology#Long_polling" target="_blank" rel="noopener">长轮询</a>、<a href="http://en.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">WebSockets</a> 和其他需要与每个用户建立长连接的应用程序。</p>
<h3 id="快速链接"><a href="#快速链接" class="headerlink" title="快速链接"></a>快速链接</h3><ul>
<li>当前版本：5.0.2(<a href="https://pypi.python.org/pypi/tornado" target="_blank" rel="noopener">download from PyPi</a> <a href="http://www.tornadoweb.org/en/stable/releases.html" target="_blank" rel="noopener">release notes</a>)</li>
<li><a href="https://github.com/tornadoweb/tornado" target="_blank" rel="noopener">源代码</a></li>
<li>邮件列表：<a href="http://groups.google.com/group/python-tornado" target="_blank" rel="noopener">discussion</a> 和 <a href="http://groups.google.com/group/python-tornado-announce" target="_blank" rel="noopener">announcements</a></li>
<li><a href="http://stackoverflow.com/questions/tagged/tornado" target="_blank" rel="noopener">Stack Overflow</a></li>
<li><a href="https://github.com/tornadoweb/tornado/wiki/Links" target="_blank" rel="noopener">Wiki</a></li>
</ul>
<h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello, World"></a>Hello, World</h3><p>以下是利用 Tornado 实现的一个简单的 “Hello, World” 应用程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tornado.ioloop</span><br><span class="line">import tornado.web</span><br><span class="line"></span><br><span class="line">class MainHandler(tornado.web.RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        self.write(&quot;Hello, world&quot;)</span><br><span class="line"></span><br><span class="line">def make_app():</span><br><span class="line">    return tornado.web.Application([</span><br><span class="line">        (r&quot;/&quot;, MainHandler),</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app = make_app()</span><br><span class="line">    app.listen(8888)</span><br><span class="line">    tornado.ioloop.IOLoop.current().start()</span><br></pre></td></tr></table></figure>
<p>以上例子没有使用 Tornado 的任何异步特性，异步特性可以移步 <a href="https://github.com/tornadoweb/tornado/tree/stable/demos/chat" target="_blank" rel="noopener">simple char room</a>。</p>
<h3 id="线程和-WSGI"><a href="#线程和-WSGI" class="headerlink" title="线程和 WSGI"></a>线程和 WSGI</h3><p>Tornado 与其他大多 Python web 框架不同，它不基于 <a href="https://wsgi.readthedocs.io/en/latest/" target="_blank" rel="noopener">WSGI</a> 且每个进程只能运行一个 Tornado 线程，移步 <a href>用户手册</a> 了解更多 Tornado 的异步编程方式。</p>
<p>然而 WSGI 支持的一些方法可以在 <a href>tornado.wsgi</a> 模块中找到，但这并不是 Tornado 后续发展的重点，大多数 Tornado 应用应该直接使用其自带的接口（例如 <a href>tornado.web</a>）而不是 WSGI。</p>
<p>一般来说，Tornado 的应用代码并不是线程安全的，Tornado 中唯一可以安全地从其他线程调用的方法是 <a href>IOLoop.add_callback</a> 。你也可以使用 <a href>IOLoop.run_in_executor</a> 在另一个线程上异步运行阻塞函数，但请注意，传给 <a href>run_in_executor</a> 的函数不能引用任何 Tornado 对象。与阻塞函数进行交互时，推荐使用 <a href>run_in_executor</a> 。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install tornado</span><br></pre></td></tr></table></figure>
<p>Tornado 在 <a href="http://pypi.python.org/pypi/tornado" target="_blank" rel="noopener">PyPi</a> 可获取安装列表中，所以可以直接使用 <code>pip</code> 方式进行安装。请注意，源代码发行版包含演示应用程序，当以这种方式安装 Tornado 时，这些演示应用程序将不会存在，因此您可能希望下载源代码 tar 包或克隆 <a href="https://github.com/tornadoweb/tornado" target="_blank" rel="noopener">git repository</a>。</p>
<p><strong>安装条件</strong>：Tornado 运行在 Python 2.7 和 Python 3.4+上。 Python 2.7.9 中需要对 ssl 模块进行更新（在某些发行版中，这些更新可能在较早的 Python 版本中可用）。除了 <code>pip</code> 或 <code>setup.py</code> 自动安装的依赖外，以下可选软件包可能会有用：</p>
<ul>
<li><a href="http://pycurl.sourceforge.net/" target="_blank" rel="noopener">pycurl</a> 在 <a href>tornado.curl_httpclient</a> 中需要使用，需要 Libcurl 7.22或更高版本；</li>
<li><a href="http://www.twistedmatrix.com/" target="_blank" rel="noopener">Twisted</a> 在 <a href>tornado.platform.twisted</a> 的诸多类中会使用到；</li>
<li><a href="https://pypi.python.org/pypi/pycares" target="_blank" rel="noopener">pycares</a> 是一个可选的非阻塞 DNS 解析器，可以在线程不适用时使用；</li>
<li><a href="https://pypi.python.org/pypi/monotonic" target="_blank" rel="noopener">monotonic</a> 或 <a href="https://pypi.python.org/pypi/Monotime" target="_blank" rel="noopener">Monotime</a> 添加对单调时钟的支持，从而提高时钟频繁调整场景下的可靠性。 在Python 3中不再需要。</li>
</ul>
<p><strong>平台</strong>：尽管为了获得最佳性能和可扩展性，Tornado 应该可以在任何类Unix平台上运行，但对于生产部署，建议只使用Linux（with <code>epoll</code>）和 BSD（with <code>kqueue</code>）（尽管 Mac OS X 源自 BSD 并支持 kqueue，但其网络 性能一般很差，所以建议仅用于开发使用）。Tornado 也可以在 Windows 上运行，这种配置没有官方的支持，只推荐用于开发。 如果不修改 Tornado IOLoop 接口，就不可能添加本地 Tornado Windows IOLoop 实现，且不能利用像 AsyncIO 或 Twisted 等框架的 Windows 的 IOCP 支持。</p>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><ul>
<li><a href="https://runnerliu.github.io/2018/06/10/tornado502-userguide/#more">用户指南</a><ul>
<li><a href="https://runnerliu.github.io/2018/06/10/tornado502-introduction/">介绍</a></li>
<li><a href="https://runnerliu.github.io/2018/06/10/tornado502-asnon/#more">异步和非阻塞 I/O</a></li>
<li><a href="https://runnerliu.github.io/2018/06/18/tornado502-coroutines/#more">协程</a></li>
<li><a href="https://runnerliu.github.io/2018/06/18/tornado502-concurrentwebspider/#more">Queue 示例-一个并发网络爬虫</a></li>
<li><a href="https://runnerliu.github.io/2020/12/19/tornado502-structureofweb/#more">Tornado 的 web 应用程序结构</a></li>
<li><a href="https://runnerliu.github.io/2020/12/19/tornado502-templateui/#more">模板和UI</a></li>
<li><a href>认证和安全</a></li>
<li><a href>运行和部署</a></li>
</ul>
</li>
<li><a href>Web 框架</a><ul>
<li><a href>tornado.web - RequestHandler Application 类</a></li>
<li><a href>tornado.template - 灵活的输出生成</a></li>
<li><a href>tornado.routing - 基本的路由实现</a></li>
<li><a href>tornado.escape - 转义和字符串操作</a></li>
<li><a href>tornado.locale - 国际化支持</a></li>
<li><a href>tornado.websocket - 与浏览器的双向通信</a></li>
</ul>
</li>
<li><a href>HTTP 服务器和客户端</a><ul>
<li><a href>tornado.httpserver - 非阻塞 HTTP 服务器</a></li>
<li><a href>tornado.httpclient - 异步 HTTP 客户端</a></li>
<li><a href>tornado.httputil - 操作HTTP标头和URL</a></li>
<li><a href>tornado.httpconnection - HTTP/1.x客户端/服务器实现</a></li>
</ul>
</li>
<li><a href>异步网络</a><ul>
<li><a href>tornado.ioloop - 主时间循环</a></li>
<li><a href>tornado.iostream - 对非阻塞 socket 的简易包装</a></li>
<li><a href>tronado.netutil - 网络实用程序</a></li>
<li><a href>tornado.tcpclient - IOStream 连接工厂</a></li>
<li><a href>tornado.tcpserver - 基于 TCP 服务器的 IOStream</a></li>
</ul>
</li>
<li><a href>协程和并发</a><ul>
<li><a href>tornado.gen - 基于生成器的协程</a></li>
<li><a href>tornado.locks - 同步原语</a></li>
<li><a href>tornado.queues - 协程队列</a></li>
<li><a href>tornado.process - 多进程的实用程序</a></li>
</ul>
</li>
<li><a href>与其他服务集成</a><ul>
<li><a href>tornado.auth - 集成 OpenID 和 OAuth 的第三方登录服务</a></li>
<li><a href>tornado.wsgi - 与其他 Python 框架和服务器的互操作性</a></li>
<li><a href>tornado.platform.caresresolver - 使用 C-Ares 的异步DNS解析器</a></li>
<li><a href>tornado.platform.twisted - 兼容 Tornado 和 Twisted</a></li>
<li><a href>tornado.asyncio - 兼容 Tornado 和 asyncio</a></li>
</ul>
</li>
<li><a href>通用工具</a><ul>
<li><a href>tornado.authoreload - 开发环境中自动检测代码变化</a></li>
<li><a href>tornado.concrrent - 与 Future 对象交互</a></li>
<li><a href>tornado.log - 日志支持</a></li>
<li><a href>tornado.options - 命令行解析</a></li>
<li><a href>tornado.stack_context - 异步回调异常处理</a></li>
<li><a href>tornado.testing - 异步代码的单元测试</a></li>
<li><a href>tornado.util - 通用程序</a></li>
</ul>
</li>
</ul>
<h3 id="讨论和支持"><a href="#讨论和支持" class="headerlink" title="讨论和支持"></a>讨论和支持</h3><p>你可以在 <a href="http://groups.google.com/group/python-tornado" target="_blank" rel="noopener">the Tornado developer mailing list</a> 参与 Tornado 的讨论，在 <a href="https://github.com/tornadoweb/tornado/issues" target="_blank" rel="noopener">GitHub issue tracker</a> 上提交你的bug，更多资源可以在 <a href="https://github.com/tornadoweb/tornado/wiki/Links" target="_blank" rel="noopener">Tornado wiki</a> 找到，新版本发布在 <a href="http://groups.google.com/group/python-tornado-announce" target="_blank" rel="noopener">announcements mailing list</a>。</p>
<p>Read More:</p>
<blockquote>
<p><a href="http://www.tornadoweb.org/en/stable/index.html" target="_blank" rel="noopener">Tornado</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>Tornado</category>
      </categories>
      <tags>
        <tag>Tornado</tag>
        <tag>翻译文档</tag>
      </tags>
  </entry>
  <entry>
    <title>阻塞|非阻塞 - 异步|同步</title>
    <url>/2017/07/20/zsfzsybtb/</url>
    <content><![CDATA[<p>最近一直在看网络编程中同步异步、阻塞与非阻塞方面的东西，发现网上各种说法解释不一，而且有些解释不透彻，感觉解释人自己都没明白。于是在知乎上找到了能让人豁然开朗的答案，如下。</p>
<p><strong>阻塞</strong> 与 <strong>非阻塞</strong> 、<strong>同步</strong> 与 <strong>异步</strong>不能简单的从字面理解，提供一个从分布式系统角度的回答。</p>
<h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>同步和异步关注的是消息通信机制。</p>
<p>所谓同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由调用者主动等待这个调用的结果。而异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p>
<p>典型的异步编程模型比如 Node.js。举个通俗的例子：</p>
<p>你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</p>
<h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。</p>
<p>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<p>还是上面的例子，你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。</p>
<p>Read More:</p>
<blockquote>
<p><a href="https://www.zhihu.com/question/19732473/answer/20851256" target="_blank" rel="noopener">怎样理解阻塞非阻塞与同步异步的区别？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>阻塞</tag>
        <tag>非阻塞</tag>
        <tag>异步</tag>
        <tag>同步</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊WebSocket与Socket.IO</title>
    <url>/2021/05/15/websocket-socketio/</url>
    <content><![CDATA[<h4 id="什么是WebSocket"><a href="#什么是WebSocket" class="headerlink" title="什么是WebSocket"></a>什么是WebSocket</h4><p><a href="https://zh.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">WebSocket</a> 是与HTTP不同的一种网络传输协议，是HTML5新增加的一种通信协议，目前流行的浏览器都支持该协议，例如 Chrome，Safrie，Firefox，Opera，IE等等。WebSocket的产生背景主要是为了方便客户端与服务器之间的双向通信，是一种全双工的数据通信机制。</p>
<h4 id="早期客户端与服务端通信方式"><a href="#早期客户端与服务端通信方式" class="headerlink" title="早期客户端与服务端通信方式"></a>早期客户端与服务端通信方式</h4><h5 id="Polling（短轮询）"><a href="#Polling（短轮询）" class="headerlink" title="Polling（短轮询）"></a>Polling（短轮询）</h5><p><img src="/images/2021-5-15T171622.png" alt="2021-5-15T171622.png"></p>
<p>这种方式下，Client 每隔一段时间都会向 Server 发送 HTTP 请求，服务器收到请求后，将最新的数据发回给 Client。一开始必须通过提交表单的形式，这样的后果就是传输很多冗余的数据，浪费了带宽。后来 Ajax 出现，减少了传输数据量。</p>
<p>如图所示，在 Client 向 Server 发送一个请求活动结束后，Server 中的数据发生了改变，所以 Client 向 Server 发送的第二次请求中，Server 会将最新的数据返回给 Client。</p>
<p>但这种方式也存在弊端。比如在某个时间段 Server 没有更新数据，但 Client 仍然每隔一段时间发送请求来询问，所以这段时间内的询问都是无效的，这样浪费了网络带宽。将发送请求的间隔时间加大会缓解这种浪费，但如果 Server 更新数据很快时，这样又不能满足数据的实时性。</p>
<h5 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h5><p>鉴于（短）轮询的弊端，一种基于 HTTP 长连接的 “服务器推” 的技术产生了，这种技术被命名为 Comet。其与（短）轮询主要区别就是，在轮询方式下，要想取得数据，必须首先发送请求，在实时性要求较高的情况下，只能增加向 Server 请求的频率；而 Comet 则不同，Client 与 Server 端保持一个长连接，只有数据发生改变时，Server 才主动将数据推送给 Client。Comet 又可以被细分为两种实现方式，一种是长轮询机制，一种是流技术。</p>
<h6 id="Long-Polling（长轮询）"><a href="#Long-Polling（长轮询）" class="headerlink" title="Long-Polling（长轮询）"></a>Long-Polling（长轮询）</h6><p><img src="/images/2021-5-15T171920.png" alt="2021-5-15T171920.png"></p>
<p>Client 向 Server 发出请求，Server 接收到请求后，Server 并不一定立即发送回应给 Client，而是看数据是否更新，如果数据已经更新了的话，那就立即将数据返回给 Client；但如果数据没有更新，那就把这个请求保持住，等待有新的数据到来时，才将数据返回给 Client。</p>
<p>当然了，如果 Server 的数据长时间没有更新，一段时间后，请求便会超时，Client 收到超时信息后，再立即发送一个新的请求给 Server。</p>
<p>如图所示，在长轮询机制下，Client 向 Server 发送了请求后，Server会等数据更新完才会将数据返回，而不是像（短）轮询一样不管数据有没有更新然后立即返回。</p>
<p>这种方式也有弊端。当 Server 向 Client 发送数据后，必须等待下一次请求才能将新的数据发送出去，这样 Client 接收到新数据的间隔最短时间便是 2 * RTT（往返时间），这样便无法应对 server 端数据更新频率较快的情况。</p>
<h6 id="HTTP-Streaming"><a href="#HTTP-Streaming" class="headerlink" title="HTTP Streaming"></a>HTTP Streaming</h6><p><img src="/images/2021-5-15T172057.png" alt="2021-5-15T172057.png"></p>
<p>流技术基于 Iframe。Iframe 是 HTML 标记，这个标记的 src 属性会保持对指定 Server 的长连接请求，Server 就可以不断地向 Client 返回数据。</p>
<p>可以看出，流技术与长轮询的区别是长轮询本质上还是一种轮询方式，只不过连接的时间有所增加，想要向 Server 获取新的数据，Client 只能一遍遍的发送请求；而流技术是一直保持连接，不需要 Client 请求，当数据发生改变时，Server 自动的将数据发送给 Client。</p>
<p>如图所示，Client 与 Server 建立连接之后，便不会断开。当数据发生变化，Server 便将数据发送给 Client。</p>
<p>但这种方式有一个明显的不足之处，网页会一直显示未加载完成的状态，虽然我没有强迫症，但这点还是难以忍受。</p>
<h4 id="WebSocket-原理"><a href="#WebSocket-原理" class="headerlink" title="WebSocket 原理"></a>WebSocket 原理</h4><p>写到现在，大家会发现，前人推出那么多的解决方案，想要解决的唯一的问题便是怎么让 Server 将最新的数据以最快的速度发送给 Client。但 HTTP 是个懒惰的协议，Server 只有收到请求才会做出回应，否则什么事都不干。因此，为了彻底解决这个 Server 主动向 Client 发送数据的问题，WebSocket应运而生。<strong>WebSocket 是一个全新的、独立的协议，基于 TCP 协议，与 HTTP 协议兼容却不会融入 HTTP 协议，仅仅作为 HTML5 的一部分</strong>。</p>
<p><img src="/images/2021-5-15T172947.png" alt="2021-5-15T172947.png"></p>
<p>那 WebSocket 与 HTTP 什么关系呢？简单来说，WebSocket 是一种协议，是一种与 HTTP 同等的网络协议，两者都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 Server 与 Client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 Client 与 Server 之间的双向通信就与 HTTP 无关了。</p>
<p><img src="/images/2021-5-15T172730.png" alt="2021-5-15T172730.png"></p>
<p>相比于传统 HTTP 的每次“请求-应答”都要 Client 与 Server 建立连接的模式，WebSocket 是一种长连接的模式。一旦 WebSocket 连接建立后，除非 Client 或者 Server 中有一端主动断开连接，否则每次数据传输之前都不需要 HTTP 那样请求数据。从上面的图可以看出，Client 第一次需要与 Server 建立连接，当 Server 确认连接之后，两者便一直处于连接状态。直到一方断开连接，WebSocket 连接才断开。</p>
<h4 id="WebSocket的优势"><a href="#WebSocket的优势" class="headerlink" title="WebSocket的优势"></a>WebSocket的优势</h4><ul>
<li>较少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。</li>
<li>更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。</li>
<li>保持连接状态。与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。</li>
<li>更好的二进制支持。Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容。</li>
<li>可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等。</li>
<li>更好的压缩效果。相对于HTTP压缩，Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率。</li>
</ul>
<h4 id="什么是Socket-IO"><a href="#什么是Socket-IO" class="headerlink" title="什么是Socket.IO"></a>什么是Socket.IO</h4><p><a href="https://zh.wikipedia.org/wiki/Socket.IO" target="_blank" rel="noopener">Socket.IO</a> 是一个封装了 Websocket、基于 Node 的 JavaScript 框架，包含 Client 的 JavaScript 和 Server 的 Node。其屏蔽了所有底层细节，让顶层调用非常简单。其不仅支持 WebSocket，还支持许多种轮询机制以及其他实时通信方式，并封装了通用的接口。这些方式包含 Adobe Flash Socket、Ajax 长轮询、Ajax multipart streaming 、持久 Iframe、JSONP 轮询等。换句话说，当 Socket.IO 检测到当前环境不支持 WebSocket 时，能够自动地选择最佳的方式来实现网络的实时通信。</p>
<p>Read More:</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/23467317" target="_blank" rel="noopener">WebSocket 与 Socket.IO</a></p>
<p><a href="https://www.jianshu.com/p/144b997e57b4" target="_blank" rel="noopener">（一）websocket和socket.io介绍</a></p>
</blockquote>
]]></content>
      <categories>
        <category>WebSocket</category>
      </categories>
      <tags>
        <tag>WebSocket</tag>
        <tag>Socket.IO</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊WS和WSS</title>
    <url>/2021/02/18/wsandwss/</url>
    <content><![CDATA[<h3 id="初识WS-WSS"><a href="#初识WS-WSS" class="headerlink" title="初识WS/WSS"></a>初识WS/WSS</h3><p>WebSocket （WS）是HTML5一种新的协议，它实现了浏览器与服务器全双工通信，能更好地节省服务器资源和带宽并达到实时通讯。WebSocket建立在TCP之上，同HTTP一样通过TCP来传输数据，但是它和HTTP最大不同是：WebSocket是一种双向通信协议，在建立连接后，WebSocket服务器和Browser/Client Agent都能主动的向对方发送或接收数据，就像Socket一样；WebSocket需要类似TCP的客户端和服务器端通过握手连接，连接成功后才能相互通信。</p>
<p>WSS（Web Socket Secure）是WebSocket的加密版本。WS一般默认是80端口，而WSS默认是443端口，大多数网站用的就是80和433端口。（在高防防护过程中，80和433端口的网站是需要备案才可以接入国内的。）当然网站也会有别的端口，这种如果做高防是方案是可以用海外高防的。WS和WSS的体现形式分别是TCP+WS AS WS ，TCP+TLS+WS AS WS。服务器网址就是 URL。</p>
<h3 id="为何使用WS-WSS"><a href="#为何使用WS-WSS" class="headerlink" title="为何使用WS/WSS"></a>为何使用WS/WSS</h3><p>随着互联网的蓬勃发展，各种类型的Web应用层出不穷，很多应用要求服务端有能力进行实时推送能力（例如直播间聊天室），以往很多网站为了实现推送技术，所用的技术都是轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断地向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽资源。</p>
<p>在这种情况下，HTML5定义了WebSocket协议，能更好地节省服务器资源和带宽，并且能够更实时地进行通讯。WebSocket实现了浏览器与服务器全双工（full-duplex）通信，允许服务器主动发送信息给客户端。</p>
<p>WebSocket协议的交互过程如下图所示。</p>
<p><img src="/images/20210218T211759.png" alt="20210218T211759.png"></p>
<h3 id="WS特点"><a href="#WS特点" class="headerlink" title="WS特点"></a>WS特点</h3><ul>
<li>建立在 TCP 协议之上，服务端实现容易；</li>
<li>与 HTTP 协议有良好的兼容性，握手时不容易被屏蔽，可以通过各种 HTTP 代理服务器；</li>
<li>数据轻量，实时通讯；</li>
<li>可以发送文本和二进制数据；</li>
<li>不限制同源，客户端可以与任意服务器端进行通讯。因此WebSocket协议的出现，为很多人解决了关于扩展以及兼容性协议的烦恼问题。</li>
</ul>
<h3 id="与http-https关系"><a href="#与http-https关系" class="headerlink" title="与http/https关系"></a>与http/https关系</h3><p>按照标准来是有如下对应关系的：</p>
<ul>
<li><p>http -&gt; new WebSocket(‘ws://xxx’)</p>
</li>
<li><p>https -&gt; new WebSocket(‘wss://xxx’)</p>
</li>
</ul>
<p>在https下应该使用wss协议做安全链接，且wss下不支持ip地址的写法，写成域名形式。</p>
<p>Read More:</p>
<blockquote>
<p><a href="https://www.alibabacloud.com/help/zh/doc-detail/63421.htm" target="_blank" rel="noopener">WS/WSS协议支持FAQ</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/75328501" target="_blank" rel="noopener">浅谈WebSocket协议、WS协议和WSS协议原理及关系</a></p>
<p><a href="https://www.jianshu.com/p/72bcc74409ad" target="_blank" rel="noopener">http/https与websocket的ws/wss的关系</a></p>
</blockquote>
]]></content>
      <categories>
        <category>WebSocket</category>
      </categories>
      <tags>
        <tag>WebSocket</tag>
        <tag>WS</tag>
        <tag>WSS</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象类和接口的区别</title>
    <url>/2017/06/10/abstractinterface/</url>
    <content><![CDATA[<p>抽象类与接口相似，都是一种比较特殊的类。抽象类是一种特殊的类，而接口也是一种特殊的抽象类。它们通常配合面向对象的多态性一起使用。虽然声明和使用都比较容易，但它们的作用在理解上会困难一点。</p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>在OOP语言中，一个类可以有一个或多个子类，而每个类都有至少一个公有方法作为外部代码访问它的接口。而抽象方法就是为了方便继承而引入的。本节中先来介绍一下抽象类和抽象方法的声明，然后再说明其用途。在声明抽象类之前，我们先了解一下什么是抽象方法。抽象方法就是没有方法体的方法，所谓没有方法体是指在方法声明时没有花括号及其中的内容，而是在声明方法时直接在方法名后加上分号结束。另外在声明抽象方法时，还要使用关键字 <code>abstract</code> 来修饰。声明抽象方法的格式如下所示：</p>
<p><code>abstract function fun1();</code> //不能有花括号，就更不能有方法体中的内容了<br><code>abstract function fun2();</code> //直接在方法名的括号后面加上分号结束，还要使用 <code>abstract</code> 修饰</p>
<p>只要在声明类时有一个方法时抽象方法，那么这个类就是抽象类，抽象类也要使用 <code>abstract</code> 关键字来修饰。在抽象类中可以有不是抽象的成员方法和成员属性，但访问权限不能使用private关键字修饰为私有的。下面的例子在Person类中声明了两个抽象方法 <code>say()</code> 和 <code>eat()</code> ，则 <code>Person</code> 类就是一个抽象类，需要使用 <code>abstract</code> 标识。代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    abstract class Person&#123;</span><br><span class="line">        protected $name;</span><br><span class="line">        protected $country;</span><br><span class="line"> </span><br><span class="line">        function __construct($name=&quot;&quot;,$country=&quot;china&quot;)&#123;</span><br><span class="line">            $this -&gt;name = $name;</span><br><span class="line">            $this -&gt;country = $country;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        abstract function say();</span><br><span class="line">        abstract function eat();</span><br><span class="line"> </span><br><span class="line">        function run()&#123;</span><br><span class="line">            echo &quot;使用两条腿走路&lt;br&gt;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>在上例中声明了一个抽象类 <code>Person</code> ，在这个类中定义了两个成员属性、一个构造方法和两个抽象方法，还有一个是非抽象的方法。抽象类就像是一个“半成品”的类，在抽象类中有没有被实现的抽象方法，所以抽象类是不能被实例化的，即创建不了对象，也就不能直接使用它。既然抽象类是一个“半成品”的类，那么使用抽象类有什么作用呢？使用抽象类就包含了继承关系，它是为它的子类定义公共接口，将它的操作（可能是部分，也可能是全部）交给子类去实现。就是将抽象类作为子类重载的模板使用，定义抽象类就相当于定义了一种规范，这种规范要求子类去遵守。当子类继承抽象类以后，就必须把抽象类中的抽象方法按照子类自己的需要去实现。子类必须把父类中的抽象方法全部都实现，否则子类中还存在抽象方法，所以还是抽象类，也不能实例化对象。在下例中声明了两个类，分别实现上例中声明的抽象类 <code>Person</code> 。代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    class ChineseMan extends Person&#123;</span><br><span class="line"> </span><br><span class="line">        function say()&#123;</span><br><span class="line">            echo $this -&gt;name.&quot;是&quot;.$this-&gt;country.&quot;人，讲汉语&lt;br&gt;&quot;;    </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        function eat()&#123;</span><br><span class="line">            echo $this -&gt;name.&quot;使用筷子吃饭&lt;br&gt;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">        class Americans extends Person&#123;</span><br><span class="line"> </span><br><span class="line">        function say()&#123;</span><br><span class="line">            echo $this -&gt;name.&quot;是&quot;.$this-&gt;country.&quot;人，讲英语&lt;br&gt;&quot;;    </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        function eat()&#123;</span><br><span class="line">            echo $this -&gt;name.&quot;使用刀子和叉子吃饭&lt;br&gt;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    $chianeseMan = new ChineseMan(&quot;高洛峰&quot;，&quot;中国&quot;);</span><br><span class="line">    $americans = new Americans (&quot;alex&quot;,&quot;美国&quot;);</span><br><span class="line"> </span><br><span class="line">    $chineseMan -&gt;say();</span><br><span class="line">    $chineseMan -&gt;eat();</span><br><span class="line"> </span><br><span class="line">    $americans -&gt;say();</span><br><span class="line">    $americans -&gt;eat();</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>在上例中声明了两个类去继承抽象类 <code>Person</code> ，并将 <code>Person</code> 类中的抽象方法按各自的需求分别实现，这样两个子类就都可以创建对象了。抽象类 <code>Person</code> 就可以看成是一个模板，类中的抽象方法自己不去实现，只是规范了子类中必须要有父类中声明的抽象方法，而且要按照自己的特点实现抽象方法的内容。</p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>因为 <code>PHP</code> 只支持单继承，也就是说每个类只能继承一个父类。当声明的新类继承抽象类实现模板以后，它就不能再有其他父类了。为了解决这个问题， <code>PHP</code> 引入了接口。接口是一种特殊的抽象类，而抽象类又是一种特殊的类。如果抽象类中的所有方法都是抽象方法，我们就可以换另外一种声明方式，使用“接口”技术。接口中声明的方法必须都是抽象方法，另外不能再接口中声明变量，只能使用 <code>const</code> 关键字声明为常量的成员属性，而且接口中所有成员都必须有 <code>public</code> 的访问权限。类的声明是使用 <code>class</code> 关键字标识的，而接口的声明则是使用 <code>interface</code> 关键字标识的。声明接口的格式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">interface 接口名称&#123; //使用interface关键字声明接口</span><br><span class="line">常量成员 //接口中的成员属性只能是常量，不能是变量</span><br><span class="line">抽象方法 //接口中的所有方法必须是抽象方法，不能有非抽象的方法存在</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>接口中的所有方法都要求是抽象方法，所以就不需要在方法前使用 <code>abstract</code> 关键字标识了。而且在接口中也不需要显式地使用 <code>public</code> 访问权限进行修饰，因为默认权限就是 <code>public</code> 的，也只能是公有的。另外接口和抽象类一样也不能实例化对象，它是一种更严格的规范，也需要通过子类来实现。但可以直接使用接口名称在接口外面去获取常量成员的值。一个接口的声明例子，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">interface one&#123;</span><br><span class="line">const CONSTANT = &apos;CONSTANT value&apos;;</span><br><span class="line">function fun1();</span><br><span class="line">function fun2();</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>也可以使用 <code>extends</code> 关键字让一个接口去继承另一个接口，实现接口之间的扩展。在下面的例子中声明一个 <code>Two</code> 接口继承了上例中的 <code>One</code> 接口。代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">interface Two extends one&#123;</span><br><span class="line">function fun3();</span><br><span class="line">function fun4();</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>如果需要使用接口中的成员，则需要通过子类去实现接口中的全部抽象方法，然后创建子类的对象去调用在子类中实现后的方法。但通过类去继承接口时需要使用 <code>implements</code> 关键字来实现，而并不是使用 <code>extends</code> 关键字完成。如果需要使用抽象类去实现接口中的部分方法，也需要使用 <code>implements</code> 关键字实现。在下面的例子中声明一个抽象类 <code>Three</code> 去实现 <code>One</code> 接口中的部分方法，但要想实例化对象，这个抽象类还需要有子类把它所有的抽象方法都实现才行。声明一个 <code>Four</code> 类去实现 <code>One</code> 接口中全部方法。代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">interface one&#123;</span><br><span class="line">const CONSTANT = &apos;CONSTANT value&apos;;</span><br><span class="line">function fun1();</span><br><span class="line">function fun2();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//声明一个抽象类去实现接口One中的第二个方法</span><br><span class="line">abstract class Three implements One&#123; //只实现接口中的一个抽象方法</span><br><span class="line">function fun2()&#123;</span><br><span class="line">//具体的实现内容由子类自己决定</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//声明一个类实现接口One中的全部抽象方法</span><br><span class="line">class Four implements One&#123;</span><br><span class="line">function fun1()&#123;</span><br><span class="line">//具体的实现内容由子类自己决定</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">function fun2()&#123;</span><br><span class="line">//具体的实现内容由子类自己决定</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p><code>PHP</code> 是单继承的，一个类只能有一个父类，但是一个类可以实现多个接口。将要实现的多个接口之间使用逗号分隔开，而且在子类中药将所有接口中的抽象方法全部实现才可以创建对象。就相当于一个类要遵守多个规范，就像我们不仅要遵守国家的法律，如果是在学校，还需要遵守学校的校规一样。实现多个接口的格式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class 类名 implements 接口一，接口二，……接口n&#123;</span><br><span class="line">实现所有接口中的抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现多个接口是使用 <code>implements</code> 关键字，同时还可以使用 <code>extends</code> 关键字继承一个类。即在继承类的同时实现多个接口，但一定更要先使用extends继承一个类，再去使用 <code>inplements</code> 实现多个接口。使用格式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class 类名 extends 父类名 implements 接口一，接口二，……接口n&#123;</span><br><span class="line">实现所有接口中的抽象方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了上述的一些应用外，还有很多地方可以使用使用接口，例如对于一些已经开发好的系统，在结构上进行较大的调整已经不太现实，这时可以通过自定义一些接口并追加相应的实现来完成功能结构的扩展。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>对接口的使用方式是通过关键字 <code>implements</code> 来实现的，而对于抽象类的操作是使用类继承的关键字 <code>extends</code> 实现的，使用时要特别注意。</li>
<li>接口没有数据成员，但是抽象类有数据成员，抽象类可以实现数据的封装。</li>
<li>接口没有构造函数，抽象类可以有构造函数。</li>
<li>接口中的方法都是 <code>public</code> 类型，而抽象类中的方法可以使用 <code>private</code> 、 <code>protected</code> 或 <code>public</code> 来修饰。</li>
<li>一个类可以同时实现多个接口，但是只能实现一个抽象类。</li>
</ul>
<h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><ul>
<li>如果要创建一个模型，这个模型将由一些紧密相关的对象采用，就可以使用抽象类。如果要创建将由一些不相关对象采用的功能，就使用接口。</li>
<li>如果必须从多个来源继承行为，就使用接口。</li>
<li>如果知道所有类都会共享一个公共的行为实现，就使用抽象类，并在其中实现该行为。</li>
</ul>
<p>Read More:</p>
<blockquote>
<p><a href="http://www.cnblogs.com/ncong/p/3901173.html" target="_blank" rel="noopener">PHP的抽象类和接口</a>  <a href="http://blog.csdn.net/fanteathy/article/details/7309966" target="_blank" rel="noopener">PHP的抽象类、接口的区别和选择</a>  <a href="http://www.cnblogs.com/picaso/archive/2012/10/05/2711865.html" target="_blank" rel="noopener">PHP高级——抽象类与接口的区别</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>基本概念</category>
      </categories>
      <tags>
        <tag>抽象类</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title>Datatables使用系列-基础配置</title>
    <url>/2018/05/27/datatables1/</url>
    <content><![CDATA[<p><a href="https://datatables.net/" target="_blank" rel="noopener">Datatables</a> 为是 <a href="https://jquery.com/" target="_blank" rel="noopener">JQuery</a> 的一款表格插件库，是一个高度灵活的工具，可以将任何 HTML 表格添加高级的交互功能。特别是后台开发者，对前端相关框架或知识并不是很熟悉，在做一些内部使用的工具时，总会涉及到页面展示的功能，<a href="http://www.bootcss.com/p/buttons/" target="_blank" rel="noopener">Buttons</a> 同样是一个高度可定制的、免费并且开源的按钮 CSS 样式库。类似插件对于后台开发者来说，简直是福音。本文主要介绍 <a href="https://datatables.net/" target="_blank" rel="noopener">Datatables</a> 的基本配置和使用。</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>从 <a href="https://datatables.net/download/" target="_blank" rel="noopener">Download</a> 页面可下载需要使用的 JS 文件和其他的插件，可以根据需求选择不同的样式、包文件和扩展文件，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Step 1. Choose a styling framework</span><br><span class="line">    Bootstrap 4</span><br><span class="line">Step 2. Select packages</span><br><span class="line">    jQuery 3</span><br><span class="line">    Bootstrap 4</span><br><span class="line">    DataTables</span><br><span class="line">Extensions</span><br><span class="line">    可选</span><br><span class="line">Step 3. Pick a download method</span><br><span class="line">    Minify</span><br><span class="line">    Concatenate</span><br><span class="line">    下载方式常用是CDN和本地文件方式（推荐）</span><br></pre></td></tr></table></figure>
<p>然后我们下载打包好的文件到本地就可以了。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>将文件打包下载后，因为一般页面都是在 web 应用中使用，所以笔者创建了一个简单的 <a href="http://www.tornadoweb.org/en/stable/" target="_blank" rel="noopener">Tornado</a> 应用，将所有的静态文件放到了 <code>/static</code> 目录下：</p>
<p> <img src="/images/2018-05-27T222132.png" alt="2018-05-27T222132"></p>
<p><strong>注意：</strong> <code>jquery.js</code> 文件是必需的，目前使用 <code>3.0</code> 版本。</p>
<p>然后我们可以创建一个简单的 HTML 静态页面，引入基本的 <code>js</code>  文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Datatables&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;static/js/Bootstrap-4-4.0.0/css/bootstrap.css&quot;/&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;static/js/DataTables-1.10.16/css/dataTables.bootstrap4.css&quot;/&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;static/css/datatables.min.css&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=&quot;static/js/jquery.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;static/js/Bootstrap-4-4.0.0/js/bootstrap.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;static/js/DataTables-1.10.16/js/jquery.dataTables.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;static/js/DataTables-1.10.16/js/dataTables.bootstrap4.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 如果在调试过程中，出现表格显示错误，请检查 <code>css</code> 文件和 <code>js</code>  文件的引用顺序。</p>
<p>接下来创建一个 <code>div</code> 作为表格区域：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;table id=&quot;test_dt&quot; class=&quot;table table-striped table-bordered&quot; cellspacing=&quot;0&quot; style=&quot;width: 100%&quot;&gt;</span><br><span class="line">        &lt;thead&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;id&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;username&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;sex&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;address&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;age&lt;/th&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;/thead&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p><code>table</code> 中的 <code>class</code> 属性都是在 <code>css</code> 文件中定义好的，直接引用即可。</p>
<p>然后就是通过 <code>js</code> 为 <code>test_dt</code> 表格填充数据，数据源一般 <a href="https://datatables.net/examples/data_sources/" target="_blank" rel="noopener">Data sources</a> 这些，我们在 <code>web</code> 应用中使用最多的就是 <a href="https://datatables.net/examples/ajax/" target="_blank" rel="noopener">Ajax</a> 方式了，可以局部刷新页面。</p>
<p>本文数据源方式使用 <a href="https://datatables.net/examples/ajax/objects.html" target="_blank" rel="noopener">Ajax data source (objects)</a> 这种方式，<code>js</code> 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function init_table()&#123;</span><br><span class="line">    $(&apos;#test_dt&apos;).DataTable(&#123;</span><br><span class="line">        order: [[ 0, &quot;desc&quot;]],</span><br><span class="line">        searching: true,</span><br><span class="line">        stateSave: true,</span><br><span class="line">        paging: true,</span><br><span class="line">        pagingType: &apos;full_numbers&apos;,</span><br><span class="line">        autoWidth: true,</span><br><span class="line">        responsive: false,</span><br><span class="line">        pageLength: 10,</span><br><span class="line">        destroy: true,</span><br><span class="line">        ajax: &#123;</span><br><span class="line">            &apos;url&apos;: &apos;/index&apos;,</span><br><span class="line">            &apos;dataSrc&apos;: handle_data_src,</span><br><span class="line">            &apos;type&apos;: &apos;POST&apos;,</span><br><span class="line">            &apos;async&apos;: false,</span><br><span class="line">            &apos;data&apos;: &#123;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        columns:[</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;data&quot;:&quot;id&quot;,</span><br><span class="line">                &quot;width&quot;: &quot;10%&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;data&quot;:&quot;username&quot;,</span><br><span class="line">                &quot;width&quot;: &quot;10%&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;data&quot;:&quot;sex&quot;,</span><br><span class="line">                &quot;width&quot;: &quot;10%&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;data&quot;:&quot;address&quot;,</span><br><span class="line">                &quot;width&quot;: &quot;10%&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;data&quot;:&quot;age&quot;,</span><br><span class="line">                &quot;width&quot;: &quot;10%&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>POST</code> 方式获取表格数据，方便表格的刷新操作。其中 <code>dataSrc</code> 参数可以对请求的数据在显示到表格前做其他处理。</p>
<p>效果图基本如下：</p>
<p><img src="/images/2018-05-27T223227.png" alt="2018-05-27T223227"></p>
<h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><p>Datatables 支持参数配置方式以提供各种场景下对表格的需求，目前笔者主要使用的参数如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
<th>可选值</th>
</tr>
</thead>
<tbody>
<tr>
<td>order</td>
<td>表格在初始化的时候的排序</td>
<td><a href="https://datatables.net/reference/option/order" target="_blank" rel="noopener">order</a></td>
</tr>
<tr>
<td>searching</td>
<td>允许表格搜索</td>
<td>true false</td>
</tr>
<tr>
<td>stateSave</td>
<td>允许浏览器缓存 Datatables，以便下次恢复之前的状态</td>
<td>true false</td>
</tr>
<tr>
<td>paging</td>
<td>允许表格分页</td>
<td>true false</td>
</tr>
<tr>
<td>pagingType</td>
<td>分页按钮显示选项</td>
<td><a href="http://www.datatables.club/reference/option/pagingType.html" target="_blank" rel="noopener">pagingType</a></td>
</tr>
<tr>
<td>autoWidth</td>
<td>定义是否由控件自动控制列宽</td>
<td>true false</td>
</tr>
<tr>
<td>pageLength</td>
<td>单页显示的数据条数</td>
<td>integer</td>
</tr>
<tr>
<td>destroy</td>
<td>销毁已经存在的 Datatables 实例并替换新的选项</td>
<td>true false</td>
</tr>
<tr>
<td>ajax</td>
<td>异步获取数据填充到表格显示</td>
<td><a href="http://www.datatables.club/reference/option/ajax.html" target="_blank" rel="noopener">ajax</a></td>
</tr>
<tr>
<td>columns</td>
<td>设定列的所有初始属性</td>
<td><a href="http://www.datatables.club/reference/option/columns.html" target="_blank" rel="noopener">columns</a></td>
</tr>
<tr>
<td>info</td>
<td>控制总数信息（标准界面右下角显示总数和过滤条数的控件）的显隐</td>
<td>true false</td>
</tr>
</tbody>
</table>
<p>其他参数设置可参考 <a href="https://datatables.net/manual/options" target="_blank" rel="noopener">Options</a> 。</p>
<h3 id="Tips-持续更新"><a href="#Tips-持续更新" class="headerlink" title="Tips[持续更新]"></a>Tips[持续更新]</h3><p><strong>ajax.reload()</strong></p>
<p>场景：间隔一定时间进行局部刷新。</p>
<p>该场景下如果每次都初始化 datatables ，则会使表格在刷新时失去鼠标控制，用户体验较差。使用 <code>ajax.reload(callback, resetPaging)</code> 方式可以在重复初始化 <code>datatables</code> 下重新加载数据，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&apos;#test_dt&apos;).DataTable().ajax.reload(null, false);</span><br></pre></td></tr></table></figure>
<p>当使用该方式时，如果 <code>ajax</code> 提交的请求 <code>data</code> 字段带的参数值需要动态更新的话，可以使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;data&apos;: function(d)&#123;</span><br><span class="line">    d.test_name = test_name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>js</code> 函数动态更新参数值，这样在 <code>reload</code> 表格时，提交的参数就是动态获取的了。</p>
<p><strong>render</strong></p>
<p>场景：获取数据后，需要根据某列值对数据进行预处理。</p>
<p>我们可以在 <code>dataSrc</code> 中对数据进行处理，但是 <code>Datatables</code> 提供了另外一种更加方便的处理方式，即 <a href="https://datatables.net/reference/option/columns.render" target="_blank" rel="noopener">columns.render</a> 方法，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;:&quot;address&quot;,</span><br><span class="line">    render: function (data, type, row, meta) &#123;</span><br><span class="line">        var node = &quot;&lt;span &quot;;</span><br><span class="line">        if (data &lt;= bw_warn) &#123;</span><br><span class="line">            node += &quot;style=&apos;color:red;font-weight: bold;&apos;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        node += &quot;&gt;&quot; + data + &quot;&lt;/span&gt;&quot;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;width&quot;: &quot;10%&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>可以根据列值，对该列的显示添加其他的 <code>css</code> 属性。</p>
<p><strong>自定义排序</strong></p>
<p>Datatables 可以根据指定的列进行排序，但是实际场景中某列值可能较为复杂，而我们只需使用其中的一部分进行排序，例如：去掉前缀。Datatables 的扩展插件提供了很多较为强大的<a href="https://datatables.net/plug-ins/sorting/" target="_blank" rel="noopener">自定义排序功能</a>。</p>
<p>例如：去掉前缀字符 <code>prefix</code> ，将剩下字符作为整型排序，可以参考 <a href="https://datatables.net/plug-ins/sorting/anti-the" target="_blank" rel="noopener">Anti-the</a>。</p>
<p>首先新建一个名为 jquery.datatable.sort.plugin.js 文件，将以下 copy 到文件中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jQuery.extend( jQuery.fn.dataTableExt.oSort, &#123;</span><br><span class="line">    &quot;anti-prefix-pre&quot;: function ( a ) &#123;</span><br><span class="line">        var x = a.replace(/^prefix /i, &quot;&quot;);</span><br><span class="line">        return parseInt(x);</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    &quot;anti-prefix-asc&quot;: function ( a, b ) &#123;</span><br><span class="line">        return ((a &lt; b) ? -1 : ((a &gt; b) ? 1 : 0));</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    &quot;anti-prefix-desc&quot;: function ( a, b ) &#123;</span><br><span class="line">        return ((a &lt; b) ? 1 : ((a &gt; b) ? -1 : 0));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>然后在页面中按照如下方式引用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/path/jquery.datatable.sort.plugin.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>最后在 Datatables 中加入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">columnDefs: [</span><br><span class="line">    &#123; type: &apos;anti-prefix&apos;, targets: 0 &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>其中：targets 表示列编号，从0开始。</p>
<p>Example：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&apos;#example&apos;).dataTable( &#123;</span><br><span class="line">    columnDefs: [</span><br><span class="line">        &#123; type: &apos;anti-the&apos;, targets: 0 &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure>
<p>Read More:</p>
<blockquote>
<p><a href="https://datatables.net/" target="_blank" rel="noopener">Datatables</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>datatables</tag>
        <tag>jquery</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>GO系列 - 垃圾回收机制</title>
    <url>/2021/02/19/gogc/</url>
    <content><![CDATA[<p>在此之前，我们介绍过 <a href="https://runnerliu.github.io/2017/07/16/pythongc/">浅析Python的垃圾回收机制</a> 和 <a href="https://runnerliu.github.io/2017/04/15/phpnewgc/">PHP新的垃圾回收机制</a> ，有兴趣的话可以参考阅读，今天我们来聊聊golang是如何进行垃圾回收的。我们知道，目前各语言进行垃圾回收的方法有很多，如引用计数、标记清除、分代回收、三色标记等，各种方式都有其特点，GO语言在发展过程中， 其GC算法也是不断改进的。</p>
<h3 id="GO的GC里程碑"><a href="#GO的GC里程碑" class="headerlink" title="GO的GC里程碑"></a>GO的GC里程碑</h3><h4 id="v1-3以前：STW"><a href="#v1-3以前：STW" class="headerlink" title="v1.3以前：STW"></a>v1.3以前：STW</h4><p>golang的垃圾回收算法都非常简陋，其性能也广被诟病：go runtime在一定条件下（内存超过阈值或定期如2min），暂停所有任务的执行，进行mark&amp;sweep操作，操作完成后启动所有任务的执行。在内存使用较多的场景下，go程序在进行垃圾回收时会发生非常明显的卡顿现象（Stop The World）。在对响应速度要求较高的后台服务进程中，这种延迟简直是不能忍受的！这个时期国内外很多在生产环境实践go语言的团队都或多或少踩过gc的坑。当时解决这个问题比较常用的方法是尽快控制自动分配内存的内存数量以减少gc负荷，同时采用手动管理内存的方法处理需要大量及高频分配内存的场景。</p>
<h4 id="v1-3：Mark-STW-amp-Sweep"><a href="#v1-3：Mark-STW-amp-Sweep" class="headerlink" title="v1.3：Mark STW &amp; Sweep"></a>v1.3：Mark STW &amp; Sweep</h4><p>1.3版本中，go runtime分离了mark和sweep操作，和以前一样，也是先暂停所有任务执行并启动mark，mark完成后马上就重新启动被暂停的任务了，而是让sweep任务和普通协程任务一样并行的和其他任务一起执行。如果运行在多核处理器上，go会试图将gc任务放到单独的核心上运行而尽量不影响业务代码的执行。go team自己的说法是减少了50%-70%的暂停时间。</p>
<h4 id="v1-5：三色标记"><a href="#v1-5：三色标记" class="headerlink" title="v1.5：三色标记"></a>v1.5：三色标记</h4><p>go 1.5正在实现的垃圾回收器“非分代的、非移动的、并发的、三色的标记清除垃圾收集器”。这种方法的mark操作是可以渐进执行的而不需每次都扫描整个内存空间，可以减少stop the world的时间。 由此可以看到，一路走来直到1.5版本，go的垃圾回收性能也是一直在提升。</p>
<h4 id="v1-8：混合写屏障（hybrid-write-barrier）"><a href="#v1-8：混合写屏障（hybrid-write-barrier）" class="headerlink" title="v1.8：混合写屏障（hybrid write barrier）"></a>v1.8：混合写屏障（hybrid write barrier）</h4><p>由于标记操作和用户逻辑是并发执行的，用户逻辑会时常生成对象或者改变对象的引用。例如把⼀个对象标记为白色准备回收时，用户逻辑突然引用了它，或者又创建了新的对象。由于对象初始时都看为白色，会被 GC 回收掉，为了解决这个问题，引入了写屏障机制。</p>
<p>GC 对扫描过后的对象使⽤操作系统写屏障功能来监控这段内存。如果这段内存发⽣引⽤改变，写屏障会给垃圾回收期发送⼀个信号，垃圾回收器捕获到信号后就知道这个对象发⽣改变，然后重新扫描这个对象，看看它的引⽤或者被引⽤是否改变。利⽤状态的重置实现当对象状态发⽣改变的时候，依然可以再次其引用的对象。</p>
<h3 id="GO的GC"><a href="#GO的GC" class="headerlink" title="GO的GC"></a>GO的GC</h3><h4 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h4><p>传统的标记清除算法中，垃圾收集器从垃圾收集的根对象出发，递归遍历这些对象指向的子对象并将所有可达的对象标记成存活；标记阶段结束后，垃圾收集器会依次遍历堆中的对象并清除其中的垃圾，整个过程需要标记对象的存活状态，用户程序在垃圾收集的过程中也不能执行，我们需要用到更复杂的机制来解决 STW 的问题，这就出现了三色标记法。</p>
<p>三色标记算法将程序中的对象分成白色、黑色和灰色三类：</p>
<ul>
<li>白色对象：潜在的垃圾，其内存可能会被垃圾收集器回收；</li>
<li>黑色对象：活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象；</li>
<li>灰色对象：活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；</li>
</ul>
<p><img src="/images/2021-2-19T154834.png" alt="2021-2-19T154834.png"></p>
<p>在垃圾收集器开始工作时，程序中不存在任何的黑色对象，垃圾收集的根对象会被标记成灰色，垃圾收集器只会从灰色对象集合中取出对象开始扫描，当灰色集合中不存在任何对象时，标记阶段就会结束。</p>
<p><img src="/images/2021-2-19T154948.png" alt="2021-2-19T154948.png"></p>
<p>三色标记垃圾收集器的工作原理很简单，我们可以将其归纳成以下几个步骤：</p>
<ul>
<li>从灰色对象的集合中选择一个灰色对象并将其标记成黑色；</li>
<li>将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收；</li>
<li>重复上述两个步骤直到对象图中不存在灰色对象。</li>
</ul>
<p>当三色的标记清除的标记阶段结束之后，应用程序的堆中就不存在任何的灰色对象，我们只能看到黑色的存活对象以及白色的垃圾对象，垃圾收集器可以回收这些白色的垃圾，下面是使用三色标记垃圾收集器执行标记后的堆内存，堆中只有对象 D 为待回收的垃圾：</p>
<p><img src="/images/2021-2-19T155305.png" alt="2021-2-19T155305.png"></p>
<p>因为用户程序可能在标记执行的过程中修改对象的指针，所以三色标记清除算法本身是不可以并发或者增量执行的，它仍然需要 STW，在如下所示的三色标记过程中，用户程序建立了从 A 对象到 D 对象的引用，但是因为程序中已经不存在灰色对象了，所以 D 对象会被垃圾收集器错误地回收。</p>
<p><img src="/images/2021-2-19T155403.png" alt="2021-2-19T155403.png"></p>
<p>本来不应该被回收的对象却被回收了，这在内存管理中是非常严重的错误，我们将这种错误称为悬挂指针，即指针没有指向特定类型的合法对象，影响了内存的安全性，想要并发或者增量地标记对象还是需要使用屏障技术。</p>
<p>整个流程如下：</p>
<p><img src="/images/2021-2-19T155548.gif" alt="2021-2-19T155548.gif"></p>
<h4 id="混合写屏障"><a href="#混合写屏障" class="headerlink" title="混合写屏障"></a>混合写屏障</h4><p>想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性（Tri-color invariant）中的一种：</p>
<ul>
<li>强三色不变性：黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；</li>
<li>弱三色不变性：黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径。</li>
</ul>
<p><img src="/images/2021-2-19T160000.png" alt="2021-2-19T160000.png"></p>
<p>上图分别展示了遵循强三色不变性和弱三色不变性的堆内存，遵循上述两个不变性中的任意一个，我们都能保证垃圾收集算法的正确性，而屏障技术就是在并发或者增量标记过程中保证三色不变性的重要技术。</p>
<p>垃圾收集中的屏障技术更像是一个钩子方法，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，根据操作类型的不同，我们可以将它们分成读屏障（Read barrier）和写屏障（Write barrier）两种，因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以编程语言往往都会采用写屏障保证三色不变性。</p>
<p>Go 语言在 v1.8 组合 Dijkstra 插入写屏障和 Yuasa 删除写屏障构成混合写屏障，该写屏障会<strong>将被覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记成灰色</strong>。</p>
<p>为了移除栈的重扫描过程，除了引入混合写屏障之外，在垃圾收集的标记阶段，我们还需要<strong>将创建的所有新对象都标记成黑色</strong>，防止新分配的栈内存和堆内存中的对象被错误地回收，因为栈内存在标记阶段最终都会变为黑色，所以不再需要重新扫描栈空间。</p>
<h4 id="增量和并发"><a href="#增量和并发" class="headerlink" title="增量和并发"></a>增量和并发</h4><p>传统的垃圾收集算法会在垃圾收集的执行期间暂停应用程序，一旦触发垃圾收集，垃圾收集器会抢占 CPU 的使用权占据大量的计算资源以完成标记和清除工作，然而很多追求实时的应用程序无法接受长时间的 STW。</p>
<p>为了减少应用程序暂停的最长时间和垃圾收集的总暂停时间，我们会使用下面的策略优化现代的垃圾收集器：</p>
<ul>
<li>增量垃圾收集：增量地标记和清除垃圾，降低应用程序暂停的最长时间；</li>
<li>并发垃圾收集：利用多核的计算资源，在用户程序执行时并发标记和清除垃圾；</li>
</ul>
<p>因为增量和并发两种方式都可以与用户程序交替运行，所以我们需要使用屏障技术保证垃圾收集的正确性；与此同时，应用程序也不能等到内存溢出时触发垃圾收集，因为当内存不足时，应用程序已经无法分配内存，这与直接暂停程序没有什么区别，增量和并发的垃圾收集需要提前触发并在内存不足前完成整个循环，避免程序的长时间暂停。</p>
<h5 id="增量收集"><a href="#增量收集" class="headerlink" title="增量收集"></a>增量收集</h5><p>增量式（Incremental）的垃圾收集是减少程序最长暂停时间的一种方案，它可以将原本时间较长的暂停时间切分成多个更小的 GC 时间片，虽然从垃圾收集开始到结束的时间更长了，但是这也减少了应用程序暂停的最大时间：</p>
<p><img src="/images/2021-2-19T160403.png" alt="2021-2-19T160403.png"></p>
<p>需要注意的是，增量式的垃圾收集需要与三色标记法一起使用，为了保证垃圾收集的正确性，我们需要在垃圾收集开始前打开写屏障，这样用户程序修改内存都会先经过写屏障的处理，保证了堆内存中对象关系的强三色不变性或者弱三色不变性。虽然增量式的垃圾收集能够减少最大的程序暂停时间，但是增量式收集也会增加一次 GC 循环的总时间，在垃圾收集期间，因为写屏障的影响用户程序也需要承担额外的计算开销，所以增量式的垃圾收集也不是只带来好处的，但是总体来说还是利大于弊。</p>
<h5 id="并发收集"><a href="#并发收集" class="headerlink" title="并发收集"></a>并发收集</h5><p>并发（Concurrent）的垃圾收集不仅能够减少程序的最长暂停时间，还能减少整个垃圾收集阶段的时间，通过开启读写屏障、利用多核优势与用户程序并行执行，并发垃圾收集器确实能够减少垃圾收集对应用程序的影响：</p>
<p><img src="/images/2021-2-19T160457.png" alt="2021-2-19T160457.png"></p>
<p>虽然并发收集器能够与用户程序一起运行，但是并不是所有阶段都可以与用户程序一起运行，部分阶段还是需要暂停用户程序的，不过与传统的算法相比，并发的垃圾收集可以将能够并发执行的工作尽量并发执行；当然，因为读写屏障的引入，并发的垃圾收集器也一定会带来额外开销，不仅会增加垃圾收集的总时间，还会影响用户程序，这是我们在设计垃圾收集策略时必须要注意的。</p>
<h3 id="GC的时机"><a href="#GC的时机" class="headerlink" title="GC的时机"></a>GC的时机</h3><p>运行时会通过如下所示的 <a href="https://draveness.me/golang/tree/runtime.gcTrigger.test" target="_blank" rel="noopener"><code>runtime.gcTrigger.test</code></a> 方法决定是否需要触发垃圾收集，当满足触发垃圾收集的基本条件时 — 允许垃圾收集、程序没有崩溃并且没有处于垃圾收集循环，该方法会根据三种不同方式触发进行不同的检查：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func (t gcTrigger) test() bool &#123;</span><br><span class="line">	if !memstats.enablegc || panicking != 0 || gcphase != _GCoff &#123;</span><br><span class="line">		return false</span><br><span class="line">	&#125;</span><br><span class="line">	switch t.kind &#123;</span><br><span class="line">	case gcTriggerHeap:</span><br><span class="line">		return memstats.heap_live &gt;= memstats.gc_trigger</span><br><span class="line">	case gcTriggerTime:</span><br><span class="line">		if gcpercent &lt; 0 &#123;</span><br><span class="line">			return false</span><br><span class="line">		&#125;</span><br><span class="line">		lastgc := int64(atomic.Load64(&amp;memstats.last_gc_nanotime))</span><br><span class="line">		return lastgc != 0 &amp;&amp; t.now-lastgc &gt; forcegcperiod</span><br><span class="line">	case gcTriggerCycle:</span><br><span class="line">		return int32(t.n-work.cycles) &gt; 0</span><br><span class="line">	&#125;</span><br><span class="line">	return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>gcTriggerHeap</code> ：堆内存的分配达到达控制器计算的触发堆大小；</li>
<li><code>gcTriggerTime</code> ：如果一定时间内没有触发，就会触发新的循环，该出发条件由 <a href="https://draveness.me/golang/tree/runtime.forcegcperiod" target="_blank" rel="noopener"><code>runtime.forcegcperiod</code></a> 变量控制，默认为 2 分钟；</li>
<li><code>gcTriggerCycle</code>：如果当前没有开启垃圾收集，则触发新的循环；</li>
<li><a href="https://draveness.me/golang/tree/runtime.gcpercent" target="_blank" rel="noopener"><code>runtime.gcpercent</code></a> 是触发垃圾收集的内存增长百分比，默认情况下为 100，即堆内存相比上次垃圾收集增长 100% 时应该触发 GC，并行的垃圾收集器会在到达该目标前完成垃圾收集。</li>
</ol>
<p>用于开启垃圾收集的方法 <a href="https://draveness.me/golang/tree/runtime.gcStart" target="_blank" rel="noopener"><code>runtime.gcStart</code></a> 会接收一个 <a href="https://draveness.me/golang/tree/runtime.gcTrigger" target="_blank" rel="noopener"><code>runtime.gcTrigger</code></a> 类型的结构，所有出现 <a href="https://draveness.me/golang/tree/runtime.gcTrigger" target="_blank" rel="noopener"><code>runtime.gcTrigger</code></a> 结构体的位置都是触发垃圾收集的代码：</p>
<ul>
<li><a href="https://draveness.me/golang/tree/runtime.sysmon" target="_blank" rel="noopener"><code>runtime.sysmon</code></a> 和 <a href="https://draveness.me/golang/tree/runtime.forcegchelper" target="_blank" rel="noopener"><code>runtime.forcegchelper</code></a> ：后台运行定时检查和垃圾收集；</li>
<li><a href="https://draveness.me/golang/tree/runtime.GC" target="_blank" rel="noopener"><code>runtime.GC</code></a> ：用户程序手动触发垃圾收集；</li>
<li><a href="https://draveness.me/golang/tree/runtime.mallocgc" target="_blank" rel="noopener"><code>runtime.mallocgc</code></a> ：申请内存时根据堆大小触发垃圾收集。</li>
</ul>
<p><img src="/images/2021-2-19T162340.png" alt="2021-2-19T162340.png"></p>
<p>Read More:</p>
<blockquote>
<p><a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/" target="_blank" rel="noopener">垃圾收集器</a></p>
<p><a href="https://segmentfault.com/a/1190000018161588" target="_blank" rel="noopener">GO GC 垃圾回收机制</a></p>
<p><a href="https://juejin.cn/post/6844903917650722829" target="_blank" rel="noopener">搞懂Go垃圾回收</a></p>
<p><a href="https://wingsxdu.com/post/golang/gc/" target="_blank" rel="noopener">Go 语言 GC 机制 · Analyze</a></p>
</blockquote>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>垃圾回收</tag>
        <tag>GC</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTPS的加密原理</title>
    <url>/2021/07/04/https/</url>
    <content><![CDATA[<h3 id="为什么需要加密？"><a href="#为什么需要加密？" class="headerlink" title="为什么需要加密？"></a>为什么需要加密？</h3><p>因为HTTP的内容是明文传输的，明文数据会经过中间代理服务器、路由器、WIFI热点、通信服务运营商等多个物理节点，如果信息在传输过程中被劫持，传输的内容就完全暴露了。劫持者还可以篡改传输的信息且不被双方察觉，这就是<code>中间人攻击</code>。所以我们才需要对信息进行加密。最容易理解的就是<code>对称加密</code> 。</p>
<h3 id="什么是对称加密？"><a href="#什么是对称加密？" class="headerlink" title="什么是对称加密？"></a>什么是对称加密？</h3><p>简单说就是有一个密钥，它可以加密一段信息，也可以对加密后的信息进行解密，和我们日常生活中用的钥匙作用差不多。</p>
<p><img src="/images/2021-7-4182803.png" alt="2021-7-4182803.png"></p>
<h3 id="用对称加密可行吗？"><a href="#用对称加密可行吗？" class="headerlink" title="用对称加密可行吗？"></a>用对称加密可行吗？</h3><p><strong>如果通信双方都各自持有同一个密钥，且没有别人知道，这两方的通信安全当然是可以被保证的（除非密钥被破解）。</strong></p>
<p>然而最大的问题就是<strong>这个密钥怎么让传输的双方知晓，同时不被别人知道</strong>。如果由服务器生成一个密钥并传输给浏览器，那在这个传输过程中密钥被别人劫持到手了怎么办？之后他就能用密钥解开双方传输的任何内容了，所以这么做当然不行。</p>
<p>换种思路？试想一下，如果浏览器内部就预存了网站A的密钥，且可以确保除了浏览器和网站A，不会有任何外人知道该密钥，那理论上用对称加密是可以的，这样浏览器只要预存好世界上所有HTTPS网站的密钥就行了！这么做显然不现实。<br>怎么办？所以我们就需要<code>非对称加密</code> 。</p>
<h3 id="什么是非对称加密？"><a href="#什么是非对称加密？" class="headerlink" title="什么是非对称加密？"></a>什么是非对称加密？</h3><p>简单说就是有两把密钥，通常一把叫做公钥、一把叫私钥，用公钥加密的内容必须用私钥才能解开，同样，私钥加密的内容只有公钥能解开。</p>
<p><img src="/images/2021-7-4182912.png" alt="2021-7-4182912.png"></p>
<h3 id="用非对称加密可行吗？"><a href="#用非对称加密可行吗？" class="headerlink" title="用非对称加密可行吗？"></a>用非对称加密可行吗？</h3><p>鉴于非对称加密的机制，我们可能会有这种思路：服务器先把公钥以明文方式传输给浏览器，之后浏览器向服务器传数据前都先用这个公钥加密好再传，这条数据的安全似乎可以保障了！<strong>因为只有服务器有相应的私钥能解开公钥加密的数据</strong>。</p>
<p>然而反过来<strong>由服务器到浏览器的这条路怎么保障安全？</strong>如果服务器用它的私钥加密数据传给浏览器，那么浏览器用公钥可以解密它，而这个公钥是一开始通过明文传输给浏览器的，若这个公钥被中间人劫持到了，那他也能用该公钥解密服务器传来的信息了。所以<strong>目前似乎只能保证由浏览器向服务器传输数据的安全性</strong>（其实仍有漏洞，下文会说），那利用这点你能想到什么解决方案吗？</p>
<h3 id="改良的非对称加密方案，似乎可以？"><a href="#改良的非对称加密方案，似乎可以？" class="headerlink" title="改良的非对称加密方案，似乎可以？"></a>改良的非对称加密方案，似乎可以？</h3><p>我们已经理解通过一组公钥私钥，可以保证单个方向传输的安全性，那用两组公钥私钥，是否就能保证双向传输都安全了？请看下面的过程：</p>
<ol>
<li>某网站服务器拥有公钥A与对应的私钥A’；浏览器拥有公钥B与对应的私钥B’。</li>
<li>浏览器把公钥B明文传输给服务器。</li>
<li>服务器把公钥A明文给传输浏览器。</li>
<li>之后浏览器向服务器传输的内容都用公钥A加密，服务器收到后用私钥A’解密。由于只有服务器拥有私钥A’，所以能保证这条数据的安全。</li>
<li>同理，服务器向浏览器传输的内容都用公钥B加密，浏览器收到后用私钥B’解密。同上也可以保证这条数据的安全。</li>
</ol>
<p>的确可以！抛开这里面仍有的漏洞不谈（下文会讲），HTTPS的加密却没使用这种方案，为什么？很重要的原因是非对称加密算法非常耗时，而对称加密快很多。那我们能不能运用非对称加密的特性解决前面提到的对称加密的漏洞？</p>
<h3 id="非对称加密-对称加密？"><a href="#非对称加密-对称加密？" class="headerlink" title="非对称加密+对称加密？"></a>非对称加密+对称加密？</h3><p>既然非对称加密耗时，那非对称加密+对称加密结合可以吗？而且得尽量减少非对称加密的次数。当然是可以的，且非对称加密、解密各只需用一次即可。<br>请看一下这个过程：</p>
<ol>
<li>某网站拥有用于非对称加密的公钥A、私钥A’。</li>
<li>浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。</li>
<li>浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。</li>
<li>服务器拿到后用私钥A’解密得到密钥X。</li>
<li>这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都通过密钥X加密解密即可。</li>
</ol>
<p>完美！HTTPS基本就是采用了这种方案。完美？还是有漏洞的。</p>
<h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p><img src="/images/2021-7-4183232.png" alt="2021-7-4183232.png"></p>
<p>如果在数据传输过程中，中间人劫持到了数据，此时他的确无法得到浏览器生成的密钥X，这个密钥本身被公钥A加密了，只有服务器才有私钥A’解开它，然而中间人却完全不需要拿到私钥A’就能干坏事了。请看：</p>
<ol>
<li>某网站有用于非对称加密的公钥A、私钥A’。</li>
<li>浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。</li>
<li><strong>中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B’）</strong>。</li>
<li>浏览器生成一个用于对称加密的密钥X，用<strong>公钥B</strong>（浏览器无法得知公钥被替换了）加密后传给服务器。</li>
<li><strong>中间人劫持后用私钥B’解密得到密钥X，再用公钥A加密后传给服务器</strong>。</li>
<li>服务器拿到后用私钥A’解密得到密钥X。</li>
</ol>
<p>这样在双方都不会发现异常的情况下，中间人通过一套“狸猫换太子”的操作，掉包了服务器传来的公钥，进而得到了密钥X。<strong>根本原因是浏览器无法确认收到的公钥是不是网站自己的，</strong>因为公钥本身是明文传输的，难道还得对公钥的传输进行加密？这似乎变成鸡生蛋、蛋生鸡的问题了。解法是什么？</p>
<h3 id="如何证明浏览器收到的公钥一定是该网站的公钥？"><a href="#如何证明浏览器收到的公钥一定是该网站的公钥？" class="headerlink" title="如何证明浏览器收到的公钥一定是该网站的公钥？"></a>如何证明浏览器收到的公钥一定是该网站的公钥？</h3><p>其实所有证明的源头都是一条或多条不证自明的“公理”（可以回想一下数学上公理），由它推导出一切。比如现实生活中，若想证明某身份证号一定是小明的，可以看他身份证，而身份证是由政府作证的，这里的“公理”就是“政府机构可信”，这也是社会正常运作的前提。</p>
<p>那能不能类似地有个机构充当互联网世界的“公理”呢？让它作为一切证明的源头，给网站颁发一个“身份证”？</p>
<p>它就是<strong>CA机构</strong>，它是如今互联网世界正常运作的前提，而CA机构颁发的“身份证”就是<strong>数字证书</strong>。</p>
<h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p><img src="/images/2021-7-4183437.png" alt="2021-7-4183437.png"></p>
<p>网站在使用HTTPS前，需要向<strong>CA机构</strong>申领一份<strong>数字证书</strong>，数字证书里含有证书持有者信息、公钥信息等。服务器把证书传输给浏览器，浏览器从证书里获取公钥就行了，证书就如身份证，证明“该公钥对应该网站”。而这里又有一个显而易见的问题，“<strong>证书本身的传输过程中，如何防止被篡改”</strong>？即如何证明证书本身的真实性？身份证运用了一些防伪技术，而数字证书怎么防伪呢？解决这个问题我们就接近胜利了！</p>
<h3 id="如何放防止数字证书被篡改？"><a href="#如何放防止数字证书被篡改？" class="headerlink" title="如何放防止数字证书被篡改？"></a>如何放防止数字证书被篡改？</h3><p>我们把证书原本的内容生成一份“签名”，比对证书内容和签名是否一致就能判别是否被篡改。这就是数字证书的“防伪技术”，这里的“签名”就叫<code>数字签名</code>：</p>
<h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p>这部分内容建议看下图并结合后面的文字理解，图中左侧是数字签名的制作过程，右侧是验证过程：</p>
<p><img src="/images/2021-7-4183542.png" alt="2021-7-4183542.png"></p>
<p>数字签名的制作过程：</p>
<ol>
<li>CA机构拥有非对称加密的私钥和公钥。</li>
<li>CA机构对证书明文数据T进行hash。</li>
<li>对hash后的值用私钥加密，得到数字签名S。</li>
</ol>
<p>明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了。<br>那浏览器拿到服务器传来的数字证书后，如何验证它是不是真的？（有没有被篡改、掉包）</p>
<p>浏览器验证过程：</p>
<ol>
<li>拿到证书，得到明文T，签名S。</li>
<li>用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S’。</li>
<li>用证书里指明的hash算法对明文T进行hash得到T’。</li>
<li>显然通过以上步骤，T’应当等于S‘，除非明文或签名被篡改。所以此时比较S’是否等于T’，等于则表明证书可信。</li>
</ol>
<p>为何么这样可以保证证书可信呢？我们来仔细想一下。</p>
<h4 id="中间人有可能篡改该证书吗？"><a href="#中间人有可能篡改该证书吗？" class="headerlink" title="中间人有可能篡改该证书吗？"></a>中间人有可能篡改该证书吗？</h4><p>假设中间人篡改了证书的原文，由于他没有CA机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名。浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改，证书不可信，从而终止向服务器传输信息，防止信息泄露给中间人。</p>
<p>既然不可能篡改，那整个证书被掉包呢？</p>
<h4 id="中间人有可能把证书掉包吗？"><a href="#中间人有可能把证书掉包吗？" class="headerlink" title="中间人有可能把证书掉包吗？"></a>中间人有可能把证书掉包吗？</h4><p>假设有另一个网站B也拿到了CA机构认证的证书，它想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到B的证书里的公钥了，这确实会导致上文“中间人攻击”那里提到的漏洞？</p>
<p>其实这并不会发生，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。</p>
<h4 id="为什么制作数字签名时需要hash一次？"><a href="#为什么制作数字签名时需要hash一次？" class="headerlink" title="为什么制作数字签名时需要hash一次？"></a>为什么制作数字签名时需要hash一次？</h4><p>我初识HTTPS的时候就有这个疑问，因为似乎那里的hash有点多余，把hash过程去掉也能保证证书没有被篡改。</p>
<p>最显然的是性能问题，前面我们已经说了非对称加密效率较差，证书信息一般较长，比较耗时。而hash后得到的是固定长度的信息（比如用md5算法hash后可以得到固定的128位的值），这样加解密就快很多。</p>
<p>当然也有安全上的原因，这部分内容相对深一些，感兴趣的可以看这篇解答：<a href="https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%3A%2F%2Fcrypto.stackexchange.com%2Fa%2F12780" target="_blank" rel="noopener">crypto.stackexchange.com/a/12780</a></p>
<h4 id="怎么证明CA机构的公钥是可信的？"><a href="#怎么证明CA机构的公钥是可信的？" class="headerlink" title="怎么证明CA机构的公钥是可信的？"></a>怎么证明CA机构的公钥是可信的？</h4><p>你们可能会发现上文中说到CA机构的公钥，我几乎一笔带过，“浏览器保有它的公钥”，这是个什么保有法？怎么证明这个公钥是否可信？</p>
<p>让我们回想一下数字证书到底是干啥的？没错，为了证明某公钥是可信的，即“该公钥是否对应该网站”，那CA机构的公钥是否也可以用数字证书来证明？没错，操作系统、浏览器本身会预装一些它们信任的根证书，如果其中会有CA机构的根证书，这样就可以拿到它对应的可信公钥了。</p>
<p>实际上证书之间的认证也可以不止一层，可以A信任B，B信任C，以此类推，我们把它叫做<code>信任链</code>或<code>数字证书链</code>。也就是一连串的数字证书，由根证书为起点，透过层层信任，使终端实体证书的持有者可以获得转授的信任，以证明身份。</p>
<p>另外，不知你们是否遇到过网站访问不了、提示需安装证书的情况？这里安装的就是根证书。说明浏览器不认给这个网站颁发证书的机构，那么你就得手动下载安装该机构的根证书（风险自己承担）。安装后，你就有了它的公钥，就可以用它验证服务器发来的证书是否可信了。</p>
<p><img src="/images/2021-7-4212126.png" alt="2021-7-4212126.png"></p>
<h3 id="每次进行HTTPS请求时都必须在SSL-TLS层进行握手传输密钥吗？"><a href="#每次进行HTTPS请求时都必须在SSL-TLS层进行握手传输密钥吗？" class="headerlink" title="每次进行HTTPS请求时都必须在SSL/TLS层进行握手传输密钥吗？"></a><strong>每次进行HTTPS请求时都</strong>必须在SSL/TLS层进行握手传输密钥吗？</h3><p>这也是我当时的困惑之一，显然每次请求都经历一次密钥传输过程非常耗时，那怎么达到只传输一次呢？</p>
<p>服务器会为每个浏览器（或客户端软件）维护一个session ID，在TLS握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了！</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以看下这张图，梳理一下整个流程（SSL、TLS握手有一些区别，不同版本间也有区别，不过大致过程就是这样）：</p>
<p><img src="/images/2021-7-4212218.png" alt="2021-7-4212218.png"></p>
<p>Read More:</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/43789231" target="_blank" rel="noopener">彻底搞懂HTTPS的加密原理</a></p>
</blockquote>
]]></content>
      <categories>
        <category>HTTPS</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
        <tag>加密</tag>
        <tag>密钥协商</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O多路复用</title>
    <url>/2021/06/21/io-multiplexing/</url>
    <content><![CDATA[<h3 id="什么是IO多路复用"><a href="#什么是IO多路复用" class="headerlink" title="什么是IO多路复用"></a>什么是IO多路复用</h3><p>多路：多个socket连接或多个文件描述符</p>
<p>复用：复用同一个线程</p>
<p>简单理解：单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力</p>
<h3 id="IO多路复用解决的问题"><a href="#IO多路复用解决的问题" class="headerlink" title="IO多路复用解决的问题"></a>IO多路复用解决的问题</h3><p>应用程序通常需要处理来自多条事件流中的事件，比如我现在用的电脑，需要同时处理键盘鼠标的输入、中断信号等等事件，再比如web服务器如nginx，需要同时处理来来自N个客户端的事件。</p>
<p>而CPU单核在同一时刻只能做一件事情，一种解决办法是对CPU进行分时复用，多个事件流将CPU切割成多个时间片，不同事件流的时间片交替进行。在计算机系统中，我们用线程或者进程来表示一条执行流，通过不同的线程或进程在操作系统内部的调度，来做到对CPU处理的分时复用。这样多个事件流就可以并发进行，不需要一个等待另一个太久，在用户看起来他们似乎就是并行在做一样。</p>
<p>但凡事都是有成本的。线程/进程也一样，有这么几个方面：</p>
<ul>
<li>线程/进程创建成本</li>
<li>CPU切换不同线程/进程成本 </li>
<li>多线程的资源竞争</li>
</ul>
<p>有没有一种可以在单线程/进程中处理多个事件流的方法呢？这就是IO多路复用要解决的问题。因此IO多路复用解决的本质问题是在<strong>用更少的资源完成更多的事</strong>。</p>
<h3 id="解释几个概念"><a href="#解释几个概念" class="headerlink" title="解释几个概念"></a>解释几个概念</h3><p>在介绍IO多路复用的实现之前，我们先来解释几个概念。</p>
<h4 id="用户空间-内核空间"><a href="#用户空间-内核空间" class="headerlink" title="用户空间/内核空间"></a>用户空间/内核空间</h4><p>现代操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。 操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。</p>
<p>针对Linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p>
<h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的，并且进程切换是非常耗费资源的。</p>
<p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p>
<ol>
<li>保存处理机上下文，包括程序计数器和其他寄存器</li>
<li>更新PCB信息</li>
<li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列</li>
<li>选择另一个进程执行，并更新其PCB</li>
<li>更新内存管理的数据结构</li>
<li>恢复处理机上下文</li>
</ol>
<h4 id="进程阻塞"><a href="#进程阻塞" class="headerlink" title="进程阻塞"></a>进程阻塞</h4><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得了CPU资源），才可能将其转为阻塞状态。当进程进入阻塞状态，是不占用CPU资源的。</p>
<h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。 文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<h4 id="缓存I-O"><a href="#缓存I-O" class="headerlink" title="缓存I/O"></a>缓存I/O</h4><p>缓存I/O又称为标准I/O，大多数文件系统的默认I/O操作都是缓存I/O。在Linux的缓存I/O机制中，操作系统会将I/O的数据缓存在文件系统的页缓存中，即数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>
<h3 id="IO多路复用的实现"><a href="#IO多路复用的实现" class="headerlink" title="IO多路复用的实现"></a>IO多路复用的实现</h3><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>它仅仅知道了，有I/O事件发生了，却并不知道是哪那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以<strong>select具有O(n)的无差别轮询复杂度</strong>，同时处理的流越多，无差别轮询时间就越长。</p>
<p>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：</p>
<ul>
<li>单个进程所打开的FD是有限制的，通过 <code>FD_SETSIZE</code> 设置，默认1024</li>
<li><p>每次调用 select，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大，需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大</p>
</li>
<li><p>对 socket 扫描时是线性扫描，采用轮询的方法，效率较低（高并发）</p>
</li>
</ul>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， <strong>但是它没有最大连接数的限制</strong>，原因是它是基于链表来存储的。</p>
<p>poll与select类似，其缺点也是相同的：</p>
<ul>
<li>每次调用 poll ，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大</li>
<li>对 socket 扫描是线性扫描，采用轮询的方法，效率较低（高并发时）</li>
</ul>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的，其复杂度降低到了O(1)。</p>
<p>epoll的优点如下：</p>
<ul>
<li>没有最大并发连接的限制，能打开的FD的上限远大于1024（1G的内存上能监听约10万个端口）</li>
<li>效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll</li>
<li>内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销</li>
</ul>
<h5 id="epoll函数接口"><a href="#epoll函数接口" class="headerlink" title="epoll函数接口"></a>epoll函数接口</h5><p>当某一进程调用epoll_create方法时，Linux内核会创建一个eventpoll结构体，这个结构体中有两个成员与epoll的使用方式密切相关。eventpoll结构体如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/epoll.h&gt;</span><br><span class="line"></span><br><span class="line">// 数据结构</span><br><span class="line">// 每一个epoll对象都有一个独立的eventpoll结构体</span><br><span class="line">// 用于存放通过epoll_ctl方法向epoll对象中添加进来的事件</span><br><span class="line">// epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可</span><br><span class="line">struct eventpoll &#123;</span><br><span class="line">    /*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/</span><br><span class="line">    struct rb_root  rbr;</span><br><span class="line">    /*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/</span><br><span class="line">    struct list_head rdlist;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// API</span><br><span class="line">int epoll_create(int size); // 内核中间加一个 ep 对象，把所有需要监听的 socket 都放到 ep 对象中</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); // epoll_ctl 负责把 socket 增加、删除到内核红黑树</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);// epoll_wait 负责检测可读队列，没有可读 socket 则阻塞进程</span><br></pre></td></tr></table></figure>
<p>每一个epoll对象都有一个独立的eventpoll结构体，用于存放通过epoll_ctl方法向epoll对象中添加进来的事件。这些事件都会挂载在红黑树中，如此，重复添加的事件就可以通过红黑树而高效的识别出来(红黑树的插入时间效率是logn，其中n为红黑树元素个数)。</p>
<p>而所有添加到epoll中的事件都会与设备（网卡）驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个回调方法。这个回调方法在内核中叫ep_poll_callback,它会将发生的事件添加到rdlist双链表中。</p>
<p>在epoll中，对于每一个事件，都会建立一个epitem结构体，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct epitem&#123;</span><br><span class="line">    struct rb_node  rbn;//红黑树节点</span><br><span class="line">    struct list_head    rdllink;//双向链表节点</span><br><span class="line">    struct epoll_filefd  ffd;  //事件句柄信息</span><br><span class="line">    struct eventpoll *ep;    //指向其所属的eventpoll对象</span><br><span class="line">    struct epoll_event event; //期待发生的事件类型</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可。如果rdlist不为空，则把发生的事件复制到用户态，同时将事件数量返回给用户。</p>
<h4 id="select-poll-epoll之间的区别"><a href="#select-poll-epoll之间的区别" class="headerlink" title="select/poll/epoll之间的区别"></a>select/poll/epoll之间的区别</h4><p>select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。<strong>但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的</strong>，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。 </p>
<p>epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现。</p>
<table>
<thead>
<tr>
<th></th>
<th>select</th>
<th>poll</th>
<th>epoll</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作方式</td>
<td>遍历</td>
<td>遍历</td>
<td>回调</td>
</tr>
<tr>
<td>数据结构</td>
<td>bitmap</td>
<td>数组</td>
<td>红黑树</td>
</tr>
<tr>
<td>最大连接数</td>
<td>1024/2048</td>
<td>无上限</td>
<td>无上限</td>
</tr>
<tr>
<td>最大支持文件描述符数</td>
<td>有最大值限制</td>
<td>65535</td>
<td>65535</td>
</tr>
<tr>
<td>fd拷贝</td>
<td>每次调用select，都需要把fd集合从用户态拷贝到内核态</td>
<td>每次调用poll，都需要把fd集合从用户态拷贝到内核态</td>
<td>fd首次调用epoll_ctl拷贝，每次调用epoll_wait不拷贝</td>
</tr>
<tr>
<td>工作模式</td>
<td>LT</td>
<td>LT</td>
<td>ET</td>
</tr>
<tr>
<td>工作效率</td>
<td>每次调用都进行线性遍历，时间复杂度为O(n)</td>
<td>每次调用都进行线性遍历，时间复杂度为O(n)</td>
<td>事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到readyList里面，时间复杂度O(1)</td>
</tr>
</tbody>
</table>
<h3 id="常见的IO多路复用方案"><a href="#常见的IO多路复用方案" class="headerlink" title="常见的IO多路复用方案"></a>常见的IO多路复用方案</h3><p>redis: Linux下 epoll(level-triggered)，没有epoll用select</p>
<p>nginx: Linux下 epoll(edge-triggered)，没有epoll用select</p>
<p>Read More:</p>
<blockquote>
<p><a href="https://juejin.cn/post/6882984260672847879#heading-12" target="_blank" rel="noopener">彻底理解 IO 多路复用实现机制</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/115220699" target="_blank" rel="noopener">一文看懂IO多路复用</a></p>
<p><a href="https://www.zhihu.com/question/28594409" target="_blank" rel="noopener">I/O多路复用技术（multiplexing）是什么？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>IO多路复用</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka文件存储机制</title>
    <url>/2018/04/30/kafkasave/</url>
    <content><![CDATA[<h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><blockquote>
<p>Kafka是最初由 Linkedin 公司开发，是一个分布式、分区的、多副本的、多订阅者，基于 zookeeper 协调的分布式日志系统（也可以当做 MQ 系统），常见可以用于 web/nginx 日志、访问日志，消息服务等等，  Linkedin 于2010年贡献给了 Apache 基金会并成为顶级开源项目。</p>
</blockquote>
<p>一个商业化消息队列的性能好坏，其文件存储机制设计是衡量一个消息队列服务技术水平和最关键指标之一。下面将从  Kafka 文件存储机制和物理结构角度，分析 Kafka 是如何实现高效文件存储，及实际应用效果。</p>
<h3 id="Kafka文件存储机制"><a href="#Kafka文件存储机制" class="headerlink" title="Kafka文件存储机制"></a>Kafka文件存储机制</h3><p>Kafka部分名词解释如下：</p>
<ul>
<li>Broker：消息中间件处理结点，一个Kafka节点就是一个broker，多个broker可以组成一个Kafka集群；</li>
<li>Topic：一类消息，例如page view日志、click日志等都可以以topic的形式存在，Kafka集群能够同时负责多个topic的分发；</li>
<li>Partition：topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列；</li>
<li>Segment：partition物理上由多个segment组成；</li>
<li>offset：每个partition都由一系列有序的、不可变的消息组成，这些消息被连续的追加到partition中。partition中的每个消息都有一个连续的序列号叫做offset,用于partition唯一标识一条消息。</li>
</ul>
<p>分析过程分为以下4个步骤：</p>
<ul>
<li>topic中partition存储分布；</li>
<li>partiton中文件存储方式；</li>
<li>partiton中segment文件存储结构；</li>
<li>在partition中如何通过offset查找message。</li>
</ul>
<p>通过上述4过程详细分析，我们就可以清楚认识到kafka文件存储机制的奥秘。</p>
<h4 id="topic中partition存储分布"><a href="#topic中partition存储分布" class="headerlink" title="topic中partition存储分布"></a>topic中partition存储分布</h4><p>假设实验环境中Kafka集群只有一个broker，xxx/message-folder为数据文件存储根目录，在Kafka broker中server.properties文件配置（参数log.dirs=xxx/message-folder），例如创建2个topic名称分别为report_push、launch_info, partitions数量都为partitions=4，存储路径和目录规则为：xxx/message-folder。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|--report_push-0</span><br><span class="line">|--report_push-1</span><br><span class="line">|--report_push-2</span><br><span class="line">|--report_push-3</span><br><span class="line">|--launch_info-0</span><br><span class="line">|--launch_info-1</span><br><span class="line">|--launch_info-2</span><br><span class="line">|--launch_info-3</span><br></pre></td></tr></table></figure>
<p>在Kafka文件存储中，同一个topic下有多个不同partition，每个partition为一个目录，partiton命名规则为topic名称+有序序号，第一个partiton序号从0开始，序号最大值为partitions数量减1。</p>
<p>如果是多broker分布情况，请参考<a href="http://blog.csdn.net/lizhitao/article/details/41778193" target="_blank" rel="noopener">kafka集群partition分布原理分析</a></p>
<h4 id="partiton中文件存储方式"><a href="#partiton中文件存储方式" class="headerlink" title="partiton中文件存储方式"></a>partiton中文件存储方式</h4><p>下面示意图形象说明了partition中文件存储方式：</p>
<p> <img src="/images/2018-04-30T203835.png" alt="2018-04-30T203835"></p>
<ul>
<li>每个partion(目录)相当于一个巨型文件被平均分配到多个大小相等segment(段)数据文件中。但每个段segment file消息数量不一定相等，这种特性方便old segment file快速被删除；</li>
<li>每个partiton只需要支持顺序读写就行了，segment文件生命周期由服务端配置参数决定。</li>
</ul>
<p>这样做的好处就是能快速删除无用文件，有效提高磁盘利用率。</p>
<h4 id="partiton中segment文件存储结构"><a href="#partiton中segment文件存储结构" class="headerlink" title="partiton中segment文件存储结构"></a>partiton中segment文件存储结构</h4><ul>
<li>segment file组成：由2大部分组成，分别为index file和data file，此2个文件一一对应，成对出现，后缀”.index”和”.log”分别表示为segment索引文件、数据文件；</li>
<li>segment文件命名规则：partion全局的第一个segment从0开始，后续每个segment文件名为上一个segment文件最后一条消息的offset值。数值最大为64位long大小，19位数字字符长度，没有数字用0填充。</li>
</ul>
<p>下面文件列表是笔者在Kafka broker上做的一个实验，创建一个topicXXX包含1 partition，设置每个segment大小为500MB，并启动producer向Kafka broker写入大量数据，如下图所示segment文件列表形象说明了上述2个规则：</p>
<p> <img src="/images/2018-04-30T204111.png" alt="2018-04-30T204111"></p>
<p>以上述图2中一对segment file文件为例，说明segment中index<--->data file对应关系物理结构如下：</---></p>
<p> <img src="/images/2018-04-30T204213.png" alt="2018-04-30T204213"></p>
<p>上述图3中索引文件存储大量元数据，数据文件存储大量消息，索引文件中元数据指向对应数据文件中message的物理偏移地址。</p>
<p>其中以索引文件中元数据3,497为例，依次在数据文件中表示第3个message(在全局partiton表示第368772个message)、以及该消息的物理偏移地址为497。</p>
<p>从上图了解到segment data file由许多message组成，下面详细说明message物理结构如下：</p>
<p> <img src="/images/2018-04-30T204327.png" alt="2018-04-30T204327"></p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>8 byte offset</td>
<td>在parition内的每条消息都有一个有序的id号，这个id号被称为偏移，它可以唯一确定每条消息在parition内的位置。即offset表示partiion的第多少message</td>
</tr>
<tr>
<td>4 byte message size</td>
<td>message大小</td>
</tr>
<tr>
<td>4 byte CRC32</td>
<td>用crc32校验message</td>
</tr>
<tr>
<td>1 byte “magic”</td>
<td>表示本次发布Kafka服务程序协议版本号</td>
</tr>
<tr>
<td>1 byte “attributes”</td>
<td>表示为独立版本、或标识压缩类型、或编码类型。</td>
</tr>
<tr>
<td>4 byte key length</td>
<td>表示key的长度,当key为-1时，K byte key字段不填</td>
</tr>
<tr>
<td>K byte key</td>
<td>可选</td>
</tr>
<tr>
<td>value bytes payload</td>
<td>表示实际消息数据</td>
</tr>
</tbody>
</table>
<h4 id="在partition中如何通过offset查找message"><a href="#在partition中如何通过offset查找message" class="headerlink" title="在partition中如何通过offset查找message"></a>在partition中如何通过offset查找message</h4><p>例如读取offset=368776的message，需要通过下面2个步骤查找。</p>
<ul>
<li>第一步查找segment file<br>上述图为例，其中00000000000000000000.index表示最开始的文件，起始偏移量（offset）为0，第二个文件00000000000000368769.index的消息量起始偏移量为368770 = 368769 + 1，同样，第三个文件00000000000000737337.index的起始偏移量为737338=737337 + 1，其他后续文件依次类推，以起始偏移量命名并排序这些文件，只要根据offset<strong>二分查找</strong>文件列表，就可以快速定位到具体文件。当offset=368776时定位到00000000000000368769.index|log；</li>
<li>第二步通过segment file查找message<br>通过第一步定位到segment file，当offset=368776时，依次定位到00000000000000368769.index的元数据物理位置和00000000000000368769.log的物理偏移地址，然后再通过00000000000000368769.log顺序查找直到offset=368776为止。</li>
</ul>
<p>这样做的优点，segment index file采取稀疏索引存储方式，它减少索引文件大小，通过mmap可以直接内存操作，稀疏索引为数据文件的每个对应message设置一个元数据指针，它比稠密索引节省了更多的存储空间，但查找起来需要消耗更多的时间。</p>
<h3 id="实际运行效果"><a href="#实际运行效果" class="headerlink" title="实际运行效果"></a>实际运行效果</h3><p>实验环境：</p>
<ul>
<li>Kafka集群：由2台虚拟机组成</li>
<li>cpu：4核</li>
<li>物理内存：8GB</li>
<li>网卡：千兆网卡</li>
<li>jvm heap: 4GB</li>
<li><p>详细Kafka服务端配置及其优化请参考：<a href="http://blog.csdn.net/lizhitao/article/details/25667831" target="_blank" rel="noopener">kafka server.properties配置详解</a></p>
<p><img src="/images/2018-04-30T205037.png" alt="2018-04-30T205037"></p>
</li>
</ul>
<p>从上图可以看出，Kafka运行时很少有大量读磁盘的操作，主要是定期批量写磁盘操作，因此操作磁盘很高效。这跟Kafka文件存储中读写message的设计是息息相关的。Kafka中读写message有如下特点:</p>
<p>写message</p>
<ul>
<li>消息从堆转入page cache（即物理内存）；</li>
<li>由异步线程刷盘,消息从page cache刷入磁盘。</li>
</ul>
<p>读message</p>
<ul>
<li>消息直接从page cache转入socket发送出去；</li>
<li>当从page cache没有找到相应数据时，此时会产生磁盘IO，从磁盘Load消息到page cache，然后直接从socket发出去。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Kafka高效文件存储设计特点</p>
<ul>
<li>Kafka把topic中一个parition大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完文件，减少磁盘占用；</li>
<li>通过索引信息可以快速定位message和确定response的最大大小；</li>
<li>通过index元数据全部映射到memory，可以避免segment file的IO磁盘操作；</li>
<li>通过索引文件稀疏存储，可以大幅降低index文件元数据占用空间大小。</li>
</ul>
<p>Read More:</p>
<blockquote>
<p><a href="https://tech.meituan.com/kafka-fs-design-theory.html" target="_blank" rel="noopener">Kafka文件存储机制那些事</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>文件存储</tag>
      </tags>
  </entry>
  <entry>
    <title>Laravel学习笔记-Laravel5.3用户登录实现及注册源码初探</title>
    <url>/2017/05/05/laraveluserlogin/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在底层代码中，<code>Laravel</code> 的认证组件由 <code>guards</code> 和 <code>providers</code> 组成，<code>Guard</code> 定义了用户在每个请求中如何实现认证，例如，<code>Laravel</code> 通过 <code>session</code> <code>guard</code>来维护 <code>Session</code> 存储的状态、<code>Cookie</code> 以及 <code>token</code> <code>guard</code>，<code>token</code> <code>guard</code> 是认证用户发送请求时带的<code>API token</code>。</p>
<p><code>Provider</code> 定义了如何从持久化存储中获取用户信息，<code>Laravel</code> 底层支持通过 <code>Eloquent</code> 和数据库查询构建器两种方式来获取用户，如果需要的话，你还可以定义额外的 <code>Provider</code>。</p>
<p>相对于 <code>Laravel5.2</code> 而言，<code>Laravel5.3</code> 在底层代码中做了很多修改，方法更加简洁。虽然代码改了很多，但是原理都是一样的，我们只需要重写不同的方法而已。</p>
<h3 id="默认认证"><a href="#默认认证" class="headerlink" title="默认认证"></a>默认认证</h3><p>首先我们使用<code>Laravel 5.3</code>提供的开箱即用的认证：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php artisan make:auth</span><br></pre></td></tr></table></figure>
<p>该Artisan命令会生成用户认证所需的路由、视图以及<code>HomeController</code></p>
<p>认证的路由也一并生成好了，查看路由文件<code>routes/web.php</code>，会发现该文件已经被更新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Auth::routes();</span><br><span class="line"></span><br><span class="line">Route::get(&apos;/home&apos;, &apos;HomeController@index&apos;);</span><br></pre></td></tr></table></figure>
<p>其中<code>Auth::routes()</code>定义了登录注册及找回密码路由，<code>/home</code> 为用户认证成功后跳转的路由。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>接下来我们先实现前台用户登录，也就是Laravel自带的Users用户表登录。通过生成的默认登录认证，已经写好了所有代码，剩下要做的就是使用迁移命令创建用户认证相关表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php artisan migrate</span><br></pre></td></tr></table></figure>
<p>执行命令后会生成 <code>users</code> 表和 <code>password_resets</code> 表，分别为用户表和密码重置表。然后我们就可以在浏览器中输入<a href="http://myapp.com/register" target="_blank" rel="noopener">http://myapp.com/register</a> 来注册新用户</p>
<p><img src="/images/2017-5-5 194722.png" alt="2017-5-5 194722"></p>
<p>我们创建一个用户，注册成功后直接跳转 <code>/home</code>，并且刚注册的用户名也已经显示出来了</p>
<p><img src="/images/2017-5-5 194823.png" alt="2017-5-5 194823"></p>
<h3 id="发送邮件重置密码"><a href="#发送邮件重置密码" class="headerlink" title="发送邮件重置密码"></a>发送邮件重置密码</h3><p>Laravel 已经为我们提供了邮件重置密码的方式，只需要简单的设置即可。</p>
<p>在<code>config/mail.php</code> 中配置邮件发送方</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;from&apos; =&gt; [</span><br><span class="line">        &apos;address&apos; =&gt; &apos;liuyangplus@163.com&apos;,</span><br><span class="line">        &apos;name&apos; =&gt; &apos;Laravel Reset Password&apos;,</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure>
<p>在根目录的<code>.env</code> 文件中配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MAIL_DRIVER=smtp</span><br><span class="line">MAIL_HOST=smtp.163.com</span><br><span class="line">MAIL_PORT=587</span><br><span class="line">MAIL_USERNAME=youremail@163.com</span><br><span class="line">MAIL_PASSWORD=youremailpassword</span><br><span class="line">MAIL_ENCRYPTION=ssl</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>如果想使用其他邮箱，最好将<code>&#39;from&#39;</code>中的<code>address</code>和<code>MAIL_HOST</code> <code>MAIL_USERNAME</code> 邮箱类型一致。</p>
<p><img src="/images/2017-5-5 195940.png" alt="2017-5-5 195940"></p>
<p>以上就是发送邮件重置密码成功的邮件，其实我们也可以通过添加邮件发送类来自定义邮件的主题、内容等，这部分内容以后再添加。</p>
<h3 id="用户认证源码初探"><a href="#用户认证源码初探" class="headerlink" title="用户认证源码初探"></a>用户认证源码初探</h3><p>我们知道 Laravel 提供了开箱即用的用户认证过程，下面为了深入了解具体的用户认证实现，我们将深入 Laravel 的源码，探究用户验证是怎么处理的。</p>
<p>在实现用户认证过程中，我们首先执行了如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php artisan make:auth</span><br></pre></td></tr></table></figure>
<p>该命令会在项目里添加以下文件（目录）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app/Http/Controller/HomeController.PHP </span><br><span class="line">resources/views/auth/ </span><br><span class="line">resources/views/auth/login.blade.php </span><br><span class="line">resources/views/auth/passwords/ </span><br><span class="line">resources/views/auth/passwords/email.blade.php </span><br><span class="line">resources/views/auth/passwords/reset.blade.php </span><br><span class="line">resources/views/auth/register.blade.php </span><br><span class="line">resources/views/home.blade.php </span><br><span class="line">resources/views/layouts/ </span><br><span class="line">resources/views/layouts/app.blade.php</span><br></pre></td></tr></table></figure>
<p>除了一个 <code>HomeController</code> 是处理用户登陆之后的逻辑，其他都是一些视图，用于显示相应的页面。</p>
<p>在 <code>routes/web.php</code> 里添加了以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Auth::routes();</span><br><span class="line"></span><br><span class="line">Route::get(&apos;/home&apos;, &apos;HomeController@index&apos;);</span><br></pre></td></tr></table></figure>
<p><code>Auth::routes()</code> 是登陆、注册需要的一些路由；下面是定义一个 <code>/home</code> 路由，交给 <code>HomeController@index</code> 处理。</p>
<p>那么，就从路由开始我们的探究之旅吧。</p>
<h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><p> <code>Auth::routes()</code>定义在 <code>vendor/laravel/framework/src/Illuminate/Support/Facades/Auth.php</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static function routes()</span><br><span class="line">    &#123;</span><br><span class="line">        static::$app-&gt;make(&apos;router&apos;)-&gt;auth();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里由 IOC 容器解析了一个 Illuminate\Routing\Router 类的实例，再调用里面的 <code>auth()</code> 方法。</p>
<p>我们再来看看 auth() 方法，定义在 <code>vendor/laravel/framework/src/Illuminate/Routing/Router.php</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function auth()</span><br><span class="line">    &#123;</span><br><span class="line">        // Authentication Routes...</span><br><span class="line">        $this-&gt;get(&apos;login&apos;, &apos;Auth\LoginController@showLoginForm&apos;)-&gt;name(&apos;login&apos;);</span><br><span class="line">        $this-&gt;post(&apos;login&apos;, &apos;Auth\LoginController@login&apos;);</span><br><span class="line">        $this-&gt;post(&apos;logout&apos;, &apos;Auth\LoginController@logout&apos;);</span><br><span class="line"></span><br><span class="line">        // Registration Routes...</span><br><span class="line">        $this-&gt;get(&apos;register&apos;, &apos;Auth\RegisterController@showRegistrationForm&apos;);</span><br><span class="line">        $this-&gt;post(&apos;register&apos;, &apos;Auth\RegisterController@register&apos;);</span><br><span class="line"></span><br><span class="line">        // Password Reset Routes...</span><br><span class="line">        $this-&gt;get(&apos;password/reset&apos;, &apos;Auth\ForgotPasswordController@showLinkRequestForm&apos;);</span><br><span class="line">        $this-&gt;post(&apos;password/email&apos;, &apos;Auth\ForgotPasswordController@sendResetLinkEmail&apos;);</span><br><span class="line">        $this-&gt;get(&apos;password/reset/&#123;token&#125;&apos;, &apos;Auth\ResetPasswordController@showResetForm&apos;);</span><br><span class="line">        $this-&gt;post(&apos;password/reset&apos;, &apos;Auth\ResetPasswordController@reset&apos;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里定义了 登陆 、 注销 、注册 和密码重置的路由。我们先看注册部分。</p>
<h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p><code>App\Http\Controllers\Auth\RegisterController</code> 负责注册的逻辑，这里 use 了<code>Illuminate\Foundation\Auth\RegistersUsers</code> 这个 trait ，包含注册时通用的一些逻辑。</p>
<p>路由 <code>get(&#39;/register&#39;)</code> 所绑定的方法 <code>Auth\RegisterController@showRegistrationForm</code> 就定义在这个 trait 里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function showRegistrationForm()</span><br><span class="line">    &#123;</span><br><span class="line">        return view(&apos;auth.register&apos;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>很简单，返回一个 <code>auth.register</code> 视图。</p>
<p><code>auth.register</code> 视图获取用户的输入： <code>name</code>，<code>email</code>，<code>password</code>，然后 POST 提交到<code>/register</code>。</p>
<p>再来看看路由 <code>post(&#39;/register&#39;)</code> 所绑定的方法 <code>Auth\RegisterController@register</code>。</p>
<p>同样， <code>register</code> 方法定义在 <code>Illuminate\Foundation\Auth\RegistersUsers</code> 里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function register(Request $request)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;validator($request-&gt;all())-&gt;validate();</span><br><span class="line"></span><br><span class="line">        $this-&gt;guard()-&gt;login($this-&gt;create($request-&gt;all()));</span><br><span class="line"></span><br><span class="line">        return redirect($this-&gt;redirectPath());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先使用请求传入的表单调用 <code>validator()</code> ，返回一个验证对象，再调用 <code>validate()</code> 验证表单内容的合法性。</p>
<p><code>validator()</code> 定义在 <code>App\Http\Controllers\Auth\RegisterController</code> 里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected function validator(array $data)</span><br><span class="line">    &#123;</span><br><span class="line">        return Validator::make($data, [</span><br><span class="line">            &apos;name&apos; =&gt; &apos;required|max:255&apos;,</span><br><span class="line">            &apos;email&apos; =&gt; &apos;required|email|max:255|unique:users&apos;,</span><br><span class="line">            &apos;password&apos; =&gt; &apos;required|min:6|confirmed&apos;,</span><br><span class="line">        ]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这里给出了输入表单的验证规则，如果我们的用户注册需要的表单与这几个字段不一致（例如需要添加一个手机号），就在这里修改。</p>
</blockquote>
<p>返回的 <code>Validator</code> 对象会在 <code>register()</code> 方法里验证。</p>
<p>再回到 <code>register()</code> 方法， 往下走 <code>$this-&gt;guard()-&gt;login($this-&gt;create($request-&gt;all()));</code>。</p>
<p><code>$this-&gt;guard()</code> 这里会调用 <code>Illuminate\Foundation\Auth\RegistersUsers</code> 里的 <code>guard()</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected function guard()</span><br><span class="line">    &#123;</span><br><span class="line">        return Auth::guard();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里无参数调用 <code>Auth::guard()</code> 返回一个默认的 guard，看一下 <code>config/auth.php</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;guards&apos; =&gt; [</span><br><span class="line">        &apos;web&apos; =&gt; [</span><br><span class="line">            &apos;driver&apos; =&gt; &apos;session&apos;,</span><br><span class="line">            &apos;provider&apos; =&gt; &apos;users&apos;,</span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">        &apos;admin&apos; =&gt; [</span><br><span class="line">            &apos;driver&apos; =&gt; &apos;session&apos;,</span><br><span class="line">            &apos;provider&apos; =&gt; &apos;admins&apos;,</span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">        &apos;api&apos; =&gt; [</span><br><span class="line">            &apos;driver&apos; =&gt; &apos;token&apos;,</span><br><span class="line">            &apos;provider&apos; =&gt; &apos;users&apos;,</span><br><span class="line">        ],</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure>
<p>默认的 guard 是 web ； web 这个 guard 采用 session 驱动， 数据提供者是 users ；users 数据提供者使用 eloquent 驱动， 使用 <code>App\User::class</code> 模型。</p>
<p>接下来调用 guard 的 <code>login($this-&gt;create($request-&gt;all()))</code>。</p>
<p>首先是 <code>$this-&gt;create()</code> ，这个方法定义在 <code>App\Http\Controllers\Auth\RegisterController</code> 里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected function create(array $data)</span><br><span class="line">    &#123;</span><br><span class="line">        return User::create([</span><br><span class="line">            &apos;name&apos; =&gt; $data[&apos;name&apos;],</span><br><span class="line">            &apos;email&apos; =&gt; $data[&apos;email&apos;],</span><br><span class="line">            &apos;password&apos; =&gt; bcrypt($data[&apos;password&apos;]),</span><br><span class="line">        ]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>User</code> 模型对输入的内容新增一条记录，并返回这个模型的对象。</p>
<blockquote>
<p>同样，如果需要修改注册时使用的字段，也是改写这个方法。</p>
</blockquote>
<p>生成的 <code>User</code> 对象交给 guard 的 <code>login()</code> 方法，做一系列登录的操作，具体怎么做的，还是放到登陆验证里再详细说明。</p>
<p>最后， <code>return redirect($this-&gt;redirectPath());</code> 完成了注册、登陆的操作，最后跳转到我们在 <code>App\Http\Controllers\Auth\RegisterController</code> 里设置的 <code>protected $redirectTo = &#39;/home&#39;;</code> 目标URL。</p>
<p>可以看一下 <code>$this-&gt;redirectPath()</code> 方法怎么写的，在 <code>Illuminate\Foundation\Auth\RedirectsUsers</code> 这个 trait 里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function redirectPath()</span><br><span class="line">    &#123;</span><br><span class="line">        return property_exists($this, &apos;redirectTo&apos;) ? $this-&gt;redirectTo : &apos;/home&apos;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果定义了 <code>$redirectTo</code> 这个属性，就按照这个属性返回；如果没有，返回 <code>&#39;/home&#39;</code>。</p>
<blockquote>
<p>这里把这个方法写成 trait 是因为这个方法还会在 <code>App\Http\Controllers\Auth\LoginController</code> 登陆控制器里使用，所以就把 <code>redirectPath()</code> 这个方法提出来做成一个 trait，严格遵守 DRY 原则。</p>
</blockquote>
<p>Read More:</p>
<blockquote>
<p><a href="http://blog.csdn.net/realghost/article/details/52558962" target="_blank" rel="noopener">Laravel 5.3 用户验证源码探究 （一） 路由与注册</a>  <a href="http://laravelacademy.org/post/5925.html" target="_blank" rel="noopener">Laravel 5.3 多用户表登录实现</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Laravel</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
        <tag>多用户登录</tag>
        <tag>验证原理</tag>
      </tags>
  </entry>
  <entry>
    <title>librdkafka的安装和使用</title>
    <url>/2018/01/04/librdkafkainstallanduse/</url>
    <content><![CDATA[<p><a href="https://kafka.apache.org/" target="_blank" rel="noopener">kafka</a> 是一种高吞吐量的分布式发布订阅消息系统。现在它已被 <a href="https://cwiki.apache.org/confluence/display/KAFKA/Powered+By" target="_blank" rel="noopener">多家不同类型的公司</a> 作为多种类型的数据管道和消息系统使用。Python对kafka的操作库主要有 <a href="https://github.com/Parsely/pykafka" target="_blank" rel="noopener">pykafka</a> 、<a href="https://github.com/confluentinc/confluent-kafka-python" target="_blank" rel="noopener">confluent-kafka-python</a> 、<a href="https://github.com/edenhill/librdkafka" target="_blank" rel="noopener">librdkafka</a> ，pykafka是Python内置的kafka操作模块，纯Python编写，提供 <a href="http://pykafka.readthedocs.io/en/latest/api/simpleconsumer.html" target="_blank" rel="noopener">simpleconsumer</a> 、<a href="http://pykafka.readthedocs.io/en/latest/api/balancedconsumer.html" target="_blank" rel="noopener">balancedconsumer</a> 两种消费方式。</p>
<p>其实严格意义上来说，librdkafka并不是kafka的操作库，它是Apache Kafka协议的C库实现，包含Producer和Consumer支持。</p>
<blockquote>
<p><strong>librdkafka</strong> is a C library implementation of the <a href="http://kafka.apache.org/" target="_blank" rel="noopener">Apache Kafka</a> protocol, containing both Producer and Consumer support. It was designed with message delivery reliability and high performance in mind, current figures exceed 1 million msgs/second for the producer and 3 million msgs/second for the consumer.</p>
</blockquote>
<p>由于项目的需要，原本使用pykafka作为数据的读取库，但是可能是达到了Python的读瓶颈，pykafka无法满足目前的要求，所以准备采用librdkafka来提高从kafka中读数据的效率。网上对Python环境中librdkafka的安装并没有详细的教程，通过自己的摸索和踩坑，终于是安装成功了。</p>
<h4 id="安装librdkafka"><a href="#安装librdkafka" class="headerlink" title="安装librdkafka"></a>安装librdkafka</h4><p>执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/edenhill/librdkafka.git</span><br></pre></td></tr></table></figure>
<p>将librdkafka源码库下载到本地，如果没有安装git，请自行搜索安装。</p>
<p>如果github上无法下载，请转到百度网盘：链接: <a href="https://pan.baidu.com/s/1sl0uj2d" target="_blank" rel="noopener">https://pan.baidu.com/s/1sl0uj2d</a> 密码: af7k</p>
<p>下载的是0.11.1版本，本文安装的也是这个版本。</p>
<p>本文直接下载到/root/目录下，执行<code>cd librdkafka-0.11.1</code>进行目录</p>
<p>依次执行一下命令进行安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./configure</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>librdkafka依赖的环境如下，如果未安装请自行安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The GNU toolchain</span><br><span class="line">GNU make</span><br><span class="line">pthreads</span><br><span class="line">zlib (optional, for gzip compression support)</span><br><span class="line">libssl-dev (optional, for SSL and SASL SCRAM support)</span><br><span class="line">libsasl2-dev (optional, for SASL GSSAPI support)</span><br></pre></td></tr></table></figure>
<p>如果安装成功，会在<code>/usr/local/lib</code>目录中出现以下文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt librdkafka-0.11.1]# cd /usr/local/lib</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt lib]# ll</span><br><span class="line">total 15200</span><br><span class="line">-rwxr-xr-x 1 root root 8122982 Jan  4 15:21 librdkafka.a</span><br><span class="line">-rwxr-xr-x 1 root root 2305704 Jan  4 15:21 librdkafka++.a</span><br><span class="line">lrwxrwxrwx 1 root root      15 Jan  4 15:21 librdkafka.so -&gt; librdkafka.so.1</span><br><span class="line">lrwxrwxrwx 1 root root      17 Jan  4 15:21 librdkafka++.so -&gt; librdkafka++.so.1</span><br><span class="line">-rwxr-xr-x 1 root root 4225307 Jan  4 15:21 librdkafka.so.1</span><br><span class="line">-rwxr-xr-x 1 root root  899617 Jan  4 15:21 librdkafka++.so.1</span><br><span class="line">drwxr-xr-x 2 root root    4096 Jan  4 15:21 pkgconfig</span><br></pre></td></tr></table></figure>
<p>librdkafka.so、librdkafka.so.1是librdkafka的动态链接库，因为Linux默认的动态链接库路径是<code>/lib</code>、<code>/usr/lib</code>，而librdkafka默认安装到了<code>/usr/local/lib</code>，为了使Python解释器可以找到librdkafka的动态链接库，本文采取的方法是修改系统文件<code>/etc/ld.so.conf</code>，这个文件中指定了默认的动态链接库查找路径，默认只有一行配置，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include ld.so.conf.d/*.conf</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>/etc/ld.so.conf</code>包含了ld.so.conf.d目录中的所有<code>.conf</code>文件，所以我们新建一个配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt ld.so.conf.d]# ll</span><br><span class="line">total 24</span><br><span class="line">...</span><br><span class="line">-rw-r--r--  1 root root  15 Jan  4 11:02 librdkafka.conf</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在<code>librdkafka.conf</code>文件中将<code>/usr/local/lib</code>路径包含进去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/local/lib</span><br></pre></td></tr></table></figure>
<p>保存退出后执行以下命令更新动态链接库的搜索配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ldconfig</span><br></pre></td></tr></table></figure>
<p>通过以上操作，Python解释器就可以找到刚才安装的librdkafka的动态链接库了。</p>
<h4 id="安装pykafka"><a href="#安装pykafka" class="headerlink" title="安装pykafka"></a>安装pykafka</h4><p>Python可以通过pip工具安装pykafka</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install pykafka</span><br></pre></td></tr></table></figure>
<p>但是我们需要使用librdkafka扩展，使用pip工具是无法安装librdkafka的，所以我们需要源码编译安装pykafka。</p>
<p>执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/Parsely/pykafka.git</span><br></pre></td></tr></table></figure>
<p>下载pykafka的源码包到本地，这时别着急执行<code>./configure</code>，文档中介绍：要使用librdkafka扩展，需要确保头文件和共享库是Python可以找到它们的地方，无论是在构建扩展还是在运行时。</p>
<blockquote>
<p>PyKafka includes a C extension that makes use of librdkafka to speed up producer and consumer operation. To use the librdkafka extension, you need to make sure the header files and shared library are somewhere where python can find them, both when you build the extension (which is taken care of by <code>setup.py develop</code>) and at run time. Typically, this means that you need to either install librdkafka in a place conventional for your system, or declare <code>C_INCLUDE_PATH</code>, <code>LIBRARY_PATH</code>, and <code>LD_LIBRARY_PATH</code> in your shell environment to point to the installation location of the librdkafka shared objects. You can find this location with locate librdkafka.so.</p>
</blockquote>
<p>我们已经将librdkafka的动态链接库加载到系统的搜索路径中，所以这个没问题，但是头文件在哪里？</p>
<p>在<code>pykafka/pykafka/rdkafka/_rd_kafkamodule.c</code>文件中有这样一行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;librdkafka/rdkafka.h&gt;</span><br></pre></td></tr></table></figure>
<p>所以我们需要在刚才下载的pykafka源码包中新建一个目录，将<code>rdkafka.h</code>放进去，保证我们在编译安装时能够找到它</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt pykafka]# ll</span><br><span class="line">total 128</span><br><span class="line">...</span><br><span class="line">drwxr-xr-x 2 root root  4096 Jan  4 14:22 librdkafka</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>rdkafka.h</code>文件可以在刚才下载的librdkafka源码包中找到，即<code>librdkafka/src/</code>目录下</p>
<p>执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp /root/librdkafka-0.11.1/src/rdkafka.h /root/pykafka/librdkafka/</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：/root代表librdkafka-0.11.1的存放目录</p>
<p>完成以上工作，依次执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd pykafka/</span><br><span class="line">python setup.py build</span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>
<p>不出意外的话，就可以安装成功，这时在Python的安装目录的<code>site-packages/</code>目录下会产生<code>pykafka-2.7.0.dev2-py3.6-linux-x86_64.egg</code>目录，内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt pykafka-2.7.0.dev2-py3.6-linux-x86_64.egg]# ll</span><br><span class="line">total 12</span><br><span class="line">drwxr-xr-x 2 root root 4096 Jan  4 15:22 EGG-INFO</span><br><span class="line">drwxr-xr-x 7 root root 4096 Jan  4 15:22 pykafka</span><br><span class="line">drwxr-xr-x 4 root root 4096 Jan  4 15:22 tests</span><br></pre></td></tr></table></figure>
<p>表明安装成功了，在<code>pykafka/rdkafka/</code>目录中可以看到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt rdkafka]# ll</span><br><span class="line">total 172</span><br><span class="line">-rw-r--r-- 1 root root  1188 Jan  4 15:22 helpers.py</span><br><span class="line">-rw-r--r-- 1 root root    89 Jan  4 15:22 __init__.py</span><br><span class="line">-rw-r--r-- 1 root root  8343 Jan  4 15:22 producer.py</span><br><span class="line">drwxr-xr-x 2 root root  4096 Jan  4 16:07 __pycache__</span><br><span class="line">-rwxr-xr-x 1 root root 83815 Jan  4 15:22 _rd_kafka.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">-rw-r--r-- 1 root root 41405 Jan  4 15:22 _rd_kafkamodule.c</span><br><span class="line">-rw-r--r-- 1 root root   314 Jan  4 15:22 _rd_kafka.py</span><br><span class="line">-rw-r--r-- 1 root root 12674 Jan  4 16:04 simple_consumer.py</span><br></pre></td></tr></table></figure>
<h4 id="踩的坑"><a href="#踩的坑" class="headerlink" title="踩的坑"></a>踩的坑</h4><ul>
<li>使用执行报错1</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pykafka.rdkafka#consumer-1 [PROTOERR] [thrd:openlive-kafka-online005-bjlt.qiyi.virtual:9092/bootstrap]: openlive-kafka-online005-bjlt.qiyi.virtual:9092/5: expected 36732025 bytes &gt; 1048618 remaining bytes</span><br><span class="line">pykafka.rdkafka#consumer-1 [PROTOERR] [thrd:openlive-kafka-online005-bjlt.qiyi.virtual:9092/bootstrap]: openlive-kafka-online005-bjlt.qiyi.virtual:9092/5: Protocol parse failure at 8/1048626 (rd_kafka_fetch_reply_handle:2496) (incorrect broker.version.fallback?)</span><br></pre></td></tr></table></figure>
<p>错误给出的提示是<code>incorrect broker.version.fallback?</code>，一番google后，找到了问题所在，请看 <a href="https://github.com/edenhill/librdkafka/wiki/Broker-version-compatibility" target="_blank" rel="noopener">Broker version compatibility</a> ，librdkafka不同版本的broker对程序的配置要求不同，主要是<code>api.version.request</code> 、<code>broker.version.fallback</code>这两个参数的配置，在<code>pykafka/rdkafka/simple_consumer.py</code>文件中有这样的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">ver10 = parse_version(self._broker_version) &gt;= parse_version(&quot;0.10.0&quot;)</span><br><span class="line">...</span><br><span class="line">conf = &#123;</span><br><span class="line">    ...</span><br><span class="line">    &quot;api.version.request&quot;: ver10,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">if not ver10:</span><br><span class="line">    conf[&quot;broker.version.fallback&quot;] = self._broker_version</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>所以在使用时加上了<code>broker_version</code>参数，这个参数需要知道<strong>kafka集群的broker的版本</strong>，这个非常重要！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.client = KafkaClient(zookeeper_hosts=zookeeper_hosts, broker_version=&quot;0.8.2&quot;)</span><br></pre></td></tr></table></figure>
<p>这样使用就没有问题了。</p>
<p>但是在实际测试中，裸pykafka和pykafka-with-librdkafka的读性能并没有差太多，以下是我在实际中测试从kafka中读取50w条数据的耗时比较：</p>
<table>
<thead>
<tr>
<th>pykafka</th>
<th>pykafka-with-librdkafka</th>
</tr>
</thead>
<tbody>
<tr>
<td>43.136744260787964</td>
<td>35.90807628631592</td>
</tr>
<tr>
<td>44.06431531906128</td>
<td>37.58351707458496</td>
</tr>
<tr>
<td>43.47287678718567</td>
<td>37.0159432888031</td>
</tr>
</tbody>
</table>
<p>理论上，使用了C库的读取，其性能应该有很大提升才对，但是测试表明性能提升并不到，这个问题还有待探讨。</p>
]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
        <tag>librdkafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令 - crontab</title>
    <url>/2017/04/02/linuxcrontab/</url>
    <content><![CDATA[<p>crond是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。</p>
<h3 id="Linux下的任务调度"><a href="#Linux下的任务调度" class="headerlink" title="Linux下的任务调度"></a>Linux下的任务调度</h3><p>Linux下的任务调度分为两类，系统任务调度和用户任务调度。</p>
<h4 id="系统任务调度"><a href="#系统任务调度" class="headerlink" title="系统任务调度"></a>系统任务调度</h4><p>系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。</p>
<p>/etc/crontab文件包括下面几行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# cat /etc/crontab </span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=&quot;&quot;HOME=/</span><br><span class="line"># run-parts</span><br><span class="line">51 * * * * root run-parts /etc/cron.hourly</span><br><span class="line">24 7 * * * root run-parts /etc/cron.daily</span><br><span class="line">22 4 * * 0 root run-parts /etc/cron.weekly</span><br><span class="line">42 4 1 * * root run-parts /etc/cron.monthly</span><br><span class="line">[root@localhost ~]#</span><br></pre></td></tr></table></figure>
<p>前四行是用来配置crond任务运行的环境变量，第一行SHELL变量指定了系统要使用哪个shell，这里是bash，第二行PATH变量指定了系统执行命令的路径，第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务执行信息给用户，第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。</p>
<h4 id="用户任务调度"><a href="#用户任务调度" class="headerlink" title="用户任务调度"></a>用户任务调度</h4><p>用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab 文件都被保存在 /var/spool/cron 目录中。其文件名与用户名一致。</p>
<h3 id="使用者权限文件"><a href="#使用者权限文件" class="headerlink" title="使用者权限文件"></a>使用者权限文件</h3><table>
<thead>
<tr>
<th>文件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>/etc/cron.deny</td>
<td>该文件中所列用户不允许使用crontab命令</td>
</tr>
<tr>
<td>/etc/cron.allow</td>
<td>该文件中所列用户允许使用crontab命令</td>
</tr>
<tr>
<td>/var/spool/cron/</td>
<td>所有用户crontab文件存放的目录，以用户名命名</td>
</tr>
</tbody>
</table>
<h3 id="crontab文件的含义"><a href="#crontab文件的含义" class="headerlink" title="crontab文件的含义"></a>crontab文件的含义</h3><p>用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">minute   hour   day   month   week   command</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>minute</td>
<td>表示分钟，可以是从0到59之间的任何整数</td>
</tr>
<tr>
<td>hour</td>
<td>表示小时，可以是从0到23之间的任何整数</td>
</tr>
<tr>
<td>day</td>
<td>表示日期，可以是从1到31之间的任何整数</td>
</tr>
<tr>
<td>month</td>
<td>表示月份，可以是从1到12之间的任何整数</td>
</tr>
<tr>
<td>week</td>
<td>表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日</td>
</tr>
<tr>
<td>command</td>
<td>要执行的命令，可以是系统命令，也可以是自己编写的脚本文件</td>
</tr>
</tbody>
</table>
<p><img src="/images/2017-4-2 165636.png" alt="2017-4-2165636"></p>
<p>在以上各个字段中，还可以使用以下特殊字符：</p>
<p>星号(*)：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作；</p>
<p>逗号(,)：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”；</p>
<p>中杠(-)：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”；</p>
<p>正斜线(/)：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。</p>
<h3 id="crond服务"><a href="#crond服务" class="headerlink" title="crond服务"></a>crond服务</h3><p>安装crontab：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install crontabs</span><br></pre></td></tr></table></figure>
<p>服务操作说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/sbin/service crond start    //启动服务</span><br><span class="line">/sbin/service crond stop     //关闭服务</span><br><span class="line">/sbin/service crond restart  //重启服务</span><br><span class="line">/sbin/service crond reload   //重新载入配置</span><br></pre></td></tr></table></figure>
<p>查看crontab服务状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service crond status</span><br></pre></td></tr></table></figure>
<p>手动启动crontab服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service crond start</span><br></pre></td></tr></table></figure>
<p>查看crontab服务是否已设置为开机启动，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ntsysv</span><br></pre></td></tr></table></figure>
<p>加入开机自动启动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chkconfig –level 35 crond on</span><br></pre></td></tr></table></figure>
<h3 id="crontab命令详解"><a href="#crontab命令详解" class="headerlink" title="crontab命令详解"></a>crontab命令详解</h3><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab [-u user] file</span><br><span class="line">crontab [-u user] [ -e | -l | -r ]</span><br></pre></td></tr></table></figure>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的日志分析或数据备份等工作。</p>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-u user</td>
<td>用来设定某个用户的crontab服务，例如，“-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行</td>
</tr>
<tr>
<td>file</td>
<td>file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab</td>
</tr>
<tr>
<td>-e</td>
<td>编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件</td>
</tr>
<tr>
<td>-l</td>
<td>显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容</td>
</tr>
<tr>
<td>-r</td>
<td>从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件</td>
</tr>
<tr>
<td>-i</td>
<td>在删除用户的crontab文件时给确认提示</td>
</tr>
</tbody>
</table>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><table>
<thead>
<tr>
<th>示例</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td>每1分钟执行一次command</td>
<td>* * * * * command</td>
</tr>
<tr>
<td>每小时的第3和第15分钟执行</td>
<td>3,15 * * * * command</td>
</tr>
<tr>
<td>在上午8点到11点的第3和第15分钟执行</td>
<td>3,15 8-11 * * * command</td>
</tr>
<tr>
<td>每隔两天的上午8点到11点的第3和第15分钟执行</td>
<td>3,15 8-11 */2 * * command</td>
</tr>
<tr>
<td>每个星期一的上午8点到11点的第3和第15分钟执行</td>
<td>3,15 8-11 * * 1 command</td>
</tr>
<tr>
<td>每晚的21:30重启smb</td>
<td>30 21 * * * /etc/init.d/smb restart</td>
</tr>
<tr>
<td>每月1、10、22日的4 : 45重启smb</td>
<td>45 4 1,10,22 * * /etc/init.d/smb restart</td>
</tr>
<tr>
<td>一月一号的4点重启smb</td>
<td>0 4 1 jan * /etc/init.d/smb restart</td>
</tr>
<tr>
<td>每小时执行/etc/cron.hourly目录内的脚本</td>
<td>01 * * * *  root run-parts /etc/cron.hourly</td>
</tr>
</tbody>
</table>
<h3 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><h4 id="注意环境变量问题"><a href="#注意环境变量问题" class="headerlink" title="注意环境变量问题"></a>注意环境变量问题</h4><p>有时我们创建了一个crontab，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在crontab文件中没有配置环境变量引起的。</p>
<p>在crontab文件中定义多个调度任务时，需要特别注意的一个问题就是环境变量的设置，因为我们手动执行某个任务时，是在当前shell环境下进行的，程序当然能找到环境变量，而系统自动执行任务调度时，是不会加载任何环境变量的，因此，就需要在crontab文件中指定任务运行所需的所有环境变量，这样，系统执行任务调度时就没有问题了。</p>
<p>不要假定cron知道所需要的特殊环境，它其实并不知道。所以你要保证在shelll脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。所以注意如下3点：</p>
<ul>
<li><p>脚本中涉及文件路径时写全局路径；</p>
</li>
<li><p>脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如：</p>
<p>​</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat start_cbp.sh</span><br><span class="line">#!/bin/sh</span><br><span class="line">source /etc/profile</span><br><span class="line">export RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf</span><br><span class="line">/usr/local/jboss-4.0.5/bin/run.sh -c mev &amp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当手动执行脚本OK，但是crontab死活不执行时。这时必须大胆怀疑是环境变量惹的祸，并可以尝试在crontab中直接引入环境变量解决问题，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 * * * * . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="注意清理系统用户的邮件日志"><a href="#注意清理系统用户的邮件日志" class="headerlink" title="注意清理系统用户的邮件日志"></a>注意清理系统用户的邮件日志</h4><p>每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。</p>
<p>例如，可以在crontab文件中设置如下形式，忽略日志输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 */3 * * * /usr/local/apache2/apachectl restart &gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p>“/dev/null 2&gt;&amp;1” 表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。</p>
<h4 id="系统级任务调度与用户级任务调度"><a href="#系统级任务调度与用户级任务调度" class="headerlink" title="系统级任务调度与用户级任务调度"></a>系统级任务调度与用户级任务调度</h4><p>系统级任务调度主要完成系统的一些维护操作，用户级任务调度主要完成用户自定义的一些任务，可以将用户级任务调度放到系统级任务调度来完成（<strong>不建议这么做</strong>），但是反过来却不行。</p>
<p>root用户的任务调度操作可以通过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab –uroot –e</span><br></pre></td></tr></table></figure>
<p>来设置，也可以将调度任务直接写入/etc/crontab文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件，即使在root用户下创建一个定时重启系统的任务也是无效的。</p>
<h4 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h4><p>新创建的cron 任务，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。当 crontab 突然失效时，可以尝试/etc/init.d/crond restart解决问题。或者查看日志看某个job有没有执行/报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -f /var/log/cron</span><br></pre></td></tr></table></figure>
<p>千万别乱运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -r</span><br></pre></td></tr></table></figure>
<p>它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab都没了。</p>
<p>在crontab中%是有特殊含义的，表示换行的意思。如果要用的话必须进行转义\%，如经常用的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date &apos;+%Y%m%d&apos;</span><br></pre></td></tr></table></figure>
<p>在crontab里是不会执行的，应该换成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date &apos;+\%Y\%m\%d&apos;</span><br></pre></td></tr></table></figure>
<p>Read More: </p>
<blockquote>
<p><a href="http://www.cnblogs.com/peida/archive/2013/01/08/2850483.html" target="_blank" rel="noopener">每天一个linux命令（50）：crontab命令</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux/Unix</category>
      </categories>
      <tags>
        <tag>命令</tag>
        <tag>Linux</tag>
        <tag>crontab</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令 - tar</title>
    <url>/2018/01/04/linuxtar/</url>
    <content><![CDATA[<p>通过SSH访问服务器，难免会要用到压缩、解压缩、打包、解包等操作，这时候<code>tar</code>命令是必不可少的一个功能强大的工具。</p>
<p>tar命令可以为Linux的文件和目录创建档案。利用<code>tar</code>可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。<code>tar</code>最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。</p>
<p>首先区分一下打包和压缩的概念：</p>
<ul>
<li>打包是将一大堆文件或目录变成一个总的文件；</li>
<li>压缩是将一个大的文件通过一些压缩算法变成一个小文件。</li>
</ul>
<p>为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（<code>tar</code>命令），然后再用压缩程序进行压缩（<code>gzip</code>、<code>bzip2</code>命令）。</p>
<p>Linux下最常用的打包程序就是<code>tar</code>了，使用<code>tar</code>程序打出来的包我们常称为<code>tar</code>包，<code>tar</code>包文件的命令通常都是以<code>.tar</code>结尾的。生成<code>tar</code>包后，就可以用其它的程序来进行压缩。</p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar [参数] [文件]</span><br></pre></td></tr></table></figure>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>用来压缩和解压文件，<code>tar</code>本身不具有压缩功能，是调用压缩功能实现的压缩。</p>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-A</td>
<td>新增文件到以存在的备份文件</td>
</tr>
<tr>
<td>-B</td>
<td>设置区块大小</td>
</tr>
<tr>
<td>-c</td>
<td>建立新的备份文件</td>
</tr>
<tr>
<td>-C &lt;目录&gt;</td>
<td>这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项</td>
</tr>
<tr>
<td>-d</td>
<td>记录文件的差别</td>
</tr>
<tr>
<td>-r</td>
<td>添加文件到已经压缩的文件</td>
</tr>
<tr>
<td>-u</td>
<td>添加改变了和现有的文件到已经存在的压缩文件</td>
</tr>
<tr>
<td>-x</td>
<td>从备份文件中还原文件</td>
</tr>
<tr>
<td>-t</td>
<td>列出备份文件的内容</td>
</tr>
<tr>
<td>-z</td>
<td>通过gzip指令处理备份文件</td>
</tr>
<tr>
<td>-j</td>
<td>支持bzip2解压文件</td>
</tr>
<tr>
<td>-Z</td>
<td>通过compress指令处理备份文件</td>
</tr>
<tr>
<td>-v</td>
<td>显示操作过程</td>
</tr>
<tr>
<td>-l</td>
<td>文件系统边界设置</td>
</tr>
<tr>
<td>-k</td>
<td>保留原有文件不覆盖</td>
</tr>
<tr>
<td>-m</td>
<td>保留文件不被覆盖</td>
</tr>
<tr>
<td>-w</td>
<td>确认压缩文件的正确性</td>
</tr>
<tr>
<td>-f &lt;备份文件&gt;</td>
<td>指定备份文件</td>
</tr>
<tr>
<td>-b &lt;区块数目&gt;</td>
<td>设置每笔记录的区块数目，每个区块大小为12Bytes</td>
</tr>
<tr>
<td>-p</td>
<td>用原来的文件权限还原文件</td>
</tr>
<tr>
<td>-P</td>
<td>文件名使用绝对名称，不移除文件名称前的”/“号</td>
</tr>
<tr>
<td>-N</td>
<td>只将较指定日期更新的文件保存到备份文件里</td>
</tr>
<tr>
<td>–version</td>
<td>显示版本信息</td>
</tr>
<tr>
<td>–exclude &lt;文件&gt;</td>
<td>排除某个文件</td>
</tr>
</tbody>
</table>
<h4 id="常见的解压-压缩命令"><a href="#常见的解压-压缩命令" class="headerlink" title="常见的解压/压缩命令"></a>常见的解压/压缩命令</h4><p><code>.tar</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解包：tar xvf FileName.tar</span><br><span class="line">打包：tar cvf FileName.tar DirName</span><br></pre></td></tr></table></figure>
<p><code>.gz</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解压1：gunzip FileName.gz</span><br><span class="line">解压2：gzip -d FileName.gz</span><br><span class="line">压缩：gzip FileName</span><br></pre></td></tr></table></figure>
<p><code>.tar.gz</code>文件 和 <code>.tgz</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解压：tar zxvf FileName.tar.gz</span><br><span class="line">压缩：tar zcvf FileName.tar.gz DirName</span><br></pre></td></tr></table></figure>
<p><code>.bz2</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解压1：bzip2 -d FileName.bz2</span><br><span class="line">解压2：bunzip2 FileName.bz2</span><br><span class="line">压缩： bzip2 -z FileName</span><br></pre></td></tr></table></figure>
<p><code>.tar.bz2</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解压：tar jxvf FileName.tar.bz2</span><br><span class="line">压缩：tar jcvf FileName.tar.bz2 DirName</span><br></pre></td></tr></table></figure>
<p><code>.bz</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解压1：bzip2 -d FileName.bz</span><br><span class="line">解压2：bunzip2 FileName.bz</span><br><span class="line">压缩：未知</span><br></pre></td></tr></table></figure>
<p><code>.tar.bz</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解压：tar jxvf FileName.tar.bz</span><br><span class="line">压缩：未知</span><br></pre></td></tr></table></figure>
<p><code>.Z</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解压：uncompress FileName.Z</span><br><span class="line">压缩：compress FileName</span><br></pre></td></tr></table></figure>
<p><code>.tar.Z</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解压：tar Zxvf FileName.tar.Z</span><br><span class="line">压缩：tar Zcvf FileName.tar.Z DirName</span><br></pre></td></tr></table></figure>
<p><code>.zip</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解压：unzip FileName.zip</span><br><span class="line">压缩：zip FileName.zip DirName</span><br></pre></td></tr></table></figure>
<p><code>.rar</code>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">解压：rar x FileName.rar</span><br><span class="line">压缩：rar a FileName.rar DirName</span><br></pre></td></tr></table></figure>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><ul>
<li>tar -cvf testlog.tar testlog.log | tar -zcvf testlog.tar.gz testlog.log | tar -jcvf testlog.tar.bz2 testlog.log</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt testtar]# ll</span><br><span class="line">total 4</span><br><span class="line">-rw-r--r-- 1 root root 94 Jan  4 17:07 testlog.log</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testtar]# tar -cvf testlog.tar testlog.log </span><br><span class="line">testlog.log</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testtar]# tar -zcvf testlog.tar.gz testlog.log </span><br><span class="line">testlog.log</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testtar]# tar -jcvf testlog.tar.bz2 testlog.log </span><br><span class="line">testlog.log</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testtar]# ll</span><br><span class="line">total 24</span><br><span class="line">-rw-r--r-- 1 root root    94 Jan  4 17:07 testlog.log</span><br><span class="line">-rw-r--r-- 1 root root 10240 Jan  4 17:08 testlog.tar</span><br><span class="line">-rw-r--r-- 1 root root   128 Jan  4 17:08 testlog.tar.bz2</span><br><span class="line">-rw-r--r-- 1 root root   125 Jan  4 17:08 testlog.tar.gz</span><br></pre></td></tr></table></figure>
<p>将文件只打包不压缩、以gzip压缩、以bzip2压缩。</p>
<ul>
<li>tar -ztvf testlog.tar.gz</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt testtar]# tar -ztvf testlog.tar.gz </span><br><span class="line">-rw-r--r-- root/root        94 2018-01-04 17:07 testlog.log</span><br></pre></td></tr></table></figure>
<p>查看testlog.tar.gz中有哪些文件。</p>
<ul>
<li>tar -zxvf testlog.tar.gz</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt testtar]# ll</span><br><span class="line">total 24</span><br><span class="line">drwxr-xr-x 2 root root  4096 Jan  4 17:17 testlog</span><br><span class="line">-rw-r--r-- 1 root root 10240 Jan  4 17:08 testlog.tar</span><br><span class="line">-rw-r--r-- 1 root root   128 Jan  4 17:08 testlog.tar.bz2</span><br><span class="line">-rw-r--r-- 1 root root   125 Jan  4 17:08 testlog.tar.gz</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testtar]# tar -zxvf testlog.tar.gz</span><br><span class="line">testlog.log</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testtar]# ll</span><br><span class="line">total 28</span><br><span class="line">drwxr-xr-x 2 root root  4096 Jan  4 17:17 testlog</span><br><span class="line">-rw-r--r-- 1 root root    94 Jan  4 17:07 testlog.log</span><br><span class="line">-rw-r--r-- 1 root root 10240 Jan  4 17:08 testlog.tar</span><br><span class="line">-rw-r--r-- 1 root root   128 Jan  4 17:08 testlog.tar.bz2</span><br><span class="line">-rw-r--r-- 1 root root   125 Jan  4 17:08 testlog.tar.gz</span><br></pre></td></tr></table></figure>
<p>将testlog.tar.gz解压缩。</p>
<ul>
<li>tar -zcvf testlogs.tar.gz testlog1.log</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt testtar]# tar -zcvf testlogs.tar.gz testlog1.log testlog2.log </span><br><span class="line">testlog1.log</span><br><span class="line">testlog2.log</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testtar]# ll</span><br><span class="line">total 36</span><br><span class="line">drwxr-xr-x 2 root root  4096 Jan  4 17:17 testlog</span><br><span class="line">-rw-r--r-- 1 root root    13 Jan  4 17:21 testlog1.log</span><br><span class="line">-rw-r--r-- 1 root root    25 Jan  4 17:21 testlog2.log</span><br><span class="line">-rw-r--r-- 1 root root   152 Jan  4 17:21 testlogs.tar.gz</span><br><span class="line">-rw-r--r-- 1 root root 10240 Jan  4 17:08 testlog.tar</span><br><span class="line">-rw-r--r-- 1 root root   128 Jan  4 17:08 testlog.tar.bz2</span><br><span class="line">-rw-r--r-- 1 root root   125 Jan  4 17:08 testlog.tar.gz</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testtar]# tar -ztvf testlogs.tar.gz </span><br><span class="line">-rw-r--r-- root/root        13 2018-01-04 17:21 testlog1.log</span><br><span class="line">-rw-r--r-- root/root        25 2018-01-04 17:21 testlog2.log</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testtar]# rm -rf testlog1.log </span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testtar]# ll</span><br><span class="line">total 32</span><br><span class="line">drwxr-xr-x 2 root root  4096 Jan  4 17:17 testlog</span><br><span class="line">-rw-r--r-- 1 root root    25 Jan  4 17:21 testlog2.log</span><br><span class="line">-rw-r--r-- 1 root root   152 Jan  4 17:21 testlogs.tar.gz</span><br><span class="line">-rw-r--r-- 1 root root 10240 Jan  4 17:08 testlog.tar</span><br><span class="line">-rw-r--r-- 1 root root   128 Jan  4 17:08 testlog.tar.bz2</span><br><span class="line">-rw-r--r-- 1 root root   125 Jan  4 17:08 testlog.tar.gz</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testtar]# tar -zxvf testlogs.tar.gz testlog1.log</span><br><span class="line">testlog1.log</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt testtar]# ll</span><br><span class="line">total 36</span><br><span class="line">drwxr-xr-x 2 root root  4096 Jan  4 17:17 testlog</span><br><span class="line">-rw-r--r-- 1 root root    13 Jan  4 17:21 testlog1.log</span><br><span class="line">-rw-r--r-- 1 root root    25 Jan  4 17:21 testlog2.log</span><br><span class="line">-rw-r--r-- 1 root root   152 Jan  4 17:21 testlogs.tar.gz</span><br><span class="line">-rw-r--r-- 1 root root 10240 Jan  4 17:08 testlog.tar</span><br><span class="line">-rw-r--r-- 1 root root   128 Jan  4 17:08 testlog.tar.bz2</span><br><span class="line">-rw-r--r-- 1 root root   125 Jan  4 17:08 testlog.tar.gz</span><br></pre></td></tr></table></figure>
<p>从压缩包中解压出指定文件。</p>
<ul>
<li>tar -N “2018/01/03” -zcvf testlog.tar.gz test: 指定文件夹中的文件比某个日期新的才备份</li>
<li>tar –exclude testlog/testlog1.log -zcvf testlogs.tar.gz testlog/*: 排除文件夹中的某个文件</li>
</ul>
<p>Read More：</p>
<blockquote>
<p><a href="http://www.cnblogs.com/peida/archive/2012/11/30/2795656.html" target="_blank" rel="noopener">每天一个linux命令（28）：tar命令</a> <a href="http://www.runoob.com/linux/linux-comm-tar.html" target="_blank" rel="noopener">Linux tar命令</a>  <a href="http://wangchujiang.com/linux-command/c/tar.html" target="_blank" rel="noopener">tar</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>Linux/Unix</category>
      </categories>
      <tags>
        <tag>命令</tag>
        <tag>Linux</tag>
        <tag>tar</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令 - top</title>
    <url>/2017/06/07/linuxtop/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>top 命令是 Linux 下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。</p>
<p>top 显示系统当前的进程和其他状况，是一个动态显示过程，即可以通过用户按键来不断刷新当前状态。如果在前台执行该命令，它将独占前台，直到用户终止该程序为止。比较准确的说，top命令提供了实时的对系统处理器的状态监视。它将显示系统中CPU最“敏感”的任务列表。该命令可以按CPU使用、内存使用、执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定。</p>
<h3 id="参数含义"><a href="#参数含义" class="headerlink" title="参数含义"></a>参数含义</h3><p><img src="/images/2017-6-7 095218.png" alt="2017-6-7 095218"></p>
<p>统计信息区前五行是系统整体的统计信息。</p>
<p>第一行是任务队列信息，同 uptime 命令的执行结果。其内容如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>09:51:29</td>
<td>当前时间</td>
</tr>
<tr>
<td>up 423 days</td>
<td>已经运行天数</td>
</tr>
<tr>
<td>15:28</td>
<td>系统运行时间，格式为时:分</td>
</tr>
<tr>
<td>5 users</td>
<td>当前登录用户数</td>
</tr>
<tr>
<td>load average: 0.09, 0.04, 0.05</td>
<td>系统负载，即任务队列的平均长度。三个数值分别为 1分钟、5分钟、15分钟前到现在的平均值。</td>
</tr>
</tbody>
</table>
<p>第二行是进程信息。其内容如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>143 total</td>
<td>进程总数</td>
</tr>
<tr>
<td>2 running</td>
<td>正在运行的进程数</td>
</tr>
<tr>
<td>138 sleeping</td>
<td>睡眠的进程数</td>
</tr>
<tr>
<td>0 stopped</td>
<td>停止的进程数</td>
</tr>
<tr>
<td>3 zombie</td>
<td>僵尸进程数</td>
</tr>
</tbody>
</table>
<p>第三行是CPU信息。其内容如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.0 us</td>
<td>用户空间占用CPU百分比</td>
</tr>
<tr>
<td>0.3 sy</td>
<td>内核空间占用CPU百分比</td>
</tr>
<tr>
<td>0.0 ni</td>
<td>用户进程空间内改变过优先级的进程占用CPU百分比</td>
</tr>
<tr>
<td>97.7 id</td>
<td>空闲CPU百分比</td>
</tr>
<tr>
<td>1.0 wa</td>
<td>等待输入输出的CPU时间百分比</td>
</tr>
<tr>
<td>0.0 hi</td>
<td>硬件CPU中断占用百分比</td>
</tr>
<tr>
<td>0.0 si</td>
<td>软中断占用百分比</td>
</tr>
<tr>
<td>0.0 st</td>
<td>虚拟机占用百分比</td>
</tr>
</tbody>
</table>
<p>最后两行是内存信息。其内容如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>KiB Mem：</td>
<td></td>
</tr>
<tr>
<td>1016656 total</td>
<td>物理内存总量</td>
</tr>
<tr>
<td>936036 used</td>
<td>使用的物理内存总量</td>
</tr>
<tr>
<td>80620 free</td>
<td>空闲内存总量</td>
</tr>
<tr>
<td>77144 buffers</td>
<td>用作内核缓存的内存量</td>
</tr>
<tr>
<td>KiB Swap：</td>
<td></td>
</tr>
<tr>
<td>0 total</td>
<td>交换区总量</td>
</tr>
<tr>
<td>0 used</td>
<td>使用的交换区总量</td>
</tr>
<tr>
<td>0 free</td>
<td>空闲交换区总量</td>
</tr>
<tr>
<td>178128 cached Mem</td>
<td>缓冲的交换区总量，内存中的内容被换出到交换区，而后又被换入到内存，但使用过的交换区尚未被覆盖，该数值即为这些内容已存在于内存中的交换区的大小,相应的内存再次被换出时可不必再对交换区写入。</td>
</tr>
</tbody>
</table>
<p>进程信息区统计信息区域的下方显示了各个进程的详细信息。首先来认识一下各列的含义。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>列名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>PID</td>
<td>进程id</td>
</tr>
<tr>
<td>2</td>
<td>PPID</td>
<td>父进程id</td>
</tr>
<tr>
<td>3</td>
<td>RUSER</td>
<td>真正的用户名</td>
</tr>
<tr>
<td>4</td>
<td>UID</td>
<td>进程所有者的用户id</td>
</tr>
<tr>
<td>5</td>
<td>USER</td>
<td>进程所有者的用户名</td>
</tr>
<tr>
<td>6</td>
<td>GROUP</td>
<td>进程所有者的组名</td>
</tr>
<tr>
<td>7</td>
<td>TTY</td>
<td>启动进程的终端名。不是从终端启动的进程则显示为 ?</td>
</tr>
<tr>
<td>8</td>
<td>PR</td>
<td>优先级</td>
</tr>
<tr>
<td>9</td>
<td>NI</td>
<td>nice值。负值表示高优先级，正值表示低优先级</td>
</tr>
<tr>
<td>10</td>
<td>P</td>
<td>最后使用的CPU，仅在多CPU环境下有意义</td>
</tr>
<tr>
<td>11</td>
<td>%CPU</td>
<td>上次更新到现在的CPU时间占用百分比</td>
</tr>
<tr>
<td>12</td>
<td>TIME</td>
<td>进程使用的CPU时间总计，单位秒</td>
</tr>
<tr>
<td>13</td>
<td>TIME+</td>
<td>进程使用的CPU时间总计，单位1/100秒</td>
</tr>
<tr>
<td>14</td>
<td>%MEM</td>
<td>进程使用的物理内存百分比</td>
</tr>
<tr>
<td>15</td>
<td>VIRT</td>
<td>进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</td>
</tr>
<tr>
<td>16</td>
<td>SWAP</td>
<td>进程使用的虚拟内存中，被换出的大小，单位kb。</td>
</tr>
<tr>
<td>17</td>
<td>RES</td>
<td>进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</td>
</tr>
<tr>
<td>18</td>
<td>CODE</td>
<td>可执行代码占用的物理内存大小，单位kb</td>
</tr>
<tr>
<td>19</td>
<td>DATA</td>
<td>可执行代码以外的部分(数据段+栈)占用的物理内存大小，单位kb</td>
</tr>
<tr>
<td>20</td>
<td>SHR</td>
<td>共享内存大小，单位kb</td>
</tr>
<tr>
<td>21</td>
<td>nFLT</td>
<td>页面错误次数</td>
</tr>
<tr>
<td>22</td>
<td>nDRT</td>
<td>最后一次写入到现在，被修改过的页面数。</td>
</tr>
<tr>
<td>23</td>
<td>S</td>
<td>进程状态(D=不可中断的睡眠状态,R=运行,S=睡眠,T=跟踪/停止,Z=僵尸进程)</td>
</tr>
<tr>
<td>24</td>
<td>COMMAND</td>
<td>命令名/命令行</td>
</tr>
<tr>
<td>25</td>
<td>WCHAN</td>
<td>若该进程在睡眠，则显示睡眠中的系统函数名</td>
</tr>
<tr>
<td>26</td>
<td>Flags</td>
<td>任务标志，参考 sched.h</td>
</tr>
</tbody>
</table>
<p>默认情况下仅显示比较重要的 PID、USER、PR、NI、VIRT、RES、SHR、S、%CPU、%MEM、TIME+、COMMAND 列。</p>
<p>可以通过下面的快捷键来更改显示内容。 更改显示内容通过 f 键可以选择显示的内容。按 f 键之后会显示列的列表，按 a-z 即可显示或隐藏对应的列，最后按回车键确定。 按 o 键可以改变列的显示顺序。按小写的 a-z 可以将相应的列向右移动，而大写的 A-Z 可以将相应的列向左移动。最后按回车键确定。 按大写的 F 或 O 键，然后按 a-z 可以将进程按照相应的列进行排序。而大写的 R 键可以将当前的排序倒转。</p>
<h3 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h3><p>top 使用格式</p>
<p><code>top [-] [d] [q] [c] [S] [s] [i] [n] [b]</code></p>
<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>d</td>
<td>改变显示的更新速度，或是在交互式指令列( interactive command)按 s</td>
</tr>
<tr>
<td>q</td>
<td>没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行</td>
</tr>
<tr>
<td>c</td>
<td>切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称S : 累积模式，会将己完成或消失的子行程 ( dead child process ) 的 CPU time 累积起来</td>
</tr>
<tr>
<td>s</td>
<td>安全模式，将交互式指令取消, 避免潜在的危机</td>
</tr>
<tr>
<td>i</td>
<td>不显示任何闲置 (idle) 或无用 (zombie) 的行程</td>
</tr>
<tr>
<td>n</td>
<td>更新的次数，完成后将会退出 top</td>
</tr>
<tr>
<td>b</td>
<td>批次档模式，搭配 “n” 参数一起使用，可以用来将 top 的结果输出到档案内</td>
</tr>
</tbody>
</table>
<h4 id="交互命令"><a href="#交互命令" class="headerlink" title="交互命令"></a>交互命令</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>h / ?</td>
<td>显示帮助画面，给出一些简短的命令总结说明</td>
</tr>
<tr>
<td>k</td>
<td>终止一个进程。系统将提示用户输入需要终止的进程PID，以及需要发送给该进程什么样的信号。一般的终止进程可以使用15信号；如果不能正常结束那就使用信号9强制结束该进程。默认值是信号15。在安全模式中此命令被屏蔽</td>
</tr>
<tr>
<td>i</td>
<td>忽略闲置和僵死进程。这是一个开关式命令</td>
</tr>
<tr>
<td>q</td>
<td>退出程序</td>
</tr>
<tr>
<td>r</td>
<td>重新安排一个进程的优先级别。系统提示用户输入需要改变的进程PID以及需要设置的进程优先级值。输入一个正值将使优先级降低，反之则可以使该进程拥有更高的优先权。默认值是10</td>
</tr>
<tr>
<td>S</td>
<td>切换到累计模式</td>
</tr>
<tr>
<td>s</td>
<td>改变两次刷新之间的延迟时间。系统将提示用户输入新的时间，单位为s。如果有小数，就换算成m s。输入0值则系统将不断刷新，默认值是5 s。需要注意的是如果设置太小的时间，很可能会引起不断刷新，从而根本来不及看清显示的情况，而且系统负载也会大大增加</td>
</tr>
<tr>
<td>f / F</td>
<td>从当前显示中添加或者删除项目</td>
</tr>
<tr>
<td>o / O</td>
<td>改变显示项目的顺序</td>
</tr>
<tr>
<td>l</td>
<td>切换显示平均负载和启动时间信息</td>
</tr>
<tr>
<td>m</td>
<td>切换显示内存信息</td>
</tr>
<tr>
<td>t</td>
<td>切换显示进程和CPU状态信息</td>
</tr>
<tr>
<td>c</td>
<td>切换显示命令名称和完整命令行</td>
</tr>
<tr>
<td>M</td>
<td>根据驻留内存大小进行排序</td>
</tr>
<tr>
<td>P</td>
<td>根据CPU使用百分比大小进行排序</td>
</tr>
<tr>
<td>T</td>
<td>根据时间/累计时间进行排序</td>
</tr>
<tr>
<td>W</td>
<td>将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法</td>
</tr>
</tbody>
</table>
<h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>top</td>
<td>每隔5秒显式所有进程的资源占用情况</td>
</tr>
<tr>
<td>top -d 2</td>
<td>每隔2秒显式所有进程的资源占用情况</td>
</tr>
<tr>
<td>top -c</td>
<td>每隔5秒显式进程的资源占用情况，并显示进程的命令行参数(默认只有进程名)</td>
</tr>
<tr>
<td>top -p 12345 -p 6789</td>
<td>每隔5秒显示pid是12345和pid是6789的两个进程的资源占用情况</td>
</tr>
<tr>
<td>top -d 2 -c -p 123456</td>
<td>每隔2秒显示pid是12345的进程的资源使用情况，并显示该进程启动的命令行参数</td>
</tr>
</tbody>
</table>
<h4 id="Load-Average"><a href="#Load-Average" class="headerlink" title="Load Average"></a>Load Average</h4><p>平均负载 (load average) 是指系统的运行队列的平均利用率，也可以认为是可运行进程的平均数。通过系统命令”w” 或”top”可以查看当前 load average 情况。</p>
<p>第一位：表示最近1分钟平均负载；<br>第二位：表示最近5分钟平均负载；<br>第三位：表示最近15分钟平均负载。</p>
<p>假设我们的系统是单CPU单内核的，把它比喻成是一条单向马路，把CPU任务比作汽车。当车不多的时候，load &lt; 1；当车占满整个马路的时候 load = 1；当马路都站满了，而且马路外还堆满了汽车的时候，load &gt; 1。</p>
<p>我们经常会发现服务器Load &gt; 1但是运行仍然不错，那是因为服务器是多核处理器。假设我们服务器CPU是2核，那么将意味我们拥有2条马路，我们的Load = 2时，所有马路都跑满车辆。</p>
<ul>
<li>0.7 &lt; load &lt; 1：此时是不错的状态，如果进来更多的汽车，你的马路仍然可以应付；</li>
<li>load = 1：你的马路即将拥堵，而且没有更多的资源额外的任务，赶紧看看发生了什么吧；</li>
<li>load &gt; 5：非常严重拥堵，我们的马路非常繁忙，每辆车都无法很快的运行。</li>
</ul>
<p>通常我们先看15分钟load，如果load很高，再看1分钟和5分钟负载，查看是否有下降趋势。1分钟负载值 &gt; 1，那么我们不用担心，但是如果15分钟负载都超过1，我们要赶紧看看发生了什么事情。所以我们要根据实际情况查看这三个值。</p>
<p>Read More:</p>
<blockquote>
<p><a href="http://www.cnblogs.com/kaituorensheng/p/3602805.html" target="_blank" rel="noopener">Linux系统中的load average</a>  <a href="http://www.cnblogs.com/ghj1976/p/5611220.html" target="_blank" rel="noopener">linux 平均负载 load average 的含义</a>  <a href="http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316399.html" target="_blank" rel="noopener">linux的top命令参数详解</a>  <a href="http://www.runoob.com/linux/linux-comm-top.html" target="_blank" rel="noopener">Linux top命令</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux/Unix</category>
      </categories>
      <tags>
        <tag>命令</tag>
        <tag>Linux</tag>
        <tag>top</tag>
      </tags>
  </entry>
  <entry>
    <title>秒杀系统设计03 - 如何才能做好动静分离？有哪些方案可选？</title>
    <url>/2021/07/04/miaosha03/</url>
    <content><![CDATA[<p>上一篇文章中，我介绍了秒杀系统在架构上要考虑的几个原则，我估计你很快就会问：“知易行难，这些原则应该怎么应用到系统中呢？”别急，从这篇文章开始，我就会逐一介绍秒杀系统的各个关键环节中涉及的关键技术。</p>
<p>今天我们就先来讨论第一个关键点：数据的动静分离。不知道你之前听过这个解决方案吗？不管你有没有听过，我都建议你先停下来思考动静分离的价值。如果你的系统还没有开始应用动静分离的方案，那你也可以想想为什么没有，是之前没有想到，还是说业务体量根本用不着？</p>
<p>不过我可以确信地说，如果你在一个业务飞速发展的公司里，并且你在深度参与公司内类秒杀类系统的架构或者开发工作，那么你迟早会想到动静分离的方案。为什么？很简单，<strong>秒杀的场景中，对于系统的要求其实就三个字：快、准、稳</strong>。</p>
<p>那怎么才能“快”起来呢？我觉得抽象起来讲，就只有两点，一点是提高单次请求的效率，一点是减少没必要的请求。今天我们聊到的“动静分离”其实就是瞄着这个大方向去的。</p>
<p>不知道你是否还记得，最早的秒杀系统其实是要刷新整体页面的，但后来秒杀的时候，你只要点击“刷新抢宝”按钮就够了，这种变化的本质就是动静分离，分离之后，客户端大幅度减少了请求的数据量。这不自然就“快”了吗？</p>
<h3 id="何为动静数据"><a href="#何为动静数据" class="headerlink" title="何为动静数据"></a>何为动静数据</h3><p>那到底什么才是动静分离呢？所谓“动静分离”，其实就是把用户请求的数据（如 HTML 页面）划分为“动态数据”和“静态数据”。</p>
<p>简单来说，<strong>“动态数据”和“静态数据”的主要区别就是看页面中输出的数据是否和 URL、浏览者、时间、地域相关，以及是否含有 Cookie 等私密数据</strong>。比如说：</p>
<ol>
<li>很多媒体类的网站，某一篇文章的内容不管是你访问还是我访问，它都是一样的。所以它就是一个典型的静态数据，但是它是个动态页面。</li>
<li>我们如果现在访问淘宝的首页，每个人看到的页面可能都是不一样的，淘宝首页中包含了很多根据访问者特征推荐的信息，而这些个性化的数据就可以理解为动态数据了。</li>
</ol>
<p>这里再强调一下，我们所说的静态数据，不能仅仅理解为传统意义上完全存在磁盘上的 HTML 页面，它也可能是经过 Java 系统产生的页面，但是它输出的页面本身不包含上面所说的那些因素。也就是所谓“动态”还是“静态”，并不是说数据本身是否动静，而是数据中是否含有和访问者相关的个性化数据。</p>
<p>还有一点要注意，就是页面中“不包含”，指的是“页面的 HTML 源码中不含有”，这一点务必要清楚。</p>
<p>理解了静态数据和动态数据，我估计你很容易就能想明白“动静分离”这个方案的来龙去脉了。分离了动静数据，我们就可以对分离出来的静态数据做缓存，有了缓存之后，静态数据的“访问效率”自然就提高了。</p>
<p>那么，怎样对静态数据做缓存呢？我在这里总结了几个重点。</p>
<p><strong>第一，你应该把静态数据缓存到离用户最近的地方</strong>。静态数据就是那些相对不会变化的数据，因此我们可以把它们缓存起来。缓存到哪里呢？常见的就三种，用户浏览器里、CDN 上或者在服务端的 Cache 中。你应该根据情况，把它们尽量缓存到离用户最近的地方。</p>
<p><strong>第二，静态化改造就是要直接缓存 HTTP 连接</strong>。相较于普通的数据缓存而言，你肯定还听过系统的静态化改造。静态化改造是直接缓存 HTTP 连接而不是仅仅缓存数据，如下图所示，Web 代理服务器根据请求 URL，直接取出对应的 HTTP 响应头和响应体然后直接返回，这个响应过程简单得连 HTTP 协议都不用重新组装，甚至连 HTTP 请求头也不需要解析。</p>
<p><img src="/images/2021-7-4101533.png" alt="2021-7-4101533.png"></p>
<p><strong>第三，让谁来缓存静态数据也很重要</strong>。不同语言写的 Cache 软件处理缓存数据的效率也各不相同。以 Java 为例，因为 Java 系统本身也有其弱点（比如不擅长处理大量连接请求，每个连接消耗的内存较多，Servlet 容器解析 HTTP 协议较慢），所以你可以不在 Java 层做缓存，而是直接在 Web 服务器层上做，这样你就可以屏蔽 Java 语言层面的一些弱点；而相比起来，Web 服务器（如 Nginx、Apache、Varnish）也更擅长处理大并发的静态文件请求。</p>
<h3 id="如何做动静分离的改造"><a href="#如何做动静分离的改造" class="headerlink" title="如何做动静分离的改造"></a>如何做动静分离的改造</h3><p>理解了动静态数据的“why”和“what”，接下来我们就要看“how”了。我们如何把动态页面改造成适合缓存的静态页面呢？其实也很简单，就是去除前面所说的那几个影响因素，把它们单独分离出来，做动静分离。</p>
<p>下面，我以典型的商品详情系统为例来详细介绍。这里，你可以先打开京东或者淘宝的商品详情页，看看这个页面里都有哪些动静数据。我们从以下 5 个方面来分离出动态内容。</p>
<ol>
<li><strong>URL 唯一化</strong>。商品详情系统天然地就可以做到 URL 唯一化，比如每个商品都由 ID 来标识，那么 <a href="http://item.xxx.com/item.htm?id=xxxx" target="_blank" rel="noopener">http://item.xxx.com/item.htm?id=xxxx</a> 就可以作为唯一的 URL 标识。为啥要 URL 唯一呢？前面说了我们是要缓存整个 HTTP 连接，那么以什么作为 Key 呢？就以 URL 作为缓存的 Key，例如以 id=xxx 这个格式进行区分。</li>
<li><strong>分离浏览者相关的因素</strong>。浏览者相关的因素包括是否已登录，以及登录身份等，这些相关因素我们可以单独拆分出来，通过动态请求来获取。</li>
<li><strong>分离时间因素</strong>。服务端输出的时间也通过动态请求获取。</li>
<li><strong>异步化地域因素</strong>。详情页面上与地域相关的因素做成异步方式获取，当然你也可以通过动态请求方式获取，只是这里通过异步获取更合适。</li>
<li><strong>去掉 Cookie</strong>。服务端输出的页面包含的 Cookie 可以通过代码软件来删除，如 Web 服务器 Varnish 可以通过 unset req.http.cookie 命令去掉 Cookie。注意，这里说的去掉 Cookie 并不是用户端收到的页面就不含 Cookie 了，而是说，在缓存的静态数据中不含有 Cookie。</li>
</ol>
<p>分离出动态内容之后，如何组织这些内容页就变得非常关键了。这里我要提醒你一点，因为这其中很多动态内容都会被页面中的其他模块用到，如判断该用户是否已登录、用户 ID 是否匹配等，所以这个时候我们应该将这些信息 JSON 化（用 JSON 格式组织这些数据），以方便前端获取。</p>
<p>前面我们介绍里用缓存的方式来处理静态数据。而动态内容的处理通常有两种方案：ESI（Edge Side Includes）方案和 CSI（Client Side Include）方案。</p>
<ol>
<li><strong>ESI 方案（或者 SSI）</strong>：即在 Web 代理服务器上做动态内容请求，并将请求插入到静态页面中，当用户拿到页面时已经是一个完整的页面了。这种方式对服务端性能有些影响，但是用户体验较好。</li>
<li><strong>CSI 方案</strong>。即单独发起一个异步 JavaScript 请求，以向服务端获取动态内容。这种方式服务端性能更佳，但是用户端页面可能会延时，体验稍差。</li>
</ol>
<h3 id="动静分离的几种架构方案"><a href="#动静分离的几种架构方案" class="headerlink" title="动静分离的几种架构方案"></a>动静分离的几种架构方案</h3><p>前面我们通过改造把静态数据和动态数据做了分离，那么如何在系统架构上进一步对这些动态和静态数据重新组合，再完整地输出给用户呢？</p>
<p>这就涉及对用户请求路径进行合理的架构了。根据架构上的复杂度，有 3 种方案可选：</p>
<ol>
<li>实体机单机部署；</li>
<li>统一 Cache 层；</li>
<li>上 CDN。</li>
</ol>
<h4 id="方案-1：实体机单机部署"><a href="#方案-1：实体机单机部署" class="headerlink" title="方案 1：实体机单机部署"></a>方案 1：实体机单机部署</h4><p>这种方案是将虚拟机改为实体机，以增大 Cache 的容量，并且采用了一致性 Hash 分组的方式来提升命中率。这里将 Cache 分成若干组，是希望能达到命中率和访问热点的平衡。Hash 分组越少，缓存的命中率肯定就会越高，但短板是也会使单个商品集中在一个分组中，容易导致 Cache 被击穿，所以我们应该适当增加多个相同的分组，来平衡访问热点和命中率的问题。</p>
<p>这里我给出了实体机单机部署方案的结构图，如下：</p>
<p><img src="/images/2021-7-4101659.png" alt="2021-7-4101659.png"></p>
<p>实体机单机部署有以下几个优点：</p>
<ol>
<li>没有网络瓶颈，而且能使用大内存；</li>
<li>既能提升命中率，又能减少 Gzip 压缩；</li>
<li>减少 Cache 失效压力，因为采用定时失效方式，例如只缓存 3 秒钟，过期即自动失效。</li>
</ol>
<p>这个方案中，虽然把通常只需要虚拟机或者容器运行的 Java 应用换成实体机，优势很明显，它会增加单机的内存容量，但是一定程度上也造成了 CPU 的浪费，因为单个的 Java 进程很难用完整个实体机的 CPU。</p>
<p>另外就是，一个实体机上部署了 Java 应用又作为 Cache 来使用，这造成了运维上的高复杂度，所以这是一个折中的方案。如果你的公司里，没有更多的系统有类似需求，那么这样做也比较合适，如果你们有多个业务系统都有静态化改造的需求，那还是建议把 Cache 层单独抽出来公用比较合理，如下面的方案 2 所示。</p>
<h4 id="方案-2：统一-Cache-层"><a href="#方案-2：统一-Cache-层" class="headerlink" title="方案 2：统一 Cache 层"></a>方案 2：统一 Cache 层</h4><p>所谓统一 Cache 层，就是将单机的 Cache 统一分离出来，形成一个单独的 Cache 集群。统一 Cache 层是个更理想的可推广方案，该方案的结构图如下：</p>
<p><img src="/images/2021-7-4101741.png" alt="2021-7-4101741.png"></p>
<p>将 Cache 层单独拿出来统一管理可以减少运维成本，同时也方便接入其他静态化系统。此外，它还有一些优点。</p>
<ol>
<li>单独一个 Cache 层，可以减少多个应用接入时使用 Cache 的成本。这样接入的应用只要维护自己的 Java 系统就好，不需要单独维护 Cache，而只关心如何使用即可。</li>
<li>统一 Cache 的方案更易于维护，如后面加强监控、配置的自动化，只需要一套解决方案就行，统一起来维护升级也比较方便。</li>
<li>可以共享内存，最大化利用内存，不同系统之间的内存可以动态切换，从而能够有效应对各种攻击。</li>
</ol>
<p>这种方案虽然维护上更方便了，但是也带来了其他一些问题，比如缓存更加集中，导致：</p>
<ol>
<li>Cache 层内部交换网络成为瓶颈；</li>
<li>缓存服务器的网卡也会是瓶颈；</li>
<li>机器少风险较大，挂掉一台就会影响很大一部分缓存数据。</li>
</ol>
<p>要解决上面这些问题，可以再对 Cache 做 Hash 分组，即一组 Cache 缓存的内容相同，这样能够避免热点数据过度集中导致新的瓶颈产生。</p>
<h4 id="方案-3：上-CDN"><a href="#方案-3：上-CDN" class="headerlink" title="方案 3：上 CDN"></a>方案 3：上 CDN</h4><p>在将整个系统做动静分离后，我们自然会想到更进一步的方案，就是将 Cache 进一步前移到 CDN 上，因为 CDN 离用户最近，效果会更好。</p>
<p>但是要想这么做，有以下几个问题需要解决。</p>
<ol>
<li><strong>失效问题</strong>。前面我们也有提到过缓存时效的问题，不知道你有没有理解，我再来解释一下。谈到静态数据时，我说过一个关键词叫“相对不变”，它的言外之意是“可能会变化”。比如一篇文章，现在不变，但如果你发现个错别字，是不是就会变化了？如果你的缓存时效很长，那用户端在很长一段时间内看到的都是错的。所以，这个方案中也是，我们需要保证 CDN 可以在秒级时间内，让分布在全国各地的 Cache 同时失效，这对 CDN 的失效系统要求很高。</li>
<li><strong>命中率问题</strong>。Cache 最重要的一个衡量指标就是“高命中率”，不然 Cache 的存在就失去了意义。同样，如果将数据全部放到全国的 CDN 上，必然导致 Cache 分散，而 Cache 分散又会导致访问请求命中同一个 Cache 的可能性降低，那么命中率就成为一个问题。</li>
<li><strong>发布更新问题</strong>。如果一个业务系统每周都有日常业务需要发布，那么发布系统必须足够简洁高效，而且你还要考虑有问题时快速回滚和排查问题的简便性。</li>
</ol>
<p>从前面的分析来看，将商品详情系统放到全国的所有 CDN 节点上是不太现实的，因为存在失效问题、命中率问题以及系统的发布更新问题。那么是否可以选择若干个节点来尝试实施呢？答案是“可以”，但是这样的节点需要满足几个条件：</p>
<ol>
<li>靠近访问量比较集中的地区；</li>
<li>离主站相对较远；</li>
<li>节点到主站间的网络比较好，而且稳定；</li>
<li>节点容量比较大，不会占用其他 CDN 太多的资源。</li>
</ol>
<p>最后，还有一点也很重要，那就是：节点不要太多。</p>
<p>基于上面几个因素，选择 CDN 的二级 Cache 比较合适，因为二级 Cache 数量偏少，容量也更大，让用户的请求先回源的 CDN 的二级 Cache 中，如果没命中再回源站获取数据，部署方式如下图所示：</p>
<p><img src="/images/2021-7-4101827.png" alt="2021-7-4101827.png"></p>
<p>使用 CDN 的二级 Cache 作为缓存，可以达到和当前服务端静态化 Cache 类似的命中率，因为节点数不多，Cache 不是很分散，访问量也比较集中，这样也就解决了命中率问题，同时能够给用户最好的访问体验，是当前比较理想的一种 CDN 化方案。</p>
<p>除此之外，CDN 化部署方案还有以下几个特点：</p>
<ol>
<li>把整个页面缓存在用户浏览器中；</li>
<li>如果强制刷新整个页面，也会请求 CDN；</li>
<li>实际有效请求，只是用户对“刷新抢宝”按钮的点击。</li>
</ol>
<p>这样就把 90% 的静态数据缓存在了用户端或者 CDN 上，当真正秒杀时，用户只需要点击特殊的“刷新抢宝”按钮，而不需要刷新整个页面。这样一来，系统只是向服务端请求很少的有效数据，而不需要重复请求大量的静态数据。</p>
<p>秒杀的动态数据和普通详情页面的动态数据相比更少，性能也提升了 3 倍以上。所以“抢宝”这种设计思路，让我们不用刷新页面就能够很好地请求到服务端最新的动态数据。</p>
<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>今天，我主要介绍了实现动静分离的几种思路，并由易到难给出了几种架构方案，以及它们各自的优缺点。可以看到，不同的架构方案会引入不同的问题，比如我们把缓存数据从 CDN 上移到用户的浏览器里，针对秒杀这个场景是没问题的，但针对一般的商品可否也这样做呢？</p>
<p>你可能会问，存储在浏览器或 CDN 上，有多大区别？我的回答是：区别很大！因为在 CDN 上，我们可以做主动失效，而在用户的浏览器里就更不可控，如果用户不主动刷新的话，你很难主动地把消息推送给用户的浏览器。</p>
<p>另外，在什么地方把静态数据和动态数据合并并渲染出一个完整的页面也很关键，假如在用户的浏览器里合并，那么服务端可以减少渲染整个页面的 CPU 消耗。如果在服务端合并的话，就要考虑缓存的数据是否进行 Gzip 压缩了：如果缓存 Gzip 压缩后的静态数据可以减少缓存的数据量，但是进行页面合并渲染时就要先解压，然后再压缩完整的页面数据输出给用户；如果缓存未压缩的静态数据，这样不用解压静态数据，但是会增加缓存容量。虽然这些都是细节问题，但你在设计架构方案时都需要考虑清楚。</p>
<p>Read More:</p>
<blockquote>
<p><a href="https://d.shikey.com/jike/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E5%B7%B2%E5%AE%8C%E7%BB%93/20%20%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F-%E8%AE%B8%E4%BB%A4%E6%B3%A2/181002-02%20_%20%E5%A6%82%E4%BD%95%E6%89%8D%E8%83%BD%E5%81%9A%E5%A5%BD%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%A1%88%E5%8F%AF%E9%80%89%EF%BC%9F.html" target="_blank" rel="noopener">02 | 如何才能做好动静分离？有哪些方案可选？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
      <tags>
        <tag>秒杀系统</tag>
        <tag>架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令 - ps</title>
    <url>/2018/01/02/linuxps/</url>
    <content><![CDATA[<p>Linux中的ps命令是Process Status的缩写。用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。</p>
<p>要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，ps 命令是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。</p>
<h4 id="Linux上的进程状态"><a href="#Linux上的进程状态" class="headerlink" title="Linux上的进程状态"></a>Linux上的进程状态</h4><ul>
<li>运行（正在运行或在运行队列中等待）</li>
<li>中断（休眠中，受阻，在等待某个条件的形成或接受到信号）</li>
<li>不可中断（收到信号不唤醒和不可运行，进程必须等待直到有中断发生）</li>
<li>僵死（进程已终止，但进程描述符存在，直到父进程调用wait4()系统调用后释放）</li>
<li>停止（进程收到SIGSTOP、SIGSTP、SIGTIN、SIGTOU信号后停止运行运行）</li>
</ul>
<h4 id="ps命令标识进程状态码"><a href="#ps命令标识进程状态码" class="headerlink" title="ps命令标识进程状态码"></a>ps命令标识进程状态码</h4><ul>
<li>R: 运行</li>
<li>S: 中断</li>
<li>D: 不可中断</li>
<li>Z: 僵死</li>
<li>T: 停止</li>
</ul>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps [参数]</span><br></pre></td></tr></table></figure>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>ps命令用来显示当前进程的状态。</p>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>显示所有进程</td>
</tr>
<tr>
<td>-a</td>
<td>显示同一终端下的所有程序</td>
</tr>
<tr>
<td>-A</td>
<td>显示所有进程</td>
</tr>
<tr>
<td>c</td>
<td>显示进程的真实名称</td>
</tr>
<tr>
<td>-N</td>
<td>反向选择</td>
</tr>
<tr>
<td>-e</td>
<td>等于”-A”</td>
</tr>
<tr>
<td>e</td>
<td>显示环境变量</td>
</tr>
<tr>
<td>f</td>
<td>显示程序间的关系</td>
</tr>
<tr>
<td>-H</td>
<td>显示树状结构</td>
</tr>
<tr>
<td>r</td>
<td>显示当前终端的进程</td>
</tr>
<tr>
<td>T</td>
<td>显示当前终端的所有程序</td>
</tr>
<tr>
<td>u</td>
<td>指定用户的所有进程</td>
</tr>
<tr>
<td>-au</td>
<td>显示较详细的资讯</td>
</tr>
<tr>
<td>-aux</td>
<td>显示所有包含其他使用者的行程</td>
</tr>
<tr>
<td>-C &lt;命令&gt;d</td>
<td>列出指定命令的状况</td>
</tr>
<tr>
<td>–lines &lt;行数&gt;</td>
<td>每页显示的行数</td>
</tr>
<tr>
<td>–width &lt;字符数&gt;</td>
<td>每页显示的字符数</td>
</tr>
<tr>
<td>–help</td>
<td>显示帮助信息</td>
</tr>
<tr>
<td>–version</td>
<td>显示版本显示</td>
</tr>
</tbody>
</table>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><ul>
<li>ps -A</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PID TTY          TIME CMD</span><br><span class="line">    1 ?        00:00:16 init</span><br><span class="line">    2 ?        00:00:00 kthreadd</span><br><span class="line">    3 ?        00:00:21 migration/0</span><br><span class="line">    4 ?        00:00:36 ksoftirqd/0</span><br><span class="line">    5 ?        00:00:00 stopper/0</span><br><span class="line">    6 ?        00:00:08 watchdog/0</span><br><span class="line">    7 ?        00:00:21 migration/1</span><br><span class="line">    8 ?        00:00:00 stopper/1</span><br><span class="line">    9 ?        00:00:35 ksoftirqd/1</span><br><span class="line">   10 ?        00:00:07 watchdog/1</span><br><span class="line">   11 ?        00:00:21 migration/2</span><br><span class="line">   12 ?        00:00:00 stopper/2</span><br><span class="line">   13 ?        00:00:34 ksoftirqd/2</span><br></pre></td></tr></table></figure>
<p>显示所有进程</p>
<ul>
<li>ps -u root</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PID TTY          TIME CMD</span><br><span class="line">    1 ?        00:00:16 init</span><br><span class="line">    2 ?        00:00:00 kthreadd</span><br><span class="line">    3 ?        00:00:21 migration/0</span><br><span class="line">    4 ?        00:00:36 ksoftirqd/0</span><br><span class="line">    5 ?        00:00:00 stopper/0</span><br><span class="line">    6 ?        00:00:08 watchdog/0</span><br><span class="line">    7 ?        00:00:21 migration/1</span><br><span class="line">    8 ?        00:00:00 stopper/1</span><br><span class="line">    9 ?        00:00:35 ksoftirqd/1</span><br><span class="line">   10 ?        00:00:07 watchdog/1</span><br></pre></td></tr></table></figure>
<p>显示特定用户的进程信息</p>
<ul>
<li>ps -ef</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root     12426 10831  0 16:47 pts/0    00:00:00 ps -ef</span><br><span class="line">root     14886     1  0  2017 ?        00:00:01 python3 /home/ly/prepullvidcs/app.py</span><br><span class="line">root     15484     1  0  2017 ?        00:00:01 python3 /home/ly/atsbtsp/app.py</span><br><span class="line">root     17080     1  0  2017 ?        00:00:00 bash /usr/local/hbase-1.2.6/bin/hbase-daemon.sh --config /usr/local/hbase-1.2.6/bin/../conf foreground_start master</span><br><span class="line">root     17094 17080  0  2017 ?        04:35:00 /usr/lib/java-1.8/jdk1.8.0_144/bin/java -Dproc_master -XX:OnOutOfMemoryError=kill -9 %p -XX:+UseConcMarkSweepGC -XX:PermSize=128m -XX:MaxPermSize=128m -Dhbase.log.dir=/usr/local/hbase-1.2.6/</span><br><span class="line">root     17890     1  0  2017 ?        00:05:22 /usr/local/zabbix/share/zabbix/externalscripts/zabbix-agentd-updater</span><br><span class="line">root     17973 18967  0  2017 ?        00:00:00 /sbin/udevd -d</span><br><span class="line">root     18634     1  0  2017 ?        00:18:54 python27 /home/ly/datawritehbase/tasks/live_stream_ugcppcpgc/stream_list_old.py</span><br></pre></td></tr></table></figure>
<p>显示所有进程信息（包括命令行）</p>
<ul>
<li>ps -ef | grep python</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root      3244     1  0  2017 ?        00:02:29 /usr/bin/python27 /usr/local/python2.7/bin/supervisord -c /etc/supervisor/supervisord.conf</span><br><span class="line">root      3245  3244  0  2017 ?        00:00:01 python27 /home/ly/analysisweb/app.py --port=8021</span><br><span class="line">root      3246  3244  0  2017 ?        00:00:01 python27 /home/ly/analysisweb/app.py --port=8020</span><br><span class="line">root      3247  3244  0  2017 ?        00:00:00 python27 /home/ly/analysisweb/app.py --port=8023</span><br><span class="line">root      3248  3244  0  2017 ?        00:00:00 python27 /home/ly/analysisweb/app.py --port=8022</span><br><span class="line">root      8472     1  0  2017 ?        00:01:20 python3 monitor.py tasks/live_stream_length_task.py</span><br><span class="line">850      12515  9226  1 16:48 ?        00:00:00 /opt/cloud-agent/agent/plugin/env/bin/python plugin/python/sys/basic/60_ifstat.py</span><br><span class="line">root     12567 10831  0 16:48 pts/0    00:00:00 grep python</span><br><span class="line">root     14886     1  0  2017 ?        00:00:01 python3 /home/ly/prepullvidcs/app.py</span><br><span class="line">root     15484     1  0  2017 ?        00:00:01 python3 /home/ly/atsbtsp/app.py</span><br><span class="line">root     18634     1  0  2017 ?        00:18:54 python27 /home/ly/datawritehbase/tasks/live_stream_ugcppcpgc/stream_list_old.py</span><br><span class="line">root     18635     1 99  2017 ?        28-05:56:25 python27 /home/ly/datawritehbase/tasks/multicdn_kafka_hbase/mcdn_main.py</span><br><span class="line">root     18636     1 99  2017 ?        28-20:46:31 python27 /home/ly/datawritehbase/tasks/nginx_kafka_hbase/nginx_main.py</span><br><span class="line">root     18638     1  3  2017 ?        20:43:58 python27 /home/ly/datawritehbase/tasks/stream_hbase/stream_main_old.py</span><br><span class="line">root     20253     1  0  2017 ?        00:01:00 python27 /home/ly/hbasequeryweb/app.py</span><br><span class="line">root     30087     1  1  2017 ?        11:27:44 python27 /home/ly/datawritehbase/tasks/rtmp_kafka_hbase/rtmp_main.py</span><br></pre></td></tr></table></figure>
<p>查找特定进程</p>
<ul>
<li>ps aux</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.0  0.0  19356  1544 ?        Ss    2017   0:16 /sbin/init</span><br><span class="line">root         2  0.0  0.0      0     0 ?        S     2017   0:00 [kthreadd]</span><br><span class="line">root         3  0.0  0.0      0     0 ?        S     2017   0:21 [migration/0]</span><br><span class="line">root         4  0.0  0.0      0     0 ?        S     2017   0:36 [ksoftirqd/0]</span><br><span class="line">root         5  0.0  0.0      0     0 ?        S     2017   0:00 [stopper/0]</span><br><span class="line">root         6  0.0  0.0      0     0 ?        S     2017   0:08 [watchdog/0]</span><br><span class="line">root         7  0.0  0.0      0     0 ?        S     2017   0:21 [migration/1]</span><br><span class="line">root         8  0.0  0.0      0     0 ?        S     2017   0:00 [stopper/1]</span><br><span class="line">root         9  0.0  0.0      0     0 ?        S     2017   0:35 [ksoftirqd/1]</span><br><span class="line">root        10  0.0  0.0      0     0 ?        S     2017   0:07 [watchdog/1]</span><br><span class="line">root        11  0.0  0.0      0     0 ?        S     2017   0:21 [migration/2]</span><br><span class="line">......</span><br><span class="line">root      1392  0.0  0.0      0     0 ?        S     2017   1:29 [flush-252:0]</span><br><span class="line">root      3244  0.0  0.0 209168 14424 ?        Ss    2017   2:29 /usr/bin/python27 /usr/local/python2.7/bin/supervisord -c /etc/supervisor/supervisord.conf</span><br><span class="line">root      3245  0.0  0.2 248368 37396 ?        S     2017   0:01 python27 /home/ly/analysisweb/app.py --port=8021</span><br><span class="line">root      3246  0.0  0.2 253408 42800 ?        S     2017   0:01 python27 /home/ly/analysisweb/app.py --port=8020</span><br><span class="line">root      3247  0.0  0.2 243556 32756 ?        S     2017   0:00 python27 /home/ly/analysisweb/app.py --port=8023</span><br><span class="line">root      3248  0.0  0.2 245124 34528 ?        S     2017   0:00 python27 /home/ly/analysisweb/app.py --port=8022</span><br><span class="line">dbus      3857  0.0  0.0  21540  1364 ?        Ss    2017   0:00 dbus-daemon --system</span><br><span class="line">root      3886  0.0  0.0   4076   648 ?        Ss    2017   0:00 /usr/sbin/acpid</span><br><span class="line">68        3895  0.0  0.0  25068  3848 ?        Ss    2017   0:37 hald</span><br><span class="line">root      3896  0.0  0.0  18104  1132 ?        S     2017   0:00 hald-runner</span><br><span class="line">root      3924  0.0  0.0  20220  1080 ?        S     2017   0:00 hald-addon-input: Listening on /dev/input/event2 /dev/input/event0</span><br><span class="line">68        3934  0.0  0.0  17804  1036 ?        S     2017   0:00 hald-addon-acpi: listening on acpid socket /var/run/acpid.socket</span><br><span class="line">root      3981  0.0  0.0   6244   292 ?        Ss    2017   0:00 /usr/sbin/mcelog --daemon</span><br><span class="line">root      4093  0.0  0.0  78728  3312 ?        Ss    2017   0:30 /usr/libexec/postfix/master</span><br><span class="line">postfix   4108  0.0  0.0  78980  3444 ?        S     2017   0:04 qmgr -l -t fifo -u</span><br><span class="line">root      4159  0.0  0.0  21452   476 ?        Ss    2017   0:00 /usr/sbin/atd</span><br><span class="line">......</span><br><span class="line">root     10826  0.0  0.0 101072  4024 ?        Ss   16:30   0:00 sshd: root@pts/0 </span><br><span class="line">root     10831  0.0  0.0 109096  2556 pts/0    Ss   16:30   0:00 -bash</span><br><span class="line">root     12865  0.0  0.0 110240  1136 pts/0    R+   16:51   0:00 ps aux</span><br><span class="line">root     14886  0.0  0.2 533372 40212 ?        Sl    2017   0:01 python3 /home/ly/prepullvidcs/app.py</span><br><span class="line">root     15484  0.0  0.1 233608 30092 ?        S     2017   0:01 python3 /home/ly/atsbtsp/app.py</span><br><span class="line">root     17080  0.0  0.0 106100  1380 ?        S     2017   0:00 bash /usr/local/hbase-1.2.6/bin/hbase-daemon.sh --config /usr/local/hbase-1.2.6/bin/../conf foreground_start master</span><br><span class="line">root     17094  0.1  9.1 6203172 1486980 ?     Sl    2017 275:00 /usr/lib/java-1.8/jdk1.8.0_144/bin/java -Dproc_master -XX:OnOutOfMemoryError=kill -9 %p -XX:+UseConcMarkSweepGC -XX:PermSize=128m -XX:MaxPermSize=128m -Dhbase.log.dir=/usr/l</span><br><span class="line">root     17890  0.0  0.0 587052 10368 ?        Sl    2017   5:22 /usr/local/zabbix/share/zabbix/externalscripts/zabbix-agentd-updater</span><br><span class="line">root     17973  0.0  0.0  11540   676 ?        S&lt;    2017   0:00 /sbin/udevd -d</span><br><span class="line">......</span><br><span class="line">root     25290  0.0  0.0 175824  1008 ?        Ss    2017   0:00 svnserve -dr /var/svndata/</span><br><span class="line">root     25793  0.0  0.0  76792  1384 ?        S    03:28   0:00 /usr/local/zabbix/sbin/zabbix_agentd_ops </span><br><span class="line">root     25794  0.0  0.0  76792  1472 ?        S    03:28   0:07 /usr/local/zabbix/sbin/zabbix_agentd_ops: collector [idle 1 sec]</span><br><span class="line">root     25795  0.0  0.0  76792  1040 ?        S    03:28   0:00 /usr/local/zabbix/sbin/zabbix_agentd_ops: listener #1 [waiting for connection]</span><br><span class="line">root     25796  0.0  0.0  78984  2008 ?        S    03:28   0:06 /usr/local/zabbix/sbin/zabbix_agentd_ops: active checks #1 [idle 1 sec]</span><br><span class="line">root     25797  0.0  0.0  78984  1996 ?        S    03:28   0:06 /usr/local/zabbix/sbin/zabbix_agentd_ops: active checks #2 [idle 1 sec]</span><br><span class="line">root     26648  0.0  0.0 125472  7688 ?        Ssl   2017   5:33 ./redis-server *:6379      </span><br><span class="line">root     30087  1.7  0.6 7316724 106248 ?      Sl    2017 687:47 python27 /home/ly/datawritehbase/tasks/rtmp_kafka_hbase/rtmp_main.py</span><br></pre></td></tr></table></figure>
<p>列出目前所有正在内存中的进程</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>USER</td>
<td>进程所属账号</td>
</tr>
<tr>
<td>PID</td>
<td>进程id号</td>
</tr>
<tr>
<td>%CPU</td>
<td>进程所占CPU资源百分比</td>
</tr>
<tr>
<td>%MEM</td>
<td>进程所占物理内存百分比</td>
</tr>
<tr>
<td>VSZ</td>
<td>进程所占虚拟内存大小</td>
</tr>
<tr>
<td>RSS</td>
<td>进程所占固定内存大小</td>
</tr>
<tr>
<td>TTY</td>
<td>进程在哪个终端机上运行。若与终端机无关，则显示 ？；tty1-tty6 是本机上面的登入者程序；若为 pts/0 等等的，则表示为由网络连接进主机的程序</td>
</tr>
<tr>
<td>STAT</td>
<td>进程当前状态</td>
</tr>
<tr>
<td>START</td>
<td>进程被触发启动的时间</td>
</tr>
<tr>
<td>TIME</td>
<td>进程实际使用CPU的时间</td>
</tr>
<tr>
<td>COMMAND</td>
<td>进程的启动指令</td>
</tr>
</tbody>
</table>
<ul>
<li>ps aux | egrep ‘(cron|syslog)’</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root      9278  0.0  0.0 117256  1276 ?        Ss   11:10   0:00 crond</span><br><span class="line">root     13816  0.0  0.0 101016   844 pts/0    S+   17:00   0:00 egrep (cron|syslog)</span><br><span class="line">root     22016  0.0  0.0 159736  5856 ?        Sl    2017   2:06 /sbin/rsyslogd -i /var/run/syslogd.pid -c 5</span><br></pre></td></tr></table></figure>
<p>显示与 cron、syslog服务有关进程的PID号</p>
<ul>
<li>ps -aux | more : 分页查看</li>
<li>ps -aux &gt; ps001.txt : 输出到文件中</li>
<li>ps -o pid,ppid,pgrp,session,tpgid,comm : 输出指定字段</li>
</ul>
<p>Read More：</p>
<blockquote>
<p><a href="http://www.cnblogs.com/peida/archive/2012/12/19/2824418.html" target="_blank" rel="noopener">每天一个linux命令（41）：ps命令</a> <a href="http://www.runoob.com/linux/linux-comm-ps.html" target="_blank" rel="noopener">Linux ps命令</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux/Unix</category>
      </categories>
      <tags>
        <tag>命令</tag>
        <tag>Linux</tag>
        <tag>ps</tag>
      </tags>
  </entry>
  <entry>
    <title>秒杀系统设计02 - 设计秒杀系统时应该注意的5个架构原则</title>
    <url>/2021/07/04/miaosha02/</url>
    <content><![CDATA[<p>说起秒杀，我想你肯定不陌生，这两年，从双十一购物到春节抢红包，再到 12306 抢火车票，“秒杀”的场景处处可见。简单来说，秒杀就是在同一个时刻有大量的请求争抢购买同一个商品并完成交易的过程，用技术的行话来说就是大量的并发读和并发写。</p>
<p>不管是哪一门语言，并发都是程序员们最为头疼的部分。同样，对于一个软件而言也是这样，你可以很快增删改查做出一个秒杀系统，但是要让它支持高并发访问就没那么容易了。比如说，如何让系统面对百万级的请求流量不出故障？如何保证高并发情况下数据的一致性写？完全靠堆服务器来解决吗？这显然不是最好的解决方案。</p>
<p>在我看来，<strong>秒杀系统本质上就是一个满足大并发、高性能和高可用的分布式系统</strong>。今天，我们就来聊聊，如何在满足一个良好架构的分布式系统基础上，针对秒杀这种业务做到极致的性能改进。</p>
<h3 id="架构原则：“4-要-1-不要”"><a href="#架构原则：“4-要-1-不要”" class="headerlink" title="架构原则：“4 要 1 不要”"></a>架构原则：“4 要 1 不要”</h3><p>如果你是一个架构师，你首先要勾勒出一个轮廓，想一想如何构建一个超大流量并发读写、高性能，以及高可用的系统，这其中有哪些要素需要考虑。我把这些要素总结为“4 要 1 不要”。</p>
<h4 id="数据要尽量少"><a href="#数据要尽量少" class="headerlink" title="数据要尽量少"></a>数据要尽量少</h4><p>所谓“数据要尽量少”，首先是指用户请求的数据能少就少。请求的数据包括上传给系统的数据和系统返回给用户的数据（通常就是网页）。</p>
<p>为啥“数据要尽量少”呢？因为首先这些数据在网络上传输需要时间，其次不管是请求数据还是返回数据都需要服务器做处理，而服务器在写网络时通常都要做压缩和字符编码，这些都非常消耗 CPU，所以减少传输的数据量可以显著减少 CPU 的使用。例如，我们可以简化秒杀页面的大小，去掉不必要的页面装修效果，等等。</p>
<p>其次，“数据要尽量少”还要求系统依赖的数据能少就少，包括系统完成某些业务逻辑需要读取和保存的数据，这些数据一般是和后台服务以及数据库打交道的。调用其他服务会涉及数据的序列化和反序列化，而这也是 CPU 的一大杀手，同样也会增加延时。而且，数据库本身也容易成为一个瓶颈，所以和数据库打交道越少越好，数据越简单、越小则越好。</p>
<h4 id="请求数要尽量少"><a href="#请求数要尽量少" class="headerlink" title="请求数要尽量少"></a>请求数要尽量少</h4><p>用户请求的页面返回后，浏览器渲染这个页面还要包含其他的额外请求，比如说，这个页面依赖的 CSS/JavaScript、图片，以及 Ajax 请求等等都定义为“额外请求”，这些额外请求应该尽量少。因为浏览器每发出一个请求都多少会有一些消耗，例如建立连接要做三次握手，有的时候有页面依赖或者连接数限制，一些请求（例如 JavaScript）还需要串行加载等。另外，如果不同请求的域名不一样的话，还涉及这些域名的 DNS 解析，可能会耗时更久。所以你要记住的是，减少请求数可以显著减少以上这些因素导致的资源消耗。</p>
<p>例如，减少请求数最常用的一个实践就是合并 CSS 和 JavaScript 文件，把多个 JavaScript 文件合并成一个文件，在 URL 中用逗号隔开（<a href="https://g.xxx.com/tm/xx-b/4.0.94/mods/??module-preview/index.xtpl.js,module-jhs/index.xtpl.js,module-focus/index.xtpl.js）。这种方式在服务端仍然是单个文件各自存放，只是服务端会有一个组件解析这个" target="_blank" rel="noopener">https://g.xxx.com/tm/xx-b/4.0.94/mods/??module-preview/index.xtpl.js,module-jhs/index.xtpl.js,module-focus/index.xtpl.js）。这种方式在服务端仍然是单个文件各自存放，只是服务端会有一个组件解析这个</a> URL，然后动态把这些文件合并起来一起返回。</p>
<h4 id="路径要尽量短"><a href="#路径要尽量短" class="headerlink" title="路径要尽量短"></a>路径要尽量短</h4><p>所谓“路径”，就是用户发出请求到返回数据这个过程中，需求经过的中间的节点数。</p>
<p>通常，这些节点可以表示为一个系统或者一个新的 Socket 连接（比如代理服务器只是创建一个新的 Socket 连接来转发请求）。每经过一个节点，一般都会产生一个新的 Socket 连接。</p>
<p>然而，每增加一个连接都会增加新的不确定性。从概率统计上来说，加入一次请求经过 5 个节点，每个节点的可用性是 99.9% 的话，那么整个请求的可用性是：99.9% 的 5 次方，约等于 99.5%。</p>
<p>所以缩短请求路径不仅可以增加可用性，同样可以有效提升性能（减少中间节点可以减少数据的序列化与反序列化），并减少延时（可以减少网络传输耗时）。</p>
<p>要缩短访问路径有一种办法，就是多个相互强依赖的应用合并部署在一起，把远程过程调用（RPC）变成 JVM 内部之间的方法调用。在《大型网站技术架构演进与性能优化》一书中，我也有一章介绍了这种技术的详细实现。</p>
<h4 id="依赖要尽量少"><a href="#依赖要尽量少" class="headerlink" title="依赖要尽量少"></a>依赖要尽量少</h4><p>所谓依赖，指的是要完成一次用户请求必须依赖的系统或者服务，这里的依赖指的是强依赖。</p>
<p>举个例子，比如说你要展示秒杀页面，而这个页面必须强依赖商品信息、用户信息，还有其他如优惠券、成交列表等这些对秒杀不是非要不可的信息（弱依赖），这些弱依赖在紧急情况下就可以去掉。</p>
<p>要减少依赖，我们可以给系统进行分级，比如 0 级系统、1 级系统、2 级系统、3 级系统，0 级系统如果是最重要的系统，那么 0 级系统强依赖的系统也同样是最重要的系统，以此类推。</p>
<p>注意，0 级系统要尽量减少对 1 级系统的强依赖，防止重要的系统被不重要的系统拖垮。例如支付系统是 0 级系统，而优惠券是 1 级系统的话，在极端情况下可以把优惠券给降级，防止支付系统被优惠券这个 1 级系统给拖垮。</p>
<h4 id="不要有单点"><a href="#不要有单点" class="headerlink" title="不要有单点"></a>不要有单点</h4><p>系统中的单点可以说是系统架构上的一个大忌，因为单点意味着没有备份，风险不可控，我们设计分布式系统最重要的原则就是“消除单点”。</p>
<p>那如何避免单点呢？我认为关键点是避免将服务的状态和机器绑定，即把服务无状态化，这样服务就可以在机器中随意移动。</p>
<p>如何那把服务的状态和机器解耦呢？这里也有很多实现方式。例如把和机器相关的配置动态化，这些参数可以通过配置中心来动态推送，在服务启动时动态拉取下来，我们在这些配置中心设置一些规则来方便地改变这些映射关系。</p>
<p>应用无状态化是有效避免单点的一种方式，但是像存储服务本身很难无状态化，因为数据要存储在磁盘上，本身就要和机器绑定，那么这种场景一般要通过冗余多个备份的方式来解决单点问题。</p>
<p>前面介绍了这些设计上的一些原则，但是你有没有发现，我一直说的是“尽量”而不是“绝对”？</p>
<p>我想你肯定会问是不是请求最少就一定最好，我的答案是“不一定”。我们曾经把有些 CSS 内联进页面里，这样做可以减少依赖一个 CSS 的请求从而加快首页的渲染，但是同样也增大了页面的大小，又不符合“数据要尽量少”的原则，这种情况下我们为了提升首屏的渲染速度，只把首屏的 HTML 依赖的 CSS 内联进来，其他 CSS 仍然放到文件中作为依赖加载，尽量实现首屏的打开速度与整个页面加载性能的平衡。</p>
<p>所以说，<strong>架构是一种平衡的艺术，而最好的架构一旦脱离了它所适应的场景，一切都将是空谈</strong>。我希望你记住的是，这里所说的几点都只是一个个方向，你应该尽量往这些方向上去努力，但也要考虑平衡其他因素。</p>
<h3 id="不同场景下的不同架构案例"><a href="#不同场景下的不同架构案例" class="headerlink" title="不同场景下的不同架构案例"></a>不同场景下的不同架构案例</h3><p>前面我说了一些架构上的原则，那么针对“秒杀”这个场景，怎样才是一个好的架构呢？下面我以淘宝早期秒杀系统架构的演进为主线，来帮你梳理不同的请求体量下，我认为的最佳秒杀系统架构。</p>
<p>如果你想快速搭建一个简单的秒杀系统，只需要把你的商品购买页面增加一个“定时上架”功能，仅在秒杀开始时才让用户看到购买按钮，当商品的库存卖完了也就结束了。这就是当时第一个版本的秒杀系统实现方式。</p>
<p>但随着请求量的加大（比如从 1w/s 到了 10w/s 的量级），这个简单的架构很快就遇到了瓶颈，因此需要做架构改造来提升系统性能。这些架构改造包括：</p>
<ol>
<li>把秒杀系统独立出来单独打造一个系统，这样可以有针对性地做优化，例如这个独立出来的系统就减少了店铺装修的功能，减少了页面的复杂度；</li>
<li>在系统部署上也独立做一个机器集群，这样秒杀的大流量就不会影响到正常的商品购买集群的机器负载；</li>
<li>将热点数据（如库存数据）单独放到一个缓存系统中，以提高“读性能”；</li>
<li>增加秒杀答题，防止有秒杀器抢单。</li>
</ol>
<p>此时的系统架构变成了下图这个样子。最重要的就是，秒杀详情成为了一个独立的新系统，另外核心的一些数据放到了缓存（Cache）中，其他的关联系统也都以独立集群的方式进行部署。</p>
<p><img src="/images/2021-7-4101018.png" alt="2021-7-4101018.png"></p>
<p>然而这个架构仍然支持不了超过 100w/s 的请求量，所以为了进一步提升秒杀系统的性能，我们又对架构做进一步升级，比如：</p>
<ol>
<li>对页面进行彻底的动静分离，使得用户秒杀时不需要刷新整个页面，而只需要点击抢宝按钮，借此把页面刷新的数据降到最少；</li>
<li>在服务端对秒杀商品进行本地缓存，不需要再调用依赖系统的后台服务获取数据，甚至不需要去公共的缓存集群中查询数据，这样不仅可以减少系统调用，而且能够避免压垮公共缓存集群。</li>
<li>增加系统限流保护，防止最坏情况发生。</li>
</ol>
<p>经过这些优化，系统架构变成了下图中的样子。在这里，我们对页面进行了进一步的静态化，秒杀过程中不需要刷新整个页面，而只需要向服务端请求很少的动态数据。而且，最关键的详情和交易系统都增加了本地缓存，来提前缓存秒杀商品的信息，热点数据库也做了独立部署，等等。</p>
<p><img src="/images/2021-7-4101136.png" alt="2021-7-4101136.png"></p>
<p>从前面的几次升级来看，其实越到后面需要定制的地方越多，也就是越“不通用”。例如，把秒杀商品缓存在每台机器的内存中，这种方式显然不适合太多的商品同时进行秒杀的情况，因为单机的内存始终有限。所以要取得极致的性能，就要在其他地方（比如，通用性、易用性、成本等方面）有所牺牲。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>来让我们回顾下前面的内容，我首先介绍了构建大并发、高性能、高可用系统中几种通用的优化思路，并抽象总结为“4 要 1 不要”原则，也就是：数据要尽量少、请求数要尽量少、路径要尽量短、依赖要尽量少，以及不要有单点。当然，这几点是你要努力的方向，具体操作时还是要密切结合实际的场景和具体条件来进行。</p>
<p>然后，我给出了实际构建秒杀系统时，根据不同级别的流量，由简单到复杂打造的几种系统架构，希望能供你参考。当然，这里面我没有说具体的解决方案，比如缓存用什么、页面静态化用什么，因为这些对于架构来说并不重要，作为架构师，你应该时刻提醒自己主线是什么。</p>
<p>说了这么多，总体上我希望给你一个方向，就是想构建大并发、高性能、高可用的系统应该从哪几个方向上去努力，然后在不同性能要求的情况下系统架构应该从哪几个方面去做取舍。同时你也要明白，越追求极致性能，系统定制开发就会越多，同时系统的通用性也就会越差。</p>
<p>Read More:</p>
<blockquote>
<p><a href="https://d.shikey.com/jike/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E5%B7%B2%E5%AE%8C%E7%BB%93/20%20%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F-%E8%AE%B8%E4%BB%A4%E6%B3%A2/181001-01%20_%20%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E6%97%B6%E5%BA%94%E8%AF%A5%E6%B3%A8%E6%84%8F%E7%9A%845%E4%B8%AA%E6%9E%B6%E6%9E%84%E5%8E%9F%E5%88%99.html" target="_blank" rel="noopener">01 | 设计秒杀系统时应该注意的5个架构原则</a></p>
</blockquote>
]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
      <tags>
        <tag>秒杀系统</tag>
        <tag>架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>秒杀系统设计04 - 二八原则：有针对性地处理好系统的“热点数据”</title>
    <url>/2021/07/04/miaosha04/</url>
    <content><![CDATA[<p>假设你的系统中存储有几十亿上百亿的商品，而每天有千万级的商品被上亿的用户访问，那么肯定有一部分被大量用户访问的热卖商品，这就是我们常说的“热点商品”。</p>
<p>这些热点商品中最极端的例子就是秒杀商品，它们在很短时间内被大量用户执行访问、添加购物车、下单等操作，这些操作我们就称为“热点操作”。那么问题来了：这些热点对系统有啥影响，我们非要关注这些热点吗？</p>
<h3 id="为什么要关注热点"><a href="#为什么要关注热点" class="headerlink" title="为什么要关注热点"></a>为什么要关注热点</h3><p>我们一定要关注热点，因为热点会对系统产生一系列的影响。</p>
<p>首先，热点请求会大量占用服务器处理资源，虽然这个热点可能只占请求总量的亿分之一，然而却可能抢占 90% 的服务器资源，如果这个热点请求还是没有价值的无效请求，那么对系统资源来说完全是浪费。</p>
<p>其次，即使这些热点是有效的请求，我们也要识别出来做针对性的优化，从而用更低的代价来支撑这些热点请求。</p>
<p>既然热点对系统来说这么重要，那么热点到底包含哪些内容呢？</p>
<h3 id="什么是“热点”"><a href="#什么是“热点”" class="headerlink" title="什么是“热点”"></a>什么是“热点”</h3><p>热点分为<strong>热点操作</strong>和<strong>热点数据</strong>。所谓“热点操作”，例如大量的刷新页面、大量的添加购物车、双十一零点大量的下单等都属于此类操作。对系统来说，这些操作可以抽象为“读请求”和“写请求”，这两种热点请求的处理方式大相径庭，读请求的优化空间要大一些，而写请求的瓶颈一般都在存储层，优化的思路就是根据 CAP 理论做平衡，这个内容我在“减库存”一文再详细介绍。</p>
<p>而“热点数据”比较好理解，那就是用户的热点请求对应的数据。而热点数据又分为“静态热点数据”和“动态热点数据”。</p>
<p>所谓“静态热点数据”，就是能够提前预测的热点数据。例如，我们可以通过卖家报名的方式提前筛选出来，通过报名系统对这些热点商品进行打标。另外，我们还可以通过大数据分析来提前发现热点商品，比如我们分析历史成交记录、用户的购物车记录，来发现哪些商品可能更热门、更好卖，这些都是可以提前分析出来的热点。</p>
<p>所谓“动态热点数据”，就是不能被提前预测到的，系统在运行过程中临时产生的热点。例如，卖家在抖音上做了广告，然后商品一下就火了，导致它在短时间内被大量购买。</p>
<p>由于热点操作是用户的行为，我们不好改变，但能做一些限制和保护，所以本文我主要针对热点数据来介绍如何进行优化。</p>
<h3 id="发现热点数据"><a href="#发现热点数据" class="headerlink" title="发现热点数据"></a>发现热点数据</h3><p>前面，我介绍了如何对单个秒杀商品的页面数据进行动静分离，以便针对性地对静态数据做优化处理，那么另外一个关键的问题来了：如何发现这些秒杀商品，或者更准确地说，如何发现热点商品呢？</p>
<p>你可能会说“参加秒杀的商品就是秒杀商品啊”，没错，关键是系统怎么知道哪些商品参加了秒杀活动呢？所以，你要有一个机制提前来区分普通商品和秒杀商品。</p>
<p>我们从发现静态热点和发现动态热点两个方面来看一下。</p>
<h4 id="发现静态热点数据"><a href="#发现静态热点数据" class="headerlink" title="发现静态热点数据"></a>发现静态热点数据</h4><p>如前面讲的，静态热点数据可以通过商业手段，例如强制让卖家通过报名参加的方式提前把热点商品筛选出来，实现方式是通过一个运营系统，把参加活动的商品数据进行打标，然后通过一个后台系统对这些热点商品进行预处理，如提前进行缓存。但是这种通过报名提前筛选的方式也会带来新的问题，即增加卖家的使用成本，而且实时性较差，也不太灵活。</p>
<p>不过，除了提前报名筛选这种方式，你还可以通过技术手段提前预测，例如对买家每天访问的商品进行大数据计算，然后统计出 TOP N 的商品，我们可以认为这些 TOP N 的商品就是热点商品。</p>
<h4 id="发现动态热点数据"><a href="#发现动态热点数据" class="headerlink" title="发现动态热点数据"></a>发现动态热点数据</h4><p>我们可以通过卖家报名或者大数据预测这些手段来提前预测静态热点数据，但这其中有一个痛点，就是实时性较差，如果我们的系统能在秒级内自动发现热点商品那就完美了。</p>
<p>能够动态地实时发现热点不仅对秒杀商品，对其他热卖商品也同样有价值，所以我们需要想办法实现热点的动态发现功能。</p>
<p>这里我给出一个动态热点发现系统的具体实现。</p>
<ol>
<li>构建一个异步的系统，它可以收集交易链路上各个环节中的中间件产品的热点 Key，如 Nginx、缓存、RPC 服务框架等这些中间件（一些中间件产品本身已经有热点统计模块）。</li>
<li>建立一个热点上报和可以按照需求订阅的热点服务的下发规范，主要目的是通过交易链路上各个系统（包括详情、购物车、交易、优惠、库存、物流等）访问的时间差，把上游已经发现的热点透传给下游系统，提前做好保护。比如，对于大促高峰期，详情系统是最早知道的，在统一接入层上 Nginx 模块统计的热点 URL。</li>
<li>将上游系统收集的热点数据发送到热点服务台，然后下游系统（如交易系统）就会知道哪些商品会被频繁调用，然后做热点保护。</li>
</ol>
<p>这里我给出了一个图，其中用户访问商品时经过的路径有很多，我们主要是依赖前面的导购页面（包括首页、搜索页面、商品详情、购物车等）提前识别哪些商品的访问量高，通过这些系统中的中间件来收集热点数据，并记录到日志中。</p>
<p><img src="/images/2021-7-4102102.png" alt="2021-7-4102102.png"></p>
<p>我们通过部署在每台机器上的 Agent 把日志汇总到聚合和分析集群中，然后把符合一定规则的热点数据，通过订阅分发系统再推送到相应的系统中。你可以是把热点数据填充到 Cache 中，或者直接推送到应用服务器的内存中，还可以对这些数据进行拦截，总之下游系统可以订阅这些数据，然后根据自己的需求决定如何处理这些数据。</p>
<p>打造热点发现系统时，我根据以往经验总结了几点注意事项。</p>
<ol>
<li>这个热点服务后台抓取热点数据日志最好采用异步方式，因为“异步”一方面便于保证通用性，另一方面又不影响业务系统和中间件产品的主流程。</li>
<li>热点服务发现和中间件自身的热点保护模块并存，每个中间件和应用还需要保护自己。热点服务台提供热点数据的收集和订阅服务，便于把各个系统的热点数据透明出来。</li>
<li>热点发现要做到接近实时（3s 内完成热点数据的发现），因为只有做到接近实时，动态发现才有意义，才能实时地对下游系统提供保护。</li>
</ol>
<h3 id="处理热点数据"><a href="#处理热点数据" class="headerlink" title="处理热点数据"></a>处理热点数据</h3><p>处理热点数据通常有几种思路：<strong>一是优化，二是限制，三是隔离</strong>。</p>
<p>先来说说优化。优化热点数据最有效的办法就是缓存热点数据，如果热点数据做了动静分离，那么可以长期缓存静态数据。但是，缓存热点数据更多的是“临时”缓存，即不管是静态数据还是动态数据，都用一个队列短暂地缓存数秒钟，由于队列长度有限，可以采用 LRU 淘汰算法替换。</p>
<p>再来说说限制。限制更多的是一种保护机制，限制的办法也有很多，例如对被访问商品的 ID 做一致性 Hash，然后根据 Hash 做分桶，每个分桶设置一个处理队列，这样可以把热点商品限制在一个请求队列里，防止因某些热点商品占用太多的服务器资源，而使其他请求始终得不到服务器的处理资源。</p>
<p>最后介绍一下隔离。秒杀系统设计的第一个原则就是将这种热点数据隔离出来，不要让 1% 的请求影响到另外的 99%，隔离出来后也更方便对这 1% 的请求做针对性的优化。</p>
<p>具体到“秒杀”业务，我们可以在以下几个层次实现隔离。</p>
<ol>
<li><strong>业务隔离</strong>。把秒杀做成一种营销活动，卖家要参加秒杀这种营销活动需要单独报名，从技术上来说，卖家报名后对我们来说就有了已知热点，因此可以提前做好预热。</li>
<li><strong>系统隔离</strong>。系统隔离更多的是运行时的隔离，可以通过分组部署的方式和另外 99% 分开。秒杀可以申请单独的域名，目的也是让请求落到不同的集群中。</li>
<li><strong>数据隔离</strong>。秒杀所调用的数据大部分都是热点数据，比如会启用单独的 Cache 集群或者 MySQL 数据库来放热点数据，目的也是不想 0.01% 的数据有机会影响 99.99% 数据。</li>
</ol>
<p>当然了，实现隔离有很多种办法。比如，你可以按照用户来区分，给不同的用户分配不同的 Cookie，在接入层，路由到不同的服务接口中；再比如，你还可以在接入层针对 URL 中的不同 Path 来设置限流策略。服务层调用不同的服务接口，以及数据层通过给数据打标来区分等等这些措施，其目的都是把已经识别出来的热点请求和普通的请求区分开。</p>
<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>本文与数据的动静分离不一样，它从另外一个维度对数据进行了区分处理。你要明白，区分的目的主要还是对读热点数据加以优化，对照“4 要 1 不要”原则，它可以减少请求量，也可以减少请求的路径。因为缓存的数据都是经过多个请求，或者从多个系统中获取的数据经过计算后的结果。</p>
<p>热点的发现和隔离不仅对“秒杀”这个场景有意义，对其他的高性能分布式系统也非常有价值，尤其是热点的隔离非常重要。我介绍了业务层面的隔离和数据层面的隔离方式，最重要最简单的方式就是独立出来一个集群，单独处理热点数据。</p>
<p>但是能够独立出来一个集群的前提还是首先能够发现热点，为此我介绍了发现热点的几种方式，比如人工标识、大数据统计计算，以及实时热点发现方案，希望能够给你启发。</p>
<p>Read More:</p>
<blockquote>
<p><a href="https://d.shikey.com/jike/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E5%B7%B2%E5%AE%8C%E7%BB%93/20%20%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F-%E8%AE%B8%E4%BB%A4%E6%B3%A2/181003-03%20_%20%E4%BA%8C%E5%85%AB%E5%8E%9F%E5%88%99%EF%BC%9A%E6%9C%89%E9%92%88%E5%AF%B9%E6%80%A7%E5%9C%B0%E5%A4%84%E7%90%86%E5%A5%BD%E7%B3%BB%E7%BB%9F%E7%9A%84%E2%80%9C%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%E2%80%9D.html" target="_blank" rel="noopener">03 | 二八原则：有针对性地处理好系统的“热点数据”</a></p>
</blockquote>
]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
      <tags>
        <tag>秒杀系统</tag>
        <tag>架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>秒杀系统设计06 - 影响性能的因素有哪些？又该如何提高系统的性能？</title>
    <url>/2021/07/04/miaosha06/</url>
    <content><![CDATA[<p>前面的几篇文章里，我介绍的内容多少都和优化有关：第一篇介绍了一些指导原则；第二篇和第三篇从动静分离和热点数据两个维度，介绍了如何有针对性地对数据进行区分和优化处理；第四篇介绍了在保证实现基本业务功能的前提下，尽量减少和过滤一些无效请求的思路。</p>
<p>这几篇文章既是在讲根据指导原则实现的具体案例，也是在讲如何实现能够让整个系统更“快”。我想说的是，优化本身有很多手段，也是一个复杂的系统工程。今天，我就来结合秒杀这一场景，重点给你介绍下服务端的一些优化技巧。</p>
<h3 id="影响性能的因素"><a href="#影响性能的因素" class="headerlink" title="影响性能的因素"></a>影响性能的因素</h3><p>你想要提升性能，首先肯定要知道哪些因素对于系统性能的影响最大，然后再针对这些具体的因素想办法做优化，是不是这个逻辑？</p>
<p>那么，哪些因素对性能有影响呢？在回答这个问题之前，我们先定义一下“性能”，服务设备不同对性能的定义也是不一样的，例如 CPU 主要看主频、磁盘主要看 IOPS（Input/Output Operations Per Second，即每秒进行读写操作的次数）。</p>
<p>而今天我们讨论的主要是系统服务端性能，一般用 QPS（Query Per Second，每秒请求数）来衡量，还有一个影响和 QPS 也息息相关，那就是响应时间（Response Time，RT），它可以理解为服务器处理响应的耗时。</p>
<p>正常情况下响应时间（RT）越短，一秒钟处理的请求数（QPS）自然也就会越多，这在单线程处理的情况下看起来是线性的关系，即我们只要把每个请求的响应时间降到最低，那么性能就会最高。</p>
<p>但是你可能想到响应时间总有一个极限，不可能无限下降，所以又出现了另外一个维度，即通过多线程，来处理请求。这样理论上就变成了“总 QPS =（1000ms / 响应时间）× 线程数量”，这样性能就和两个因素相关了，一个是一次响应的服务端耗时，一个是处理请求的线程数。</p>
<p>接下来，我们一起看看这个两个因素到底会造成什么样的影响。</p>
<p><strong>首先，我们先来看看响应时间和 QPS 有啥关系</strong>。</p>
<p>对于大部分的 Web 系统而言，响应时间一般都是由 CPU 执行时间和线程等待时间（比如 RPC、IO 等待、Sleep、Wait 等）组成，即服务器在处理一个请求时，一部分是 CPU 本身在做运算，还有一部分是在各种等待。</p>
<p>理解了服务器处理请求的逻辑，估计你会说为什么我们不去减少这种等待时间。很遗憾，根据我们实际的测试发现，减少线程等待时间对提升性能的影响没有我们想象得那么大，它并不是线性的提升关系，这点在很多代理服务器（Proxy）上可以做验证。</p>
<p>如果代理服务器本身没有 CPU 消耗，我们在每次给代理服务器代理的请求加个延时，即增加响应时间，但是这对代理服务器本身的吞吐量并没有多大的影响，因为代理服务器本身的资源并没有被消耗，可以通过增加代理服务器的处理线程数，来弥补响应时间对代理服务器的 QPS 的影响。</p>
<p>其实，真正对性能有影响的是 CPU 的执行时间。这也很好理解，因为 CPU 的执行真正消耗了服务器的资源。经过实际的测试，如果减少 CPU 一半的执行时间，就可以增加一倍的 QPS。</p>
<p>也就是说，我们应该致力于减少 CPU 的执行时间。</p>
<p><strong>其次，我们再来看看线程数对 QPS 的影响</strong>。</p>
<p>单看“总 QPS”的计算公式，你会觉得线程数越多 QPS 也就会越高，但这会一直正确吗？显然不是，线程数不是越多越好，因为线程本身也消耗资源，也受到其他因素的制约。例如，线程越多系统的线程切换成本就会越高，而且每个线程也都会耗费一定内存。</p>
<p>那么，设置什么样的线程数最合理呢？其实<strong>很多多线程的场景都有一个默认配置，即“线程数 = 2 * CPU 核数 + 1”</strong>。除去这个配置，还有一个根据最佳实践得出来的公式：</p>
<blockquote>
<p>线程数 = [(线程等待时间 + 线程 CPU 时间) / 线程 CPU 时间] × CPU 数量</p>
</blockquote>
<p>当然，最好的办法是通过性能测试来发现最佳的线程数。</p>
<p>换句话说，要提升性能我们就要减少 CPU 的执行时间，另外就是要设置一个合理的并发线程数，通过这两方面来显著提升服务器的性能。</p>
<p>现在，你知道了如何来快速提升性能，那接下来你估计会问，我应该怎么发现系统哪里最消耗 CPU 资源呢？</p>
<h3 id="如何发现瓶颈"><a href="#如何发现瓶颈" class="headerlink" title="如何发现瓶颈"></a>如何发现瓶颈</h3><p>就服务器而言，会出现瓶颈的地方有很多，例如 CPU、内存、磁盘以及网络等都可能会导致瓶颈。此外，不同的系统对瓶颈的关注度也不一样，例如对缓存系统而言，制约它的是内存，而对存储型系统来说 I/O 更容易是瓶颈。</p>
<p><strong>这个专栏中，我们定位的场景是秒杀，它的瓶颈更多地发生在 CPU 上</strong>。</p>
<p>那么，如何发现 CPU 的瓶颈呢？其实有很多 CPU 诊断工具可以发现 CPU 的消耗，最常用的就是 JProfiler 和 Yourkit 这两个工具，它们可以列出整个请求中每个函数的 CPU 执行时间，可以发现哪个函数消耗的 CPU 时间最多，以便你有针对性地做优化。</p>
<p>当然还有一些办法也可以近似地统计 CPU 的耗时，例如通过 jstack 定时地打印调用栈，如果某些函数调用频繁或者耗时较多，那么那些函数就会多次出现在系统调用栈里，这样相当于采样的方式也能够发现耗时较多的函数。</p>
<p>虽说秒杀系统的瓶颈大部分在 CPU，但这并不表示其他方面就一定不出现瓶颈。例如，如果海量请求涌过来，你的页面又比较大，那么网络就有可能出现瓶颈。</p>
<p>怎样简单地判断 CPU 是不是瓶颈呢？一个办法就是看当 QPS 达到极限时，你的服务器的 CPU 使用率是不是超过了 95%，如果没有超过，那么表示 CPU 还有提升的空间，要么是有锁限制，要么是有过多的本地 I/O 等待发生。</p>
<p>现在你知道了优化哪些因素，又发现了瓶颈，那么接下来就要关注如何优化了。</p>
<h3 id="如何优化系统"><a href="#如何优化系统" class="headerlink" title="如何优化系统"></a>如何优化系统</h3><p>对 Java 系统来说，可以优化的地方很多，这里我重点说一下比较有效的几种手段，供你参考，它们是：减少编码、减少序列化、Java 极致优化、并发读优化。接下来，我们分别来看一下。</p>
<h4 id="减少编码"><a href="#减少编码" class="headerlink" title="减少编码"></a>减少编码</h4><p>Java 的编码运行比较慢，这是 Java 的一大硬伤。在很多场景下，只要涉及字符串的操作（如输入输出操作、I/O 操作）都比较耗 CPU 资源，不管它是磁盘 I/O 还是网络 I/O，因为都需要将字符转换成字节，而这个转换必须编码。</p>
<p>每个字符的编码都需要查表，而这种查表的操作非常耗资源，所以减少字符到字节或者相反的转换、减少字符编码会非常有成效。减少编码就可以大大提升性能。</p>
<p>那么如何才能减少编码呢？例如，网页输出是可以直接进行流输出的，即用 resp.getOutputStream() 函数写数据，把一些静态的数据提前转化成字节，等到真正往外写的时候再直接用 OutputStream() 函数写，就可以减少静态数据的编码转换。</p>
<p>我在《深入分析 Java Web 技术内幕》一书中介绍的“Velocity 优化实践”一章的内容，就是基于把静态的字符串提前编码成字节并缓存，然后直接输出字节内容到页面，从而大大减少编码的性能消耗的，网页输出的性能比没有提前进行字符到字节转换时提升了 30% 左右。</p>
<h4 id="减少序列化"><a href="#减少序列化" class="headerlink" title="减少序列化"></a>减少序列化</h4><p>序列化也是 Java 性能的一大天敌，减少 Java 中的序列化操作也能大大提升性能。又因为序列化往往是和编码同时发生的，所以减少序列化也就减少了编码。</p>
<p>序列化大部分是在 RPC 中发生的，因此避免或者减少 RPC 就可以减少序列化，当然当前的序列化协议也已经做了很多优化来提升性能。有一种新的方案，就是可以将多个关联性比较强的应用进行“合并部署”，而减少不同应用之间的 RPC 也可以减少序列化的消耗。</p>
<p>所谓“合并部署”，就是把两个原本在不同机器上的不同应用合并部署到一台机器上，当然不仅仅是部署在一台机器上，还要在同一个 Tomcat 容器中，且不能走本机的 Socket，这样才能避免序列化的产生。</p>
<p>另外针对秒杀场景，我们还可以做得更极致一些，接下来我们来看第 3 点：Java 极致优化。</p>
<h4 id="Java-极致优化"><a href="#Java-极致优化" class="headerlink" title="Java 极致优化"></a>Java 极致优化</h4><p>Java 和通用的 Web 服务器（如 Nginx 或 Apache 服务器）相比，在处理大并发的 HTTP 请求时要弱一点，所以一般我们都会对大流量的 Web 系统做静态化改造，让大部分请求和数据直接在 Nginx 服务器或者 Web 代理服务器（如 Varnish、Squid 等）上直接返回（这样可以减少数据的序列化与反序列化），而 Java 层只需处理少量数据的动态请求。针对这些请求，我们可以使用以下手段进行优化：</p>
<ul>
<li>直接使用 Servlet 处理请求。避免使用传统的 MVC 框架，这样可以绕过一大堆复杂且用处不大的处理逻辑，节省 1ms 时间（具体取决于你对 MVC 框架的依赖程度）。</li>
<li>直接输出流数据。使用 resp.getOutputStream() 而不是 resp.getWriter() 函数，可以省掉一些不变字符数据的编码，从而提升性能；数据输出时推荐使用 JSON 而不是模板引擎（一般都是解释执行）来输出页面。</li>
</ul>
<h4 id="并发读优化"><a href="#并发读优化" class="headerlink" title="并发读优化"></a>并发读优化</h4><p>也许有读者会觉得这个问题很容易解决，无非就是放到 Tair 缓存里面。集中式缓存为了保证命中率一般都会采用一致性 Hash，所以同一个 key 会落到同一台机器上。虽然单台缓存机器也能支撑 30w/s 的请求，但还是远不足以应对像“大秒”这种级别的热点商品。那么，该如何彻底解决单点的瓶颈呢？</p>
<p>答案是采用应用层的 LocalCache，即在秒杀系统的单机上缓存商品相关的数据。</p>
<p>那么，又如何缓存（Cache）数据呢？你需要划分成动态数据和静态数据分别进行处理：</p>
<ul>
<li>像商品中的“标题”和“描述”这些本身不变的数据，会在秒杀开始之前全量推送到秒杀机器上，并一直缓存到秒杀结束；</li>
<li>像库存这类动态数据，会采用“被动失效”的方式缓存一定时间（一般是数秒），失效后再去缓存拉取最新的数据。</li>
</ul>
<p>你可能还会有疑问：像库存这种频繁更新的数据，一旦数据不一致，会不会导致超卖？</p>
<p>这就要用到前面介绍的读数据的分层校验原则了，读的场景可以允许一定的脏数据，因为这里的误判只会导致少量原本无库存的下单请求被误认为有库存，可以等到真正写数据时再保证最终的一致性，通过在数据的高可用性和一致性之间的平衡，来解决高并发的数据读取问题。</p>
<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>性能优化的过程首先要从发现短板开始，除了我今天介绍的一些优化措施外，你还可以在减少数据、数据分级（动静分离），以及减少中间环节、增加预处理等这些环节上做优化。</p>
<p>首先是“发现短板”，比如考虑以下因素的一些限制：光速（光速：C = 30 万千米 / 秒；光纤：V = C/1.5=20 万千米 / 秒，即数据传输是有物理距离的限制的）、网速（2017 年 11 月知名测速网站 Ookla 发布报告，全国平均上网带宽达到 61.24 Mbps，千兆带宽下 10KB 数据的极限 QPS 为 1.25 万 QPS=1000Mbps/8/10KB）、网络结构（交换机 / 网卡的限制）、TCP/IP、虚拟机（内存 /CPU/IO 等资源的限制）和应用本身的一些瓶颈等。</p>
<p>其次是减少数据。事实上，有两个地方特别影响性能，一是服务端在处理数据时不可避免地存在字符到字节的相互转化，二是 HTTP 请求时要做 Gzip 压缩，还有网络传输的耗时，这些都和数据大小密切相关。</p>
<p>再次，就是数据分级，也就是要保证首屏为先、重要信息为先，次要信息则异步加载，以这种方式提升用户获取数据的体验。</p>
<p>最后就是要减少中间环节，减少字符到字节的转换，增加预处理（提前做字符到字节的转换）去掉不需要的操作。</p>
<p>此外，要做好优化，你还需要做好应用基线，比如性能基线（何时性能突然下降）、成本基线（去年双 11 用了多少台机器）、链路基线（我们的系统发生了哪些变化），你可以通过这些基线持续关注系统的性能，做到在代码上提升编码质量，在业务上改掉不合理的调用，在架构和调用链路上不断的改进。</p>
<p>Read More:</p>
<blockquote>
<p><a href="https://d.shikey.com/jike/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E5%B7%B2%E5%AE%8C%E7%BB%93/20%20%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F-%E8%AE%B8%E4%BB%A4%E6%B3%A2/181005-05%20_%20%E5%BD%B1%E5%93%8D%E6%80%A7%E8%83%BD%E7%9A%84%E5%9B%A0%E7%B4%A0%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E5%8F%88%E8%AF%A5%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%A7%E8%83%BD%EF%BC%9F.html" target="_blank" rel="noopener">05 | 影响性能的因素有哪些？又该如何提高系统的性能？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
      <tags>
        <tag>秒杀系统</tag>
        <tag>架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>秒杀系统设计05 - 流量削峰这事应该怎么做？</title>
    <url>/2021/07/04/miaosha05/</url>
    <content><![CDATA[<p>如果你看过秒杀系统的流量监控图的话，你会发现它是一条直线，就在秒杀开始那一秒是一条很直很直的线，这是因为秒杀请求在时间上高度集中于某一特定的时间点。这样一来，就会导致一个特别高的流量峰值，它对资源的消耗是瞬时的。</p>
<p>但是对秒杀这个场景来说，最终能够抢到商品的人数是固定的，也就是说 100 人和 10000 人发起请求的结果都是一样的，并发度越高，无效请求也越多。</p>
<p>但是从业务上来说，秒杀活动是希望更多的人来参与的，也就是开始之前希望有更多的人来刷页面，但是真正开始下单时，秒杀请求并不是越多越好。因此我们可以设计一些规则，让并发的请求更多地延缓，而且我们甚至可以过滤掉一些无效请求。</p>
<h3 id="为什么要削峰"><a href="#为什么要削峰" class="headerlink" title="为什么要削峰"></a>为什么要削峰</h3><p>为什么要削峰呢？或者说峰值会带来哪些坏处？</p>
<p>我们知道服务器的处理资源是恒定的，你用或者不用它的处理能力都是一样的，所以出现峰值的话，很容易导致忙到处理不过来，闲的时候却又没有什么要处理。但是由于要保证服务质量，我们的很多处理资源只能按照忙的时候来预估，而这会导致资源的一个浪费。</p>
<p>这就好比因为存在早高峰和晚高峰的问题，所以有了错峰限行的解决方案。削峰的存在，一是可以让服务端处理变得更加平稳，二是可以节省服务器的资源成本。针对秒杀这一场景，削峰从本质上来说就是更多地延缓用户请求的发出，以便减少和过滤掉一些无效请求，它遵从“请求数要尽量少”的原则。</p>
<p>今天，我就来介绍一下流量削峰的一些操作思路：排队、答题、分层过滤。这几种方式都是无损（即不会损失用户的发出请求）的实现方案，当然还有些有损的实现方案，包括我们后面要介绍的关于稳定性的一些办法，比如限流和机器负载保护等一些强制措施也能达到削峰保护的目的，当然这都是不得已的一些措施，因此就不归类到这里了。</p>
<h4 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h4><p>要对流量进行削峰，最容易想到的解决方案就是用消息队列来缓冲瞬时流量，把同步的直接调用转换成异步的间接推送，中间通过一个队列在一端承接瞬时的流量洪峰，在另一端平滑地将消息推送出去。在这里，消息队列就像“水库”一样， 拦蓄上游的洪水，削减进入下游河道的洪峰流量，从而达到减免洪水灾害的目的。</p>
<p>用消息队列来缓冲瞬时流量的方案，如下图所示：</p>
<p><img src="/images/2021-7-4102313.png" alt="2021-7-4102313.png"></p>
<p>但是，如果流量峰值持续一段时间达到了消息队列的处理上限，例如本机的消息积压达到了存储空间的上限，消息队列同样也会被压垮，这样虽然保护了下游的系统，但是和直接把请求丢弃也没多大的区别。就像遇到洪水爆发时，即使是有水库恐怕也无济于事。</p>
<p>除了消息队列，类似的排队方式还有很多，例如：</p>
<ol>
<li>利用线程池加锁等待也是一种常用的排队方式；</li>
<li>先进先出、先进后出等常用的内存排队算法的实现方式；</li>
<li>把请求序列化到文件中，然后再顺序地读文件（例如基于 MySQL binlog 的同步机制）来恢复请求等方式。</li>
</ol>
<p>可以看到，这些方式都有一个共同特征，就是把“一步的操作”变成“两步的操作”，其中增加的一步操作用来起到缓冲的作用。</p>
<p>说到这里你可能会说，这样一来增加了访问请求的路径啊，并不符合我们介绍的“4 要 1 不要”原则。没错，的确看起来不太合理，但是如果不增加一个缓冲步骤，那么在一些场景下系统很可能会直接崩溃，所以最终还是需要你做出妥协和平衡。</p>
<h4 id="答题"><a href="#答题" class="headerlink" title="答题"></a>答题</h4><p>你是否还记得，最早期的秒杀只是纯粹地刷新页面和点击购买按钮，它是后来才增加了答题功能的。那么，为什么要增加答题功能呢？</p>
<p>这主要是为了增加购买的复杂度，从而达到两个目的。</p>
<p>第一个目的是防止部分买家使用秒杀器在参加秒杀时作弊。2011 年秒杀非常火的时候，秒杀器也比较猖獗，因而没有达到全民参与和营销的目的，所以系统增加了答题来限制秒杀器。增加答题后，下单的时间基本控制在 2s 后，秒杀器的下单比例也大大下降。答题页面如下图所示。</p>
<p><img src="/images/2021-7-4102422.png" alt="2021-7-4102422.png"></p>
<p>第二个目的其实就是延缓请求，起到对请求流量进行削峰的作用，从而让系统能够更好地支持瞬时的流量高峰。这个重要的功能就是把峰值的下单请求拉长，从以前的 1s 之内延长到 2s~10s。这样一来，请求峰值基于时间分片了。这个时间的分片对服务端处理并发非常重要，会大大减轻压力。而且，由于请求具有先后顺序，靠后的请求到来时自然也就没有库存了，因此根本到不了最后的下单步骤，所以真正的并发写就非常有限了。这种设计思路目前用得非常普遍，如当年支付宝的“咻一咻”、微信的“摇一摇”都是类似的方式。</p>
<p>这里，我重点说一下秒杀答题的设计思路。</p>
<p><img src="/images/2021-7-4102454.png" alt="2021-7-4102454.png"></p>
<p>如上图所示，整个秒杀答题的逻辑主要分为 3 部分。</p>
<ol>
<li><strong>题库生成模块</strong>，这个部分主要就是生成一个个问题和答案，其实题目和答案本身并不需要很复杂，重要的是能够防止由机器来算出结果，即防止秒杀器来答题。</li>
<li><strong>题库的推送模块</strong>，用于在秒杀答题前，把题目提前推送给详情系统和交易系统。题库的推送主要是为了保证每次用户请求的题目是唯一的，目的也是防止答题作弊。</li>
<li><strong>题目的图片生成模块</strong>，用于把题目生成为图片格式，并且在图片里增加一些干扰因素。这也同样是为防止机器直接来答题，它要求只有人才能理解题目本身的含义。这里还要注意一点，由于答题时网络比较拥挤，我们应该把题目的图片提前推送到 CDN 上并且要进行预热，不然的话当用户真正请求题目时，图片可能加载比较慢，从而影响答题的体验。</li>
</ol>
<p>其实真正答题的逻辑比较简单，很好理解：当用户提交的答案和题目对应的答案做比较，如果通过了就继续进行下一步的下单逻辑，否则就失败。我们可以把问题和答案用下面这样的 key 来进行 MD5 加密：</p>
<ul>
<li>问题 key：userId+itemId+question_Id+time+PK</li>
<li>答案 key：userId+itemId+answer+PK</li>
</ul>
<p>验证的逻辑如下图所示：</p>
<p><img src="/images/2021-7-4102527.png" alt="2021-7-4102527.png"></p>
<p>注意，这里面的验证逻辑，除了验证问题的答案以外，还包括用户本身身份的验证，例如是否已经登录、用户的 Cookie 是否完整、用户是否重复频繁提交等。</p>
<p>除了做正确性验证，我们还可以对提交答案的时间做些限制，例如从开始答题到接受答案要超过 1s，因为小于 1s 是人为操作的可能性很小，这样也能防止机器答题的情况。</p>
<h4 id="分层过滤"><a href="#分层过滤" class="headerlink" title="分层过滤"></a>分层过滤</h4><p>前面介绍的排队和答题要么是少发请求，要么对发出来的请求进行缓冲，而针对秒杀场景还有一种方法，就是对请求进行分层过滤，从而过滤掉一些无效的请求。分层过滤其实就是采用“漏斗”式设计来处理请求的，如下图所示。</p>
<p><img src="/images/2021-7-4102644.png" alt="2021-7-4102644.png"></p>
<p>假如请求分别经过 CDN、前台读系统（如商品详情系统）、后台系统（如交易系统）和数据库这几层，那么：</p>
<ul>
<li>大部分数据和流量在用户浏览器或者 CDN 上获取，这一层可以拦截大部分数据的读取；</li>
<li>经过第二层（即前台系统）时数据（包括强一致性的数据）尽量得走 Cache，过滤一些无效的请求；</li>
<li>再到第三层后台系统，主要做数据的二次检验，对系统做好保护和限流，这样数据量和请求就进一步减少；</li>
<li>最后在数据层完成数据的强一致性校验。</li>
</ul>
<p>这样就像漏斗一样，尽量把数据量和请求量一层一层地过滤和减少了。</p>
<p><strong>分层过滤的核心思想是：在不同的层次尽可能地过滤掉无效请求，让“漏斗”最末端的才是有效请求</strong>。而要达到这种效果，我们就必须对数据做分层的校验。</p>
<p>分层校验的基本原则是：</p>
<ol>
<li>将动态请求的读数据缓存（Cache）在 Web 端，过滤掉无效的数据读；</li>
<li>对读数据不做强一致性校验，减少因为一致性校验产生瓶颈的问题；</li>
<li>对写数据进行基于时间的合理分片，过滤掉过期的失效请求；</li>
<li>对写请求做限流保护，将超出系统承载能力的请求过滤掉；</li>
<li>对写数据进行强一致性校验，只保留最后有效的数据。</li>
</ol>
<p>分层校验的目的是：在读系统中，尽量减少由于一致性校验带来的系统瓶颈，但是尽量将不影响性能的检查条件提前，如用户是否具有秒杀资格、商品状态是否正常、用户答题是否正确、秒杀是否已经结束、是否非法请求、营销等价物是否充足等；在写数据系统中，主要对写的数据（如“库存”）做一致性检查，最后在数据库层保证数据的最终准确性（如“库存”不能减为负数）。</p>
<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>今天，我介绍了如何在网站面临大流量冲击时进行请求的削峰，并主要介绍了削峰的 3 种处理方式：一个是通过队列来缓冲请求，即控制请求的发出；一个是通过答题来延长请求发出的时间，在请求发出后承接请求时进行控制，最后再对不符合条件的请求进行过滤；最后一种是对请求进行分层过滤。</p>
<p>其中，队列缓冲方式更加通用，它适用于内部上下游系统之间调用请求不平缓的场景，由于内部系统的服务质量要求不能随意丢弃请求，所以使用消息队列能起到很好的削峰和缓冲作用。</p>
<p>而答题更适用于秒杀或者营销活动等应用场景，在请求发起端就控制发起请求的速度，因为越到后面无效请求也会越多，所以配合后面介绍的分层拦截的方式，可以更进一步减少无效请求对系统资源的消耗。</p>
<p>分层过滤非常适合交易性的写请求，比如减库存或者拼车这种场景，在读的时候需要知道还有没有库存或者是否还有剩余空座位。但是由于库存和座位又是不停变化的，所以读的数据是否一定要非常准确呢？其实不一定，你可以放一些请求过去，然后在真正减的时候再做强一致性保证，这样既过滤一些请求又解决了强一致性读的瓶颈。</p>
<p>不过，在削峰的处理方式上除了采用技术手段，其实还可以采用业务手段来达到一定效果，例如在零点开启大促的时候由于流量太大导致支付系统阻塞，这个时候可以采用发放优惠券、发起抽奖活动等方式，将一部分流量分散到其他地方，这样也能起到缓冲流量的作用。</p>
<p>Read More:</p>
<blockquote>
<p><a href="https://d.shikey.com/jike/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E5%B7%B2%E5%AE%8C%E7%BB%93/20%20%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F-%E8%AE%B8%E4%BB%A4%E6%B3%A2/181004-04%20_%20%E6%B5%81%E9%87%8F%E5%89%8A%E5%B3%B0%E8%BF%99%E4%BA%8B%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F.html" target="_blank" rel="noopener">04 | 流量削峰这事应该怎么做？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
      <tags>
        <tag>秒杀系统</tag>
        <tag>架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql系列 - 索引</title>
    <url>/2021/02/20/mysql-index/</url>
    <content><![CDATA[<blockquote>
<p> 索引是存储引擎用于快速找到记录的一种数据结构</p>
</blockquote>
<p>这是MySQL官方对于索引的定义，可以看到索引是一种数据结构，那么我们应该怎样理解索引呢？一个常见的例子就是书的目录。我们都已经养成了看目录的习惯，拿到一本书时，我们首先会先去查看他的目录，并且当我们要查找某个内容时，我们会在目录中查找，然后找到该片段对应的页码，再根据相应的页码去书中查找。如果没有索引(目录)的话，我们就只能一页一页的去查找了。</p>
<h3 id="索引优缺点"><a href="#索引优缺点" class="headerlink" title="索引优缺点"></a>索引优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>减少查询需要扫描的数据量(加快了查询速度)</li>
<li>减少服务器的排序操作和创建临时表的操作(加快了groupby和orderby等操作)</li>
<li>将服务器的随机IO变为顺序IO(加快查询速度)</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>索引占用磁盘或者内存空间</li>
<li>减慢了插入更新操作的速度</li>
</ul>
<h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><p>从存储结构划分</p>
<ul>
<li>Btree索引（B+tree，B-tree)</li>
<li>哈希索引</li>
<li>全文索引 </li>
<li>RTree</li>
</ul>
<p>从应用层次划分</p>
<ul>
<li>普通索引：即一个索引只包含单个列，一个表可以有多个单列索引。<code>ALTER TABLE table_name ADD INDEX index_name (column)</code></li>
<li>唯一索引：索引列的值必须唯一，但允许有空值。<code>ALTER TABLE table_name ADD UNIQUE (column)</code></li>
<li>主键索引：特殊的唯一索引，不允许为空，只能有一个，一般是在建表时指定。<code>ALTER TABLE table_name ADD PRIMARY KEY (column)</code></li>
<li>组合索引：在多个字段上创建索引，遵循<strong>最左前缀原则</strong>。<code>ALTER TABLE table_name ADD INDEX index_name (column1,column2,column3)</code></li>
</ul>
<p>从表记录的排列顺序和索引的排列顺序是否一致划分</p>
<ul>
<li>聚集索引：表记录的排列顺序和索引的排列顺序一致，查询效率快，因为只要找到第一个索引值记录，其余的连续性的记录在物理表中也会连续存放，一起就可以查询到。</li>
<li>非聚集索引：表记录的排列顺序和索引的排列顺序不一致，非聚集索引在叶子节点存储的是主键和索引列，当我们使用非聚集索引查询数据时，需要拿到叶子上的主键再去表中查到想要查找的数据。这个过程就是回表。</li>
</ul>
<p>聚集索引和非聚集索引区别：</p>
<blockquote>
<p>聚集索引在叶子节点存储的是表中的数据，非聚集索引在叶子节点存储的是主键和索引列。</p>
</blockquote>
<p>比如汉语字典，想要查「阿」字，只需要翻到字典前几页，a开头的位置，接着「啊」「爱」都会出来。也就是说，字典的正文部分本身就是一个目录，不需要再去查其他目录来找到需要找的内容。我们把这种正文内容本身就是一种按照一定规则排列的目录称为聚集索引。</p>
<p>比如要查“玉”字，我们可以看到在查部首之后的检字表中“玉”的页码是587页，然后是珏，是251页。很显然，在字典中这两个字并没有挨着，现在看到的连续的“玉、珏、莹”三字实际上就是他们在非聚集索引中的排序，是字典正文中的字在非聚集索引中的映射。我们可以通过这种方式来找到所需要的字，但它需要两个过程，先找到目录中的结果，然后再翻到结果所对应的页码。我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为非聚集索引。</p>
<h3 id="索引建立原则"><a href="#索引建立原则" class="headerlink" title="索引建立原则"></a>索引建立原则</h3><ul>
<li><strong>索引并非越多越好</strong>，大量索引不仅占用磁盘空间，而且会影响INSERT、DELETE、UPDATE等语句的性能，表数据更改的同时，索引也会进行调整和更新</li>
<li><strong>避免对经常更新的表进行过多的索引</strong>，并且索引中的列尽可能少。而对经常用于查询的字段应该创建索引，但要避免添加不必要的字段</li>
<li><strong>数据量小的表最好不要使用索引</strong>，由于数据较少，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果</li>
<li><strong>在条件表达式中经常用到的不同值较多的列上建立索引，在不同值很少的列上不要建立索引</strong>。比如在学生表的“性别”字段上只有“男”与“女”两个不同值，因此就无须建立索引。如果建立索引，不但不会提高查询效率，反而会严重降低数据更新速度</li>
<li><strong>当唯一性是某种数据本身的特征时，指定唯一索引</strong>。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度</li>
<li><strong>在频繁进行排序或分组（即进行group by或order by操作）的列上建立索引</strong>，如果待排序的列有多个，可以在这些列上建立组合索引</li>
<li><strong>搜索的索引列，不一定是所要选择的列</strong>。换句话说，最适合索引的列是出现在WHERE子句中的列，或连接子句中指定的列，而不是出现在SELECT关键字后的选择列表中的列</li>
<li><strong>使用短索引</strong>。如果对字符串列进行索引，应该指定一个前缀长度，只要有可能就应该这样做。例如，有一个CHAR(200)列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。对前10个或20个字符进行索引能够节省大量索引空间，也可能会使查询更快。较小的索引涉及的磁盘 IO 较少，较短的值比较起来更快。更为重要的是，对于较短的键值，索引高速缓存中的块能容纳更多的键值，因此，MySQL 也可以在内存中容纳更多的值。这样就增加了找到行而不用读取索引中较多块的可能性</li>
<li><strong>利用最左前缀</strong>。在创建一个n列的索引时，实际是创建了MySQL可利用的n个索引。多列索引可起几个索引的作用，因为可利用索引中最左边的列集来匹配行。这样的列集称为最左前缀</li>
<li>对于InnoDB存储引擎的表，记录默认会按照一定的顺序保存，如果有明确定义的主键，则按照主键顺序保存。如果没有主键，但是有唯一索引，那么就是按照唯一索引的顺序保存。如果既没有主键又没有唯一索引，那么表中会自动生成一个内部列，按照这个列的顺序保存。按照主键或者内部列进行的访问是最快的，所以<strong>InnoDB表尽量自己指定主键</strong>，当表中同时有几个列都是唯一的，都可以作为主键的时候，要选择最常作为访问条件的列作为主键，提高查询的效率。另外，还需要注意，InnoDB 表的普通索引都会保存主键的键值，所以主键要尽可能选择较短的数据类型，可以有效地减少索引的磁盘占用，提高索引的缓存效果</li>
</ul>
<h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><ul>
<li>使用!=、&lt;&gt; 导致索引失效</li>
<li>类型不一致导致的索引失效：查询时字段值类型必须与表字段类型一致，避免进行类型转换</li>
<li>函数导致的索引失效：避免查询语句中使用函数</li>
<li>运算符导致的索引失效：如果对列进行<code>+，-，*，/，!</code>运算，则索引失效</li>
<li>OR引起的索引失效：OR导致索引是在特定情况下的，并不是所有的OR都是使索引失效，如果OR连接的是同一个字段，那么索引不会失效，反之索引失效</li>
<li>模糊搜索导致的索引失效：like语句使用”xxx%”会走索引，使用”%xxx”或”%xxx%”不走索引</li>
<li>尽量少用is null、is not null</li>
</ul>
<h3 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h3><ul>
<li>先运行看看是否真的很慢，注意设置SQL_NO_CACHE</li>
<li>where条件单表查，锁定最小返回记录表。把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高</li>
<li>explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）</li>
<li>order by limit 形式的sql语句让排序的表优先查</li>
<li>了解业务方使用场景</li>
<li>加索引时参照建索引的几大原则</li>
<li>观察结果，不符合预期继续从0分析</li>
</ul>
<p>Read More:</p>
<blockquote>
<p><a href="https://juejin.cn/post/6844903909899632654#heading-2" target="_blank" rel="noopener">详解Mysql索引原理及其优化</a></p>
<p><a href="https://segmentfault.com/a/1190000023911554" target="_blank" rel="noopener">导致MySQL索引失效的几种常见写法</a></p>
<p><a href="https://www.cnblogs.com/zsql/p/13808417.html" target="_blank" rel="noopener">Mysql索引（一篇就够le）</a></p>
<p><a href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank" rel="noopener">MySQL索引原理及慢查询优化</a></p>
</blockquote>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>秒杀系统设计07 - 秒杀系统“减库存”设计的核心逻辑</title>
    <url>/2021/07/04/miaosha07/</url>
    <content><![CDATA[<p>如果要设计一套秒杀系统，那我想你的老板肯定会先对你说：千万不要超卖，这是大前提。</p>
<p>如果你第一次接触秒杀，那你可能还不太理解，库存 100 件就卖 100 件，在数据库里减到 0 就好了啊，这有什么麻烦的？是的，理论上是这样，但是具体到业务场景中，“减库存”就不是这么简单了。</p>
<p>例如，我们平常购物都是这样，看到喜欢的商品然后下单，但并不是每个下单请求你都最后付款了。你说系统是用户下单了就算这个商品卖出去了，还是等到用户真正付款了才算卖出了呢？这的确是个问题！</p>
<p>我们可以先根据减库存是发生在下单阶段还是付款阶段，把减库存做一下划分。</p>
<h3 id="减库存有哪几种方式"><a href="#减库存有哪几种方式" class="headerlink" title="减库存有哪几种方式"></a>减库存有哪几种方式</h3><p>在正常的电商平台购物场景中，用户的实际购买过程一般分为两步：下单和付款。你想买一台 iPhone 手机，在商品页面点了“立即购买”按钮，核对信息之后点击“提交订单”，这一步称为下单操作。下单之后，你只有真正完成付款操作才能算真正购买，也就是俗话说的“落袋为安”。</p>
<p>那如果你是架构师，你会在哪个环节完成减库存的操作呢？总结来说，减库存操作一般有如下几个方式：</p>
<ul>
<li><strong>下单减库存</strong>，即当买家下单后，在商品的总库存中减去买家购买数量。下单减库存是最简单的减库存方式，也是控制最精确的一种，下单时直接通过数据库的事务机制控制商品库存，这样一定不会出现超卖的情况。但是你要知道，有些人下完单可能并不会付款。</li>
<li><strong>付款减库存</strong>，即买家下单后，并不立即减库存，而是等到有用户付款后才真正减库存，否则库存一直保留给其他买家。但因为付款时才减库存，如果并发比较高，有可能出现买家下单后付不了款的情况，因为可能商品已经被其他人买走了。</li>
<li><strong>预扣库存</strong>，这种方式相对复杂一些，买家下单后，库存为其保留一定的时间（如 10 分钟），超过这个时间，库存将会自动释放，释放后其他买家就可以继续购买。在买家付款前，系统会校验该订单的库存是否还有保留：如果没有保留，则再次尝试预扣；如果库存不足（也就是预扣失败）则不允许继续付款；如果预扣成功，则完成付款并实际地减去库存。</li>
</ul>
<p>以上这几种减库存的方式都会存在一些问题，下面我们一起来看下。</p>
<h3 id="减库存可能存在的问题"><a href="#减库存可能存在的问题" class="headerlink" title="减库存可能存在的问题"></a>减库存可能存在的问题</h3><p>由于购物过程中存在两步或者多步的操作，因此在不同的操作步骤中减库存，就会存在一些可能被恶意买家利用的漏洞，例如发生恶意下单的情况。</p>
<p>假如我们采用“下单减库存”的方式，即用户下单后就减去库存，正常情况下，买家下单后付款的概率会很高，所以不会有太大问题。但是有一种场景例外，就是当卖家参加某个活动时，此时活动的有效时间是商品的黄金售卖时间，如果有竞争对手通过恶意下单的方式将该卖家的商品全部下单，让这款商品的库存减为零，那么这款商品就不能正常售卖了。要知道，这些恶意下单的人是不会真正付款的，这正是“下单减库存”方式的不足之处。</p>
<p>既然“下单减库存”可能导致恶意下单，从而影响卖家的商品销售，那么有没有办法解决呢？你可能会想，采用“付款减库存”的方式是不是就可以了？的确可以。但是，“付款减库存”又会导致另外一个问题：库存超卖。</p>
<p>假如有 100 件商品，就可能出现 300 人下单成功的情况，因为下单时不会减库存，所以也就可能出现下单成功数远远超过真正库存数的情况，这尤其会发生在做活动的热门商品上。这样一来，就会导致很多买家下单成功但是付不了款，买家的购物体验自然比较差。</p>
<p>可以看到，不管是“下单减库存”还是“付款减库存”，都会导致商品库存不能完全和实际售卖情况对应起来的情况，看来要把商品准确地卖出去还真是不容易啊！</p>
<p>那么，既然“下单减库存”和“付款减库存”都有缺点，我们能否把两者相结合，将两次操作进行前后关联起来，下单时先预扣，在规定时间内不付款再释放库存，即采用“预扣库存”这种方式呢？</p>
<p>这种方案确实可以在一定程度上缓解上面的问题。但是否就彻底解决了呢？其实没有！针对恶意下单这种情况，虽然把有效的付款时间设置为 10 分钟，但是恶意买家完全可以在 10 分钟后再次下单，或者采用一次下单很多件的方式把库存减完。针对这种情况，解决办法还是要结合安全和反作弊的措施来制止。</p>
<p>例如，给经常下单不付款的买家进行识别打标（可以在被打标的买家下单时不减库存）、给某些类目设置最大购买件数（例如，参加活动的商品一人最多只能买 3 件），以及对重复下单不付款的操作进行次数限制等。</p>
<p>针对“库存超卖”这种情况，在 10 分钟时间内下单的数量仍然有可能超过库存数量，遇到这种情况我们只能区别对待：对普通的商品下单数量超过库存数量的情况，可以通过补货来解决；但是有些卖家完全不允许库存为负数的情况，那只能在买家付款时提示库存不足。</p>
<h3 id="大型秒杀中如何减库存？"><a href="#大型秒杀中如何减库存？" class="headerlink" title="大型秒杀中如何减库存？"></a>大型秒杀中如何减库存？</h3><p>目前来看，业务系统中最常见的就是预扣库存方案，像你在买机票、买电影票时，下单后一般都有个“有效付款时间”，超过这个时间订单自动释放，这都是典型的预扣库存方案。而具体到秒杀这个场景，应该采用哪种方案比较好呢？</p>
<p>由于参加秒杀的商品，一般都是“抢到就是赚到”，所以成功下单后却不付款的情况比较少，再加上卖家对秒杀商品的库存有严格限制，所以秒杀商品采用“下单减库存”更加合理。另外，理论上由于“下单减库存”比“预扣库存”以及涉及第三方支付的“付款减库存”在逻辑上更为简单，所以性能上更占优势。</p>
<p>“下单减库存”在数据一致性上，主要就是保证大并发请求时库存数据不能为负数，也就是要保证数据库中的库存字段值不能为负数，一般我们有多种解决方案：一种是在应用程序中通过事务来判断，即保证减后库存不能为负数，否则就回滚；另一种办法是直接设置数据库的字段数据为无符号整数，这样减后库存字段值小于零时会直接执行 SQL 语句来报错；再有一种就是使用 CASE WHEN 判断语句，例如这样的 SQL 语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UPDATE item SET inventory = CASE WHEN inventory &gt;= xxx THEN inventory-xxx ELSE inventory END</span><br></pre></td></tr></table></figure>
<h3 id="秒杀减库存的极致优化"><a href="#秒杀减库存的极致优化" class="headerlink" title="秒杀减库存的极致优化"></a>秒杀减库存的极致优化</h3><p>在交易环节中，“库存”是个关键数据，也是个热点数据，因为交易的各个环节中都可能涉及对库存的查询。但是，我在前面介绍分层过滤时提到过，秒杀中并不需要对库存有精确的一致性读，把库存数据放到缓存（Cache）中，可以大大提升读性能。</p>
<p>解决大并发读问题，可以采用 LocalCache（即在秒杀系统的单机上缓存商品相关的数据）和对数据进行分层过滤的方式，但是像减库存这种大并发写无论如何还是避免不了，这也是秒杀场景下最为核心的一个技术难题。</p>
<p><strong>因此，这里我想专门来说一下秒杀场景下减库存的极致优化思路，包括如何在缓存中减库存以及如何在数据库中减库存</strong>。</p>
<p>秒杀商品和普通商品的减库存还是有些差异的，例如商品数量比较少，交易时间段也比较短，因此这里有一个大胆的假设，即能否把秒杀商品减库存直接放到缓存系统中实现，也就是直接在缓存中减库存或者在一个带有持久化功能的缓存系统（如 Redis）中完成呢？</p>
<p>如果你的秒杀商品的减库存逻辑非常单一，比如没有复杂的 SKU 库存和总库存这种联动关系的话，我觉得完全可以。但是如果有比较复杂的减库存逻辑，或者需要使用事务，你还是必须在数据库中完成减库存。</p>
<p>由于 MySQL 存储数据的特点，同一数据在数据库里肯定是一行存储（MySQL），因此会有大量线程来竞争 InnoDB 行锁，而并发度越高时等待线程会越多，TPS（Transaction Per Second，即每秒处理的消息数）会下降，响应时间（RT）会上升，数据库的吞吐量就会严重受影响。</p>
<p>这就可能引发一个问题，就是单个热点商品会影响整个数据库的性能， 导致 0.01% 的商品影响 99.99% 的商品的售卖，这是我们不愿意看到的情况。一个解决思路是遵循前面介绍的原则进行隔离，把热点商品放到单独的热点库中。但是这无疑会带来维护上的麻烦，比如要做热点数据的动态迁移以及单独的数据库等。</p>
<p>而分离热点商品到单独的数据库还是没有解决并发锁的问题，我们应该怎么办呢？要解决并发锁的问题，有两种办法：</p>
<ul>
<li><strong>应用层做排队</strong>。按照商品维度设置队列顺序执行，这样能减少同一台机器对数据库同一行记录进行操作的并发度，同时也能控制单个商品占用数据库连接的数量，防止热点商品占用太多的数据库连接。</li>
<li><strong>数据库层做排队</strong>。应用层只能做到单机的排队，但是应用机器数本身很多，这种排队方式控制并发的能力仍然有限，所以如果能在数据库层做全局排队是最理想的。阿里的数据库团队开发了针对这种 MySQL 的 InnoDB 层上的补丁程序（patch），可以在数据库层上对单行记录做到并发排队。</li>
</ul>
<p>你可能有疑问了，排队和锁竞争不都是要等待吗，有啥区别？</p>
<p>如果熟悉 MySQL 的话，你会知道 InnoDB 内部的死锁检测，以及 MySQL Server 和 InnoDB 的切换会比较消耗性能，淘宝的 MySQL 核心团队还做了很多其他方面的优化，如 COMMIT_ON_SUCCESS 和 ROLLBACK_ON_FAIL 的补丁程序，配合在 SQL 里面加提示（hint），在事务里不需要等待应用层提交（COMMIT），而在数据执行完最后一条 SQL 后，直接根据 TARGET_AFFECT_ROW 的结果进行提交或回滚，可以减少网络等待时间（平均约 0.7ms）。据我所知，目前阿里 MySQL 团队已经将包含这些补丁程序的 MySQL 开源。</p>
<p>另外，数据更新问题除了前面介绍的热点隔离和排队处理之外，还有些场景（如对商品的 lastmodifytime 字段的）更新会非常频繁，在某些场景下这些多条 SQL 是可以合并的，一定时间内只要执行最后一条 SQL 就行了，以便减少对数据库的更新操作。</p>
<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>今天，我围绕商品减库存的场景，介绍了减库存的三种实现方案，以及分别存在的问题和可能的缓解办法。最后，我又聚焦秒杀这个场景说了如何实现减库存，以及在这个场景下做到极致优化的一些思路。</p>
<p>当然减库存还有很多细节问题，例如预扣的库存超时后如何进行库存回补，再比如目前都是第三方支付，如何在付款时保证减库存和成功付款时的状态一致性，这些都是很大的挑战。</p>
<p>Read More:</p>
<blockquote>
<p><a href="https://d.shikey.com/jike/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E5%B7%B2%E5%AE%8C%E7%BB%93/20%20%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F-%E8%AE%B8%E4%BB%A4%E6%B3%A2/181006-06%20_%20%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E2%80%9C%E5%87%8F%E5%BA%93%E5%AD%98%E2%80%9D%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91.html" target="_blank" rel="noopener">06 | 秒杀系统“减库存”设计的核心逻辑</a></p>
</blockquote>
]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
      <tags>
        <tag>秒杀系统</tag>
        <tag>架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>秒杀系统设计08 - 准备Plan B：如何设计兜底方案?</title>
    <url>/2021/07/04/miaosha08/</url>
    <content><![CDATA[<p>这是《如何设计一个秒杀系统》专栏的最后一篇文章，前面我们一起看了很多极致的优化思路，以及架构的优化方案。但是很遗憾，现实中总难免会发生一些这样或者那样的意外，而这些看似不经意的意外，却可能带来非常严重的后果。</p>
<p>我想对于很多秒杀系统而言，在诸如双十一这样的大流量的迅猛冲击下，都曾经或多或少发生过宕机的情况。当一个系统面临持续的大流量时，它其实很难单靠自身调整来恢复状态，你必须等待流量自然下降或者人为地把流量切走才行，这无疑会严重影响用户的购物体验。</p>
<p>同时，你也要知道，没有人能够提前预估所有情况，意外无法避免。那么，我们是不是就没办法了呢？当然不是，我们可以在系统达到不可用状态之前就做好流量限制，防止最坏情况的发生。用现在流行的话来说，任何一个系统，都需要“反脆弱”。</p>
<p>具体到秒杀这一场景下，为了保证系统的高可用，我们必须设计一个 Plan B 方案来兜底，这样在最坏情况发生时我们仍然能够从容应对。今天，我们就来看下兜底方案设计的一些具体思路。</p>
<h3 id="高可用建设应该从哪里着手"><a href="#高可用建设应该从哪里着手" class="headerlink" title="高可用建设应该从哪里着手"></a>高可用建设应该从哪里着手</h3><p>说到系统的高可用建设，它其实是一个系统工程，需要考虑到系统建设的各个阶段，也就是说它其实贯穿了系统建设的整个生命周期，如下图所示：</p>
<p><img src="/images/2021-7-4103326.png" alt="2021-7-4103326.png"></p>
<p>具体来说，系统的高可用建设涉及架构阶段、编码阶段、测试阶段、发布阶段、运行阶段，以及故障发生时。接下来，我们分别看一下。</p>
<ol>
<li><strong>架构阶段</strong>：架构阶段主要考虑系统的可扩展性和容错性，要避免系统出现单点问题。例如多机房单元化部署，即使某个城市的某个机房出现整体故障，仍然不会影响整体网站的运转。</li>
<li><strong>编码阶段</strong>：编码最重要的是保证代码的健壮性，例如涉及远程调用问题时，要设置合理的超时退出机制，防止被其他系统拖垮，也要对调用的返回结果集有预期，防止返回的结果超出程序处理范围，最常见的做法就是对错误异常进行捕获，对无法预料的错误要有默认处理结果。</li>
<li><strong>测试阶段</strong>：测试主要是保证测试用例的覆盖度，保证最坏情况发生时，我们也有相应的处理流程。</li>
<li><strong>发布阶段</strong>：发布时也有一些地方需要注意，因为发布时最容易出现错误，因此要有紧急的回滚机制。</li>
<li><strong>运行阶段</strong>：运行时是系统的常态，系统大部分时间都会处于运行态，运行态最重要的是对系统的监控要准确及时，发现问题能够准确报警并且报警数据要准确详细，以便于排查问题。</li>
<li><strong>故障发生</strong>：故障发生时首先最重要的就是及时止损，例如由于程序问题导致商品价格错误，那就要及时下架商品或者关闭购买链接，防止造成重大资产损失。然后就是要能够及时恢复服务，并定位原因解决问题。</li>
</ol>
<p>为什么系统的高可用建设要放到整个生命周期中全面考虑？因为我们在每个环节中都可能犯错，而有些环节犯的错，你在后面是无法弥补的。例如在架构阶段，你没有消除单点问题，那么系统上线后，遇到突发流量把单点给挂了，你就只能干瞪眼，有时候想加机器都加不进去。所以高可用建设是一个系统工程，必须在每个环节都做好。</p>
<p>那么针对秒杀系统，我们重点介绍在遇到大流量时，应该从哪些方面来保障系统的稳定运行，所以更多的是看如何针对运行阶段进行处理，这就引出了接下来的内容：降级、限流和拒绝服务。</p>
<h4 id="降级"><a href="#降级" class="headerlink" title="降级"></a>降级</h4><p>所谓“降级”，就是当系统的容量达到一定程度时，限制或者关闭系统的某些非核心功能，从而把有限的资源保留给更核心的业务。它是一个有目的、有计划的执行过程，所以对降级我们一般需要有一套预案来配合执行。如果我们把它系统化，就可以通过预案系统和开关系统来实现降级。</p>
<p>降级方案可以这样设计：当秒杀流量达到 5w/s 时，把成交记录的获取从展示 20 条降级到只展示 5 条。“从 20 改到 5”这个操作由一个开关来实现，也就是设置一个能够从开关系统动态获取的系统参数。</p>
<p>这里，我给出开关系统的示意图。它分为两部分，一部分是开关控制台，它保存了开关的具体配置信息，以及具体执行开关所对应的机器列表；另一部分是执行下发开关数据的 Agent，主要任务就是保证开关被正确执行，即使系统重启后也会生效。</p>
<p><img src="/images/2021-7-4103414.png" alt="2021-7-4103414.png"></p>
<p>执行降级无疑是在系统性能和用户体验之间选择了前者，降级后肯定会影响一部分用户的体验，例如在双 11 零点时，如果优惠券系统扛不住，可能会临时降级商品详情的优惠信息展示，把有限的系统资源用在保障交易系统正确展示优惠信息上，即保障用户真正下单时的价格是正确的。所以降级的核心目标是牺牲次要的功能和用户体验来保证核心业务流程的稳定，是一个不得已而为之的举措。</p>
<h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h4><p>如果说降级是牺牲了一部分次要的功能和用户的体验效果，那么限流就是更极端的一种保护措施了。限流就是当系统容量达到瓶颈时，我们需要通过限制一部分流量来保护系统，并做到既可以人工执行开关，也支持自动化保护的措施。</p>
<p>这里，我同样给出了限流系统的示意图。总体来说，限流既可以是在客户端限流，也可以是在服务端限流。此外，限流的实现方式既要支持 URL 以及方法级别的限流，也要支持基于 QPS 和线程的限流。</p>
<p>首先，我以内部的系统调用为例，来分别说下客户端限流和服务端限流的优缺点。</p>
<ul>
<li><strong>客户端限流</strong>，好处可以限制请求的发出，通过减少发出无用请求从而减少对系统的消耗。缺点就是当客户端比较分散时，没法设置合理的限流阈值：如果阈值设的太小，会导致服务端没有达到瓶颈时客户端已经被限制；而如果设的太大，则起不到限制的作用。</li>
<li><strong>服务端限流</strong>，好处是可以根据服务端的性能设置合理的阈值，而缺点就是被限制的请求都是无效的请求，处理这些无效的请求本身也会消耗服务器资源。</li>
</ul>
<p><img src="/images/2021-7-4103450.png" alt="2021-7-4103450.png"></p>
<p>在限流的实现手段上来讲，基于 QPS 和线程数的限流应用最多，最大 QPS 很容易通过压测提前获取，例如我们的系统最高支持 1w QPS 时，可以设置 8000 来进行限流保护。线程数限流在客户端比较有效，例如在远程调用时我们设置连接池的线程数，超出这个并发线程请求，就将线程进行排队或者直接超时丢弃。</p>
<p>限流无疑会影响用户的正常请求，所以必然会导致一部分用户请求失败，因此在系统处理这种异常时一定要设置超时时间，防止因被限流的请求不能 fast fail（快速失败）而拖垮系统。</p>
<h4 id="拒绝服务"><a href="#拒绝服务" class="headerlink" title="拒绝服务"></a>拒绝服务</h4><p>如果限流还不能解决问题，最后一招就是直接拒绝服务了。</p>
<p>当系统负载达到一定阈值时，例如 CPU 使用率达到 90% 或者系统 load 值达到 2*CPU 核数时，系统直接拒绝所有请求，这种方式是最暴力但也最有效的系统保护方式。例如秒杀系统，我们在如下几个环节设计过载保护：</p>
<blockquote>
<p>在最前端的 Nginx 上设置过载保护，当机器负载达到某个值时直接拒绝 HTTP 请求并返回 503 错误码，在 Java 层同样也可以设计过载保护。</p>
</blockquote>
<p>拒绝服务可以说是一种不得已的兜底方案，用以防止最坏情况发生，防止因把服务器压跨而长时间彻底无法提供服务。像这种系统过载保护虽然在过载时无法提供服务，但是系统仍然可以运作，当负载下降时又很容易恢复，所以每个系统和每个环节都应该设置这个兜底方案，对系统做最坏情况下的保护。</p>
<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>网站的高可用建设是基础，可以说要深入到各个环节，更要长期规划并进行体系化建设，要在预防（建立常态的压力体系，例如上线前的单机压测到上线后的全链路压测）、管控（做好线上运行时的降级、限流和兜底保护）、监控（建立性能基线来记录性能的变化趋势以及线上机器的负载报警体系，发现问题及时预警）和恢复体系（遇到故障要及时止损，并提供快速的数据订正工具等）等这些地方加强建设，每一个环节可能都有很多事情要做。</p>
<p>另外，要保证高可用建设的落实，你不仅要做系统建设，还要在组织上做好保障。高可用其实就是在说“稳定性”。稳定性是一个平时不重要，但真出了问题就会要命的事儿，所以很可能平时业务发展良好，稳定性建设就会给业务让路，相关的稳定性负责人员平时根本得不到重视，一旦遇到故障却又成了“背锅侠”。</p>
<p>而要防止出现这种情况，就必须在组织上有所保障，例如可以让业务负责人背上稳定性 KPI 考核指标，然后在技术部门中建立稳定性建设小组，小组成员由每个业务线的核心力量兼任，他们的 KPI 由稳定性负责人来打分，这样稳定性小组就可以把一些体系化的建设任务落实到具体的业务系统中了。</p>
<p>Read More:</p>
<blockquote>
<p><a href="https://d.shikey.com/jike/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%E5%B7%B2%E5%AE%8C%E7%BB%93/20%20%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F-%E8%AE%B8%E4%BB%A4%E6%B3%A2/181007-07%20_%20%E5%87%86%E5%A4%87Plan%20B%EF%BC%9A%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%85%9C%E5%BA%95%E6%96%B9%E6%A1%88_.html" target="_blank" rel="noopener">07 | 准备Plan B：如何设计兜底方案?</a></p>
</blockquote>
]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
      <tags>
        <tag>秒杀系统</tag>
        <tag>架构设计</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql系列 - 事务</title>
    <url>/2017/08/28/mysqltransaction/</url>
    <content><![CDATA[<p>学习 MySQL 、SQL Server 或者 Oracle 这些关系型数据库的时候，必须了解的概念之一就是事务，在各种大中小型项目中，事务的使用非常频繁和广泛。本文简单介绍 MySQL 中事务的四大特性，以及在不考虑事务隔离时，对数据的不同操作会产生的一些影响，同时介绍了事务的四中隔离级别。</p>
<h3 id="事务-ACID-特性"><a href="#事务-ACID-特性" class="headerlink" title="事务 ACID 特性"></a>事务 ACID 特性</h3><h4 id="原子性：Atomicity"><a href="#原子性：Atomicity" class="headerlink" title="原子性：Atomicity"></a>原子性：Atomicity</h4><p>事务必须是原子工作单元；对于其执行的数据修改操作，要么全都执行，要么全都不执行。通常，与某个事务关联的操作具有共同的目标，并且是相互依赖的。如果系统只执行这些操作的一个子集，则可能会破坏事务的总体目标。原子性消除了系统处理操作子集的可能性。</p>
<h4 id="一致性：Consistency"><a href="#一致性：Consistency" class="headerlink" title="一致性：Consistency"></a>一致性：Consistency</h4><p>事务在完成时，必须使所有的数据都保持一致状态。在相关数据库中，所有规则都必须应用于事务的修改，以保持所有数据的完整性。事务结束时，所有的内部数据结构（如 B 树索引或双向链表）都必须是正确的。某些维护一致性的责任由应用程序开发人员承担，他们必须确保应用程序已强制所有已知的完整性约束。例如，当开发用于转帐的应用程序时，应避免在转帐过程中任意移动小数点。假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p>
<h4 id="隔离性：Isolation"><a href="#隔离性：Isolation" class="headerlink" title="隔离性：Isolation"></a>隔离性：Isolation</h4><p>由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。这称为隔离性，因为它能够重新装载起始数据，并且重播一系列事务，以使数据结束时的状态与原始事务执行的状态相同。当事务可序列化时将获得最高的隔离级别。在此级别上，从一组可并行执行的事务获得的结果与通过连续运行每个事务所获得的结果相同。由于高度隔离会限制可并行执行的事务数，所以一些应用程序降低隔离级别以换取更大的吞吐量。</p>
<p>即要达到这么一种效果：对于任意两个并发的事务 T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前就已经结束，要么在 T1 结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p>
<h4 id="持久性：Durability"><a href="#持久性：Durability" class="headerlink" title="持久性：Durability"></a>持久性：Durability</h4><p>事务完成之后，它对于系统的影响是永久性的。该修改即使出现致命的系统故障也将一直保持。</p>
<p>例如我们在操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。</p>
<p>以上介绍完事务的 ACID 特性，现在重点来说明下事务的隔离性，当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性，在介绍数据库提供的各种隔离级别之前，我们先看看如果不考虑事务的隔离性，会发生的几种问题：</p>
<h3 id="并发事务的问题"><a href="#并发事务的问题" class="headerlink" title="并发事务的问题"></a>并发事务的问题</h3><h4 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h4><p>当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，会发生丢失更新问题。每个事务都不知道其它事务的存在。最后的更新将重写由其它事务所做的更新，这将导致数据丢失。</p>
<p>例如，两个编辑人员制作了同一文档的电子复本。每个编辑人员独立地更改其复本，然后保存更改后的复本，这样就覆盖了原始文档。最后保存其更改复本的编辑人员覆盖了第一个编辑人员所做的更改。如果在第一个编辑人员完成之后第二个编辑人员才能进行更改，则可以避免该问题。</p>
<h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>读“脏”数据是指事务 T1 修改某一数据，并将其写回磁盘，事务 T2 读取同一数据后，T1 由于某种原因被除撤消，而此时T1 把已修改过的数据又恢复原值，T2 读到的数据与数据库的数据不一致，则 T2 读到的数据就为“脏”数据，即不正确的数据。简单来说就是，事务 T2 读取了事务 T1 还未提交的更新。</p>
<p>例如：一个编辑人员正在更改电子文档。在更改过程中，另一个编辑人员复制了该文档（该复本包含到目前为止所做的全部更改）并将其分发给预期的用户。此后，第一个编辑人员认为所做的更改是错误的，于是删除了所做的编辑并保存了文档。分发给用户的文档包含不再存在的编辑内容，并且这些编辑内容应认为从未存在过。如果在第一个编辑人员确定最终更改前任何人都不能读取更改的文档，则可以避免该问题。</p>
<h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>指事务 T1 读取数据后，事务 T2 执行更新操作，使 T1 无法读取前一次结果。</p>
<h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>按一定条件从数据库中读取了某些记录后，T2 删除了其中部分记录，当 T1 再次按相同条件读取数据时，发现某些记录消失；T1 按一定条件从数据库中读取某些数据记录后，T2 插入了一些记录，当 T1 再次按相同条件读取数据时，发现多了一些记录。</p>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><h4 id="读取未提交内容：Read-Uncommitted"><a href="#读取未提交内容：Read-Uncommitted" class="headerlink" title="读取未提交内容：Read Uncommitted"></a>读取未提交内容：Read Uncommitted</h4><ul>
<li>所有事务都可以看到其他未提交事务的执行结果</li>
<li>一个事务更新的时候不允许另一更新，但允许另一事务读取，不会出现丢失更新</li>
<li>该级别引发的问题是 - 脏读：读取到了未提交的数据</li>
</ul>
<p>该隔离级别可以通过“排他写锁”实现。</p>
<h4 id="读取提交内容：Read-Committed"><a href="#读取提交内容：Read-Committed" class="headerlink" title="读取提交内容：Read Committed"></a>读取提交内容：Read Committed</h4><ul>
<li>这是大多数数据库系统的默认隔离级别（但不是 MySQL 默认的）</li>
<li>一个事务更新的时候不允许读取，必须等到更新事务提交后才能读取</li>
<li>这种隔离级别出现的问题是 - 不可重复读：不可重复读意味着我们在同一个事务中执行完全相同的select语句时可能看到不一样的结果。导致这种情况的原因可能有：<ul>
<li>有一个交叉的事务有新的commit，导致了数据的改变</li>
<li>一个数据库被多个实例操作时，同一事务的其他实例在该实例处理其间可能会有新的commit</li>
</ul>
</li>
</ul>
<h4 id="可重复读：Repeatable-Read"><a href="#可重复读：Repeatable-Read" class="headerlink" title="可重复读：Repeatable Read"></a>可重复读：Repeatable Read</h4><ul>
<li><strong>这是 MySQL 的默认事务隔离级别</strong></li>
<li>一个事务读取时，不允许更新，但允许插入</li>
<li>此级别可能出现的问题 - 幻读：当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行</li>
<li>InnoDB 和 Falcon 存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题</li>
</ul>
<h4 id="序列化：Serializable"><a href="#序列化：Serializable" class="headerlink" title="序列化：Serializable"></a>序列化：Serializable</h4><ul>
<li>这是最高的隔离级别</li>
<li>它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁</li>
<li>在这个级别，可能导致大量的超时现象和锁竞争</li>
</ul>
<p>Read More：</p>
<blockquote>
<p><a href="https://www.oschina.net/question/258230_134502" target="_blank" rel="noopener">数据库事务隔离级别通俗理解</a></p>
<p><a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/9744607?fr=aladdin" target="_blank" rel="noopener">数据库事务</a></p>
<p><a href="https://baike.baidu.com/item/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/2638091?fr=aladdin" target="_blank" rel="noopener">事务隔离级别</a></p>
<p><a href="http://blog.csdn.net/u012712087/article/details/46402433" target="_blank" rel="noopener">更改MySQL的默认事务隔离级别</a></p>
<p><a href="http://www.cnblogs.com/fjdingsd/p/5273008.html" target="_blank" rel="noopener">数据库事务的四大特性以及事务的隔离级别</a></p>
<p><a href="http://www.cnblogs.com/snsdzjlz320/p/5761387.html" target="_blank" rel="noopener">[MySQL]–通过例子理解事务的4中隔离级别</a></p>
</blockquote>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>事务</tag>
        <tag>事务隔离</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql系列 - 锁</title>
    <url>/2021/05/23/mysql-lock/</url>
    <content><![CDATA[<p>我们都知道事务的ACID性质（参考<a href="https://runnerliu.github.io/2017/08/28/mysqltransaction/">Mysql系列 - 事务</a>），数据库为了维护这些性质，尤其是一致性(C)和隔离性(I)，一般使用加锁这种方式，同时数据库又是个高并发的应用，同一时间会有大量的并发访问，如果加锁过度，会极大的降低并发处理能力。所以对于加锁的处理，可以说就是数据库对于事务处理的精髓所在。</p>
<h4 id="一次封锁or两段锁"><a href="#一次封锁or两段锁" class="headerlink" title="一次封锁or两段锁"></a>一次封锁or两段锁</h4><p>因为有大量的并发访问，为了预防死锁，一般应用中推荐使用一次封锁法，就是在方法的开始阶段，已经预先知道会用到哪些数据，然后全部锁住，在方法运行之后，再全部解锁。这种方式可以有效的避免循环死锁，但在数据库中却不适用，因为在事务开始阶段，数据库并不知道会用到哪些数据。</p>
<p>数据库遵循的是两段锁协议，将事务分成两个阶段，加锁阶段和解锁阶段（所以叫两段锁）：</p>
<ul>
<li>加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁（共享锁，其它事务可以继续加共享锁，但不能加排它锁），在进行写操作之前要申请并获得X锁（排它锁，其它事务不能再获得任何锁）。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。</li>
<li>解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。</li>
</ul>
<p>两段锁虽然无法避免死锁，但是可以保证事务的并发调度是串行化（串行化很重要，尤其是在数据恢复和备份的时候）的。</p>
<h4 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h4><p>从锁定资源的角度来看，MySQL 中的锁分为：</p>
<ul>
<li>表级锁：对整张表加锁。开销小，加锁快，不会出现死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低。适合以查询为主。</li>
<li>行级锁：对行记录加锁。开销大，加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最低，并发度也最高。适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用。</li>
<li>页面锁：开销和加锁时间界于表锁和行锁之间，会出现死锁，锁定粒度界于表锁和行锁之间，并发度一般</li>
</ul>
<h5 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h5><p>InnoDB加行锁时通过给索引上的索引项加锁来实现，这种行锁实现特点意味着，只有通过索引条件检索条件数据，InnoDB才使用行锁，否则InnoDB将使用表锁。</p>
<p>行锁的加锁算法：</p>
<ul>
<li>记录锁 Record Locks：对单个记录的索引项加锁，即使表没有建立索引，InnoDB也会创建一个隐藏的聚簇索引(隐藏的递增主键索引)，并使用此索引进行记录锁定。</li>
<li>间隙锁 Gap Locks：锁定一个范围，但不包含记录本身，间隙锁作用在索引记录之间的间隔，又或者作用在第一个索引之前，最后一个索引之后的间隙。</li>
<li>Next-key锁：Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身。当查询的索引含有唯一属性时，InnoDB存储引擎会对Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</li>
</ul>
<h5 id="意向共享锁"><a href="#意向共享锁" class="headerlink" title="意向共享锁"></a>意向共享锁</h5><p>一个事务给一个数据行加共享锁时，必须先获得表的意向共享锁</p>
<h5 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h5><p>共享锁又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁，共享锁可以同时加上多个。</p>
<p>加了共享锁后，该事务只能对数据进行读取而不能修改，并且其它事务只能加共享锁，不能加排他锁。</p>
<p>加锁方式：在执行语句后面加上 <code>lock in share mode</code> 就代表对某些资源加上共享锁了。</p>
<h5 id="意向排它锁"><a href="#意向排它锁" class="headerlink" title="意向排它锁"></a>意向排它锁</h5><p>一个事务给一个数据行加排他锁时，必须先获得表的意向排他锁</p>
<h5 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h5><p>排他锁又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，和其他的排他锁、共享锁都相斥。</p>
<p>事务对数据加上排他锁时，只允许此事务读取和修改此数据，并且其它事务不能对该数据加任何锁。</p>
<h5 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h5><p>悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p>
<p>悲观锁认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其它事务读取或修改数据（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程），应用于数据更新比较频繁的场景。</p>
<p>悲观锁的实现方式：</p>
<ul>
<li>实现悲观锁时，我们必须先使用<code>set autocommit=0;</code>，关闭mysql的AutoCommit属性。因为我们查询出数据之后就要将该数据锁定，关闭自动提交后，我们需要手动开启事务。</li>
</ul>
<p>悲观锁的优点：</p>
<ul>
<li>悲观锁保证了数据处理时的安全性。</li>
</ul>
<p>悲观锁的缺点：</p>
<ul>
<li>加锁造成了开销增加，并且增加了死锁的机会。降低了并发性。</li>
</ul>
<h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5><p>乐观锁不是数据库自带的，需要我们自己去实现。乐观锁是指操作数据库时（更新操作），想法很乐观，认为这次的操作不会导致冲突，在操作数据时，并不进行任何其他的特殊处理（也就是不加锁），而在进行更新后，再去判断是否有冲突，适用于读多写少的场景。</p>
<p>乐观锁的实现方式：</p>
<ul>
<li>版本号机制：加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段。一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</li>
<li>CAS算法：Compare And Swap（比较与交换），是一种有名的无锁算法。先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新。一般情况下是一个自旋操作，即不断的重试。</li>
</ul>
<p>乐观锁的优点：</p>
<ul>
<li>乐观锁机制避免了长事务中的数据库加锁开销，大大提升了大并发量下的系统整体性能表现。</li>
</ul>
<p>乐观锁的缺点：</p>
<ul>
<li>ABA问题：如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。</li>
<li>循环时间长开销大：自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。</li>
</ul>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁是指两个或两个以上事务在执行过程中因争抢锁资源而造成的互相等待（形成环路）的现象。<strong>表级锁不会产生死锁</strong>，所以解决死锁主要还是针对于最常用的InnoDB。</p>
<p>死锁的解决：</p>
<ul>
<li><p>查出阻塞的进程，将其kill掉，将资源释放</p>
</li>
<li><p>设置锁的超时时间：InnoDB 行锁的等待时间，单位秒。可在会话级别设置，RDS 实例该参数的默认值为 50s。生产环境不推荐使用过大的 <code>innodb_lock_wait_timeout</code> 参数值该参数支持在会话级别修改，方便应用在会话级别单独设置某些特殊操作的行锁等待超时时</p>
</li>
<li><p>如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会</p>
</li>
<li><p>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率</p>
</li>
<li><p>对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率，<strong>不推荐</strong></p>
</li>
</ul>
<p>Read More:</p>
<blockquote>
<p><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener">Innodb中的事务隔离级别和锁的关系</a></p>
<p><a href="https://www.jianshu.com/p/4f2311f38040" target="_blank" rel="noopener">深入理解MySQL数据库各种锁（总结）</a></p>
<p><a href="https://segmentfault.com/a/1190000022839728" target="_blank" rel="noopener">面试官：小伙子，给我说一下mysql 乐观锁和悲观锁吧</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/29150809" target="_blank" rel="noopener">MySQL锁总结</a></p>
<p><a href="https://learnku.com/articles/39212?order_by=vote_count&amp;" target="_blank" rel="noopener">一张图彻底搞懂 MySQL 的锁机制</a></p>
</blockquote>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Lock</tag>
      </tags>
  </entry>
  <entry>
    <title>项目部署Nginx+Tornado+Supervisor</title>
    <url>/2017/09/03/nginxtornadosupervisor/</url>
    <content><![CDATA[<p>在项目中应用到了 Tornado 框架，开始时只是单进程裸跑 Tornado 实例，但是在高并发的情况下，单进程无法满足上千的连接请求。Nginx 是我们熟知的反向代理服务器，它可以支持上万的平行连接，在与 PHP、Python 集成后可以应用在大规模的集群上，Nginx 同时也可以用作负载平衡器，以减小单点服务器的压力。</p>
<p><a href="http://supervisord.org/" target="_blank" rel="noopener">Supervisor</a> 是一个进程管理工具，我们可以使用它管理多个 Tornado 实例，非常方便。</p>
<p>总的思路是：Nginx 通过唯一监听端口接收大量请求，然后将请求分发到不同的 Tornado 实例上，Supervisor 将多个 Tornado 实例进程统一管理。</p>
<h4 id="Tornado"><a href="#Tornado" class="headerlink" title="Tornado"></a>Tornado</h4><p>Tornado 和现在的主流 Web 服务器框架（包括大多数 Python 的框架）有着明显的区别：它是非阻塞式服务器，而且速度相当快。得利于其非阻塞的方式和对 <a href="http://kaimingwan.com/post/linux/epollshi-xian-yuan-li-qian-xi" target="_blank" rel="noopener">epoll</a> 的运用，Tornado 每秒可以处理数以千计的连接，这意味着对于实时 Web 服务来说，Tornado 是一个理想的 Web 框架。Tornado 由于内置了支持 epoll/kqueue 等高效网络库，而具备了处理高并发的能力。</p>
<p>程序入口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">import os.path</span><br><span class="line"></span><br><span class="line">import tornado.escape</span><br><span class="line">import tornado.ioloop</span><br><span class="line">import tornado.web</span><br><span class="line">from tornado.httpserver import HTTPServer</span><br><span class="line">from tornado.options import define, options</span><br><span class="line"></span><br><span class="line">from handlers import stream_handler</span><br><span class="line"></span><br><span class="line">define(&quot;port&quot;, default=8888, help=&quot;run on the given port&quot;, type=int)</span><br><span class="line">define(&quot;debug&quot;, default=False, help=&quot;run in debug mode&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Application(tornado.web.Application):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        handlers = [</span><br><span class="line">            # (r&quot;/&quot;, main_handler.MainHandler),</span><br><span class="line">            (r&quot;/stream.*?&quot;, stream_handler.StreamHandler),</span><br><span class="line">        ]</span><br><span class="line">        settings = dict(</span><br><span class="line">            template_path=os.path.join(os.path.dirname(__file__), &quot;templates&quot;),</span><br><span class="line">            static_path=os.path.join(os.path.dirname(__file__), &quot;static&quot;),</span><br><span class="line">            debug=options.debug,</span><br><span class="line">        )</span><br><span class="line">        super(Application, self).__init__(handlers, **settings)</span><br><span class="line"></span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    tornado.options.parse_command_line()</span><br><span class="line">    http_server = HTTPServer(Application())</span><br><span class="line">    http_server.listen(options.port)</span><br><span class="line">    tornado.ioloop.IOLoop.instance().start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>执行以下命令运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python27 app.py --port=8081</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 因为我的机器上安装了不同版本的 Python 解释器，<code>python27</code> 是我为 Python 2.7.13 创建的软连接。</p>
<p>以下一行代码必须有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tornado.options.parse_command_line()</span><br></pre></td></tr></table></figure>
<p>因为我们运行程序脚本时，需要指定不同的端口，这是在执行 Tornado 的解析命令行。</p>
<h4 id="Supervisor-管理-Tornado-进程"><a href="#Supervisor-管理-Tornado-进程" class="headerlink" title="Supervisor 管理 Tornado 进程"></a>Supervisor 管理 Tornado 进程</h4><p>Supervisor 的安装可以在官方文章中找到，可使用 <code>yum pip easy_insatll</code> 等方法。最简单的就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip27 install supervisor</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 因为我的机器上安装了不同版本的 pip 包，<code>pip27</code> 是我为 Python 2.7.13 使用的。</p>
<p>创建文件夹：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir /etc/supervisor</span><br></pre></td></tr></table></figure>
<p>创建配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo_supervisord_conf &gt; /etc/supervisor/supervisord.conf</span><br></pre></td></tr></table></figure>
<p>修改 <code>/etc/supervisor/supervisord.conf</code> 文件内容，在文件结尾 <code>[include]</code> 节点处</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; [include]</span><br><span class="line">; files = relative/directory/*.ini</span><br><span class="line"></span><br><span class="line">=&gt;</span><br><span class="line"></span><br><span class="line">[include]</span><br><span class="line">files = conf.d/*.conf</span><br></pre></td></tr></table></figure>
<p>保存并退出</p>
<p>在 <code>/etc/supervisor/</code> 下创建 <code>conf.d</code> 文件夹，及 <code>ProjectName.conf</code> (以项目名称命名的，例如：tornados.conf)</p>
<p>执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi tornados.conf</span><br></pre></td></tr></table></figure>
<p>添加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[group:tornados]</span><br><span class="line">programs=tornado-0,tornado-1,tornado-2,tornado-3,tornado-4,tornado-5,tornado-6,tornado-7</span><br><span class="line"></span><br><span class="line">[program:tornado-0]</span><br><span class="line"># 执行的命令</span><br><span class="line">command=python27 /home/ly/analysisweb/app.py --port=8020</span><br><span class="line"># 项目目录</span><br><span class="line">directory=/home/ly/analysisweb/</span><br><span class="line"># 用户</span><br><span class="line">user=root</span><br><span class="line"># 自动重启</span><br><span class="line">autorestart=true</span><br><span class="line">redirect_stderr=true</span><br><span class="line"># log文件路径</span><br><span class="line">stdout_logfile=/home/ly/analysisweb/log/supervisor/tornado0.log</span><br><span class="line"># log级别</span><br><span class="line">loglevel=info</span><br><span class="line"></span><br><span class="line">[program:tornado-1]</span><br><span class="line">command=python27 /home/ly/analysisweb/app.py --port=8021</span><br><span class="line">directory=/home/ly/analysisweb/</span><br><span class="line">user=root</span><br><span class="line">autorestart=true</span><br><span class="line">redirect_stderr=true</span><br><span class="line">stdout_logfile=/home/ly/analysisweb/log/supervisor/tornado1.log</span><br><span class="line">loglevel=info</span><br><span class="line"></span><br><span class="line">[program:tornado-2]</span><br><span class="line">command=python27 /home/ly/analysisweb/app.py --port=8022</span><br><span class="line">directory=/home/ly/analysisweb/</span><br><span class="line">user=root</span><br><span class="line">autorestart=true</span><br><span class="line">redirect_stderr=true</span><br><span class="line">stdout_logfile=/home/ly/analysisweb/log/supervisor/tornado2.log</span><br><span class="line">loglevel=info</span><br><span class="line"></span><br><span class="line">[program:tornado-3]</span><br><span class="line">command=python27 /home/ly/analysisweb/app.py --port=8023</span><br><span class="line">directory=/home/ly/analysisweb/</span><br><span class="line">user=root</span><br><span class="line">autorestart=true</span><br><span class="line">redirect_stderr=true</span><br><span class="line">stdout_logfile=/home/ly/analysisweb/log/supervisor/tornado3.log</span><br><span class="line">loglevel=info</span><br><span class="line"></span><br><span class="line">[program:tornado-4]</span><br><span class="line">command=python27 /home/ly/analysisweb/app.py --port=8024</span><br><span class="line">directory=/home/ly/analysisweb/</span><br><span class="line">user=root</span><br><span class="line">autorestart=true</span><br><span class="line">redirect_stderr=true</span><br><span class="line">stdout_logfile=/home/ly/analysisweb/log/supervisor/tornado4.log</span><br><span class="line">loglevel=info</span><br><span class="line"></span><br><span class="line">[program:tornado-5]</span><br><span class="line">command=python27 /home/ly/analysisweb/app.py --port=8025</span><br><span class="line">directory=/home/ly/analysisweb/</span><br><span class="line">user=root</span><br><span class="line">autorestart=true</span><br><span class="line">redirect_stderr=true</span><br><span class="line">stdout_logfile=/home/ly/analysisweb/log/supervisor/tornado5.log</span><br><span class="line">loglevel=info</span><br><span class="line"></span><br><span class="line">[program:tornado-6]</span><br><span class="line">command=python27 /home/ly/analysisweb/app.py --port=8026</span><br><span class="line">directory=/home/ly/analysisweb/</span><br><span class="line">user=root</span><br><span class="line">autorestart=true</span><br><span class="line">redirect_stderr=true</span><br><span class="line">stdout_logfile=/home/ly/analysisweb/log/supervisor/tornado6.log</span><br><span class="line">loglevel=info</span><br><span class="line"></span><br><span class="line">[program:tornado-7]</span><br><span class="line">command=python27 /home/ly/analysisweb/app.py --port=8027</span><br><span class="line">directory=/home/ly/analysisweb/</span><br><span class="line">user=root</span><br><span class="line">autorestart=true</span><br><span class="line">redirect_stderr=true</span><br><span class="line">stdout_logfile=/home/ly/analysisweb/log/supervisor/tornado7.log</span><br><span class="line">loglevel=info</span><br></pre></td></tr></table></figure>
<p>保存并退出</p>
<p>执行以下命令启动 Supervisor ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">supervisord -c /etc/supervisor/supervisord.conf</span><br></pre></td></tr></table></figure>
<blockquote>
<p>坑1：出现错误 Error: Another program is already listening on a port that one of our HTTP servers is configured to use.  Shut this program down first before starting supervisord.For help, use /usr/bin/supervisord –h</p>
<p>解决办法：是因为有一个使用 supervisor 配置的应用程序正在运行。执行 <code>ps -ef | grep supervisor</code> 查看进程，杀掉 supervisor 的所有进程，重新运行 <a href="https://stackoverflow.com/questions/25121838/supervisor-on-debian-wheezy-another-program-is-already-listening-on-a-port-that" target="_blank" rel="noopener">参考这里</a> </p>
<p>坑2：出现错误 Unlinking stale socket /tmp/supervisor.sock </p>
<p>解决办法：执行 <code>unlink /tmp/supervisor.sock</code> <a href="https://stackoverflow.com/questions/14479894/stopping-supervisord-shut-down" target="_blank" rel="noopener">参考这里</a> </p>
</blockquote>
<p>如果执行成功，<code>ps -ef | grep python</code> 结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root     21314     1  0 15:22 ?        00:00:00 /usr/bin/python27 /usr/local/python2.7/bin/supervisord -c /etc/supervisor/supervisord.conf</span><br><span class="line">root     21315 21314  0 15:22 ?        00:00:00 python27 /home/ly/analysisweb/app.py --port=8021</span><br><span class="line">root     21316 21314  0 15:22 ?        00:00:00 python27 /home/ly/analysisweb/app.py --port=8020</span><br><span class="line">root     21317 21314  0 15:22 ?        00:00:00 python27 /home/ly/analysisweb/app.py --port=8023</span><br><span class="line">root     21318 21314  0 15:22 ?        00:00:00 python27 /home/ly/analysisweb/app.py --port=8022</span><br><span class="line">root     21319 21314  0 15:22 ?        00:00:00 python27 /home/ly/analysisweb/app.py --port=8025</span><br><span class="line">root     21320 21314  0 15:22 ?        00:00:00 python27 /home/ly/analysisweb/app.py --port=8024</span><br><span class="line">root     21321 21314  0 15:22 ?        00:00:00 python27 /home/ly/analysisweb/app.py --port=8027</span><br><span class="line">root     21322 21314  0 15:22 ?        00:00:00 python27 /home/ly/analysisweb/app.py --port=8026</span><br></pre></td></tr></table></figure>
<h4 id="Nginx-作反向代理"><a href="#Nginx-作反向代理" class="headerlink" title="Nginx 作反向代理"></a>Nginx 作反向代理</h4><p><img src="/images/2017-9-1 161933.jpg" alt="2017-9-1 161933"></p>
<p>安装好 Nginx 后，编辑 nginx.conf 文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    # 我启动了8个Tornado实例，配置不同端口</span><br><span class="line">    upstream tornados &#123;</span><br><span class="line">        server 127.0.0.1:8020;</span><br><span class="line">        server 127.0.0.1:8021;</span><br><span class="line">        server 127.0.0.1:8022;</span><br><span class="line">        server 127.0.0.1:8023;</span><br><span class="line">        server 127.0.0.1:8024;</span><br><span class="line">        server 127.0.0.1:8025;</span><br><span class="line">        server 127.0.0.1:8026;</span><br><span class="line">        server 127.0.0.1:8027;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    proxy_next_upstream error;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        # nginx 监听8081端口</span><br><span class="line">        listen       8081;</span><br><span class="line">		</span><br><span class="line">		# 静态文件的路径</span><br><span class="line">        location /static/&#123;</span><br><span class="line">            alias /home/ly/analysisweb/static/;</span><br><span class="line">            expires 24h;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">            proxy_pass_header Server;</span><br><span class="line">            proxy_set_header Host $http_host;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_pass http://tornados;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可参考 <a href="http://tornado-zh.readthedocs.io/zh/latest/guide/running.html" target="_blank" rel="noopener">运行和部署</a> </p>
<p>以上，就完成了Nginx+Tornado+Supervisor 的项目部署，分别启动 nginx、supervisord ，就可以达到不错的负载均衡效果（我的项目中没有访问静态资源的情景，所以主要还是作负载均衡用）</p>
]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
        <tag>Tornado</tag>
        <tag>Supervisor</tag>
        <tag>项目部署</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP关键字之self,final,static,this,parent</title>
    <url>/2017/04/08/phpkeywords1/</url>
    <content><![CDATA[<p>最近在看PHP手册，看到类和对象的时候，有一个“后期静态绑定”的内容，self，static，parent这几个关键字弄的我云里雾里，索性查了一些资料，看看self，final，static，this，parent这些关键字到底是什么意思。</p>
<p><a href="http://php.net/manual/zh/language.oop5.late-static-bindings.php" target="_blank" rel="noopener">官方文档解释：后期静态绑定</a></p>
<blockquote>
<p>自 PHP 5.3.0 起，PHP 增加了一个叫做后期静态绑定的功能，用于在继承范围内引用静态调用的类。</p>
<p>准确说，后期静态绑定工作原理是存储了在上一个“非转发调用”（non-forwarding call）的类名。当进行静态方法调用时，该类名即为明确指定的那个（通常在 :: 运算符左侧部分）；当进行非静态方法调用时，即为该对象所属的类。所谓的“转发调用”（forwarding call）指的是通过以下几种方式进行的静态调用：self::，parent::，static:: 以及 forward_static_call()。可用 get_called_class() 函数来得到被调用的方法所在的类名，static:: 则指出了其范围。</p>
<p>该功能从语言内部角度考虑被命名为“后期静态绑定”。“后期绑定”的意思是说，static:: 不再被解析为定义当前方法所在的类，而是在实际运行时计算的。也可以称之为“静态绑定”，因为它可以用于（但不限于）静态方法的调用。</p>
</blockquote>
<p>因为存在继承和不存在继承的情况下，self，static，parent关键字的作用不同，而this和final是不受继承限制的，我们先来看看this，final。</p>
<h3 id="关键字this"><a href="#关键字this" class="headerlink" title="关键字this"></a>关键字this</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class name                              //建立了一个名为name的类</span><br><span class="line">&#123;</span><br><span class="line">    private $name;                      //定义属性，私有</span><br><span class="line"></span><br><span class="line">    //定义构造函数，用于初始化赋值</span><br><span class="line">    function __construct($name)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;name = $name;            //这里已经使用了this指针语句(1)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //析构函数</span><br><span class="line">    function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //打印用户名成员函数</span><br><span class="line">    function print_name()</span><br><span class="line">    &#123;</span><br><span class="line">        print($this-&gt;name);             //再次使用了this指针语句(2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$obj1 = new name(&quot;PHP_Home&quot;);            //实例化对象 语句(3)</span><br><span class="line"></span><br><span class="line">//执行打印</span><br><span class="line">$obj1-&gt;print_name();                    //输出:PBPHome</span><br><span class="line"></span><br><span class="line">//第二次实例化对象</span><br><span class="line">$obj2 = new name(&quot;PHP&quot;);</span><br><span class="line"></span><br><span class="line">//执行打印</span><br><span class="line">$obj2-&gt;print_name();                    //输出：PHP</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>：上面的类分别在语句(1)和语句(2)使用了 this 指针，那么当时 this 是指向谁呢？其实 <strong>this 是在实例化的时候来确定指向谁</strong>，比如第一次实例化对象的时候（语句(3)），那么当时 this 就是指向 \$obj1 对象，那么执行语句(2)的打印时就把</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print($this-&gt;name)</span><br></pre></td></tr></table></figure>
<p>变成了 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print($obj1-&gt;name)</span><br></pre></td></tr></table></figure>
<p>那么当然就输出了”PHP_Home”。</p>
<p>第二个实例的时候，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print($this-&gt;name )</span><br></pre></td></tr></table></figure>
<p>变成了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print( $obj2-&gt;name)</span><br></pre></td></tr></table></figure>
<p>于是就输出了”PHP”。所以说，<strong>this 是指向当前对象实例的指针，不指向任何其他对象或类</strong>。</p>
<h3 id="关键字final"><a href="#关键字final" class="headerlink" title="关键字final"></a>关键字final</h3><p><strong>如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承</strong>。</p>
<p>final 方法示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BaseClass &#123;</span><br><span class="line">   public function test() &#123;</span><br><span class="line">       echo &quot;BaseClass::test() called\n&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   final public function moreTesting() &#123;</span><br><span class="line">       echo &quot;BaseClass::moreTesting() called\n&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ChildClass extends BaseClass &#123;</span><br><span class="line">   public function moreTesting() &#123;</span><br><span class="line">       echo &quot;ChildClass::moreTesting() called\n&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 产生Fatal error: Cannot override final method BaseClass::moreTesting()</span><br></pre></td></tr></table></figure>
<p>final 类示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final class BaseClass &#123;</span><br><span class="line">   public function test() &#123;</span><br><span class="line">       echo &quot;BaseClass::test() called\n&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // 这里无论你是否将方法声明为final，都没有关系</span><br><span class="line">   final public function moreTesting() &#123;</span><br><span class="line">       echo &quot;BaseClass::moreTesting() called\n&quot;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ChildClass extends BaseClass &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 产生 Fatal error: Class ChildClass may not inherit from final class (BaseClass)</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong>：属性不能被定义为 final，只有类和方法才能被定义为 final。</p>
<p>下面我们在存在继承和不存在继承两种情况下看看self，static，parent关键字的作用。</p>
<h3 id="不存在继承的时候"><a href="#不存在继承的时候" class="headerlink" title="不存在继承的时候"></a>不存在继承的时候</h3><p>顾名思义，不存在继承就是书写一个单独的类来使用。self 和 static 在范围解析操作符 （::） 的使用上，并无区别。</p>
<p>在静态函数中，self 和 static 可以调用静态属性和静态函数（没有实例化类，因此不能调用非静态的属性和函数）。<br>在非静态函数中，self 和 static 可以调用静态属性和静态函数以及非静态函数。<br>不存在继承的情况下，self 和 static 的作用是一样的，同时可替换为 <strong>类名::</strong> 的方式调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Demo &#123;</span><br><span class="line">    public static $static;</span><br><span class="line">    public $Nostatic;</span><br><span class="line"></span><br><span class="line">    public function __construct() &#123;</span><br><span class="line">        self::$static = &quot;static&quot;;</span><br><span class="line">        $this-&gt;Nostatic = &quot;Nostatic&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static function get() &#123;</span><br><span class="line">        return __CLASS__;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function show() &#123;</span><br><span class="line">        return &quot;this is function show with &quot; . $this-&gt;Nostatic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function test() &#123;</span><br><span class="line">        echo Demo::$static . &quot;&lt;br/&gt;&quot;;   //使用类名调用静态属性</span><br><span class="line">        echo Demo::get() . &quot;&lt;br/&gt;&quot;;     //使用类名调用静态属性</span><br><span class="line">        echo Demo::show() . &quot;&lt;br/&gt;&quot;;    //使用类名调用静态属性</span><br><span class="line">        echo self::$static . &quot;&lt;br/&gt;&quot;;   //self调用静态属性</span><br><span class="line">        echo self::show() . &quot;&lt;br/&gt;&quot;;    //self调用非静态方法</span><br><span class="line">        echo self::get() . &quot;&lt;br/&gt;&quot;;     //self调用静态方法</span><br><span class="line">        echo static::$static . &quot;&lt;br/&gt;&quot;; //static调用静态属性</span><br><span class="line">        echo static::show() . &quot;&lt;br/&gt;&quot;;  //static调用非静态方法</span><br><span class="line">        echo static::get() . &quot;&lt;br/&gt;&quot;;   //static调用静态方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$obj = new Demo();</span><br><span class="line">$obj-&gt;test();</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static</span><br><span class="line">Demo</span><br><span class="line">this is function show with Nostatic</span><br><span class="line">static</span><br><span class="line">this is function show with Nostatic</span><br><span class="line">Demo</span><br><span class="line">static</span><br><span class="line">this is function show with Nostatic</span><br><span class="line">Demo</span><br></pre></td></tr></table></figure>
<h3 id="存在继承的时候"><a href="#存在继承的时候" class="headerlink" title="存在继承的时候"></a>存在继承的时候</h3><p>示例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    static function getClassName() &#123;</span><br><span class="line">        return &quot;this is class A&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static function testSelf() &#123;</span><br><span class="line">        echo self::getClassName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static function testStatic() &#123;</span><br><span class="line">        echo static::getClassName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">    static function getClassName() &#123;</span><br><span class="line">        return &quot;this is class B&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B::testSelf();</span><br><span class="line">B::testStatic();</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this is class A</span><br><span class="line">this is class B</span><br></pre></td></tr></table></figure>
<p>Note：self 调用的静态方法或属性始终表示其在使用的时候的当前类（A）的方法或属性，可以替换为其类名，static 调用的静态方法或属性会在继承中被其子类重写覆盖，应该替换为对应的子类名（B）。</p>
<p>对于parent关键字，用于调用父类的方法和属性。在静态方法中，可以调用父类的静态方法和属性；在非静态方法中，可以调用父类的方法和属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    public static $static;</span><br><span class="line">    public $Nostatic;</span><br><span class="line"></span><br><span class="line">    public function __construct() &#123;</span><br><span class="line">        self::$static = &quot;static&quot;;</span><br><span class="line">        $this-&gt;Nostatic = &quot;Nostatic&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static function staticFun() &#123;</span><br><span class="line">        return self::$static;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function noStaticFun() &#123;</span><br><span class="line">        return &quot;this is function show with &quot; . $this-&gt;Nostatic;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">    static function testS() &#123;</span><br><span class="line">        echo parent::staticFun();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function testNoS() &#123;</span><br><span class="line">        echo parent::noStaticFun();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$obj = new B();</span><br><span class="line">$obj-&gt;testS();</span><br><span class="line">$obj-&gt;testNoS();</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static</span><br><span class="line">this is function show with Nostatic</span><br></pre></td></tr></table></figure>
<h3 id="PHP手册中的例子"><a href="#PHP手册中的例子" class="headerlink" title="PHP手册中的例子"></a>PHP手册中的例子</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    public static function foo() &#123;</span><br><span class="line">        static::who();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static function who() &#123;</span><br><span class="line">        echo __CLASS__ . &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">    public static function test() &#123;</span><br><span class="line">        A::foo();</span><br><span class="line">        parent::foo();</span><br><span class="line">        self::foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static function who() &#123;</span><br><span class="line">        echo __CLASS__ . &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C extends B &#123;</span><br><span class="line">    public static function who() &#123;</span><br><span class="line">        echo __CLASS__ . &quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">C::test();</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A</span><br><span class="line">C</span><br><span class="line">C</span><br></pre></td></tr></table></figure>
<p>我们分析 test() 方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static function test() &#123;</span><br><span class="line">        A::foo();</span><br><span class="line">        parent::foo();</span><br><span class="line">        self::foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A::foo()；这个语句是可以在任何地方执行的，它表示使用A去调用静态方法 foo() 得到“A”。 </p>
<p>parent::foo()；C 的 parent 是 B ， B 的parent是A，回溯找到了A 的 foo 方法；static::who()；语句中的 static:: 调用的方法会被子类覆盖，所以优先调用 C 的 who() 方法，如果 C 的 who 方法不存在会调用 B 的 who 方法，如果 B 的 who 方法不存在会调用 A 的 who 方法。所以，输出结果是”C”。</p>
<p>self::foo()；这个 self:: 是在 B 中使用的，所以 self:: 等价于 B:: ，但是 B 没有实现 foo() 方法，B 又继承自 A，所以我们实际上调用了 A::foo() 这个方法。foo() 方法使用了static::who() 语句，导致我们又调用了 C 的 who 函数。</p>
<p>Read More:</p>
<blockquote>
<p><a href="http://www.cnblogs.com/myjavawork/articles/1793664.html" target="_blank" rel="noopener">PHP中this,self,parent的区别</a>  <a href="http://php.net/manual/zh/language.oop5.final.php" target="_blank" rel="noopener">Final 关键字</a>   <a href="http://php.net/manual/zh/language.oop5.late-static-bindings.php" target="_blank" rel="noopener">后期静态绑定</a>  <a href="http://blog.csdn.net/koastal/article/details/52166246" target="_blank" rel="noopener">PHP中的self、static、parent关键字</a></p>
</blockquote>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>self</tag>
        <tag>final</tag>
        <tag>this</tag>
        <tag>parent</tag>
        <tag>static</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP新的垃圾回收机制</title>
    <url>/2017/04/15/phpnewgc/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在5.2及更早版本的PHP中，没有专门的垃圾回收器GC（Garbage Collection），引擎在判断一个变量空间是否能够被释放的时候是依据这个变量的zval的refcount的值，如果refcount为0，那么变量的空间可以被释放，否则就不释放，这是一种非常简单的GC实现。</p>
<p>然而在这种简单的GC实现方案中，出现了意想不到的变量内存泄漏情况（<a href="http://bugs.php.net/bug.php?id=33595" target="_blank" rel="noopener">Bug</a>），引擎将无法回收这些内存，于是在PHP 5.3中出现了新的GC，新的GC有专门的机制负责清理垃圾数据，防止内存泄漏。</p>
<p>手册中相关内容：<a href="http://php.net/manual/zh/features.gc.php" target="_blank" rel="noopener">垃圾回收机制</a>  在介绍这个新的GC之前，读者必须先了解PHP中变量的内部存储相关知识，请先阅读  <a href="https://runnerliu.github.io/2017/04/15/phpvarinternstore1/">PHP内核探索：变量的内部存储（值和类型）</a>  <a href="https://runnerliu.github.io/2017/04/15/phpvarinternstore2/">PHP内核探索：变量的内部存储（引用和计数）</a></p>
<h3 id="什么算垃圾"><a href="#什么算垃圾" class="headerlink" title="什么算垃圾"></a>什么算垃圾</h3><p>首先我们需要定义一下“垃圾”的概念，新的GC负责清理的垃圾是指变量的容器zval还存在，但是又没有任何变量名指向此zval。因此GC判断是否为垃圾的一个重要标准是有没有变量名指向变量容器zval。<br>假设我们有一段PHP代码，使用了一个临时变量<code>$tmp</code>存储了一个字符串，在处理完字符串之后，就不需要这个<code>$tmp</code>变量了，<code>$tmp</code>变量对于我们来说可以算是一个“垃圾”了，但是对于GC来说，<code>$tmp</code>其实并不是一个垃圾，<code>$tmp</code>变量对我们没有意义，但是这个变量实际还存在，<code>$tmp</code>符号依然指向它所对应的zval，GC会认为PHP代码中可能还会使用到此变量，所以不会将其定义为垃圾。</p>
<p>那么如果我们在PHP代码中使用完<code>$tmp</code>后，调用unset删除这个变量，那么<code>$tmp</code>是不是就成为一个垃圾了呢。很可惜，GC仍然不认为<code>$tmp</code>是一个垃圾，因为<code>$tmp</code>在unset之后，refcount减少1变成了0(这里假设没有别的变量和<code>$tmp</code>指向相同的zval)，这个时候GC会直接将<code>$tmp</code>对应的zval的内存空间释放，<code>$tmp</code>和其对应的zval就根本不存在了。此时的<code>$tmp</code>也不是新的GC所要对付的那种“垃圾”。那么新的GC究竟要对付什么样的垃圾呢，下面我们将生产一个这样的垃圾。  </p>
<h3 id="顽固垃圾的产生过程"><a href="#顽固垃圾的产生过程" class="headerlink" title="顽固垃圾的产生过程"></a>顽固垃圾的产生过程</h3><p>如果读者已经阅读了变量内部存储相关的内容，想必对refcount和is_ref这些变量内部的信息有了一定的了解。这里我们将结合手册中的一个例子来介绍垃圾的产生过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = array(&apos;one&apos;);</span><br><span class="line">$a[] = &amp;$a;</span><br><span class="line">xdebug_debug_zval(&apos;a&apos;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>以上例程的输出类似于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a: (refcount=2, is_ref=1)=array (</span><br><span class="line">   0 =&gt; (refcount=1, is_ref=0)=&apos;one&apos;,</span><br><span class="line">   1 =&gt; (refcount=2, is_ref=1)=...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>图示：</p>
<p><img src="/images/2017-4-15 135755.png" alt="2017-4-15 135755"></p>
<p>能看到数组变量 (a) 同时也是这个数组的第二个元素(1) 指向的变量容器中“refcount”为 2。上面的输出结果中的”…”说明发生了递归操作，显然在这种情况下意味着”…”指向原始数组。</p>
<p>跟刚刚一样，对一个变量调用unset，将删除这个符号，且它指向的变量容器中的引用次数也减1。所以，如果我们在执行完上面的代码后，对变量a调用unset，那么变量 a 和数组元素 “1” 所指向的变量容器的引用次数减1，从”2”变成”1”。下例可以说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(refcount=1, is_ref=1)=array (</span><br><span class="line">   0 =&gt; (refcount=1, is_ref=0)=&apos;one&apos;,</span><br><span class="line">   1 =&gt; (refcount=1, is_ref=1)=...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>图示：</p>
<p><img src="/images/2017-4-15 140001.png" alt="2017-4-15 140001"></p>
<p>那么问题也就产生了，a已经不在符号表中了，用户无法再访问此变量，但是a之前指向的zval的refcount变为1而不是0，因此不能被回收，这样产生了内存泄露，这样，这么一个zval就成为了一个真是意义的垃圾了，新的GC要做的工作就是清理这种垃圾。</p>
<h3 id="新的GC算法"><a href="#新的GC算法" class="headerlink" title="新的GC算法"></a>新的GC算法</h3><p>在较新的PHP手册中有简单的介绍新的GC使用的垃圾清理算法，这个算法名为 <a href="http://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon01Concurrent.pdf" target="_blank" rel="noopener">计数系统中的同步周期回收(Concurrent Cycle Collection in Reference Counted Systems)</a> ，这里不详细介绍此算法，根据手册中的内容来先简单的介绍一下思路：</p>
<p>首先我们有几个基本的准则：</p>
<ol>
<li>如果一个zval的refcount增加，那么此zval还在使用，不属于垃圾；</li>
<li>如果一个zval的refcount减少到0， 那么zval可以被释放掉，不属于垃圾；</li>
<li>如果一个zval的refcount减少之后大于0，那么此zval还不能被释放，此zval可能成为一个垃圾。</li>
</ol>
<p>只有在准则3下，GC才会把zval收集起来，然后通过新的算法来判断此zval是否为垃圾。那么如何判断这么一个变量是否为真正的垃圾呢？</p>
<p>简单的说，就是对此zval中的每个元素进行一次refcount减1操作，操作完成之后，如果zval的refcount=0，那么这个zval就是一个垃圾。这个原理看起来很简单，但是又不是那么容易理解，起初笔者也无法理解其含义，直到挖掘了源代码之后才算是了解。如果你现在不理解没有关系，后面会详细介绍，这里先把这算法的几个步骤描叙一下，首先引用手册中的一张图：</p>
<p><img src="/images/2017-4-15 172459.png" alt="2017-4-15 172459"></p>
<p>A：为了避免每次变量的refcount减少的时候都调用GC的算法进行垃圾判断，此算法会先把所有前面准则3情况下的zval节点放入一个节点(root)缓冲区(root buffer)，并且将这些zval节点标记成紫色，同时算法必须确保每一个zval节点在缓冲区中之出现一次。当缓冲区被节点塞满的时候，GC才开始开始对缓冲区中的zval节点进行垃圾判断。</p>
<p>B：当缓冲区满了之后，算法以深度优先对每一个节点所包含的zval进行减1操作，为了确保不会对同一个zval的refcount重复执行减1操作，一旦zval的refcount减1之后会将zval标记成灰色。需要强调的是，这个步骤中，起初节点zval本身不做减1操作，但是如果节点zval中包含的zval又指向了节点zval（环形引用），那么这个时候需要对节点zval进行减1操作。</p>
<p>C：算法再次以深度优先判断每一个节点包含的zval的值，如果zval的refcount等于0，那么将其标记成白色(代表垃圾)，如果zval的refcount大于0，那么将对此zval以及其包含的zval进行refcount加1操作，这个是对非垃圾的还原操作，同时将这些zval的颜色变成黑色（zval的默认颜色属性）</p>
<p>D：遍历zval节点，将C中标记成白色的节点zval释放掉。</p>
<p>比如还是前面那个变成垃圾的数组a对应的zval，命名为zval_a,  如果没有执行unset， zval_a的refcount为2，分别由a和a中的索引1指向这个zval。  用算法对这个数组中的所有元素（索引0和索引1）的zval的refcount进行减1操作，由于索引1对应的就是zval_a，所以这个时候zval_a的refcount应该变成了1，这样zva_a就不是一个垃圾。如果执行了unset操作，zval_a的refcount就是1，由zval_a中的索引1指向zval_a，用算法对数组中的所有元素（索引0和索引1）的zval的refcount进行减1操作，这样zval_a的refcount就会变成0，于是就发现zval_a是一个垃圾了。 算法就这样发现了顽固的垃圾数据。</p>
<p>对于一个包含环形引用的数组，对数组中包含的每个元素的zval进行减1操作，之后如果发现数组自身的zval的refcount变成了0，那么可以判断这个数组是一个垃圾。</p>
<p>这个道理其实很简单，假设数组a的refcount等于m，a中有n个元素又指向a，如果m等于n，那么算法的结果是m减n，m-n=0，那么a就是垃圾，如果m&gt;n，那么算法的结果m-n&gt;0，所以a就不是垃圾了。</p>
<p>m=n代表什么？代表a的refcount都来自数组a自身包含的zval元素，代表a之外没有任何变量指向它，代表用户代码空间中无法再访问到a所对应的zval，代表a是泄漏的内存，因此GC将a这个垃圾回收了。</p>
<h3 id="新的GC算法的性能"><a href="#新的GC算法的性能" class="headerlink" title="新的GC算法的性能"></a>新的GC算法的性能</h3><h4 id="防止泄漏节省内存"><a href="#防止泄漏节省内存" class="headerlink" title="防止泄漏节省内存"></a>防止泄漏节省内存</h4><p>新的GC算法的目的就是为了防止循环引用的变量引起的内存泄漏问题，在PHP中GC算法，当节点缓冲区满了之后，垃圾分析算法会启动，并且会释放掉发现的垃圾，从而回收内存，在PHP手册上给了一段代码和内存使用状况图：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Foo</span><br><span class="line">&#123;</span><br><span class="line">    public $var = &apos;3.1415962654&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$baseMemory = memory_get_usage();</span><br><span class="line"></span><br><span class="line">for ( $i = 0; $i &lt;= 100000; $i++ )</span><br><span class="line">&#123;</span><br><span class="line">    $a = new Foo;</span><br><span class="line">    $a-&gt;self = $a;</span><br><span class="line">    if ( $i % 500 === 0 )</span><br><span class="line">    &#123;</span><br><span class="line">        echo sprintf( &apos;%8d: &apos;, $i ), memory_get_usage() - $baseMemory, &quot;/n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/images/2017-4-15 173341.png" alt="2017-4-15 173341"></p>
<p>这段代码的循环体中，新建了一个对象变量，并且用对象的一个成员指向了自己，这样就形成了一个循环引用，当进入下一次循环的时候，又一次给对象变量重新赋值，这样会导致之前的对象变量内存泄漏，在这个例子里面有两个变量泄漏了，一个是对象本身，另外一个是对象中的成员self，但是这两个变量只有对象会作为垃圾收集器的节点被放入缓冲区(因为重新赋值相当于对它进行了unset操作，满足前面的准则3)。在这里我们进行了100,000次循环，而GC在缓冲区中有10,000节点的时候会启动垃圾分析算法，所以这里一共会进行10次的垃圾分析算法。从图中可以清晰的看到，在5.3版本PHP中，每次GC的垃圾分析算法被触发后，内存会有一个明显的减少。而在5.2版本的PHP中，内存使用量会一直增加。</p>
<h4 id="运行效率影响"><a href="#运行效率影响" class="headerlink" title="运行效率影响"></a>运行效率影响</h4><p> 启用了新的GC后，垃圾分析算法将是一个比较耗时的操作，手册中给了一段测试代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Foo</span><br><span class="line">&#123;</span><br><span class="line">    public $var = &apos;3.1415962654&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for ( $i = 0; $i &lt;= 1000000; $i++ )</span><br><span class="line">&#123;</span><br><span class="line">    $a = new Foo;</span><br><span class="line">    $a-&gt;self = $a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">echo memory_get_peak_usage(), &quot;/n&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>然后分别在GC开启和关闭的情况下执行这段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">time php -dzend.enable_gc=0 -dmemory_limit=-1 -n example2.php</span><br><span class="line"># and</span><br><span class="line">time php -dzend.enable_gc=1 -dmemory_limit=-1 -n example2.php</span><br></pre></td></tr></table></figure>
<p>最终在该机器上，第一次执行大概使用10.7秒，第二次执行大概使用11.4秒，性能大约降低7%，不过内存的使用量降低了98%，从931M降低到了10M。当然这并不是一个比较科学的测试方法，但是也能说明一定的问题。这种代码测试的是一种极端恶劣条件，实际代码中，特别是在WEB的应用中，很难出现大量循环引用，GC的分析算法的启动不会这么频繁，小规模的代码中甚至很少有机会启动GC分析算法。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>当GC的垃圾分析算法执行的时候，PHP脚本的效率会受到一定的影响，但是小规模的代码一般不会有这个机会运行这个算法。如果一旦脚本中GC分析算法开始运行了，那么将花费少量的时间节省出来了大量的内存，是一件非常划算的事情。新的GC对一些长期运行的PHP脚本效果更好，比如PHP的DAEMON守护进程，或则PHP-GTK进程等等。</p>
<p>Read More:</p>
<blockquote>
<p><a href="http://blog.csdn.net/phpkernel/article/details/5734743" target="_blank" rel="noopener">PHP新的垃圾回收机制:Zend GC详解</a>  <a href="http://php.net/manual/zh/features.gc.collecting-cycles.php" target="_blank" rel="noopener">回收周期(Collecting Cycles)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP内核探索：变量的内部存储（引用和计数）</title>
    <url>/2017/04/15/phpvarinternstore2/</url>
    <content><![CDATA[<p>在  <a href="https://runnerliu.github.io/2017/04/15/phpvarinternstore1/#more">PHP内核探索：变量的内部存储（值和类型）</a>  中介绍了PHP变量在引擎中是如何存储以及PHP如何实现其弱类型功能的。本文将从引用和计数的角度继续介绍变量的内部存储。</p>
<h3 id="引用计数基本知识"><a href="#引用计数基本知识" class="headerlink" title="引用计数基本知识"></a>引用计数基本知识</h3><p>每个php变量存在一个叫”zval”的变量容器中。一个zval变量容器，除了包含变量的类型和值，还包括两个字节的额外信息。第一个是”is_ref”(此字段在5.3.2版本中是is_ref__gc)，是个bool值，用来标识这个变量是否是属于引用集合。通过这个字节，php引擎才能把普通变量和引用变量区分开来，由于php允许用户通过使用&amp;来使用自定义引用，zval变量容器中还有一个内部引用计数机制，来优化内存使用。第二个额外字节是”refcount”(此字段在5.3.2版本中是refcount__gc)，用以表示指向这个zval变量容器的变量(也称符号即symbol)个数。所有的符号存在一个符号表中，其中每个符号都有作用域，那些主脚本(比如：通过浏览器请求的的脚本)和每个函数或者方法也都有作用域。</p>
<p>当一个变量被赋常量值时，就会生成一个zval变量容器，如下例这样：</p>
<p><strong>Example #1</strong> 生成一个新的zval容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = &quot;new string&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>在上例中，新的变量a，是在当前作用域中生成的。并且生成了类型为 string 和值为new string的变量容器。在额外的两个字节信息中，”is_ref”被默认设置为 FALSE，因为没有任何自定义的引用生成。”refcount” 被设定为 1，因为这里只有一个变量使用这个变量容器， 注意到当”refcount”的值是1时，”is_ref”的值总是FALSE。如果你已经安装了Xdebug，你能通过调用函数 xdebug_debug_zval()显示”refcount”和”is_ref”的值。</p>
<p><strong>Example #2 </strong>显示zval信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">xdebug_debug_zval(&apos;a&apos;);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>以上例程会输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a: (refcount=1, is_ref=0)=&apos;new string&apos;</span><br></pre></td></tr></table></figure>
<p>把一个变量赋值给另一变量将增加引用次数(refcount)。</p>
<p><strong>Example #3 </strong>增加一个zval的引用计数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = &quot;new string&quot;;</span><br><span class="line">$b = $a;</span><br><span class="line">xdebug_debug_zval( &apos;a&apos; );</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>以上例程会输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a: (refcount=2, is_ref=0)=&apos;new string&apos;</span><br></pre></td></tr></table></figure>
<p>这时，引用次数是2，因为同一个变量容器被变量a 和变量 b关联。当没必要时，php不会去复制已生成的变量容器。变量容器在”refcount“变成0时就被销毁. 当任何关联到某个变量容器的变量离开它的作用域(比如：函数执行结束)，或者对变量调用了函数 unset()时，”refcount“就会减1，下面的例子就能说明：</p>
<p><strong>Example #4 </strong>减少引用计数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = &quot;new string&quot;;</span><br><span class="line">$c = $b = $a;</span><br><span class="line">xdebug_debug_zval( &apos;a&apos; );</span><br><span class="line">unset( $b, $c );</span><br><span class="line">xdebug_debug_zval( &apos;a&apos; );</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>以上例程会输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a: (refcount=3, is_ref=0)=&apos;new string&apos;</span><br><span class="line">a: (refcount=1, is_ref=0)=&apos;new string&apos;</span><br></pre></td></tr></table></figure>
<p>如果我们现在执行 unset($a)，包含类型和值的这个变量容器就会从内存中删除。</p>
<h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><p>当考虑像 array和object这样的复合类型时，事情就稍微有点复杂。与 标量类型的值不同，array和 object类型的变量把它们的成员或属性存在自己的符号表中。这意味着下面的例子将生成三个zval变量容器。</p>
<p><strong>Example #5</strong> Creating a array zval</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = array( &apos;meaning&apos; =&gt; &apos;life&apos;, &apos;number&apos; =&gt; 42 );</span><br><span class="line">xdebug_debug_zval( &apos;a&apos; );</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>以上例程的输出类似于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a: (refcount=1, is_ref=0)=array (</span><br><span class="line">   &apos;meaning&apos; =&gt; (refcount=1, is_ref=0)=&apos;life&apos;,</span><br><span class="line">   &apos;number&apos; =&gt; (refcount=1, is_ref=0)=42</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>图示：</p>
<p><img src="/images/2017-4-15 135317.png" alt="2017-4-15 135317"></p>
<p>这三个zval变量容器是: a，meaning和 number。增加和减少”refcount”的规则和上面提到的一样。下面， 我们在数组中再添加一个元素，并且把它的值设为数组中已存在元素的值：</p>
<p><strong>Example #6 </strong>添加一个已经存在的元素到数组中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = array( &apos;meaning&apos; =&gt; &apos;life&apos;, &apos;number&apos; =&gt; 42 );</span><br><span class="line">$a[&apos;life&apos;] = $a[&apos;meaning&apos;];</span><br><span class="line">xdebug_debug_zval( &apos;a&apos; );</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>以上例程的输出类似于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a: (refcount=1, is_ref=0)=array (</span><br><span class="line">   &apos;meaning&apos; =&gt; (refcount=2, is_ref=0)=&apos;life&apos;,</span><br><span class="line">   &apos;number&apos; =&gt; (refcount=1, is_ref=0)=42,</span><br><span class="line">   &apos;life&apos; =&gt; (refcount=2, is_ref=0)=&apos;life&apos;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>图示：</p>
<p><img src="/images/2017-4-15 135507.png" alt="2017-4-15 135507"></p>
<p>从以上的Xdebug输出信息，我们看到原有的数组元素和新添加的数组元素关联到同一个”refcount”为2的zval变量容器. 尽管 Xdebug的输出显示两个值为’life’的 zval 变量容器，其实是同一个。 函数xdebug_debug_zval()不显示这个信息，但是你能通过显示内存指针信息来看到。</p>
<p>删除数组中的一个元素，就是类似于从作用域中删除一个变量. 删除后,数组中的这个元素所在的容器的“refcount”值减少，同样，当“refcount”为0时，这个变量容器就从内存中被删除，下面又一个例子可以说明：</p>
<p><strong>Example #7 </strong>从数组中删除一个元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = array( &apos;meaning&apos; =&gt; &apos;life&apos;, &apos;number&apos; =&gt; 42 );</span><br><span class="line">$a[&apos;life&apos;] = $a[&apos;meaning&apos;];</span><br><span class="line">unset( $a[&apos;meaning&apos;], $a[&apos;number&apos;] );</span><br><span class="line">xdebug_debug_zval( &apos;a&apos; );</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>以上例程的输出类似于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a: (refcount=1, is_ref=0)=array (</span><br><span class="line">   &apos;life&apos; =&gt; (refcount=1, is_ref=0)=&apos;life&apos;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>现在，当我们添加一个数组本身作为这个数组的元素时，事情就变得有趣，下个例子将说明这个。例中我们加入了引用操作符，否则php将生成一个复制。</p>
<p><strong>Example #8 </strong>把数组作为一个元素添加到自己</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = array( &apos;one&apos; );</span><br><span class="line">$a[] =&amp; $a;</span><br><span class="line">xdebug_debug_zval( &apos;a&apos; );</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>以上例程的输出类似于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a: (refcount=2, is_ref=1)=array (</span><br><span class="line">   0 =&gt; (refcount=1, is_ref=0)=&apos;one&apos;,</span><br><span class="line">   1 =&gt; (refcount=2, is_ref=1)=...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>图示：</p>
<p><img src="/images/2017-4-15 135755.png" alt="2017-4-15 135755"></p>
<p>能看到数组变量 (a) 同时也是这个数组的第二个元素(1) 指向的变量容器中“refcount”为 2。上面的输出结果中的”…”说明发生了递归操作, 显然在这种情况下意味着”…”指向原始数组。</p>
<p>跟刚刚一样，对一个变量调用unset，将删除这个符号，且它指向的变量容器中的引用次数也减1。所以，如果我们在执行完上面的代码后，对变量a调用unset，那么变量 a 和数组元素 “1” 所指向的变量容器的引用次数减1，从”2”变成”1”。下例可以说明：</p>
<p><strong>Example #9 </strong>Unsetting a</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(refcount=1, is_ref=1)=array (</span><br><span class="line">   0 =&gt; (refcount=1, is_ref=0)=&apos;one&apos;,</span><br><span class="line">   1 =&gt; (refcount=1, is_ref=1)=...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>图示：</p>
<p><img src="/images/2017-4-15 140001.png" alt="2017-4-15 140001"></p>
<h3 id="清理变量容器的问题"><a href="#清理变量容器的问题" class="headerlink" title="清理变量容器的问题"></a>清理变量容器的问题</h3><p>尽管不再有某个作用域中的任何符号指向这个结构(就是变量容器)，由于数组元素“1”仍然指向数组本身，所以这个容器不能被清除 。因为没有另外的符号指向它，用户没有办法清除这个结构，结果就会导致内存泄漏。庆幸的是，php将在脚本执行结束时清除这个数据结构，但是在php清除之前，将耗费不少内存。如果你要实现分析算法，或者要做其他像一个子元素指向它的父元素这样的事情，这种情况就会经常发生。当然，同样的情况也会发生在对象上，实际上对象更有可能出现这种情况，因为对象总是隐式的被引用。</p>
<p>如果上面的情况发生仅仅一两次倒没什么，但是如果出现几千次，甚至几十万次的内存泄漏，这显然是个大问题。这样的问题往往发生在长时间运行的脚本中，比如请求基本上不会结束的守护进程或者单元测试中的大的套件中。后者的例子：在给巨大的eZ(一个知名的PHP Library) 组件库的模板组件做单元测试时，就可能会出现问题。有时测试可能需要耗用2GB的内存，而测试服务器很可能没有这么大的内存。</p>
<p><strong>这就涉及到了PHP中的垃圾回收机制</strong>，将在下一篇博客中介绍。</p>
<h3 id="写时复制机制（Copy-on-write）"><a href="#写时复制机制（Copy-on-write）" class="headerlink" title="写时复制机制（Copy on write）"></a>写时复制机制（Copy on write）</h3><p>考虑以下示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line">$a = &quot;Hello world&quot;;  </span><br><span class="line">$b = $a;  </span><br><span class="line">$b = &quot;new string&quot;;  </span><br><span class="line">echo $a;  </span><br><span class="line">echo $b;  </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>a和b明明是指向同一个zval，为什么修改了b，a还能保持不变呢，这就是copy on write（写时复制）技术，简单的说，当重新给b赋值的时候，会将b从之前的zval中分离出来。分离之后，a和b分别是指向不同的zval了。</p>
<blockquote>
<p>写时复制技术的一个比较有名的应用是在unix类操作系统内核中，当一个进程调用fork函数生成一个子进程的时候，父子进程拥有相同的地址空间内容，在老版本的系统中，子进程是在fork的时候就将父进程的地址空间中的内容都拷贝一份，对于规模较大的程序这个过程可能会有着很大的开销，更崩溃的是，很多进程在fork之后，直接在子进程中调用exec执行另外一个程序，这样原来花了大量时间从父进程复制的地址空间都还没来得及碰一下就被新的进程地址空间代替，这显然是对资源的极大浪费，所以在后来的系统中，就使用了写时复制技术，fork之后，子进程的地址空间还是简单的指向父进程的地址空间，只有当子进程需要写地址空间中的内容的时候，才会单独分离一份（一般以内存页为单位）给子进程，这样就算子进程马上调用exec函数也没关系，因为根本就不需要从父进程的地址空间中拷贝内容，这样节约了内存同时又提高了速度。</p>
</blockquote>
<p>当b从a指向的zval分离出来之后，zval的refcount就要减1，这样由之前的2变成了1，表示这个zval还有一个变量指向它，就是a。b变量指向了一个新的zval，新的zval的refcount为1，值为字符串”new string”，大概过程如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$a = &quot;Hello world&quot;	//a：(refcount=1, is_ref=0)=&quot;Hello world&quot;</span><br><span class="line">$b = $a			//a，b： (refcount=2, is_ref=0)=&quot;Hello world&quot;</span><br><span class="line">$b = &quot;new string&quot;	//a： (refcount=1, is_ref=0)=&quot;Hello world&quot;   b: (refcount=1, is_ref=0)=&quot;new string&quot;(发生分离操作)</span><br></pre></td></tr></table></figure>
<p>这个分离逻辑可以表叙为：<br>对一个一般变量a（is_ref=0）进行一般赋值操作，如果a所指向的zval的计数refcount大于1,那么需要为a重新分配一个新的zval，并且把之前的zval的计数refcount减少1。</p>
<p>以上为普通赋值的情况，如果是引用赋值，我们看看这个变化过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$a = &quot;Hello world&quot;	//a： (refcount=1, is_ref=0)=&quot;Hello world&quot;</span><br><span class="line">$b = &amp;$a		//a，b： (refcount=2, is_ref=1)=&quot;Hello world&quot;</span><br><span class="line">$b = &quot;new string&quot;	//a，b： (refcount=2, is_ref=1)=&quot;new string&quot;</span><br></pre></td></tr></table></figure>
<p>可以看出来，对一个引用类型的zval进行赋值是不会进行分离操作的，实际上我们再产生一个引用变量的时候是可能出现一个分离操作的，只是时机有些不同：</p>
<ol>
<li>在普通赋值的情况下，分离操作发生在<code>$b=&quot;new string&quot;</code>这一步，也就是在对变量赋新的值的时候，才会进行zval分离操作；</li>
<li>在引用赋值的情况下，分离操作有可能发生在<code>$b = &amp;$a</code>这一步，也就是在生成引用变量的时候。</li>
</ol>
<p>情况1就不多解释了，情况2中强调是有可能发生分离，以前面的这代码为例子，是否进行分离与a当前指向的zval的refcount有关系，代码中<code>$b = &amp;$a</code> 的时候，a指向的zval的refcount=1，这个时候不需要进行分离操作，但是如果refcount=2，那么就需要分离一个zval出来。比如如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line">$a = &quot;Hello world&quot;;  </span><br><span class="line">$c = $a;  </span><br><span class="line">$b = &amp;$a;  </span><br><span class="line">$b = &quot;new string&quot;;  </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>在执行引用赋值的时候，a指向的zval的refcount=2，因为a和c同时指向了这个zval，所以在<code>$b=&amp;$a</code>的时候，就需要进行一个分离操作，这个分离操作生成了一个ref=1的zval，并且计数为2，因为a，b两个变量指向分离出来的zval，原来的zval的refcount减少1，所以最终只有c指向一个值为”Hello world”，ref=0的zval1，a和b指向一个值为”Hello world”，ref=1的zval2。 这样我们对c的修改时在操作zval1，对a和b的修改都是在操作zval2，这样就符合引用的特性了。</p>
<p>此过程大致如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$a = &quot;Hello world&quot;;	//a: (refcount=1, is_ref=0)=&quot;Hello world&quot;</span><br><span class="line">$c = $a;		// a,c: (refcount=2, is_ref=0)=&quot;Hello world&quot;</span><br><span class="line">$b = &amp;$a;		// c: (refcount=1, is_ref=0)=&quot;Hello world&quot; a,b: (refcount=2, is_ref=1)=&quot;Hello world&quot; (发生分离操作)</span><br><span class="line">$b = &quot;new string&quot;;	// c: (refcount=1, is_ref=0)=&quot;Hello world&quot; a,b: (refcount=2, is_ref=1)=&quot;new string&quot;</span><br></pre></td></tr></table></figure>
<p>试想一下如果不进行这个分离会有什么后果？<br>如果不进行分离，a，b，c都指向了同一个zval，对b的修改也会影响到c，这显然是不符合PHP语言特性的。</p>
<p>这个分离逻辑可以表述为：<br>将一个一般变量a(is_ref=0)的引用赋给另外一个变量b的时候，如果a的refcount大于1，那么需要对a进行一次分离操作，分离之后的 zval 的is_ref等于1，refcount等于2。</p>
<h3 id="unset的作用"><a href="#unset的作用" class="headerlink" title="unset的作用"></a>unset的作用</h3><p>unset()并非一个函数，而是一种语言结构，主要的操作时从当前符号表中删除参数中的符号，比如在全局代码中执行<code>unset($a)</code>，那么将会在全局符号表中删除a这个符号。全局符号表是一张哈希表，建立这张表的时候会提供一个表中的项的析构函数，当我们从符号表中删除a的时候，会对符号a指向的项（这里是zval的指针）调用这个析构函数，这个析构函数的主要功能是将a对应的zval的refcount减1，如果refcount变成了0，那么释放这个zval。所以当我们调用unset的时候，不一定能释放变量所占的内存空间，只有当这个变量对应的zval没有别的变量指向它的时候，才会释放掉zval，否则只是对refcount进行减1操作。</p>
<h3 id="继续Example"><a href="#继续Example" class="headerlink" title="继续Example"></a>继续Example</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果将代码：  </span><br><span class="line">&lt;?php    </span><br><span class="line">$a = &quot;Hello world&quot;;    </span><br><span class="line">$c = $a;    </span><br><span class="line">$b = &amp;$a;    </span><br><span class="line">$b = &quot;new string&quot;;    </span><br><span class="line">?&gt;   </span><br><span class="line">  </span><br><span class="line">改为：  </span><br><span class="line">  </span><br><span class="line">&lt;?php    </span><br><span class="line">$a = &quot;Hello world&quot;;    </span><br><span class="line">$c = &amp;$a;         </span><br><span class="line">$b = &amp;$a;    </span><br><span class="line">$b = &quot;new string&quot;;    </span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>
<p>执行以上示例，会发现，输出的a，b，c都是“new string”：</p>
<p>此过程大致如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$a = &quot;Hello world&quot;;		//a：(refcount=1, is_ref=0)=&quot;Hello world&quot;</span><br><span class="line">$c = &amp;$a;			//a，c:(refcount=2, is_ref=1)=&quot;hello world&quot;</span><br><span class="line">$b = &amp;$a;			//a，b，c:(refcount=3, is_ref=1)=&quot;hello world&quot;</span><br><span class="line">$b = &quot;new string&quot;;		//a，b，c:(refcount=3, is_ref=1)=&quot;new string&quot;</span><br></pre></td></tr></table></figure>
<p>我们发现，如果都是引用赋值的话，PHP是不会进行分离的，这种情况与上述情况2还是有区别的。</p>
<p>Read More:</p>
<blockquote>
<p><a href="http://php.net/manual/zh/features.gc.refcounting-basics.php" target="_blank" rel="noopener">引用计数基本知识</a>  <a href="http://blog.csdn.net/phpkernel/article/details/5732784" target="_blank" rel="noopener">变量的内部存储：引用和计数</a>  </p>
</blockquote>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>变量的内部存储</tag>
      </tags>
  </entry>
  <entry>
    <title>进程与线程的关系</title>
    <url>/2017/04/04/processthread/</url>
    <content><![CDATA[<p>写这篇文章是想总结一下在操作系统中，进程和线程到底是什么样的，它们之间有什么区别和联系，虽然在实践中使用过多线程和多进程，但也只是了解了皮毛，故在此总结一下，因为操作系统是一个比较复杂的东西，通过进程和线程可以推演出各种复杂的概念和情况，所以文章只是在现有水平下的一点解释。</p>
<h3 id="从操作系统说起"><a href="#从操作系统说起" class="headerlink" title="从操作系统说起"></a>从操作系统说起</h3><p>操作系统 (Operating System，OS) 是管理和控制计算机硬件与软件资源的计算机程序，是直接运行在“裸机”上的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。</p>
<p>操作系统的功能主要包括管理计算机系统的硬件、软件及数据资源，控制程序运行，改善人机界面，为其它应用软件提供支持，让计算机系统所有资源最大限度地发挥作用，提供各种形式的用户界面，使用户有一个好的工作环境，为其它软件的开发提供必要的服务和相应的接口等。</p>
<p>实际上，用户是不用接触操作系统的，操作系统管理着计算机硬件资源，同时按照应用程序的资源请求，分配资源，如：划分CPU时间，内存空间的开辟，调用打印机等。</p>
<p>我们的计算机由硬件和软件两个部分组成。硬件部分包括控制器、运算器、存储器、输入设备、输出设备；软件部分包括系统软件和应用软件。而在计算机运行过程中最最重要的就是控制器和运算器，他们构成了计算机的核心：CPU。简而言之，CPU+RAM+各种资源 (比如显卡，光驱，键盘，GPS, 等等外设) 构成我们的电脑，但是电脑的运行，实际就是CPU和相关寄存器以及RAM之间的事情。</p>
<p>目前计算机的软硬件发展太快，CPU的运行速度也是直线上升，而寄存器仅仅能够追的上他的脚步，RAM和别的挂在各总线上的设备完全是望其项背。那当多个任务要执行的时候怎么办呢？轮流着来？或者谁优先级高谁来？不管怎么样的策略，一句话就是：在CPU看来就是轮流着来。</p>
<h3 id="搞清楚几个概念"><a href="#搞清楚几个概念" class="headerlink" title="搞清楚几个概念"></a>搞清楚几个概念</h3><p><strong>进程</strong> 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，是一个动态的概念；</p>
<p><strong>线程</strong>是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针PC，寄存器集合和堆栈组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，它可与同属一个进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行；</p>
<p><strong>程序</strong>只是一组指令的有序集合，是一个静态的概念；</p>
<p><strong>任务</strong>是指由软件完成的一个活动。一个任务既可以是一个进程，也可以是一个线程。它指的是一系列共同达到某一目的的操作。例如，读取数据并将数据放入内存中。这个任务可以作为一个进程来实现，也可以作为一个线程来实现。</p>
<h3 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h3><p>目前大部分的操作系统的任务调度是采用时间片轮转的抢占式调度方式，也就是说一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。</p>
<p>任务执行的一小段时间叫做时间片，任务正在执行时的状态叫运行状态，任务执行一段时间后强制暂停去执行下一个任务，被暂停的任务就处于就绪状态，等待下一个属于它的时间片的到来。这样每个任务都能得到执行，由于CPU的执行效率非常高，时间片非常短，在各个任务之间快速地切换，给人的感觉就是多个任务在“同时进行”，这也就是我们所说的并发。多任务运行过程的示意图如下：</p>
<p><img src="/images/2017-4-4 132812.png" alt="2017-4-4 132812"></p>
<p>当执行一段程序代码，实现一个功能的过程时，得到CPU时间片的时候，相关的资源必须也已经就位，比如显卡等资源，然后CPU开始执行。这时除了CPU以外所有的其他资源就构成了这个程序的执行环境，也就是我们所说的程序上下文。当这个程序执行完了，或者分配给他的CPU时间片用完了，那它就要被切换出去，等待下一次CPU的<strong>临幸</strong>。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存。</p>
<p>具体的轮流执行方法就是：先加载程序 A 的上下文，然后开始执行 A ，保存程序 A 的上下文，调入下一个要执行的程序 B 的程序上下文，然后开始执行 B ，保存程序 B 的上下文……循环执行。</p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>计算机的核心是CPU，它承担了所有的计算任务；而操作系统是计算机的管理者，它负责任务的调度、资源的分配和管理，统领整个计算机硬件；应用程序侧是具有某种功能的程序，程序是运行于操作系统之上的。</p>
<p>进程一般由程序、数据集合和进程控制块三部分组成。程序用于描述进程要完成的功能，是控制进程执行的指令集；数据集合是程序在执行时所需要的数据和工作区；程序控制块 (PCB) 包含进程的描述信息和控制信息，是进程存在的唯一标志。</p>
<p>程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为<strong>进程</strong>。</p>
<p><strong>进程具有的特征</strong>：<br><strong>动态性</strong>：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；<br><strong>并发性</strong>：任何进程都可以同其他进程一起并发执行；<br><strong>独立性</strong>：进程是系统进行资源分配和调度的一个独立单位；<br><strong>结构性</strong>：进程由程序、数据和进程控制块三部分组成。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。</p>
<p>随着计算机的发展，对 CPU 的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程，线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间（也就是所在进程的内存空间）。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间（代码、数据、进程空间、打开的文件）和一个或多个线程组成。</p>
<p><strong>为什么需要线程</strong></p>
<p>进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。</p>
<p>进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。</p>
<p><strong>线程的优点</strong></p>
<p>进程属于在处理器这一层上提供的抽象；线程则属于在进程这个层次上再提供了一层并发的抽象。如果我们进入计算机体系结构里，就会发现，流水线提供的也是一种并发，不过是指令级的并发。这样，流水线、线程、进程就从低到高在三个层次上提供我们所迫切需要的并发。</p>
<p>除了提高进程的并发度，线程还有个好处，就是可以有效地利用多处理器和多核计算机。现在的处理器有个趋势就是朝着多核方向发展，在没有线程之前，多核并不能让一个进程的执行速度提高，原因还是上面所有的两点限制。但如果讲一个进程分解为若干个线程，则可以让不同的线程运行在不同的核上，从而提高了进程的执行速度。</p>
<p>例如：我们经常使用微软的Word进行文字排版，实际上就打开了多个线程。这些线程一个负责显示，一个接受键盘的输入，一个进行存盘等等。这些线程一起运行，让我们感觉到我们输入和屏幕显示同时发生，而不是输入一些字符，过一段时间才能看到显示出来。在我们不经意间，还进行了自动存盘操作。这就是线程给我们带来的方便之处。</p>
<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><h4 id="无名管道通信"><a href="#无名管道通信" class="headerlink" title="无名管道通信"></a>无名管道通信</h4><p>管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p>
<h4 id="高级管道通信"><a href="#高级管道通信" class="headerlink" title="高级管道通信"></a>高级管道通信</h4><p>将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。</p>
<h4 id="有名管道通信"><a href="#有名管道通信" class="headerlink" title="有名管道通信"></a>有名管道通信</h4><p>有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p>
<h4 id="消息队列通信"><a href="#消息队列通信" class="headerlink" title="消息队列通信"></a>消息队列通信</h4><p>消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
<h4 id="信号量通信"><a href="#信号量通信" class="headerlink" title="信号量通信"></a>信号量通信</h4><p>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
<h4 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h4><p>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
<h4 id="共享内存通信"><a href="#共享内存通信" class="headerlink" title="共享内存通信"></a>共享内存通信</h4><p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p>
<h4 id="套接字通信"><a href="#套接字通信" class="headerlink" title="套接字通信"></a>套接字通信</h4><p> 套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</p>
<h3 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h3><p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p>
<h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>提供了以排他方式阻止数据结构被并发修改的方法。</p>
<h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</p>
<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><p>允许多个线程同时读共享数据，而对写操作时互斥的。</p>
<h4 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h4><p>包括无名线程信号量和命名线程信号量。</p>
<h4 id="信号-1"><a href="#信号-1" class="headerlink" title="信号"></a>信号</h4><p>类似进程间的信号处理。</p>
<h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><p>一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。</p>
<p>资源分配给进程，同一进程的所有线程共享该进程的所有资源。</p>
<p>处理机分给线程，即真正在处理机上运行的是线程。</p>
<p>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</p>
<p>划分尺度：线程更小，所以多线程程序并发性更高；</p>
<p>资源分配：进程是资源分配的基本单位，同一进程内多个线程共享其资源；</p>
<p>地址空间：进程拥有独立的地址空间，同一进程内多个线程共享其资源；</p>
<p>处理器调度：线程是处理器调度的基本单位；</p>
<p>执行：每个线程都有一个程序运行的入口，顺序执行序列和程序的出口，但线程不能单独执行，必须组成进程，一个进程至少有一个主线程。</p>
<p>调度和切换：线程上下文切换比进程上下文切换要快得多；</p>
<h3 id="进程与程序的区别"><a href="#进程与程序的区别" class="headerlink" title="进程与程序的区别"></a>进程与程序的区别</h3><p>程序只是一组指令的有序集合，它本身没有任何运行的含义，它只是一个静态的实体。而进程则不同，它是程序在某个数据集上的执行。</p>
<p>进程是一个动态的实体，它有自己的生命周期。它因创建而产生，因调度而运行，因等待资源或事件而被处于等待状态，因完成任务而被撤消。反映了一个程序在一定的数据集上运行的全部动态过程。</p>
<p>进程和程序并不是一一对应的，一个程序执行在不同的数据集上就成为不同的进程，可以用进程控制块来唯一地标识每个进程。而这一点正是程序无法做到的，由于程序没有和数据产生直接的联系，既使是执行不同的数据的程序，他们的指令的集合依然是一样的，所以无法唯一地标识出这些运行于不同数据集上的程序。一般来说，一个进程肯定有一个与之对应的程序，而且只有一个。而一个程序有可能没有与之对应的进程（因为它没有执行），也有可能有多个进程与之对应（运行在几个不同的数据集上）。</p>
<p>进程还具有并发性和交往性，这也与程序的封闭性不同。进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性。</p>
<p><strong>一个程序至少有一个进程，一个进程至少有一个线程。</strong></p>
<p>Read More:</p>
<blockquote>
<p><a href="http://baike.baidu.com/link?url=4fOde2n_NRgpRtqZoalXZ06Aayt58wQqHh2mObGpB1VMjxqC9mh9KOYyUUJYgxNYFn99uBslB2vi1FsJixsNVak3o9wzgXQp7mQXBYevW1NStO1VyvH8o4r0oLHJiQ9p" target="_blank" rel="noopener">操作系统</a>  <a href="http://baike.baidu.com/link?url=vJj7GOmk5b7mmXDQ_2lqqrMiW9dQij-XKGOP3KpEW835yuIqIAsKbfalfXoBIVqSNQcUn0pEnsJ9rQTuf4AbFVvU-9T0weTo116bFk5B-3s0J8WEyIlut5Sc3kD6y8CnMgK6m5VSOy6DtlgHzynDLK" target="_blank" rel="noopener">计算机组成</a>  <a href="http://baike.baidu.com/link?url=aVTgdRi8naSwdGTY_CWy9hFsphNKF7y7-CU3sANapR1ymm3M-tMMLF7Wu7JgHu_cVsHIVzzBLzu_ZfPNvPxV0dn1nH1Dr_QxEty0lhr1Zz3#6" target="_blank" rel="noopener">线程</a>  <a href="http://baike.baidu.com/link?url=F9FJKdccMHkGhOdEAFbGUyqttk1lf6zz5y2jjrgtacsMeHLeu38Uewn4asIvKyT46rxz2NpMm6Ha5CkzEQXgh2Fc1tlKYY7_qlXCm-W93a3" target="_blank" rel="noopener">进程</a>  <a href="https://www.zhihu.com/question/25532384/answer/81152571" target="_blank" rel="noopener">线程和进程的区别是什么？</a>  <a href="http://blog.csdn.net/violet_echo_0908/article/details/51201278" target="_blank" rel="noopener">进程间8种通信方式详解</a>  <a href="http://blog.163.com/magicc_love/blog/static/185853662201111810300646/" target="_blank" rel="noopener">程序、任务、进程和线程的联系与区别 </a>  <a href="http://blog.csdn.net/cowena/article/details/47132675" target="_blank" rel="noopener">操作系统专题——进程与线程的区别</a>  <a href="http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html" target="_blank" rel="noopener">进程与线程的一个简单解释</a></p>
</blockquote>
]]></content>
      <categories>
        <category>进程/线程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>线程</tag>
        <tag>进程</tag>
        <tag>程序</tag>
      </tags>
  </entry>
  <entry>
    <title>Python库-celery</title>
    <url>/2020/11/18/python-lib-celery/</url>
    <content><![CDATA[<p>作为一个分布式异步计算框架，Celery虽然常用于Web框架中，但也可以单独使用。常规搭配的消息队列是RabbitMQ、Redis。</p>
<h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tree your_project</span><br><span class="line">your_project</span><br><span class="line">├── __init__.py</span><br><span class="line">├── celery.py</span><br><span class="line">├── config.py</span><br><span class="line">└── tasks.py</span><br><span class="line"></span><br><span class="line">0 directories, 4 files</span><br></pre></td></tr></table></figure>
<p>其中<code>celery.py</code>是主文件，定义celery app，<code>config.py</code>是celery的配置，<code>tasks.py</code> 是异步任务的具体实现。</p>
<p><code>celery.py</code>文件内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from __funture__ import absolute_import</span><br><span class="line">from celery import Celery, platform</span><br><span class="line"></span><br><span class="line">platform.C_FORCE_ROOT = true</span><br><span class="line"></span><br><span class="line">app = Celery(&apos;your project name&apos;)</span><br><span class="line">app.config_from_object(config)</span><br></pre></td></tr></table></figure>
<p><code>config.py</code>文件内容可参考下一节</p>
<p><code>tasks.py</code>文件内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from __funture__ import absolute_import</span><br><span class="line"></span><br><span class="line">from .app import app</span><br><span class="line"></span><br><span class="line">@app.task</span><br><span class="line">def add(x, y):</span><br><span class="line">    return x + y</span><br><span class="line">    </span><br><span class="line">@app.task</span><br><span class="line">def sub(x, y):</span><br><span class="line">    return x - y</span><br></pre></td></tr></table></figure>
<p>运行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup /usr/local/python3.6/bin/python3.6 -m celery worker --loglevel=DEBUG --app=$&#123;PROGRAM_NAME&#125; --queues=$1 --hostname=$2 --pidfile=$3 1&gt;/dev/null 2&gt;/dev/null &amp;</span><br></pre></td></tr></table></figure>
<p>其中运行可参考后续章节。</p>
<h4 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h4><p>一次Task从触发到完成，序列图如下：</p>
<p><img src="/images/2020-11-22194305.jpg" alt="2020-11-22194305.png"></p>
<p>其中，<code>main</code>代表业务代码主进程。它可能是Django、Flask这类Web服务，也可能是一个其它类型的进程。<code>worker</code>就是指Celery的Worker。</p>
<p><code>main</code>发送消息后，会得到一个<code>AsyncResult</code>，其中包含<code>task_id</code>。仅通过<code>task_id</code>，也可以自己构造一个<code>AsyncResult</code>，查询相关信息。其中，代表运行过程的，主要是<code>state</code>。</p>
<p><code>worker</code>会持续保持对Redis（或其它消息队列，如RabbitMQ）的关注，查询新的消息。如果获得新消息，将其消费后，开始运行<code>do_sth</code>。</p>
<p>运行完成会把返回值对应的结果，以及一些运行信息，回写到Redis（或其它backend，如Django数据库等）上。在系统的任何地方，通过对应的<code>AsyncResult(task_id)</code>就可以查询到结果。</p>
<h4 id="celery-task的状态"><a href="#celery-task的状态" class="headerlink" title="celery task的状态"></a>celery task的状态</h4><p><img src="/images/2020-11-22194435.jpg" alt="2020-11-22194435.png"></p>
<p>其中，除<code>SUCCESS</code>外，还有失败（<code>FAILURE</code>）、取消（<code>REVOKED</code>）两个结束状态。而<code>RETRY</code>则是在设置了重试机制后，进入的临时等待状态。</p>
<p>另外，如果保存在Redis的结果信息被清理（默认仅保存1天），那么任务状态又会变成<code>PENDING</code>。这在设计上是个巨大的问题，使用时要做对应容错。</p>
<h4 id="celery常用配置"><a href="#celery常用配置" class="headerlink" title="celery常用配置"></a>celery常用配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 指定任务接受的内容类型(序列化)</span><br><span class="line"># pickle/json/yaml/msgpack</span><br><span class="line">CELERY_ACCEPT_CONTENT = [&apos;json&apos;]</span><br><span class="line"></span><br><span class="line"># 时区</span><br><span class="line">CELERY_TIMEZONE = &apos;Asia/Shanghai&apos;</span><br><span class="line"></span><br><span class="line"># 调度任务</span><br><span class="line">CELERY_INCLUDE = [&apos;celerys.task&apos;]</span><br><span class="line"></span><br><span class="line"># 调度器 </span><br><span class="line">CELERYBEAT_SCHEDULER = &apos;celery.beat:PersistentScheduler&apos;</span><br><span class="line"></span><br><span class="line"># 调度器存储最后运行定时任务的时间</span><br><span class="line">CELERYBEAT_SCHEDULE_FILENAME = &apos;log/celery.db&apos;</span><br><span class="line"></span><br><span class="line"># 消息代理</span><br><span class="line">BROKER_URL = LBT_CONFIG_OTHER[&apos;BROKER_URL&apos;]</span><br><span class="line"></span><br><span class="line"># 广播前缀设置，由仅活动的虚拟机接收任务消息</span><br><span class="line">BROKER_TRANSPORT_OPTIONS = &#123;&apos;fanout_prefix&apos;: True&#125;</span><br><span class="line"></span><br><span class="line"># 结果存储地址</span><br><span class="line">CELERY_RESULT_BACKEND = BROKER_URL</span><br><span class="line"></span><br><span class="line"># 任务执行结果序列化方式</span><br><span class="line">CELERY_RESULT_SERIALIZER = &apos;json&apos;</span><br><span class="line"></span><br><span class="line"># 结果是否持久化，默认关闭</span><br><span class="line">CELERY_RESULT_PERSISTENT = False</span><br><span class="line"></span><br><span class="line"># 任务过期时间，单位秒</span><br><span class="line">CELERY_TASK_RESULT_EXPIRES = 60 * 60</span><br><span class="line"></span><br><span class="line"># 任务序列化方式</span><br><span class="line">CELERY_TASK_SERIALIZER = &apos;json&apos;</span><br><span class="line"></span><br><span class="line"># 任务执行最大时间，单位秒，超过会将worker杀死</span><br><span class="line">CELERY_TASK_TIME_LIMIT = 60 * 60</span><br><span class="line"></span><br><span class="line"># 不关心任务执行结果，无需持久化结果</span><br><span class="line">CELERY_TASK_IGNORE_RESULT = True</span><br><span class="line"></span><br><span class="line"># 并发worker数量，默认为cpu核数</span><br><span class="line">CELERYD_CONCURRENCY = 6</span><br><span class="line"></span><br><span class="line"># worker被杀死前执行的最大任务数</span><br><span class="line">CELERYD_MAX_TASKS_PER_CHILD = 1024</span><br><span class="line"></span><br><span class="line"># redis最大连接数</span><br><span class="line">CELERY_REDIS_MAX_CONNECTIONS = 1024</span><br></pre></td></tr></table></figure>
<p>更多配置参数请移步<a href="https://docs.celeryproject.org/en/stable/userguide/configuration.html" target="_blank" rel="noopener">Configuration and defaults</a></p>
<h4 id="worker命令行参数"><a href="#worker命令行参数" class="headerlink" title="worker命令行参数"></a>worker命令行参数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Global Options:</span><br><span class="line">  -A APP, --app APP</span><br><span class="line">  -b BROKER, --broker BROKER</span><br><span class="line">  --result-backend RESULT_BACKEND</span><br><span class="line">  --loader LOADER</span><br><span class="line">  --config CONFIG</span><br><span class="line">  --workdir WORKDIR     Optional directory to change to after detaching.</span><br><span class="line">  --no-color, -C</span><br><span class="line">  --quiet, -q</span><br><span class="line"></span><br><span class="line">Worker Options:</span><br><span class="line">  -n HOSTNAME, --hostname HOSTNAME</span><br><span class="line">                        Set custom hostname (e.g., &apos;w1@%h&apos;). Expands: %h</span><br><span class="line">                        (hostname), %n (name) and %d, (domain).</span><br><span class="line">  -D, --detach          Start worker as a background process.</span><br><span class="line">  -S STATEDB, --statedb STATEDB</span><br><span class="line">                        Path to the state database. The extension &apos;.db&apos; may be</span><br><span class="line">                        appended to the filename. Default: None</span><br><span class="line">  -l LOGLEVEL, --loglevel LOGLEVEL</span><br><span class="line">                        Logging level, choose between DEBUG, INFO, WARNING,</span><br><span class="line">                        ERROR, CRITICAL, or FATAL.</span><br><span class="line">  -O OPTIMIZATION</span><br><span class="line">  --prefetch-multiplier PREFETCH_MULTIPLIER</span><br><span class="line">                        Set custom prefetch multiplier value for this worker</span><br><span class="line">                        instance.</span><br><span class="line"></span><br><span class="line">Pool Options:</span><br><span class="line">  -c CONCURRENCY, --concurrency CONCURRENCY</span><br><span class="line">                        Number of child processes processing the queue. The</span><br><span class="line">                        default is the number of CPUs available on your</span><br><span class="line">                        system.</span><br><span class="line">  -P POOL, --pool POOL  Pool implementation: prefork (default), eventlet,</span><br><span class="line">                        gevent, threads or solo. 注意：threads只能在4.4.0以上版本使用</span><br><span class="line">  -E, --task-events, --events</span><br><span class="line">                        Send task-related events that can be captured by</span><br><span class="line">                        monitors like celery events, celerymon, and others.</span><br><span class="line">  --time-limit TIME_LIMIT</span><br><span class="line">                        Enables a hard time limit (in seconds int/float) for</span><br><span class="line">                        tasks.</span><br><span class="line">  --soft-time-limit SOFT_TIME_LIMIT</span><br><span class="line">                        Enables a soft time limit (in seconds int/float) for</span><br><span class="line">                        tasks.</span><br><span class="line">  --max-tasks-per-child MAX_TASKS_PER_CHILD, --maxtasksperchild MAX_TASKS_PER_CHILD</span><br><span class="line">                        Maximum number of tasks a pool worker can execute</span><br><span class="line">                        before it&apos;s terminated and replaced by a new worker.</span><br><span class="line">  --max-memory-per-child MAX_MEMORY_PER_CHILD, --maxmemperchild MAX_MEMORY_PER_CHILD</span><br><span class="line">                        Maximum amount of resident memory, in KiB, that may be</span><br><span class="line">                        consumed by a child process before it will be replaced</span><br><span class="line">                        by a new one. If a single task causes a child process</span><br><span class="line">                        to exceed this limit, the task will be completed and</span><br><span class="line">                        the child process will be replaced afterwards.</span><br><span class="line">                        Default: no limit.</span><br><span class="line"></span><br><span class="line">Queue Options:</span><br><span class="line">  --purge, --discard    Purges all waiting tasks before the daemon is started.</span><br><span class="line">                        **WARNING**: This is unrecoverable, and the tasks will</span><br><span class="line">                        be deleted from the messaging server.</span><br><span class="line">  --queues QUEUES, -Q QUEUES</span><br><span class="line">                        List of queues to enable for this worker, separated by</span><br><span class="line">                        comma. By default all configured queues are enabled.</span><br><span class="line">                        Example: -Q video,image</span><br><span class="line">  --exclude-queues EXCLUDE_QUEUES, -X EXCLUDE_QUEUES</span><br><span class="line">                        List of queues to disable for this worker, separated</span><br><span class="line">                        by comma. By default all configured queues are</span><br><span class="line">                        enabled. Example: -X video,image.</span><br><span class="line">  --include INCLUDE, -I INCLUDE</span><br><span class="line">                        Comma separated list of additional modules to import.</span><br><span class="line">                        Example: -I foo.tasks,bar.tasks</span><br><span class="line"></span><br><span class="line">Features:</span><br><span class="line">  --without-gossip      Don&apos;t subscribe to other workers events.</span><br><span class="line">  --without-mingle      Don&apos;t synchronize with other workers at start-up.</span><br><span class="line">  --without-heartbeat   Don&apos;t send event heartbeats.</span><br><span class="line">  --heartbeat-interval HEARTBEAT_INTERVAL</span><br><span class="line">                        Interval in seconds at which to send worker heartbeat</span><br><span class="line">  --autoscale AUTOSCALE</span><br><span class="line">                        Enable autoscaling by providing max_concurrency,</span><br><span class="line">                        min_concurrency. Example:: --autoscale=10,3 (always</span><br><span class="line">                        keep 3 processes, but grow to 10 if necessary)</span><br><span class="line"></span><br><span class="line">Daemonization Options:</span><br><span class="line">  -f LOGFILE, --logfile LOGFILE</span><br><span class="line">                        Path to log file. If no logfile is specified, stderr</span><br><span class="line">                        is used.</span><br><span class="line">  --pidfile PIDFILE     Optional file used to store the process pid. The</span><br><span class="line">                        program won&apos;t start if this file already exists and</span><br><span class="line">                        the pid is still alive.</span><br><span class="line">  --uid UID             User id, or user name of the user to run as after</span><br><span class="line">                        detaching.</span><br><span class="line">  --gid GID             Group id, or group name of the main group to change to</span><br><span class="line">                        after detaching.</span><br><span class="line">  --umask UMASK         Effective umask(1) (in octal) of the process after</span><br><span class="line">                        detaching. Inherits the umask(1) of the parent process</span><br><span class="line">                        by default.</span><br><span class="line">  --executable EXECUTABLE</span><br><span class="line">                        Executable to use for the detached process.</span><br><span class="line"></span><br><span class="line">Embedded Beat Options:</span><br><span class="line">  -B, --beat            Also run the celery beat periodic task scheduler.</span><br><span class="line">                        Please note that there must only be one instance of</span><br><span class="line">                        this service. .. note:: -B is meant to be used for</span><br><span class="line">                        development purposes. For production environment, you</span><br><span class="line">                        need to start celery beat separately.</span><br><span class="line">  -s SCHEDULE_FILENAME, --schedule-filename SCHEDULE_FILENAME, --schedule SCHEDULE_FILENAME</span><br><span class="line">                        Path to the schedule database if running with the -B</span><br><span class="line">                        option. Defaults to celerybeat-schedule. The extension</span><br><span class="line">                        &quot;.db&quot; may be appended to the filename. Apply</span><br><span class="line">                        optimization profile. Supported: default, fair</span><br><span class="line">  --scheduler SCHEDULER</span><br><span class="line">                        Scheduler class to use. Default is</span><br><span class="line">                        celery.beat.PersistentScheduler</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python库-gevent</title>
    <url>/2020/11/29/python-lib-gevent/</url>
    <content><![CDATA[<p>Gevent是一个并发网络库。它的协程是基于greenlet的，并基于libev实现快速事件循环（Linux上是epoll，FreeBSD上是kqueue，Mac OS X上是select）。有了Gevent，协程的使用将无比简单，你根本无须像greenlet一样显式的切换，每当一个协程阻塞时，程序将自动调度，Gevent处理了所有的底层细节。让我们看个例子来感受下吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import gevent</span><br><span class="line"></span><br><span class="line">def test1():</span><br><span class="line">    print(12)</span><br><span class="line">    gevent.sleep(0)</span><br><span class="line">    print(34)</span><br><span class="line"></span><br><span class="line">def test2():</span><br><span class="line">    print(56)</span><br><span class="line">    gevent.sleep(0)</span><br><span class="line">    print(78)</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(test1),</span><br><span class="line">    gevent.spawn(test2),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>解释下，<code>gevent.spawn()</code>方法会创建一个新的greenlet协程对象，并运行它。<code>gevent.joinall()</code>方法会等待所有传入的greenlet协程运行结束后再退出，这个方法可以接受一个<code>timeout</code>参数来设置超时时间，单位是秒。运行上面的程序，执行顺序如下： </p>
<ol>
<li>先进入协程test1，打印12</li>
<li>遇到<code>gevent.sleep(0)</code>时，test1被阻塞，自动切换到协程test2，打印56</li>
<li>之后test2被阻塞，这时test1阻塞已结束，自动切换回test1，打印34</li>
<li>当test1运行完毕返回后，此时test2阻塞已结束，再自动切换回test2，打印78</li>
<li>所有协程执行完毕，程序退出</li>
</ol>
<p>所以，程序运行下来的输出就是： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">12</span><br><span class="line">56</span><br><span class="line">34</span><br><span class="line">78</span><br></pre></td></tr></table></figure>
<p>我们换一个更有意义的例子： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">urls = [<span class="string">'www.baidu.com'</span>, <span class="string">'www.gevent.org'</span>, <span class="string">'www.python.org'</span>]</span><br><span class="line">jobs = [gevent.spawn(socket.gethostbyname, url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">gevent.joinall(jobs, timeout=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print([job.value <span class="keyword">for</span> job <span class="keyword">in</span> jobs])</span><br></pre></td></tr></table></figure>
<p>我们通过协程分别获取三个网站的IP地址，由于打开远程地址会引起IO阻塞，所以gevent会自动调度不同的协程。另外，我们可以通过协程对象的”value”属性，来获取协程函数的返回值。 </p>
<h4 id="猴子补丁-Monkey-patching"><a href="#猴子补丁-Monkey-patching" class="headerlink" title="猴子补丁 Monkey patching"></a>猴子补丁 Monkey patching</h4><p>其实程序运行的时间同不用协程是一样的，是三个网站打开时间的总和。可是理论上协程是非阻塞的，那运行时间应该等于最长的那个网站打开时间呀？其实这是因为Python标准库里的socket是阻塞式的，DNS解析无法并发，包括像urllib库也一样，所以这种情况下用协程完全没意义。那怎么办？</p>
<p>一种方法是使用gevent下的socket模块，我们可以通过<code>from gevent import socket</code>来导入。不过更常用的方法是使用猴子布丁（Monkey patching）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from gevent import monkey; monkey.patch_socket()</span><br><span class="line">import gevent</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line">urls = [&apos;www.baidu.com&apos;, &apos;www.gevent.org&apos;, &apos;www.python.org&apos;]</span><br><span class="line">jobs = [gevent.spawn(socket.gethostbyname, url) for url in urls]</span><br><span class="line">gevent.joinall(jobs, timeout=5)</span><br><span class="line"></span><br><span class="line">print([job.value for job in jobs])</span><br></pre></td></tr></table></figure>
<p>上述代码的第一行就是对socket标准库打上猴子补丁，此后socket标准库中的类和方法都会被替换成非阻塞式的，所有其他的代码都不用修改，这样协程的效率就真正体现出来了。Python中其它标准库也存在阻塞的情况，gevent提供了<code>monkey.patch_all()</code>方法将所有标准库都替换。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from gevent import monkey; monkey.patch_all()</span><br></pre></td></tr></table></figure>
<p> 使用猴子补丁褒贬不一，但是官网上还是建议使用<code>patch_all()</code>，而且在程序的第一行就执行 。</p>
<h4 id="获取协程状态"><a href="#获取协程状态" class="headerlink" title="获取协程状态"></a>获取协程状态</h4><p>协程状态有已启动和已停止，分别可以用协程对象的<code>started</code>属性和<code>ready()</code>方法来判断。对于已停止的协程，可以用<code>successful()</code>方法来判断其是否成功运行且没抛异常。如果协程执行完有返回值，可以通过<code>value</code>属性来获取。另外，greenlet协程运行过程中发生的异常是不会被抛出到协程外的，因此需要用协程对象的<code>exception</code>属性来获取协程中的异常。下面的例子很好的演示了各种方法和属性的使用。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">win</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'You win!'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fail</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">'You failed!'</span>)</span><br><span class="line"></span><br><span class="line">winner = gevent.spawn(win)</span><br><span class="line">loser = gevent.spawn(fail)</span><br><span class="line"></span><br><span class="line">print(winner.started) <span class="comment"># True</span></span><br><span class="line">print(loser.started)  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在Greenlet中发生的异常，不会被抛到Greenlet外面。</span></span><br><span class="line"><span class="comment"># 控制台会打出Stacktrace，但程序不会停止</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    gevent.joinall([winner, loser])</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 这段永远不会被执行</span></span><br><span class="line">    print(<span class="string">'This will never be reached'</span>)</span><br><span class="line"></span><br><span class="line">print(winner.ready()) <span class="comment"># True</span></span><br><span class="line">print(loser.ready())  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">print(winner.value) <span class="comment"># 'You win!'</span></span><br><span class="line">print(loser.value)  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line">print(winner.successful()) <span class="comment"># True</span></span><br><span class="line">print(loser.successful())  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里可以通过raise loser.exception 或 loser.get()</span></span><br><span class="line"><span class="comment"># 来将协程中的异常抛出</span></span><br><span class="line">print(loser.exception)</span><br></pre></td></tr></table></figure>
<h4 id="协程运行超时"><a href="#协程运行超时" class="headerlink" title="协程运行超时"></a>协程运行超时</h4><p>之前我们讲过在<code>gevent.joinall()</code>方法中可以传入<code>timeout</code>参数来设置超时，我们也可以在全局范围内设置超时时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> Timeout</span><br><span class="line"></span><br><span class="line">timeout = Timeout(<span class="number">2</span>)  <span class="comment"># 2 seconds</span></span><br><span class="line">timeout.start()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">()</span>:</span></span><br><span class="line">    gevent.sleep(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    gevent.spawn(wait).join()</span><br><span class="line"><span class="keyword">except</span> Timeout:</span><br><span class="line">    traceback.print_exc()</span><br><span class="line">    print(<span class="string">'Could not complete'</span>)</span><br></pre></td></tr></table></figure>
<p>上例中，我们将超时设为2秒，此后所有协程的运行，如果超过两秒就会抛出<code>Timeout</code>异常。我们也可以将超时设置在with语句内，这样该设置只在with语句块中有效：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> Timeout(<span class="number">1</span>):</span><br><span class="line">    gevent.sleep(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>此外，我们可以指定超时所抛出的异常，来替换默认的<code>Timeout</code>异常。比如下例中超时就会抛出我们自定义的<code>TooLong</code>异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TooLong</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Timeout(<span class="number">1</span>, TooLong):</span><br><span class="line">    gevent.sleep(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<h4 id="协程间通讯"><a href="#协程间通讯" class="headerlink" title="协程间通讯"></a>协程间通讯</h4><p>greenlet协程间的异步通讯可以使用事件（Event）对象。该对象的<code>wait()</code>方法可以阻塞当前协程，而<code>set()</code>方法可以唤醒之前阻塞的协程。在下面的例子中，5个waiter协程都会等待事件evt，当setter协程在3秒后设置evt事件，所有的waiter协程即被唤醒。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent.event <span class="keyword">import</span> Event</span><br><span class="line"></span><br><span class="line">evt = Event()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setter</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Wait for me'</span>)</span><br><span class="line">    gevent.sleep(<span class="number">3</span>)  <span class="comment"># 3秒后唤醒所有在evt上等待的协程</span></span><br><span class="line">    print(<span class="string">"Ok, I'm done"</span>)</span><br><span class="line">    evt.set()  <span class="comment"># 唤醒</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">waiter</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I'll wait for you"</span>)</span><br><span class="line">    evt.wait()  <span class="comment"># 等待</span></span><br><span class="line">    print(<span class="string">'Finish waiting'</span>)</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(setter),</span><br><span class="line">    gevent.spawn(waiter),</span><br><span class="line">    gevent.spawn(waiter),</span><br><span class="line">    gevent.spawn(waiter),</span><br><span class="line">    gevent.spawn(waiter),</span><br><span class="line">    gevent.spawn(waiter)</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>除了Event事件外，gevent还提供了<code>AsyncResult</code>事件，它可以在唤醒时传递消息。让我们将上例中的<code>setter</code>和<code>waiter</code>作如下改动:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent.event <span class="keyword">import</span> AsyncResult</span><br><span class="line"></span><br><span class="line">aevt = AsyncResult()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setter</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Wait for me'</span>)</span><br><span class="line">    gevent.sleep(<span class="number">3</span>)  <span class="comment"># 3秒后唤醒所有在evt上等待的协程</span></span><br><span class="line">    print(<span class="string">"Ok, I'm done"</span>)</span><br><span class="line">    aevt.set(<span class="string">'Hello!'</span>)  <span class="comment"># 唤醒，并传递消息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">waiter</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I'll wait for you"</span>)</span><br><span class="line">    message = aevt.get()  <span class="comment"># 等待，并在唤醒时获取消息</span></span><br><span class="line">    print(<span class="string">'Got wake up message: %s'</span> % message)</span><br></pre></td></tr></table></figure>
<h4 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 Queue</h4><p>队列Queue的概念相信大家都知道，我们可以用它的<code>put</code>和<code>get</code>方法来存取队列中的元素。gevent的队列对象可以让greenlet协程之间安全的访问。运行下面的程序，你会看到3个消费者会分别消费队列中的产品，且消费过的产品不会被另一个消费者再取到：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent.queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line">products = Queue()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> products.empty():</span><br><span class="line">        print(<span class="string">'%s got product %s'</span> % (name, products.get()))</span><br><span class="line">        gevent.sleep(<span class="number">0</span>)</span><br><span class="line">    print(<span class="string">'%s Quit'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        products.put(i)</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(producer),</span><br><span class="line">    gevent.spawn(consumer, <span class="string">'steve'</span>),</span><br><span class="line">    gevent.spawn(consumer, <span class="string">'john'</span>),</span><br><span class="line">    gevent.spawn(consumer, <span class="string">'nancy'</span>),</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p><code>put</code>和<code>get</code>方法都是阻塞式的，它们都有非阻塞的版本：<code>put_nowait</code>和<code>get_nowait</code>。如果调用<code>get</code>方法时队列为空，则抛出<code>gevent.queue.Empty</code>异常。</p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>信号量可以用来限制协程并发的个数。它有两个方法，<code>acquire</code>和<code>release</code>。顾名思义，<code>acquire</code>就是获取信号量，而<code>release</code>就是释放。当所有信号量都已被获取，那剩余的协程就只能等待任一协程释放信号量后才能得以运行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent.coros <span class="keyword">import</span> BoundedSemaphore</span><br><span class="line"></span><br><span class="line">sem = BoundedSemaphore(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(n)</span>:</span></span><br><span class="line">    sem.acquire()</span><br><span class="line">    print(<span class="string">'Worker %i acquired semaphore'</span> % n)</span><br><span class="line">    gevent.sleep(<span class="number">0</span>)</span><br><span class="line">    sem.release()</span><br><span class="line">    print(<span class="string">'Worker %i released semaphore'</span> % n)</span><br><span class="line"></span><br><span class="line">gevent.joinall([gevent.spawn(worker, i) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, <span class="number">6</span>)])</span><br></pre></td></tr></table></figure>
<p>上面的例子中，我们初始化了<code>BoundedSemaphore</code>信号量，并将其个数定为<code>2</code>。所以同一个时间，只能有两个worker协程被调度。程序运行后的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Worker 0 acquired semaphore</span><br><span class="line">Worker 1 acquired semaphore</span><br><span class="line">Worker 0 released semaphore</span><br><span class="line">Worker 1 released semaphore</span><br><span class="line">Worker 2 acquired semaphore</span><br><span class="line">Worker 3 acquired semaphore</span><br><span class="line">Worker 2 released semaphore</span><br><span class="line">Worker 3 released semaphore</span><br><span class="line">Worker 4 acquired semaphore</span><br><span class="line">Worker 4 released semaphore</span><br><span class="line">Worker 5 acquired semaphore</span><br><span class="line">Worker 5 released semaphore</span><br></pre></td></tr></table></figure>
<p>如果信号量个数为1，那就等同于同步锁。</p>
<h4 id="协程本地变量"><a href="#协程本地变量" class="headerlink" title="协程本地变量"></a>协程本地变量</h4><p>同线程类似，协程也有本地变量，也就是只在当前协程内可被访问的变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent.local <span class="keyword">import</span> local</span><br><span class="line"></span><br><span class="line">data = local()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    data.x = <span class="number">1</span></span><br><span class="line">    print(data.x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(data.x)</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        print(<span class="string">'x is not visible'</span>)</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(f1),</span><br><span class="line">    gevent.spawn(f2)</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>通过将变量存放在<code>local</code>对象中，即可将其的作用域限制在当前协程内，当其他协程要访问该变量时，就会抛出异常。不同协程间可以有重名的本地变量，而且互相不影响。因为协程本地变量的实现，就是将其存放在以的<code>greenlet.getcurrent()</code>的返回为键值的私有的命名空间内。</p>
<p>Read More:</p>
<blockquote>
<p><a href="http://www.bjhee.com/gevent.html" target="_blank" rel="noopener">基于协程的Python网络库gevent介绍</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>新浪2014校园招聘 PHP 开发工程师</title>
    <url>/2017/04/09/sina2014php/</url>
    <content><![CDATA[<h4 id="PHP中的"><a href="#PHP中的" class="headerlink" title="PHP中的%"></a>PHP中的%</h4><p>在PHP中，正数%正数为正数，正数%负数为正数，负数%正数为负数，Example：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 24 % 5;	// 输出 4</span><br><span class="line">echo 24 % (-5);	// 输出 4</span><br><span class="line">echo -24 % 5;	// 输出 -4</span><br></pre></td></tr></table></figure>
<h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><p>在PHP5中，如果需要类 C 的实例销毁时自动完成默写逻辑，<strong>定义析构函数_­­__destruct</strong></p>
<h4 id="shell命令"><a href="#shell命令" class="headerlink" title="shell命令"></a>shell命令</h4><p><strong>top</strong>：用于实时显示进程的动态。</p>
<p><strong>ps</strong>：用于显示当前进程的状态。</p>
<p><strong>mv</strong>：用来为文件或目录改名、或将文件或目录移入其它位置。</p>
<p><strong>find</strong>：用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p>
<p><strong>df</strong>：用于显示目前在Linux系统上的文件系统的磁盘使用情况统计。</p>
<p><strong>cat</strong>：用于连接文件并打印到标准输出设备上。</p>
<p><strong>chmod</strong>：Linux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以控制文件如何被他人所调用。其实就是修改读写文件权限。</p>
<p><strong>chgrp</strong>：用于变更文件或目录的所属群组。</p>
<p><strong>grep</strong>：用于查找文件里符合条件的字符串。</p>
<p><strong>wc</strong>：用于计算字数。利用 wc 指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为”-“，则 wc 指令会从标准输入设备读取数据。</p>
<h4 id="文本传输协议"><a href="#文本传输协议" class="headerlink" title="文本传输协议"></a>文本传输协议</h4><p>FTP：文本传输协议。用于 Internet 上的控制文件的双向传输。TCP/IP 协议中，FTP 标准命令 TCP 端口号为21，Port 方式数据端口为20。FTP 的任务是从一台计算机将文件传送到另一台计算机，不受操作系统的限制。</p>
<p>SSH：安全外壳协议。专为远程登录会话和其他网络服务提供安全性的协议，利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。有基于口令的安全验证和基于秘钥的安全验证两种方式。默认运行端口是22。</p>
<p>HTTP：超文本传输协议。是客户端和服务器端请求和应答的标准。默认端口是80。</p>
<p>Telnet：是Internet远程登陆服务的标准协议和主要方式。为用户提供了在本地计算机上完成远程主机工作的能力，Telnet是常用的远程控制Web服务器的方法，默认端口是23。</p>
<p>HTTPS：以安全为目标的HTTP通道，简单讲是HTTP的安全版。HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。默认端口是443。</p>
<h4 id="http与https的区别"><a href="#http与https的区别" class="headerlink" title="http与https的区别"></a>http与https的区别</h4><p>超文本传输协议 HTTP 协议被用于在 Web 浏览器和网站服务器之间传递信息。HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此 HTTP 协议不适合传输一些敏感信息，比如信用卡号、密码等。</p>
<p>为了解决 HTTP 协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS。为了数据传输的安全， HTTPS 在 HTTP 的基础上加入了 SSL 协议，SSL 依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p>
<p>HTTPS和HTTP的区别主要为以下四点：</p>
<ol>
<li>https 协议需要到 ca 申请证书，一般免费证书很少，需要交费。</li>
<li>http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 SSL 加密传输协议。</li>
<li>http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比http 协议安全。</li>
</ol>
<h4 id="SSH与Telnet的区别"><a href="#SSH与Telnet的区别" class="headerlink" title="SSH与Telnet的区别"></a>SSH与Telnet的区别</h4><ol>
<li>Telnet 是明文传送，SSH是加密的且支持压缩；</li>
<li>SSH 服务一般都提供 sftp 支持，支持文件传送。telnet一般只能通过zmodem等协议传送文件;</li>
<li>SSH 还可以借助 SSH 连接建立 TCP 通道，映射远端或本地的端口，以及转发X到本地X Server等；</li>
<li>在使用SSH 的时候，一个数字证书将认证客户端(你的工作站)和服务器(你的网络设备)之间的连接，并加密受保护的口令。SSH1 使用 RSA 加密密钥，SSH2 使用数字签名算法(DSA)密钥保护连接和认证。加密算法包括Blowfish，数据加密标准(DES)，以及三重 DES(3DES)。SSH 保护并且有助于防止欺骗，“中间人”攻击，以及数据包监听。</li>
</ol>
<h4 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h4><p>设计模式考察：请用单态设计模式方法设计类满足如下要求：请用PHP5代码编写类实现在每次对数据库连接的访问中都只能获取唯一的一个数据库连接，具体拦截数据库的详细代码忽略，请写出主要逻辑代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Database&#123;</span><br><span class="line">    static public $_instance;</span><br><span class="line">    private function __construct()&#123;</span><br><span class="line">        // 连接数据库</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static function getInstance()&#123;</span><br><span class="line">        if (!self::$_instance) self::$_instance = new self();</span><br><span class="line">        return self::$_instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private function __clone() &#123;</span><br><span class="line">        // 私有化clone方法</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function query($sql) &#123;</span><br><span class="line">        // 查询</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Session和Cookie的区别"><a href="#Session和Cookie的区别" class="headerlink" title="Session和Cookie的区别"></a>Session和Cookie的区别</h4><ol>
<li>Cookie 数据存放在客户的浏览器上，需要客户端支持Cookie，Session 数据放在服务器上;</li>
<li>Cookie 不是很安全，别人可以分析存放在本地的 Cookie 并进行 Cookie 欺骗，考虑到安全应当使用session；</li>
<li>Session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用 Cookie ；</li>
<li>单个 Cookie 保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个Cookie；</li>
<li>Session 中存储的是对象引用，Cookie 中存放的是字符串；</li>
<li>Session  不能区分路径，同一个用户在访问一个网站期间，所有的Session 在任何一个地方都可以访问到。而Cookie 中如果设置了路径参数，那么同一个网站中不同路径下的Cookie 互相是访问不到的。</li>
</ol>
<h4 id="include和require的区别"><a href="#include和require的区别" class="headerlink" title="include和require的区别"></a>include和require的区别</h4><ol>
<li>include() 在执行文件时每次都要进行读取和评估；require() 文件只处理一次(实际上文件内容替换了require()语句)；</li>
<li>require() 通常放在 PHP 脚本程序的最前面 include() 的使用和 require() 不一样，一般放在流程控制的处理区段中，PHP脚本文件读到 include() 语句时，才将它包含的文件读进来，这种方式,可以把程序执行时的流程简单化；</li>
<li>require() 和 include() 语句是语言结构，不是真正的函数，可以像PHP的其他语言结构一样；</li>
<li>require() 包含文件失败，停止执行，给出错误(致命的)；</li>
<li>include() 常用于动态包含，通常是自动加载的文件，即使加载出错,整个程序还是继续执行一个页面声明，另一个页面调用包函文件失败，继续向下执行，返回一条警告；</li>
<li>include_once() 和 require_once() 语句也是在脚本执行期间包括并运行指定文件，与 include() require() 唯一的区别是如果文件中的代码已经被包括了，则不会再次包括。</li>
</ol>
<h4 id="PHP处理上传文件的流程"><a href="#PHP处理上传文件的流程" class="headerlink" title="PHP处理上传文件的流程"></a>PHP处理上传文件的流程</h4><p><strong>流程</strong></p>
<p>首先用户在浏览器端选择上传的文件；<br>提交后，通过post方式上传到Apache服务器；<br>然后由 PHP 引擎处理判断文件是否能够上传到 PHP 配置文件中指定的临时目录；<br>之后获取文件后缀名判断文件是否是允许上传的文件格式；<br>如果没问题，则按照随机数+时间的方式生成文件的名字+后缀；<br>最后将文件从临时目录转移至Apache服务器目录。</p>
<p><strong>限制上传文件大小</strong></p>
<p>在 PHP 配置文件中 有一个 upload_max_filesize 设置其值的大小就可以限制上传文件大小；</p>
<p>在处理上传的 PHP 代码中限制，$_FILES[‘name’][‘size’]。</p>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP1.0、HTTP1.1、HTTP2.0的区别</title>
    <url>/2020/10/25/tcpdiff/</url>
    <content><![CDATA[<h3 id="HTTP发展史"><a href="#HTTP发展史" class="headerlink" title="HTTP发展史"></a>HTTP发展史</h3><p><img src="/images/2020-10-25T150500.png" alt="2020-10-25T150500.png"></p>
<h3 id="HTTP的优化"><a href="#HTTP的优化" class="headerlink" title="HTTP的优化"></a>HTTP的优化</h3><p>影响一个HTTP网络请求的因素主要有两个：带宽和延迟。</p>
<p><strong>带宽</strong></p>
<p>现在的网络基础建设已使得带宽得到极大的提升，在影响网速的因素中，带宽所占比重越来越少。</p>
<p><strong>延迟</strong></p>
<p>浏览器阻塞：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。</p>
<p>DNS 解析：浏览器需要知道目标服务器的 IP 才能建立连接。此过程为DNS解析，可参考<a href="https://runnerliu.github.io/2017/06/22/urlrequestprocess/">从输入 URL 到页面展示到底发生了什么</a>，这个通常可以利用DNS缓存结果来达到减少这个时间的目的。</p>
<p>建立连接：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能携带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</p>
<h3 id="HTTP1-0、HTTP1-1"><a href="#HTTP1-0、HTTP1-1" class="headerlink" title="HTTP1.0、HTTP1.1"></a>HTTP1.0、HTTP1.1</h3><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别体现在：</p>
<p><strong>缓存处理</strong></p>
<p>在HTTP1.0中主要使用header里的If-Modified-Since、Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag、If-Unmodified-Since、If-Match、If-None-Match等更多可供选择的缓存头来控制缓存策略。</p>
<p><strong>带宽优化及网络连接</strong></p>
<p>HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p>
<p><strong>错误通知的管理</strong></p>
<p>在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突、410（Gone）表示服务器上的某个资源被永久性的删除。</p>
<p><strong>Host头处理</strong></p>
<p>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p>
<p><strong>长连接</strong></p>
<p>HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection: keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p>
<h3 id="HTTPS、HTTP的区别"><a href="#HTTPS、HTTP的区别" class="headerlink" title="HTTPS、HTTP的区别"></a>HTTPS、HTTP的区别</h3><ul>
<li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费</li>
<li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的</li>
<li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443</li>
<li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题</li>
</ul>
<p><img src="/images/2020-10-25T152300.png" alt="2020-10-25T152300.png"></p>
<h3 id="说说SPDY"><a href="#说说SPDY" class="headerlink" title="说说SPDY"></a>说说SPDY</h3><p>其实 SPDY 并不是新的一种协议，而是在 HTTP 之前做了一层会话层。</p>
<p><img src="/images/2020-10-25T152800.png" alt="2020-10-25T152800.png"></p>
<p>SPDY是一个由 Google 主导的研究项目发明的HTTP替代协议。SPDY位于HTTP之下、TCP/SSL之上，这样可以轻松兼容老版本的HTTP协议，同时可以使用已有的SSL功能。SPDY优化了HTTP1.X的请求延迟，解决了HTTP1.X的安全性，具体如下：</p>
<p><strong>降低延迟</strong></p>
<p>针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。</p>
<p><strong>请求优先级</strong></p>
<p>多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。</p>
<p><strong>header压缩</strong></p>
<p>前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</p>
<p><strong>传输协议</strong></p>
<p>基于HTTPS的加密协议传输，大大提高了传输数据的可靠性。</p>
<p><strong>服务端推送</strong></p>
<p>采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。</p>
<h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><p>HTTP2.0是基于SPDY设计的，但与SPDY 仍有不同的地方，如下：</p>
<ul>
<li>HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</li>
<li>HTTP2.0 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE</li>
</ul>
<h4 id="HTTP2-0的新特性"><a href="#HTTP2-0的新特性" class="headerlink" title="HTTP2.0的新特性"></a>HTTP2.0的新特性</h4><h5 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h5><p>HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</p>
<p><img src="/images/2020-10-25T154700.png" alt="2020-10-25T154700.png"></p>
<p>在应用层与传输层之间增加一个二进制分帧层，以此达到在不改动 HTTP 的语义，HTTP 方法、状态码、URI 及首部字段的情况下，突破HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。在二进制分帧层上，HTTP2.0 会将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，其中 HTTP1.x 的首部信息会被封装到 Headers 帧，而我们的 request body 则封装到 Data 帧里面。</p>
<h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><p>即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</p>
<p><img src="/images/2020-10-25T154800.png" alt="2020-10-25T154800.png"></p>
<h5 id="header压缩"><a href="#header压缩" class="headerlink" title="header压缩"></a>header压缩</h5><p>如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p>
<p><img src="/images/2020-10-25T154900.png" alt="2020-10-25T154900.png"></p>
<h5 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h5><p>同SPDY一样，HTTP2.0也具有server push功能。</p>
<p>客户端请求的过程：</p>
<p><img src="/images/2020-10-25T155200.png" alt="2020-10-25T155200.png"></p>
<p>服务端推送的过程：</p>
<p><img src="/images/2020-10-25T155300.png" alt="2020-10-25T155300.png"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>HTTP1.0到HTTP1.1，是无连接到长连接的发展</p>
</li>
<li><p>HTTP1.x到HTTP2.0，是二进制分帧、多路复用的发展</p>
</li>
</ul>
<p>Read More:</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/be29d679cbff" target="_blank" rel="noopener">HTTP1.0、HTTP1.1和HTTP2.0的区别</a></p>
<p><a href="https://juejin.im/post/6844903824390537230" target="_blank" rel="noopener">HTTP1.0，HTTP1.1，HTTPS和HTTP2.0的区别</a></p>
<p><a href="https://juejin.im/post/6844903712113360903" target="_blank" rel="noopener">HTTP 的前世今生：一次性搞懂 HTTP、HTTPS、SPDY、HTTP2</a></p>
<p><a href="https://zh.wikipedia.org/wiki/HTTP/2" target="_blank" rel="noopener">HTTP/2</a></p>
</blockquote>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Tornado5.0.2翻译文档 - 协程</title>
    <url>/2018/06/18/tornado502-coroutines/</url>
    <content><![CDATA[<p>Tornado中推荐使用 <strong>协程</strong> 编写异步代码，协程使用了Python的 <code>yield</code> 关键字代替链式回调来将程序挂起和恢复执行(像在 <a href="http://www.gevent.org/" target="_blank" rel="noopener">gevent</a> 中出现的轻量级线程合作方式有时也被称为协程，但是在Tornado中所有的协程使用明确的上下文切换，并被称为异步函数)。</p>
<p>使用协程几乎像写同步代码一样简单，并且不需要浪费额外的线程。它们还通过减少上下文切换来 <a href="https://glyph.twistedmatrix.com/2014/02/unyielding.html" target="_blank" rel="noopener">使并发编程更简单</a> 。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from tornado import gen</span><br><span class="line"></span><br><span class="line">@gen.coroutine</span><br><span class="line">def fetch_coroutine(url):</span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    response = yield http_client.fetch(url)</span><br><span class="line">    # In Python versions prior to 3.3, returning a value from</span><br><span class="line">    # a generator is not allowed and you must use</span><br><span class="line">    #   raise gen.Return(response.body)</span><br><span class="line">    # instead.</span><br><span class="line">    return response.body</span><br></pre></td></tr></table></figure>
<h3 id="Python-3-5-async-和-await"><a href="#Python-3-5-async-和-await" class="headerlink" title="Python 3.5: async 和 await"></a>Python 3.5: <code>async</code> 和 <code>await</code></h3><p>Python 3.5 引入了 <code>async</code> 和 <code>await</code> 关键字(使用这些关键字的函数也被称为”原生协程”)。从Tornado 4.3，你可以用它们代替 <code>yield</code> 为基础的协程。只需要简单的使用 <code>async def foo()</code> 在函数定义的时候代替 <a href="mailto:`@gen.coroutine" target="_blank" rel="noopener">`@gen.coroutine</a><code>装饰器，用</code>await<code>代替 yield。本文档的其他部分会继续使用</code>yield<code>的风格来和旧版本的Python兼容，但是如果</code>async<code>和</code>await` 可用的话，它们运行起来会更快：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async def fetch_coroutine(url):</span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    response = await http_client.fetch(url)</span><br><span class="line">    return response.body</span><br></pre></td></tr></table></figure>
<p><code>await</code> 关键字比 <code>yield</code> 关键字功能要少一些。例如，在一个使用 <code>yield</code> 的协程中，你可以得到 <code>Futures</code> 列表，但是在原生协程中，你必须把列表用 <a href="http://tornado-zh.readthedocs.io/zh/latest/gen.html#tornado.gen.multi" target="_blank" rel="noopener"><code>tornado.gen.multi</code></a> 包起来。同时也去掉了与 <a href="https://docs.python.org/3.6/library/concurrent.futures.html#module-concurrent.futures" target="_blank" rel="noopener"><code>concurrent.futures</code></a> 的集成。你也可以使用 <a href="http://tornado-zh.readthedocs.io/zh/latest/gen.html#tornado.gen.convert_yielded" target="_blank" rel="noopener"><code>tornado.gen.convert_yielded</code></a> 来把任何使用 <code>yield</code> 工作的代码转换成使用 <code>await</code> 的形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async def f():</span><br><span class="line">    executor = concurrent.futures.ThreadPoolExecutor()</span><br><span class="line">    await tornado.gen.convert_yielded(executor.submit(g))</span><br></pre></td></tr></table></figure>
<h3 id="它如何工作"><a href="#它如何工作" class="headerlink" title="它如何工作"></a>它如何工作</h3><p>包含了 <code>yield</code> 关键字的函数是一个 <strong>生成器(generator)</strong> 。所有的生成器都是异步的；当调用它们的时候，会返回一个生成器对象，而不是一个执行完的结果。 <a href="mailto:`@gen.coroutine" target="_blank" rel="noopener">`@gen.coroutine</a><code>装饰器通过</code>yield<code>表达式和生成器进行交流，而且通过返回一个 [</code>Future`](<a href="http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future" target="_blank" rel="noopener">http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future</a>) 与协程的调用方进行交互。</p>
<p>下面是一个协程装饰器内部循环的简单版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Simplified inner loop of tornado.gen.Runner</span><br><span class="line">def run(self):</span><br><span class="line">    # send(x) makes the current yield return x.</span><br><span class="line">    # It returns when the next yield is reached</span><br><span class="line">    future = self.gen.send(self.next)</span><br><span class="line">    def callback(f):</span><br><span class="line">        self.next = f.result()</span><br><span class="line">        self.run()</span><br><span class="line">    future.add_done_callback(callback)</span><br></pre></td></tr></table></figure>
<p>装饰器从生成器接收一个 <a href="http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future" target="_blank" rel="noopener"><code>Future</code></a> 对象，等待(非阻塞的)这个 <a href="http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future" target="_blank" rel="noopener"><code>Future</code></a> 对象执行完成，然后“解开(unwraps)” 这个 <a href="http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future" target="_blank" rel="noopener"><code>Future</code></a> 对象，并把结果作为 <code>yield</code> 表达式的结果传回给生成器。大多数异步代码从来不会直接接触 <a href="http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future" target="_blank" rel="noopener"><code>Future</code></a> 类 除非 <a href="http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future" target="_blank" rel="noopener"><code>Future</code></a> 立即通过异步函数返回给 <code>yield</code> 表达式。</p>
<h3 id="如何调用协程"><a href="#如何调用协程" class="headerlink" title="如何调用协程"></a>如何调用协程</h3><p>协程一般不会抛出异常：它们抛出的任何异常将被 <a href="http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future" target="_blank" rel="noopener"><code>Future</code></a> 捕获直到它被得到，这意味着用正确的方式调用协程是重要的，否则你可能有被忽略的错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@gen.coroutine</span><br><span class="line">def divide(x, y):</span><br><span class="line">    return x / y</span><br><span class="line"></span><br><span class="line">def bad_call():</span><br><span class="line">    # This should raise a ZeroDivisionError, but it won&apos;t because</span><br><span class="line">    # the coroutine is called incorrectly.</span><br><span class="line">    divide(1, 0)</span><br></pre></td></tr></table></figure>
<p>几乎所有的情况下，任何一个调用协程的函数都必须是协程它自身，并且在调用的时候使用 <code>yield</code> 关键字。当你重写超类中的方法，请参阅文档，看看协程是否支持(文档应该会写该方法 “可能是一个协程” 或者 “可能返回 一个 <a href="http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future" target="_blank" rel="noopener"><code>Future</code></a> ”)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@gen.coroutine</span><br><span class="line">def good_call():</span><br><span class="line">    # yield will unwrap the Future returned by divide() and raise</span><br><span class="line">    # the exception.</span><br><span class="line">    yield divide(1, 0)</span><br></pre></td></tr></table></figure>
<p>有时你可能想要对一个协程”一劳永逸”而且不等待它的结果。在这种情况下，建议使用 <a href="http://tornado-zh.readthedocs.io/zh/latest/ioloop.html#tornado.ioloop.IOLoop.spawn_callback" target="_blank" rel="noopener"><code>IOLoop.spawn_callback</code></a> ，它使得 <a href="http://tornado-zh.readthedocs.io/zh/latest/ioloop.html#tornado.ioloop.IOLoop" target="_blank" rel="noopener"><code>IOLoop</code></a> 负责调用。如果它失败了， <a href="http://tornado-zh.readthedocs.io/zh/latest/ioloop.html#tornado.ioloop.IOLoop" target="_blank" rel="noopener"><code>IOLoop</code></a> 会在日志中把调用栈记录下来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># The IOLoop will catch the exception and print a stack trace in</span><br><span class="line"># the logs. Note that this doesn&apos;t look like a normal call, since</span><br><span class="line"># we pass the function object to be called by the IOLoop.</span><br><span class="line">IOLoop.current().spawn_callback(divide, 1, 0)</span><br></pre></td></tr></table></figure>
<p>如果函数使用了 <a href="mailto:`@gen.coroutine" target="_blank" rel="noopener">`@gen.coroutine</a><code>，则推荐以上方式使用 [</code>IOLoop.spawn_callback<code>](http://www.tornadoweb.org/en/stable/ioloop.html#tornado.ioloop.IOLoop.spawn_callback) ，但如果函数使用</code>async def` ，则必须使用以上方式(否则协程不会运行)。</p>
<p>最后，在程序顶层，如果 IOLoop 尚未运行，你可以启动 <a href="http://tornado-zh.readthedocs.io/zh/latest/ioloop.html#tornado.ioloop.IOLoop" target="_blank" rel="noopener"><code>IOLoop</code></a> 执行协程，然后使用 <a href="http://tornado-zh.readthedocs.io/zh/latest/ioloop.html#tornado.ioloop.IOLoop.run_sync" target="_blank" rel="noopener"><code>IOLoop.run_sync</code></a> 方法停止 <a href="http://tornado-zh.readthedocs.io/zh/latest/ioloop.html#tornado.ioloop.IOLoop" target="_blank" rel="noopener"><code>IOLoop</code></a> 。这通常被用来启动面向批处理程序的 <code>main</code> 函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># run_sync() doesn&apos;t take arguments, so we must wrap the</span><br><span class="line"># call in a lambda.</span><br><span class="line">IOLoop.current().run_sync(lambda: divide(1, 0))</span><br></pre></td></tr></table></figure>
<h3 id="协程模式"><a href="#协程模式" class="headerlink" title="协程模式"></a>协程模式</h3><h4 id="调用阻塞函数"><a href="#调用阻塞函数" class="headerlink" title="调用阻塞函数"></a>调用阻塞函数</h4><p>从一个协程调用阻塞函数最简单的方式是使用 <code>IOLoop.run_in_executor</code> ，它将返回和协程兼容的<code>Futures</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@gen.coroutine</span><br><span class="line">def call_blocking():</span><br><span class="line">    yield IOLoop.current().run_in_executor(blocking_func, args)</span><br></pre></td></tr></table></figure>
<h4 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h4><p>协程装饰器能识别列表或者字典对象中各自的 <code>Futures</code> ，并且并行的等待这些 <code>Futures</code> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@gen.coroutine</span><br><span class="line">def parallel_fetch(url1, url2):</span><br><span class="line">    resp1, resp2 = yield [http_client.fetch(url1),</span><br><span class="line">                          http_client.fetch(url2)]</span><br><span class="line"></span><br><span class="line">@gen.coroutine</span><br><span class="line">def parallel_fetch_many(urls):</span><br><span class="line">    responses = yield [http_client.fetch(url) for url in urls]</span><br><span class="line">    # responses is a list of HTTPResponses in the same order</span><br><span class="line"></span><br><span class="line">@gen.coroutine</span><br><span class="line">def parallel_fetch_dict(urls):</span><br><span class="line">    responses = yield &#123;url: http_client.fetch(url)</span><br><span class="line">                        for url in urls&#125;</span><br><span class="line">    # responses is a dict &#123;url: HTTPResponse&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用 <code>await</code> 关键字，列表和字典必须使用 <a href="http://www.tornadoweb.org/en/stable/gen.html#tornado.gen.multi" target="_blank" rel="noopener"><code>tornado.gen.multi</code></a> 包装起来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async def parallel_fetch(url1, url2):</span><br><span class="line">    resp1, resp2 = await gen.multi([http_client.fetch(url1),</span><br><span class="line">                                    http_client.fetch(url2)])</span><br></pre></td></tr></table></figure>
<h4 id="交叉存取"><a href="#交叉存取" class="headerlink" title="交叉存取"></a>交叉存取</h4><p>有时候我们需要保存<code>Future</code> 而不是立即返回，所以可以在等待之前执行其他操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@gen.coroutine</span><br><span class="line">def get(self):</span><br><span class="line">    fetch_future = self.fetch_next_chunk()</span><br><span class="line">    while True:</span><br><span class="line">        chunk = yield fetch_future</span><br><span class="line">        if chunk is None: break</span><br><span class="line">        self.write(chunk)</span><br><span class="line">        fetch_future = self.fetch_next_chunk()</span><br><span class="line">        yield self.flush()</span><br></pre></td></tr></table></figure>
<p>这种模式最适用于 <a href="mailto:`@gen.coroutine" target="_blank" rel="noopener">`@gen.coroutine</a><code>，如果</code>fetch_next_chunk()<code>使用</code>async def<code>，则必须如下调用：</code>fetch_future = tornado.gen.convert_yielded(self.fetch_next_chunk())`才能启动后台进程。</p>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>在原生协程中，可以使用<code>aysnc for</code> 。在老版本的Python中，协程的循环是棘手的，因为没有办法在 <code>for</code> 循环或者 <code>while</code> 循环 <code>yield</code> 迭代器，并且捕获 yield 的结果。相反，你需要将循环条件从访问结果中分离出来，下面是一个使用 <a href="http://motor.readthedocs.org/en/stable/" target="_blank" rel="noopener">Motor</a> 的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import motor</span><br><span class="line">db = motor.MotorClient().test</span><br><span class="line"></span><br><span class="line">@gen.coroutine</span><br><span class="line">def loop_example(collection):</span><br><span class="line">    cursor = db.collection.find()</span><br><span class="line">    while (yield cursor.fetch_next):</span><br><span class="line">        doc = cursor.next_object()</span><br></pre></td></tr></table></figure>
<h4 id="在后台运行"><a href="#在后台运行" class="headerlink" title="在后台运行"></a>在后台运行</h4><p><a href="http://tornado-zh.readthedocs.io/zh/latest/ioloop.html#tornado.ioloop.PeriodicCallback" target="_blank" rel="noopener"><code>PeriodicCallback</code></a> 通常不使用协程。相反，一个协程可以包含一个 <code>while True:</code> 循环并使用<a href="http://tornado-zh.readthedocs.io/zh/latest/gen.html#tornado.gen.sleep" target="_blank" rel="noopener"><code>tornado.gen.sleep</code></a> ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@gen.coroutine</span><br><span class="line">def minute_loop():</span><br><span class="line">    while True:</span><br><span class="line">        yield do_something()</span><br><span class="line">        yield gen.sleep(60)</span><br><span class="line"></span><br><span class="line"># Coroutines that loop forever are generally started with</span><br><span class="line"># spawn_callback().</span><br><span class="line">IOLoop.current().spawn_callback(minute_loop)</span><br></pre></td></tr></table></figure>
<p>有时可能会遇到一个更复杂的循环。例如，上一个循环运行每次花费 <code>60+N</code> 秒，其中 <code>N</code> 是 <code>do_something()</code> 花费的时间。为了 准确的每60秒运行，使用上面的交叉模式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@gen.coroutine</span><br><span class="line">def minute_loop2():</span><br><span class="line">    while True:</span><br><span class="line">        nxt = gen.sleep(60)   # Start the clock.</span><br><span class="line">        yield do_something()  # Run while the clock is ticking.</span><br><span class="line">        yield nxt             # Wait for the timer to run out.</span><br></pre></td></tr></table></figure>
<p>Read More:</p>
<blockquote>
<p><a href="http://www.tornadoweb.org/en/stable/guide/coroutines.html" target="_blank" rel="noopener">Coroutines</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>Tornado</category>
      </categories>
      <tags>
        <tag>Tornado</tag>
        <tag>翻译文档</tag>
        <tag>协程</tag>
      </tags>
  </entry>
  <entry>
    <title>Tornado5.0.2翻译文档 - Tornado web应用程序的结构</title>
    <url>/2020/12/19/tornado502-structureofweb/</url>
    <content><![CDATA[<p>Tornado web应用程序通常由一个或多个 <code>RequestHandler</code> 子类组成，将传入请求路由到处理程序的 <code>Application</code> 对象，和一个启动服务程序的 <code>main</code> 方法。</p>
<p>一个最小的“hello world”示例是这样的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tornado.ioloop</span><br><span class="line">import tornado.web</span><br><span class="line"></span><br><span class="line">class MainHandler(tornado.web.RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        self.write(&quot;Hello, world&quot;)</span><br><span class="line"></span><br><span class="line">def make_app():</span><br><span class="line">    return tornado.web.Application([</span><br><span class="line">        (r&quot;/&quot;, MainHandler),</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app = make_app()</span><br><span class="line">    app.listen(8888)</span><br><span class="line">    tornado.ioloop.IOLoop.current().start()</span><br></pre></td></tr></table></figure>
<h3 id="Application-对象"><a href="#Application-对象" class="headerlink" title="Application 对象"></a>Application 对象</h3><p><code>Application</code> 对象负责全局配置，包括将请求映射到处理程序的路由表。</p>
<p>路由表是 <code>URLSpec</code> 对象(或元组)的列表，每个对象都包含(至少)一个正则表达式和一个处理程序类。顺序问题：使用第一个匹配规则。如果正则表达式包含捕获组，那么这些组就是路径参数，并将被传递给处理程序的HTTP方法。如果字典作为 <code>URLSpec</code> 的第三个元素传递，它将提供初始化参数，该参数将被传递给 <code>RequestHandler.initialize</code>。<code>URLSpec</code> 对象也可自定义名称，用于 <code>RequestHandler.reverse_url</code>。</p>
<p>例如，在这个片段中，根URL <code>/</code> 被映射到 <code>MainHandler</code>，而形式 <code>/story/</code> 后面跟着一个数字的 <code>URL</code> 被映射到 <code>StoryHandler</code>。这个数字被传递(作为字符串)给 <code>StoryHandler.get</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MainHandler(RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        self.write(&apos;&lt;a href=&quot;%s&quot;&gt;link to story 1&lt;/a&gt;&apos; %</span><br><span class="line">                   self.reverse_url(&quot;story&quot;, &quot;1&quot;))</span><br><span class="line"></span><br><span class="line">class StoryHandler(RequestHandler):</span><br><span class="line">    def initialize(self, db):</span><br><span class="line">        self.db = db</span><br><span class="line"></span><br><span class="line">    def get(self, story_id):</span><br><span class="line">        self.write(&quot;this is story %s&quot; % story_id)</span><br><span class="line"></span><br><span class="line">app = Application([</span><br><span class="line">    url(r&quot;/&quot;, MainHandler),</span><br><span class="line">    url(r&quot;/story/([0-9]+)&quot;, StoryHandler, dict(db=db), name=&quot;story&quot;)</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure>
<p><code>Application</code> 构造函数接受许多关键字参数，这些参数可用于自定义应用程序的行为和启用可选特性；点击 <a href="https://www.tornadoweb.org/en/stable/web.html#tornado.web.Application.settings" target="_blank" rel="noopener">Application.settings</a>，查看完整设置。</p>
<h3 id="RequestHandler-子类"><a href="#RequestHandler-子类" class="headerlink" title="RequestHandler 子类"></a>RequestHandler 子类</h3><p>Tornado web应用程序的大部分工作都是在 <code>RequestHandler</code> 的子类中完成的。处理程序子类的主要入口点是以被处理的HTTP方法命名的方法: <code>get()</code>、<code>post()</code>等。每个处理程序可以定义一个或多个这样的方法来处理不同的HTTP操作。如上所述，这些方法将被调用，参数与匹配的路由规则的捕获组相对应。</p>
<p>在处理程序中，调用 <code>RequestHandler.render</code>、<code>RequestHandler.write</code>来产生一个响应。<code>render()</code> 按名称加载模板，并使用给定参数呈现它。<code>write()</code> 用于非基于模板的输出；它接受字符串、字节和字典(dicts将被编码为JSON)。</p>
<p><code>RequestHandler</code> 中的许多方法被设计成可以在子类中重写，并在整个应用程序中使用。通常定义一个 <code>BaseHandler</code> 类，覆盖 <code>write_error</code> 和 <code>get_current_user</code> 等方法，然后为所有特定的处理程序子类化你自己的 <code>BaseHandler</code> 而不是 <code>RequestHandler</code>。</p>
<h4 id="处理请求输入"><a href="#处理请求输入" class="headerlink" title="处理请求输入"></a>处理请求输入</h4><p>请求处理程序可以通过 <code>self.request</code> 访问表示当前请求的对象。有关属性的完整列表，请参阅 <a href="https://www.tornadoweb.org/en/stable/httputil.html#tornado.httputil.HTTPServerRequest" target="_blank" rel="noopener">HTTPServerRequest</a> 的类定义。</p>
<p>HTML表单使用的格式的请求数据将为您解析，并在 <code>get_query_argument</code> 和 <code>get_body_argument</code> 等方法中可用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyFormHandler(tornado.web.RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        self.write(&apos;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/myform&quot; method=&quot;POST&quot;&gt;&apos;</span><br><span class="line">                   &apos;&lt;input type=&quot;text&quot; name=&quot;message&quot;&gt;&apos;</span><br><span class="line">                   &apos;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&apos;</span><br><span class="line">                   &apos;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&apos;)</span><br><span class="line"></span><br><span class="line">    def post(self):</span><br><span class="line">        self.set_header(&quot;Content-Type&quot;, &quot;text/plain&quot;)</span><br><span class="line">        self.write(&quot;You wrote &quot; + self.get_body_argument(&quot;message&quot;))</span><br></pre></td></tr></table></figure>
<p>由于HTML表单编码对于参数是单个值还是包含一个元素的列表是模棱两可的，<code>RequestHandler</code> 提供了不同的方法，允许应用程序指示它是否需要列表。对于列表，使用 <code>get_query_arguments</code> 和 <code>get_body_arguments</code> 而不是它们的单一对应项。</p>
<p>通过表单上传的文件在 <code>self.request.files</code> 中可用。它将名称 <code>&lt;input type=&quot;file&quot;&gt;</code> 元素映射到一个文件列表。每个文件是一个字典形式 <code>{&quot;filename&quot;:…, &quot;content_type&quot;:……, &quot;body&quot;:…}</code>。<code>files</code> 对象只有在文件上传带有表单包装器(即 <code>multipart/form-data</code> 类型)时才存在;如果未使用此格式，则在 <code>self.request.body</code> 中可以使用原始上传数据。默认情况下，上传的文件在内存中完全缓冲;如果您需要处理太大而不能舒适地保存在内存中的文件，请参阅 <a href="https://www.tornadoweb.org/en/stable/web.html#tornado.web.stream_request_body" target="_blank" rel="noopener">stream_request_body</a> 类装饰器。</p>
<p>在demos目录中，<a href="https://github.com/tornadoweb/tornado/tree/master/demos/file_upload/" target="_blank" rel="noopener">file_receiver.py</a>显示了两种接收文件上传的方法。</p>
<p>由于HTML表单编码的奇怪之处(例如，单参数与复数参数之间的模糊性)，Tornado并不试图将表单参数与其他类型的输入统一起来。特别地，我们不解析JSON请求体。希望使用JSON而不是form-encoding的应用程序可以重写 <code>prepare</code> 来解析它们的请求:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def prepare(self):</span><br><span class="line">    if self.request.headers.get(&quot;Content-Type&quot;, &quot;&quot;).startswith(&quot;application/json&quot;):</span><br><span class="line">        self.json_args = json.loads(self.request.body)</span><br><span class="line">    else:</span><br><span class="line">        self.json_args = None</span><br></pre></td></tr></table></figure>
<h3 id="重写RequestHandler方法"><a href="#重写RequestHandler方法" class="headerlink" title="重写RequestHandler方法"></a>重写RequestHandler方法</h3><p>除了 <code>get()</code>/ <code>post()</code>/等，<code>RequestHandler</code> 中的某些其他方法被设计成在必要时由子类覆盖。在每个请求中，会发生以下调用序列:</p>
<ul>
<li>每个请求都会创建一个新的 <code>RequestHandler</code> 对象。</li>
<li><code>initialize()</code> 使用来自应用程序配置的初始化参数调用。初始化通常应该只保存传递给成员变量的实参;它可能不会产生任何输出或调用 <code>send_error</code> 之类的方法。</li>
<li><code>prepare()</code> 被调用。这在所有处理程序子类共享的基类中最有用，因为无论使用哪种HTTP方法都将调用 <code>prepare</code>。准备可产生产出;如果它调用<code>finish</code>(或<code>redirect</code>，等等)，处理将在此停止。</li>
<li>其中一个HTTP方法被调用:<code>get()</code>、<code>post()</code>、<code>put()</code>等等。如果URL正则表达式包含捕获组，则将它们作为参数传递给此方法。</li>
<li>当请求完成时，调用<code>on_finish()</code>。这通常是在<code>get()</code>或另一个HTTP方法返回之后。</li>
</ul>
<p>所有设计要重写的方法都在<code>RequestHandler</code>文档中有这样的说明。一些最常见的覆盖方法包括:</p>
<ul>
<li><code>write_error</code> - 输出用于错误页面的HTML。</li>
<li><code>on_connection_close</code> - 当客户端断开连接时调用;应用程序可以选择检测这种情况并停止进一步处理。请注意，不能保证能够迅速检测到关闭的连接。</li>
<li><code>get_current_user</code> - 参见<a href="https://www.tornadoweb.org/en/stable/guide/security.html#user-authentication" target="_blank" rel="noopener">User authentication</a>。</li>
<li><code>get_user_locale</code> - 返回用于当前用户的<code>Locale</code>对象。</li>
<li><code>set_default_headers</code> - 可以用于设置响应的附加标头(例如自定义<code>Server</code>头)。</li>
</ul>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果处理程序抛出异常，Tornado将调用<code>RequestHandler.write_error</code>生成一个错误页面。<code>tornado.web.HTTPError</code>可以用来生成指定的状态码;所有其他异常返回一个500状态。</p>
<p>默认的错误页面包括调试模式下的堆栈跟踪和错误的单行描述(例如:“500: Internal Server Error”)。若要生成自定义错误页面，请覆盖<code>RequestHandler.write_error</code>(可能在所有处理程序共享的基类中)。该方法可以通过<code>write</code>和<code>render</code>等方法正常生成输出。如果错误是由异常引起的，那么将传递一个<code>exc_info</code>三元组作为关键字参数(注意，这个异常不能保证是<code>sys.exc_info</code>，所以<code>write_error</code>必须使用<code>traceback.format_exception</code>代替<code>traceback.format_exc</code>)。</p>
<p>通过调用<code>set_status</code>编写响应并返回，也可以从常规处理程序方法而不是<code>write_error</code>生成一个错误页面。在简便返回不很方便的情况下<code>tornado.web.Finish</code> 异常会被抛出来终止处理程序而不是抛出<code>write_error</code>。</p>
<p>对于404错误，使用<code>default_handler_class</code> <code>Application settings</code>。这个处理程序应该覆盖<code>prepare</code>而不是像<code>get()</code>这样更具体的方法，这样它就可以与任何HTTP方法一起工作。它应该像上面描述的那样生成它的错误页面:通过调用<code>HTTPError(404)</code>并覆盖<code>write_error</code>，或者调用<code>self.set_status(404)</code>并在<code>prepare()</code>中直接生成响应。</p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>在Tornado中有两种主要的重定向请求的方法:<code>RequestHandler.redirect</code> 和 <code>RedirectHandler</code>。</p>
<p>您可以在<code>RequestHandler</code>方法中使用<code>self.redirect()</code>将用户重定向到其他地方。还有一个可选参数<code>permanent</code>，您可以使用它来指示重定向被认为是永久性的。<code>permanent</code>的默认值是False，它生成<code>302 Found HTTP</code>响应代码，适合在成功POST请求后重定向用户。如果<code>permanent</code>为True，则使用301移动的永久HTTP响应代码，这在以面向seo的方式重定向到页面的规范URL时很有用。</p>
<p><code>RedirectHandler</code>允许您在应用程序路由表中直接配置重定向。例如，要配置一个静态重定向:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app = tornado.web.Application([</span><br><span class="line">    url(r&quot;/app&quot;, tornado.web.RedirectHandler,</span><br><span class="line">        dict(url=&quot;http://itunes.apple.com/my-app-id&quot;)),</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure>
<p><code>RedirectHandler</code>也支持正则表达式替换。下面的规则将所有以<code>/pictures/</code>开头的请求重定向到前缀<code>/photos/</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app = tornado.web.Application([</span><br><span class="line">    url(r&quot;/photos/(.*)&quot;, MyPhotoHandler),</span><br><span class="line">    url(r&quot;/pictures/(.*)&quot;, tornado.web.RedirectHandler,</span><br><span class="line">        dict(url=r&quot;/photos/&#123;0&#125;&quot;)),</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure>
<p>不像<code>RequestHandler.redirect</code>，<code>RedirectHandler</code>默认使用永久重定向。这是因为路由表在运行时不会改变，并且被认为是永久的，而在处理程序中发现的重定向很可能是其他可能改变的逻辑的结果。要使用<code>RedirectHandler</code>发送临时重定向，请在<code>RedirectHandler</code>初始化参数中添加<code>permanent=False</code>。</p>
<h3 id="异步处理类"><a href="#异步处理类" class="headerlink" title="异步处理类"></a>异步处理类</h3><p>某些处理程序方法(包括<code>prepare()</code>和HTTP动词方法<code>get()</code>/ <code>post()</code>/等)可能被重写为协程，以使处理程序异步。</p>
<p>例如，下面是一个使用协同程序的简单处理程序:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MainHandler(tornado.web.RequestHandler):</span><br><span class="line">    async def get(self):</span><br><span class="line">        http = tornado.httpclient.AsyncHTTPClient()</span><br><span class="line">        response = await http.fetch(&quot;http://friendfeed-api.com/v2/feed/bret&quot;)</span><br><span class="line">        json = tornado.escape.json_decode(response.body)</span><br><span class="line">        self.write(&quot;Fetched &quot; + str(len(json[&quot;entries&quot;])) + &quot; entries &quot;</span><br><span class="line">                   &quot;from the FriendFeed API&quot;)</span><br></pre></td></tr></table></figure>
<p>关于更高级的异步示例，请查看<a href="https://github.com/tornadoweb/tornado/tree/stable/demos/chat" target="_blank" rel="noopener">聊天示例应用程序</a>，该应用程序使用长轮询实现了一个AJAX聊天室。使用长轮询的用户可能希望覆盖<code>on_connection_close()</code>，以便在客户端关闭连接后进行清理(但请参阅该方法的文档字符串以了解注意事项)。</p>
<p>Read More:</p>
<blockquote>
<p><a href="https://www.tornadoweb.org/en/stable/guide/structure.html" target="_blank" rel="noopener">Structure of a Tornado web application</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Tornado</category>
      </categories>
      <tags>
        <tag>Tornado</tag>
        <tag>翻译文档</tag>
      </tags>
  </entry>
  <entry>
    <title>从输入 URL 到页面展示到底发生了什么</title>
    <url>/2017/06/22/urlrequestprocess/</url>
    <content><![CDATA[<p>当我们在浏览器中输入 <code>www.google.com</code> 后，浏览器会给我们展示最终页面，本文就来讨论一下展示页面的过程到底是怎样的。</p>
<h3 id="输入网络地址"><a href="#输入网络地址" class="headerlink" title="输入网络地址"></a>输入网络地址</h3><p>当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得 URL 了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的 URL，然后给出智能提示，让你可以补全 URL 地址。对于 google 的 Chrome 的浏览器，他甚至会直接从缓存中把网页展示出来，就是说，你还没有按下 Enter，页面就出来了。</p>
<h3 id="DNS解析获取域名IP地址"><a href="#DNS解析获取域名IP地址" class="headerlink" title="DNS解析获取域名IP地址"></a>DNS解析获取域名IP地址</h3><p>请求一旦发起，浏览器首先要做的事情就是解析这个域名，一般来说，浏览器会首先查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 IP 地址。</p>
<p>如果在本地的 hosts 文件没有能够找到对应的 IP 地址，浏览器会发出一个 DNS 请求到本地 DNS 服务器 。本地 DNS 服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。</p>
<p>查询你输入的网址的 DNS 请求到达本地 DNS 服务器之后，本地 DNS 服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地 DNS 服务器还要向 DNS 根服务器进行查询。</p>
<p>根 DNS 服务器没有记录具体的域名和 IP 地址的对应关系，而是告诉本地 DNS 服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。这种过程是迭代的过程。</p>
<p>本地 DNS 服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和 IP 地址的对应关系，而是告诉本地 DNS 服务器，你的域名的解析服务器的地址。</p>
<p>最后，本地 DNS 服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地 DNS 服务器不仅要把 IP 地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</p>
<p><img src="/images/2017-6-22 134442.png" alt="2017-6-22 134442"></p>
<h4 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h4><p>DNS 存在着多级缓存，从离浏览器的距离排序的话，有以下几种：浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。</p>
<ul>
<li>在你的 Chrome 浏览器中输入 chrome://dns/，你可以看到 Chrome 浏览器的 DNS 缓存</li>
<li>系统缓存主要存在 /etc/hosts 中</li>
</ul>
<h4 id="DNS负载均衡"><a href="#DNS负载均衡" class="headerlink" title="DNS负载均衡"></a>DNS负载均衡</h4><p>当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会宕掉。处理办法就是用 DNS 负载均衡技术，它的原理是在 DNS 服务器中为同一个主机名配置多个 IP 地址，在应答 DNS 查询时，DNS 服务器对每个查询将以 DNS 文件中主机记录的IP地址按顺序返回不同的解析结果，将客户端的访问引导到不同的机器上去，使得不同的客户端访问不同的服务器，从而达到负载均衡的目的。例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。</p>
<h3 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a>建立TCP连接</h3><p>获取域名对应的 IP 地址之后，浏览器会以一个随机端口，进入到网卡，然后是进入到内核的 TCP/IP 协议栈，还有可能要经过 NetFilter 防火墙（属于内核的模块）的过滤，最终到达 Web 程序，最终建立了 TCP/IP 的连接。</p>
<p>因为 HTTP 报文是包裹在 TCP 报文中发送的，在发送 HTTP 请求之前需要客户端与服务器进行 TCP 连接以保证数据的正确稳定传输。TCP/IP协议可以参考 <a href="https://runnerliu.github.io/2017/04/03/tcpip/">TCP/IP协议入门篇</a> </p>
<h3 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h3><p>发送 HTTP 请求的过程就是构建 HTTP 请求报文并通过 TCP 协议中发送到服务器指定端口(HTTP 协议80/8080, HTTPS 协议443)。HTTP 请求报文是由三部分组成：请求行, 请求报头和请求正文。</p>
<h4 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h4><p>格式如下:<br>Method Request-URL HTTP-Version CRLF</p>
<p>eg：GET index.html HTTP/1.1<br>常用的方法有：GET、POST、PUT、DELETE、OPTIONS、HEAD。</p>
<h4 id="请求报头"><a href="#请求报头" class="headerlink" title="请求报头"></a>请求报头</h4><p>请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。</p>
<p>客户端不一定特指浏览器，有时候也可使用 Linux 下的 CURL 命令以及 HTTP 客户端测试工具等。<br>常见的请求报头有：Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Type、Authorization、Cookie、User-Agent等。</p>
<h4 id="请求正文"><a href="#请求正文" class="headerlink" title="请求正文"></a>请求正文</h4><p>当使用POST、PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如：现在的 Web 应用通常采用 Rest 架构，请求的数据格式一般为 JSON。这时就需要设置Content-Type:application/json。</p>
<h3 id="服务器永久重定向响应"><a href="#服务器永久重定向响应" class="headerlink" title="服务器永久重定向响应"></a>服务器永久重定向响应</h3><p>服务器给浏览器响应一个 301 永久重定向响应，这样浏览器就会访问 “<a href="http://www.google.com/”" target="_blank" rel="noopener">http://www.google.com/”</a>  而非 “<a href="http://google.com/”。" target="_blank" rel="noopener">http://google.com/”。</a></p>
<p>为什么服务器一定要重定向而不是直接发送用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像 <a href="http://www.yy.com/" target="_blank" rel="noopener">http://www.yy.com/</a> 和 <a href="http://yy.com/" target="_blank" rel="noopener">http://yy.com/</a> ，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而降低排名。而搜索引擎知道 301 永久重定向是什么意思，这样就会把访问带 www 的和不带 www 的地址归到同一个网站排名下。还有就是用不同的地址会造成缓存友好性变差，当一个页面有好几个名字时，它可能会在缓存里出现好几次。</p>
<h4 id="301和302的区别"><a href="#301和302的区别" class="headerlink" title="301和302的区别"></a>301和302的区别</h4><p>301 和 302 状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的 URL 地址，这个地址可以从响应的 Location 首部中获取（用户看到的效果就是他输入的地址 A 瞬间变成了另一个地址 B）——这是它们的共同点。</p>
<p>他们的不同在于。301 表示旧地址 A 的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；</p>
<p>302 表示旧地址 A 的资源还在（仍然可以访问），这个重定向只是临时地从旧地址 A 跳转到地址 B，搜索引擎会抓取新的内容而保存旧的网址。</p>
<h4 id="重定向原因"><a href="#重定向原因" class="headerlink" title="重定向原因"></a>重定向原因</h4><ul>
<li>网站调整（如改变网页目录结构）；</li>
<li>网页被移到一个新地址；</li>
<li>网页扩展名改变(如应用需要把 .php 改成 .Html 或 .shtml )。</li>
</ul>
<p>这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个 404 页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。</p>
<h4 id="跳转的时机"><a href="#跳转的时机" class="headerlink" title="跳转的时机"></a>跳转的时机</h4><p>当一个网站或者网页 24-48 小时内临时移动到一个新的位置，这时候就要进行 302 跳转，而使用301 跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的。</p>
<p>清晰明确而言：使用 301 跳转的大概场景如下：</p>
<ul>
<li>域名到期不想续费（或者发现了更适合网站的域名），想换个域名</li>
<li>在搜索引擎的搜索结果中出现了不带 www 的域名，而带 www 的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个</li>
<li>空间服务器不稳定，换空间的时候</li>
</ul>
<h3 id="浏览器跟踪重定向地址"><a href="#浏览器跟踪重定向地址" class="headerlink" title="浏览器跟踪重定向地址"></a>浏览器跟踪重定向地址</h3><p>现在浏览器知道了 “<a href="http://www.google.com/”" target="_blank" rel="noopener">http://www.google.com/”</a> 才是要访问的正确地址，所以它会发送另一个http请求。</p>
<h3 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h3><h4 id="数据的接收"><a href="#数据的接收" class="headerlink" title="数据的接收"></a>数据的接收</h4><p>我们知道，IP 协议的作用是把 TCP 分割好的各种数据包传送给接收方。而要保证确实能传到接收方还需要接收方的 MAC 地址，也就是物理地址。IP 地址和 MAC 地址是一一对应的关系，一个网络设备的 IP 地址可以更换，但是 MAC 地址一般是固定不变的。ARP 协议可以将 IP 地址解析成对应的 MAC 地址。当通信的双方不在同一个局域网时，需要多次中转才能到达最终的目标，在中转的过程中需要通过下一个中转站的MAC地址来搜索下一个中转目标。</p>
<p>在找到对方的 MAC 地址后，就将数据发送到数据链路层传输。接收端的服务器在链路层接收到数据包，再层层向上直到应用层。这过程中包括在运输层通过TCP协议讲分段的数据包重新组成原来的HTTP请求报文。</p>
<h4 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h4><p>一些大一点的网站会将你的请求转到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。此时，客户端不是直接通过 HTTP 协议访问某网站应用服务器，而是先请求到 Nginx，Nginx 再请求应用服务器，然后将结果返回给客户端，这里 Nginx 的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。</p>
<ul>
<li>用户将 HTTP 请求发送给 Nginx 服务器；</li>
<li>Nginx 会根据用户访问的 URL 和后缀对请求进行判断，如果请求的是静态资源（HTML页面）会直接返回，如果请求的是动态资源，执行下一步；</li>
<li>Nginx 会通过 fastcgi_pass 将用户的请求发送给 PHP-FPM；</li>
<li>fastcgi_pass 将动态资源交给 PHP-FPM 后，PHP-FPM 会将资源转给 PHP 脚本解析服务器的 Wrapper；</li>
<li>Wrapper 收到 PHP-FPM 转过来的请求后，Wrapper 会生成一个新的线程调用 PHP 动态程序解析服务器；</li>
<li>PHP 会将查询到的结果返回给 Nginx ；</li>
<li>Nginx 构造一个响应报文将结果返回给用户。</li>
</ul>
<h3 id="返回HTTP响应"><a href="#返回HTTP响应" class="headerlink" title="返回HTTP响应"></a>返回HTTP响应</h3><p>HTTP 响应与 HTTP 请求相似，HTTP 响应也由3个部分构成，分别是：状态行、响应头、响应正文</p>
<h4 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h4><p>状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。</p>
<p>格式:    HTTP-Version Status-Code Reason-Phrase CRLF</p>
<p>例如:    HTTP/1.1 200 OK</p>
<h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><p><img src="/images/2017-6-22 143353.png" alt="2017-6-22 143353"></p>
<p><img src="/images/2017-6-22 143420.png" alt="2017-6-22 143420"></p>
<h4 id="响应正文"><a href="#响应正文" class="headerlink" title="响应正文"></a>响应正文</h4><p>服务器返回给浏览器的文本信息，通常 HTML、CSS、JS, 图片等文件就放在这一部分。</p>
<h3 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h3><p>在浏览器没有完整接受全部 HTML 文档时，它就已经开始显示这个页面了，浏览器是如何把页面呈现在屏幕上的呢？不同浏览器可能解析的过程不太一样，这里我们只介绍 WebKit 的渲染过程，下图对应的就是 WebKit 渲染的过程，这个过程包括：</p>
<p>解析 HTML 以构建 DOM 树 -&gt; 构建 Render 树 -&gt; 布局 Render 树 -&gt; 绘制 Render 树</p>
<p><img src="/images/2017-6-22 143824.png" alt="2017-6-22 143824"></p>
<p>浏览器在解析 HTML 文件时，会”自上而下“加载，并在加载过程中进行解析渲染。在解析过程中，如果遇到请求外部资源时，如图片、外链的 CSS、iconfont 等，请求过程是异步的，并不会影响 HTML 文档进行加载。</p>
<p>解析过程中，浏览器首先会解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念：reflow(回流)和 repain(重绘)。</p>
<p>DOM 节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow；当盒模型的位置、大小以及其他属性，如颜色、字体等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。</p>
<p>页面在首次加载时必然会经历 reflow 和 repain。reflow 和 repain 过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少 reflow 和 repain。</p>
<p><img src="/images/2017-6-22 144024.png" alt="2017-6-22 144024"></p>
<p>当文档加载过程中遇到 JS 文件，HTML 文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待文档中 JS 文件加载完毕，还要等待解析执行完毕，才可以恢复 HTML 文档的渲染线程。因为 JS 有可能会修改DOM，最为经典的document.write，这意味着，在 JS 执行完成前，后续所有资源的下载可能是没有必要的，这是 JS 阻塞后续资源下载的根本原因。所以我明平时的代码中， JS 是放在 HTML 文档末尾的。</p>
<p>JS 的解析是由浏览器中的 JS 解析引擎完成的，比如谷歌的是V8。 JS 是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。</p>
<p>JS 的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。</p>
<p>在浏览器还没接收到完整的 HTML 文件时，它就开始渲染页面了，在遇到外部链入的脚本标签或样式标签或图片时，会再次发送 HTTP 请求重复上述的步骤。在收到 CSS 文件后会对已经渲染的页面重新渲染，加入它们应有的样式，图片文件加载完立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。</p>
<p>Read More:</p>
<blockquote>
<p><a href="http://www.cnblogs.com/kongxy/p/4615226.html" target="_blank" rel="noopener">从输入URL到浏览器显示页面发生了什么</a>  <a href="https://www.feehi.com/view/5880" target="_blank" rel="noopener">从输入 URL 到页面展示到底发生了什么</a>  <a href="http://www.cnblogs.com/rollenholt/archive/2012/03/23/2414345.html" target="_blank" rel="noopener">百度面试题：从输入url到显示网页，后台发生了什么？</a>  <a href="http://www.cnblogs.com/engeng/articles/5943382.html" target="_blank" rel="noopener">从输入URL到页面加载发生了什么?</a>  <a href="http://www.runoob.com/http/http-header-fields.html" target="_blank" rel="noopener">HTTP 响应头信息</a>  </p>
</blockquote>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>网络编程</tag>
        <tag>TCP/IP</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Laravel学习笔记-Laravel5.3后台用户认证</title>
    <url>/2017/05/05/laraveladminlogin/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Laravel 5.3 的 Auth 认证在 5.2 的基础上又有一些改变，本文说明如何在 Laravel 5.3 下做不同用户表的登录认证。</p>
<h3 id="Auth-认证原理简述"><a href="#Auth-认证原理简述" class="headerlink" title="Auth 认证原理简述"></a>Auth 认证原理简述</h3><p>Laravel 的认证是使用 guard 与 provider 配合完成， guard 负责认证的业务逻辑，认证信息的服务端保存等； provider 负责提供认证信息的持久化数据提供。<br>请求提交给 guard， guard 从 provider 里取出数据（类似用户名、密码等），验证输入数据与服务器端存储的数据是否吻合。如果提交的数据正确，再做 session 等业务的处理（如有需要）。</p>
<h3 id="认证脚手架"><a href="#认证脚手架" class="headerlink" title="认证脚手架"></a>认证脚手架</h3><p>首先我们导入 Laravel 的自带的认证脚手架</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php artisan make:auth</span><br></pre></td></tr></table></figure>
<p>执行数据库迁移</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php artisan migrate</span><br></pre></td></tr></table></figure>
<p>修改 Auth 认证的配置文件 config/auth.php，在 gurads 处，添加 admin guard 用于后台管理员认证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;guards&apos; =&gt; [</span><br><span class="line">        &apos;web&apos; =&gt; [</span><br><span class="line">            &apos;driver&apos; =&gt; &apos;session&apos;,</span><br><span class="line">            &apos;provider&apos; =&gt; &apos;users&apos;,</span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">        &apos;admin&apos; =&gt; [</span><br><span class="line">            &apos;driver&apos; =&gt; &apos;session&apos;,</span><br><span class="line">            &apos;provider&apos; =&gt; &apos;admins&apos;,</span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">        &apos;api&apos; =&gt; [</span><br><span class="line">            &apos;driver&apos; =&gt; &apos;token&apos;,</span><br><span class="line">            &apos;provider&apos; =&gt; &apos;users&apos;,</span><br><span class="line">        ],</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure>
<p>在 providers 处添加 admins provider，使用 Admin 模型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;providers&apos; =&gt; [</span><br><span class="line">        &apos;users&apos; =&gt; [</span><br><span class="line">            &apos;driver&apos; =&gt; &apos;eloquent&apos;,</span><br><span class="line">            &apos;model&apos; =&gt; App\Models\User::class,</span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">        &apos;admins&apos; =&gt; [</span><br><span class="line">            &apos;driver&apos; =&gt; &apos;eloquent&apos;,</span><br><span class="line">            &apos;model&apos; =&gt; App\Models\Admin::class,</span><br><span class="line">        ],</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>本文将所有的 Model 都存放在 App\Models\ 目录下。</p>
<h3 id="创建后台管理员模型"><a href="#创建后台管理员模型" class="headerlink" title="创建后台管理员模型"></a>创建后台管理员模型</h3><p>我们再创建一个 Admin 模型，用于后台管理员登录验证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php artisan make:model Admin -m</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-m 参数会同时生成数据库迁移文件 xxxx_create_admins_table</p>
</blockquote>
<p>修改 app/Admin.php 模型文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App;</span><br><span class="line"></span><br><span class="line">use Illuminate\Notifications\Notifiable;</span><br><span class="line">use Illuminate\Foundation\Auth\User as Authenticatable;</span><br><span class="line"></span><br><span class="line">class Admin extends Authenticatable</span><br><span class="line">&#123;</span><br><span class="line">    use Notifiable;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The attributes that are mass assignable.</span><br><span class="line">     *</span><br><span class="line">     * @var array</span><br><span class="line">     */</span><br><span class="line">    protected $fillable = [</span><br><span class="line">        &apos;name&apos;, &apos;password&apos;,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * The attributes that should be hidden for arrays.</span><br><span class="line">     *</span><br><span class="line">     * @var array</span><br><span class="line">     */</span><br><span class="line">    protected $hidden = [</span><br><span class="line">        &apos;password&apos;, &apos;remember_token&apos;,</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编辑 xxxx_create_admins_table 文件，后台管理员模型结构与前台用户差不多，去掉 email 字段，name 字段设为 unique()，后台用户登录使用用户名、密码的形式，如果需要 email ，也可以不去掉。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">use Illuminate\Support\Facades\Schema;</span><br><span class="line">use Illuminate\Database\Schema\Blueprint;</span><br><span class="line">use Illuminate\Database\Migrations\Migration;</span><br><span class="line"></span><br><span class="line">class CreateAdminsTable extends Migration</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * Run the migrations.</span><br><span class="line">     *</span><br><span class="line">     * @return void</span><br><span class="line">     */</span><br><span class="line">    public function up()</span><br><span class="line">    &#123;</span><br><span class="line">        Schema::create(&apos;admins&apos;, function (Blueprint $table) &#123;</span><br><span class="line">            $table-&gt;increments(&apos;id&apos;);</span><br><span class="line">            $table-&gt;string(&apos;name&apos;)-&gt;unique();</span><br><span class="line">            $table-&gt;string(&apos;password&apos;);</span><br><span class="line">            $table-&gt;rememberToken();</span><br><span class="line">            $table-&gt;timestamps();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Reverse the migrations.</span><br><span class="line">     *</span><br><span class="line">     * @return void</span><br><span class="line">     */</span><br><span class="line">    public function down()</span><br><span class="line">    &#123;</span><br><span class="line">        Schema::dropIfExists(&apos;admins&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="管理员模型填充数据"><a href="#管理员模型填充数据" class="headerlink" title="管理员模型填充数据"></a>管理员模型填充数据</h3><p>定义一个数据模型工厂，在 database/factories/ModelFactory.php 中添加如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$factory-&gt;define(App\Admin::class, function (Faker\Generator $faker) &#123;</span><br><span class="line">    static $password;</span><br><span class="line"></span><br><span class="line">    return [</span><br><span class="line">        &apos;name&apos; =&gt; $faker-&gt;firstName,</span><br><span class="line">        &apos;password&apos; =&gt; $password ?: $password = bcrypt(&apos;secret&apos;),</span><br><span class="line">        &apos;remember_token&apos; =&gt; str_random(10),</span><br><span class="line">    ];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 Faker 随机填充用户名</p>
</blockquote>
<p>在 database/seeds 目录下生成 AdminsTableSeeder.php 文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php artisan make:seeder AdminsTableSeeder</span><br></pre></td></tr></table></figure>
<p>编辑 database/seeds/AdminsTableSeeder.php 文件的 run 方法，添加3个管理员用户，密码为 123456</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function run()</span><br><span class="line">    &#123;</span><br><span class="line">        factory(&apos;App\Admin&apos;, 3)-&gt;create([</span><br><span class="line">            &apos;password&apos; =&gt; bcrypt(&apos;123456&apos;)</span><br><span class="line">            ]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在 database/seeds/DatabaseSeeder.php 的 run 方法里调用 AdminsTableSeeder 类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function run()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;call(AdminsTableSeeder::class);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>执行数据库迁移命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php artisan migrate --seed</span><br></pre></td></tr></table></figure>
<p>数据库里会创建 admins 表，并且生成了3条数据：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>password</th>
<th>remember_token</th>
<th>created_at</th>
<th>updated_at</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>John</td>
<td>$2y$10$AYD4MoW…</td>
<td>9p7bycJ5Wn</td>
<td>2017-05-05 15:12:37</td>
<td>2017-05-05 15:12:37</td>
</tr>
<tr>
<td>2</td>
<td>Ransom</td>
<td>$2y$10$AYD4MoW…</td>
<td>Ct8W5nmTsg</td>
<td>2017-05-05 15:12:37</td>
<td>2017-05-05 15:12:37</td>
</tr>
<tr>
<td>3</td>
<td>Dulce</td>
<td>$2y$10$AYD4MoW…</td>
<td>I8RJpxwVrk</td>
<td>2017-05-05 15:12:37</td>
<td>2017-05-05 15:12:37</td>
</tr>
</tbody>
</table>
<h3 id="创建后台页面"><a href="#创建后台页面" class="headerlink" title="创建后台页面"></a>创建后台页面</h3><h4 id="创建控制器"><a href="#创建控制器" class="headerlink" title="创建控制器"></a>创建控制器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php artisan make:controller Admin/LoginController    </span><br><span class="line">php artisan make:controller Admin/IndexController</span><br></pre></td></tr></table></figure>
<p>其中， Admin/LoginController 负责登录逻辑； Admin/IndexController 管理登录后的首页。</p>
<p>编辑 Admin/LoginController.php</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Http\Controllers\Admin;</span><br><span class="line"></span><br><span class="line">use App\Http\Controllers\Controller;</span><br><span class="line">use Illuminate\Foundation\Auth\AuthenticatesUsers;</span><br><span class="line"></span><br><span class="line">class LoginController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    /*</span><br><span class="line">    |--------------------------------------------------------------------------</span><br><span class="line">    | Login Controller</span><br><span class="line">    |--------------------------------------------------------------------------</span><br><span class="line">    |</span><br><span class="line">    | This controller handles authenticating users for the application and</span><br><span class="line">    | redirecting them to your home screen. The controller uses a trait</span><br><span class="line">    | to conveniently provide its functionality to your applications.</span><br><span class="line">    |</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    use AuthenticatesUsers;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Where to redirect users after login / registration.</span><br><span class="line">     *</span><br><span class="line">     * @var string</span><br><span class="line">     */</span><br><span class="line">    protected $redirectTo = &apos;/admin&apos;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Create a new controller instance.</span><br><span class="line">     *</span><br><span class="line">     * @return void</span><br><span class="line">     */</span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;middleware(&apos;guest.admin&apos;, [&apos;except&apos; =&gt; &apos;logout&apos;]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 显示后台登录模板</span><br><span class="line">     */</span><br><span class="line">    public function showLoginForm()</span><br><span class="line">    &#123;</span><br><span class="line">        return view(&apos;admin.login&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 使用 admin guard</span><br><span class="line">     */</span><br><span class="line">    protected function guard()</span><br><span class="line">    &#123;</span><br><span class="line">        return auth()-&gt;guard(&apos;admin&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编辑 Admin/IndexController.php</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Http\Controllers\Admin;</span><br><span class="line"></span><br><span class="line">use Illuminate\Http\Request;</span><br><span class="line"></span><br><span class="line">use App\Http\Requests;</span><br><span class="line">use App\Http\Controllers\Controller;</span><br><span class="line"></span><br><span class="line">class IndexController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * 显示后台管理模板首页</span><br><span class="line">     */</span><br><span class="line">    public function index()</span><br><span class="line">    &#123;</span><br><span class="line">        return view(&apos;admin.index&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="后台显示模板"><a href="#后台显示模板" class="headerlink" title="后台显示模板"></a>后台显示模板</h4><p>复制 views/layouts/app.blade.php 成 views/layouts/admin.blade.php。</p>
<p>编辑后台管理布局模板</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- CSRF Token --&gt;</span><br><span class="line">    &lt;meta name=&quot;csrf-token&quot; content=&quot;&#123;&#123; csrf_token() &#125;&#125;&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;title&gt;&#123;&#123; config(&apos;app.name&apos;, &apos;Laravel&apos;) &#125;&#125; - Admin&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Styles --&gt;</span><br><span class="line">    &lt;link href=&quot;/css/app.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- Scripts --&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        window.Laravel = &lt;?php echo json_encode([</span><br><span class="line">            &apos;csrfToken&apos; =&gt; csrf_token(),</span><br><span class="line">        ]); ?&gt;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;nav class=&quot;navbar navbar-default navbar-static-top&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;navbar-header&quot;&gt;</span><br><span class="line"></span><br><span class="line">                &lt;!-- Collapsed Hamburger --&gt;</span><br><span class="line">                &lt;button type=&quot;button&quot; class=&quot;navbar-toggle collapsed&quot; data-toggle=&quot;collapse&quot; data-target=&quot;#app-navbar-collapse&quot;&gt;</span><br><span class="line">                    &lt;span class=&quot;sr-only&quot;&gt;Toggle Navigation&lt;/span&gt;</span><br><span class="line">                    &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;</span><br><span class="line">                    &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;</span><br><span class="line">                    &lt;span class=&quot;icon-bar&quot;&gt;&lt;/span&gt;</span><br><span class="line">                &lt;/button&gt;</span><br><span class="line"></span><br><span class="line">                &lt;!-- Branding Image --&gt;</span><br><span class="line">                &lt;a class=&quot;navbar-brand&quot; href=&quot;&#123;&#123; url(&apos;/&apos;) &#125;&#125;&quot;&gt;</span><br><span class="line">                    &#123;&#123; config(&apos;app.name&apos;, &apos;Laravel&apos;) &#125;&#125;</span><br><span class="line">                &lt;/a&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">            &lt;div class=&quot;collapse navbar-collapse&quot; id=&quot;app-navbar-collapse&quot;&gt;</span><br><span class="line">                &lt;!-- Left Side Of Navbar --&gt;</span><br><span class="line">                &lt;ul class=&quot;nav navbar-nav&quot;&gt;</span><br><span class="line">                    &amp;nbsp;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">                &lt;!-- Right Side Of Navbar --&gt;</span><br><span class="line">                &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt;</span><br><span class="line">                    &lt;!-- Authentication Links --&gt;</span><br><span class="line">                    @if (auth()-&gt;guard(&apos;admin&apos;)-&gt;guest())</span><br><span class="line">                        &lt;li&gt;&lt;a href=&quot;&#123;&#123; url(&apos;/admin/login&apos;) &#125;&#125;&quot;&gt;Login&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">                    @else</span><br><span class="line">                        &lt;li class=&quot;dropdown&quot;&gt;</span><br><span class="line">                            &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; role=&quot;button&quot; aria-expanded=&quot;false&quot;&gt;</span><br><span class="line">                                &#123;&#123; auth()-&gt;guard(&apos;admin&apos;)-&gt;user()-&gt;name &#125;&#125; &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt;</span><br><span class="line">                            &lt;/a&gt;</span><br><span class="line"></span><br><span class="line">                            &lt;ul class=&quot;dropdown-menu&quot; role=&quot;menu&quot;&gt;</span><br><span class="line">                                &lt;li&gt;</span><br><span class="line">                                    &lt;a href=&quot;&#123;&#123; url(&apos;/admin/logout&apos;) &#125;&#125;&quot;</span><br><span class="line">                                        onclick=&quot;event.preventDefault();</span><br><span class="line">                                                 document.getElementById(&apos;logout-form&apos;).submit();&quot;&gt;</span><br><span class="line">                                        Logout</span><br><span class="line">                                    &lt;/a&gt;</span><br><span class="line"></span><br><span class="line">                                    &lt;form id=&quot;logout-form&quot; action=&quot;&#123;&#123; url(&apos;/admin/logout&apos;) &#125;&#125;&quot; method=&quot;POST&quot; style=&quot;display: none;&quot;&gt;</span><br><span class="line">                                        &#123;&#123; csrf_field() &#125;&#125;</span><br><span class="line">                                    &lt;/form&gt;</span><br><span class="line">                                &lt;/li&gt;</span><br><span class="line">                            &lt;/ul&gt;</span><br><span class="line">                        &lt;/li&gt;</span><br><span class="line">                    @endif</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/nav&gt;</span><br><span class="line"></span><br><span class="line">    @yield(&apos;content&apos;)</span><br><span class="line"></span><br><span class="line">    &lt;!-- Scripts --&gt;</span><br><span class="line">    &lt;script src=&quot;/js/app.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>复制 views/auth/login.blade.php 成 views/admin/login.blade.php。</p>
<p>编辑该模板，更改布局文件为 layouts.admin， 把表单的提交 url 改为 admin/login，email 字段改成 name 字段，去掉找回密码的部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@extends(&apos;layouts.admin&apos;)</span><br><span class="line"></span><br><span class="line">@section(&apos;content&apos;)</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;row&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;col-md-8 col-md-offset-2&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;panel panel-default&quot;&gt;</span><br><span class="line">                &lt;div class=&quot;panel-heading&quot;&gt;Admin Login&lt;/div&gt;</span><br><span class="line">                &lt;div class=&quot;panel-body&quot;&gt;</span><br><span class="line">                    &lt;form class=&quot;form-horizontal&quot; role=&quot;form&quot; method=&quot;POST&quot; action=&quot;&#123;&#123; url(&apos;/admin/login&apos;) &#125;&#125;&quot;&gt;</span><br><span class="line">                        &#123;&#123; csrf_field() &#125;&#125;</span><br><span class="line"></span><br><span class="line">                        &lt;div class=&quot;form-group&#123;&#123; $errors-&gt;has(&apos;name&apos;) ? &apos; has-error&apos; : &apos;&apos; &#125;&#125;&quot;&gt;</span><br><span class="line">                            &lt;label for=&quot;name&quot; class=&quot;col-md-4 control-label&quot;&gt;Name&lt;/label&gt;</span><br><span class="line"></span><br><span class="line">                            &lt;div class=&quot;col-md-6&quot;&gt;</span><br><span class="line">                                &lt;input id=&quot;name&quot; type=&quot;text&quot; class=&quot;form-control&quot; name=&quot;name&quot; value=&quot;&#123;&#123; old(&apos;name&apos;) &#125;&#125;&quot; required autofocus&gt;</span><br><span class="line"></span><br><span class="line">                                @if ($errors-&gt;has(&apos;name&apos;))</span><br><span class="line">                                    &lt;span class=&quot;help-block&quot;&gt;</span><br><span class="line">                                        &lt;strong&gt;&#123;&#123; $errors-&gt;first(&apos;name&apos;) &#125;&#125;&lt;/strong&gt;</span><br><span class="line">                                    &lt;/span&gt;</span><br><span class="line">                                @endif</span><br><span class="line">                            &lt;/div&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">                        &lt;div class=&quot;form-group&#123;&#123; $errors-&gt;has(&apos;password&apos;) ? &apos; has-error&apos; : &apos;&apos; &#125;&#125;&quot;&gt;</span><br><span class="line">                            &lt;label for=&quot;password&quot; class=&quot;col-md-4 control-label&quot;&gt;Password&lt;/label&gt;</span><br><span class="line"></span><br><span class="line">                            &lt;div class=&quot;col-md-6&quot;&gt;</span><br><span class="line">                                &lt;input id=&quot;password&quot; type=&quot;password&quot; class=&quot;form-control&quot; name=&quot;password&quot; required&gt;</span><br><span class="line"></span><br><span class="line">                                @if ($errors-&gt;has(&apos;password&apos;))</span><br><span class="line">                                    &lt;span class=&quot;help-block&quot;&gt;</span><br><span class="line">                                        &lt;strong&gt;&#123;&#123; $errors-&gt;first(&apos;password&apos;) &#125;&#125;&lt;/strong&gt;</span><br><span class="line">                                    &lt;/span&gt;</span><br><span class="line">                                @endif</span><br><span class="line">                            &lt;/div&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">                        &lt;div class=&quot;form-group&quot;&gt;</span><br><span class="line">                            &lt;div class=&quot;col-md-6 col-md-offset-4&quot;&gt;</span><br><span class="line">                                &lt;div class=&quot;checkbox&quot;&gt;</span><br><span class="line">                                    &lt;label&gt;</span><br><span class="line">                                        &lt;input type=&quot;checkbox&quot; name=&quot;remember&quot;&gt; Remember Me</span><br><span class="line">                                    &lt;/label&gt;</span><br><span class="line">                                &lt;/div&gt;</span><br><span class="line">                            &lt;/div&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">                        &lt;div class=&quot;form-group&quot;&gt;</span><br><span class="line">                            &lt;div class=&quot;col-md-8 col-md-offset-4&quot;&gt;</span><br><span class="line">                                &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;</span><br><span class="line">                                    Login</span><br><span class="line">                                &lt;/button&gt;</span><br><span class="line">                            &lt;/div&gt;</span><br><span class="line">                        &lt;/div&gt;</span><br><span class="line">                    &lt;/form&gt;</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">@endsection</span><br></pre></td></tr></table></figure>
<p>复制 views/home.blade.php 成 views/admins/index.blade.php。</p>
<p>编辑该模板</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@extends(&apos;layouts.admin&apos;)</span><br><span class="line"></span><br><span class="line">@section(&apos;content&apos;)</span><br><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;row&quot;&gt;</span><br><span class="line">        &lt;div class=&quot;col-md-8 col-md-offset-2&quot;&gt;</span><br><span class="line">            &lt;div class=&quot;panel panel-default&quot;&gt;</span><br><span class="line">                &lt;div class=&quot;panel-heading&quot;&gt;Dashboard&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">                &lt;div class=&quot;panel-body&quot;&gt;</span><br><span class="line">                    You are logged in admin dashboard!</span><br><span class="line">                &lt;/div&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">@endsection</span><br></pre></td></tr></table></figure>
<h4 id="添加后台路由"><a href="#添加后台路由" class="headerlink" title="添加后台路由"></a>添加后台路由</h4><p>编辑 routes/web.php， 添加以下内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Route::group([&apos;prefix&apos; =&gt; &apos;admin&apos;], function () &#123;</span><br><span class="line">    Route::group([&apos;middleware&apos; =&gt; &apos;auth.admin&apos;], function () &#123;</span><br><span class="line">        Route::get(&apos;/&apos;, &apos;Admin\IndexController@index&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Route::get(&apos;login&apos;, &apos;Admin\LoginController@showLoginForm&apos;)-&gt;name(&apos;admin.login&apos;);</span><br><span class="line">    Route::post(&apos;login&apos;, &apos;Admin\LoginController@login&apos;);</span><br><span class="line">    Route::post(&apos;logout&apos;, &apos;Admin\LoginController@logout&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="后台管理认证中间件"><a href="#后台管理认证中间件" class="headerlink" title="后台管理认证中间件"></a>后台管理认证中间件</h4><p>创建后台管理认证中间件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php artisan make:middleware AuthAdmin</span><br></pre></td></tr></table></figure>
<p>编辑 AuthAdmin</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App\Http\Middleware;</span><br><span class="line"></span><br><span class="line">use Closure;</span><br><span class="line"></span><br><span class="line">class AuthAdmin</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * Handle an incoming request.</span><br><span class="line">     *</span><br><span class="line">     * @param  \Illuminate\Http\Request  $request</span><br><span class="line">     * @param  \Closure  $next</span><br><span class="line">     * @return mixed</span><br><span class="line">     */</span><br><span class="line">    public function handle($request, Closure $next)</span><br><span class="line">    &#123;</span><br><span class="line">        if (auth()-&gt;guard(&apos;admin&apos;)-&gt;guest()) &#123;</span><br><span class="line">            if ($request-&gt;ajax() || $request-&gt;wantsJson()) &#123;</span><br><span class="line">                return response(&apos;Unauthorized.&apos;, 401);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return redirect()-&gt;guest(&apos;admin/login&apos;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return $next($request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建后台管理登录跳转中间件，用于有些操作在登录之后的跳转</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php artisan make:middleware GuestAdmin</span><br></pre></td></tr></table></figure>
<p>编辑该中间件的 handle 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function handle($request, Closure $next)</span><br><span class="line">    &#123;</span><br><span class="line">        if (auth()-&gt;guard(&apos;admin&apos;)-&gt;check()) &#123;</span><br><span class="line">            return redirect(&apos;/admin&apos;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return $next($request);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在 app/Http/Kernel.php 中注册以上中间件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected $routeMiddleware = [</span><br><span class="line">    ......</span><br><span class="line">    &apos;auth.admin&apos; =&gt; \App\Http\Middleware\AuthAdmin::class,</span><br><span class="line">    &apos;guest.admin&apos; =&gt; \App\Http\Middleware\GuestAdmin::class,</span><br><span class="line">    ......</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h4 id="处理注销"><a href="#处理注销" class="headerlink" title="处理注销"></a>处理注销</h4><p>经过上面的步骤，已经实现了前后台分离登录，但是不管是在前台注销，还是在后台注销，都销毁了所有的 session，导致前后台注销连在一起。所以我们还要对注销的方法处理一下。</p>
<p>原来的 logout 方法是这样写的，在 Illuminate\Foundation\Auth\AuthenticatesUsers 里</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function logout(Request $request)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;guard()-&gt;logout();</span><br><span class="line"></span><br><span class="line">        $request-&gt;session()-&gt;flush();</span><br><span class="line"></span><br><span class="line">        $request-&gt;session()-&gt;regenerate();</span><br><span class="line"></span><br><span class="line">        return redirect(&apos;/&apos;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意这一句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$request-&gt;session()-&gt;flush();</span><br></pre></td></tr></table></figure>
<p>将所有的 session 全部清除，这里不分前台、后台，所以要对这里进行改造。</p>
<p>因为前台、后台注销都要修改，所以我们新建一个 trait，前后台都可以使用。</p>
<p>新建一个文件 app/Extensions/AuthenticatesLogout.php <strong>这里需要新建 Extensions 文件夹，在Laravel5.3中是没有这个文件夹的</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace App\Extensions;</span><br><span class="line"></span><br><span class="line">use Illuminate\Http\Request;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">trait AuthenticatesLogout</span><br><span class="line">&#123;</span><br><span class="line">    public function logout(Request $request)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;guard()-&gt;logout();</span><br><span class="line"></span><br><span class="line">        $request-&gt;session()-&gt;forget($this-&gt;guard()-&gt;getName());</span><br><span class="line"></span><br><span class="line">        $request-&gt;session()-&gt;regenerate();</span><br><span class="line"></span><br><span class="line">        return redirect(&apos;/&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$request-&gt;session()-&gt;flush();</span><br></pre></td></tr></table></figure>
<p>改成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$request-&gt;session()-&gt;forget($this-&gt;guard()-&gt;getName());</span><br></pre></td></tr></table></figure>
<p>只是删除掉当前 guard 所创建的 session，这样就达到了分别注销的目的。</p>
<p>修改 Auth/LoginController.php 和 Admin/LoginController.php，将</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use AuthenticatesUsers;</span><br></pre></td></tr></table></figure>
<p>改掉，在文件的前面别忘了加上 use 语句</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use App\Extensions\AuthenticatesLogout;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">class LoginController extends Controller</span><br><span class="line">&#123;</span><br><span class="line">    use AuthenticatesUsers, AuthenticatesLogout &#123;</span><br><span class="line">        AuthenticatesLogout::logout insteadof AuthenticatesUsers;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>到这里，就完成了整个不同用户表登录认证的过程。</p>
<p>Read More:</p>
<blockquote>
<p><a href="http://www.fullstack.pub/doc/1" target="_blank" rel="noopener">Laravel 5.3 不同用户表登录认证</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Laravel</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
        <tag>后台用户认证</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令 - netstat</title>
    <url>/2018/01/02/linuxnetstat/</url>
    <content><![CDATA[<h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][--ip]</span><br></pre></td></tr></table></figure>
<h3 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h3><p>Linux netstat命令用于显示网络状态，一般用于检验本机各端口的网络连接情况。netstat是在内核中访问网络及相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。</p>
<h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a / -all</td>
<td>显示所有连接中的Socket</td>
</tr>
<tr>
<td>-A&lt;网络类型&gt; / –&lt;网络类型&gt;</td>
<td>列出该网络类型连接中的相关地址</td>
</tr>
<tr>
<td>-c / –continuous</td>
<td>持续列出网络状态</td>
</tr>
<tr>
<td>-C / –cache</td>
<td>显示路由器配置的快取信息</td>
</tr>
<tr>
<td>-e / –extend</td>
<td>显示网络其他相关信息</td>
</tr>
<tr>
<td>-F / –fib</td>
<td>显示FIB</td>
</tr>
<tr>
<td>-g / –groups</td>
<td>显示多重广播功能群组组员名单</td>
</tr>
<tr>
<td>-h / –help</td>
<td>在线帮助</td>
</tr>
<tr>
<td>-i / –interfaces</td>
<td>显示网络界面信息表单</td>
</tr>
<tr>
<td>-l / –listening</td>
<td>显示监控中的服务器的Socket</td>
</tr>
<tr>
<td>-M / –masquerade</td>
<td>显示伪装的网络连线</td>
</tr>
<tr>
<td>-n / –numeric</td>
<td>直接使用IP地址，而不通过域名服务器</td>
</tr>
<tr>
<td>-N / –netlink / –symbolic</td>
<td>显示网络硬件外围设备的符号连接名称</td>
</tr>
<tr>
<td>-o / –timers</td>
<td>显示计时器</td>
</tr>
<tr>
<td>-p / –programs</td>
<td>显示正在使用Socket的程序识别码和程序名称</td>
</tr>
<tr>
<td>-r / –route</td>
<td>显示路由表</td>
</tr>
<tr>
<td>-s / –statistice</td>
<td>显示网络工作信息统计表</td>
</tr>
<tr>
<td>-t / –tcp</td>
<td>显示TCP传输协议的连线状况</td>
</tr>
<tr>
<td>-u / –udp</td>
<td>显示UDP传输协议的连线状况</td>
</tr>
<tr>
<td>-v / –verbose</td>
<td>显示指令执行过程</td>
</tr>
<tr>
<td>-V / –version</td>
<td>显示版本信息</td>
</tr>
<tr>
<td>-w / –raw</td>
<td>显示RAW传输协议的连线状况</td>
</tr>
<tr>
<td>-x / –unix</td>
<td>此参数的效果和指定”-A unix”参数相同</td>
</tr>
<tr>
<td>–ip / –inet</td>
<td>此参数的效果和指定”-A inet”参数相同</td>
</tr>
</tbody>
</table>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><ul>
<li>netstat</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address               Foreign Address             State      </span><br><span class="line">tcp        0      0 hcdn-others-worker-de:62710 10.15.207.143:8433          ESTABLISHED </span><br><span class="line">tcp        0      0 hcdn-others-worker-de:30881 openlive-hbase-online:websm ESTABLISHED </span><br><span class="line">tcp        0      0 hcdn-others-worker-dev:9546 10.153.149.218:XmlIpcRegSvc ESTABLISHED </span><br><span class="line">tcp        0      0 hcdn-others-worker-de:53486 10.153.149.192:XmlIpcRegSvc ESTABLISHED </span><br><span class="line">tcp        0      0 hcdn-others-worker-de:38198 10.153.149.213:XmlIpcRegSvc ESTABLISHED </span><br><span class="line">tcp        0      0 hcdn-others-worker-de:24007 10.153.149.214:XmlIpcRegSvc ESTABLISHED </span><br><span class="line">Active UNIX domain sockets (w/o servers)</span><br><span class="line">Proto RefCnt Flags       Type       State         I-Node Path</span><br><span class="line">unix  2      [ ]         DGRAM                    17227  @/org/freedesktop/hal/udev_event</span><br><span class="line">unix  2      [ ]         DGRAM                    12672370 @/org/kernel/udev/udevd</span><br><span class="line">unix  3      [ ]         STREAM     CONNECTED     253334334 </span><br><span class="line">unix  3      [ ]         STREAM     CONNECTED     253334333</span><br></pre></td></tr></table></figure>
<p><code>netstat</code> 命令的输出结果可以分为两个部分：Active Internet connections（有源TCP连接），其中”Recv-Q”和”Send-Q”指的是接收队列和发送队列，这些数字一般都应该是0，如果不是则表示软件包正在队列中堆积；Active UNIX domain sockets（有源Unix域套接口），和网络套接字一样，但只能用于本机通信，性能可以提高一倍。</p>
<p>Proto显示连接使用的协议，RefCnt显示连接到本套接口上的进程号，Type显示套接口的类型，State显示套接口当前的状态，Path表示连接到套接口的其它进程使用的路径名。</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>LISTEN</td>
<td>侦听来自远方的TCP端口的连接请求</td>
</tr>
<tr>
<td>SYN-SENT</td>
<td>在发送连接请求后等待匹配的连接请求</td>
</tr>
<tr>
<td>SYN-RECEIVED</td>
<td>在收到和发送一个连接请求后等待对方对连接请求的确认</td>
</tr>
<tr>
<td>ESTABLISHED</td>
<td>一个打开的连接</td>
</tr>
<tr>
<td>FIN-WAIT-1</td>
<td>等待远程TCP连接中断请求，或先前的连接中断请求的确认</td>
</tr>
<tr>
<td>FIN-WAIT-2</td>
<td>从远程TCP等待连接中断请求</td>
</tr>
<tr>
<td>CLOSE-WAIT</td>
<td>等待从本地用户发来的连接中断请求</td>
</tr>
<tr>
<td>CLOSING</td>
<td>等待远程TCP对连接中断的确认</td>
</tr>
<tr>
<td>LAST-ACK</td>
<td>等待原来的发向远程TCP的连接中断请求的确认</td>
</tr>
<tr>
<td>TIME-WAIT</td>
<td>等待足够的时间以确保远程TCP接收到连接中断请求的确认</td>
</tr>
<tr>
<td>CLOSED</td>
<td>没有任何连接状态</td>
</tr>
</tbody>
</table>
<ul>
<li>netstat -a</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address               Foreign Address             State      </span><br><span class="line">tcp        0      0 *:tproxy                    *:*                         LISTEN      </span><br><span class="line">tcp        0      0 *:us-cli                    *:*                         LISTEN      </span><br><span class="line">tcp        0      0 *:us-srv                    *:*                         LISTEN      </span><br><span class="line">tcp        0      0 *:intu-ec-svcdisc           *:*                         LISTEN      </span><br><span class="line">Active UNIX domain sockets (servers and established)</span><br><span class="line">Proto RefCnt Flags       Type       State         I-Node Path</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     12688527 /var/run/abrt/abrt.socket</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     288268830 /tmp/supervisor.sock.3241</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     7341   @/com/ubuntu/upstart</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     17201  @/var/run/hald/dbus-vA2CSxY4CU</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     17196  @/var/run/hald/dbus-5pcejJb6np</span><br><span class="line">unix  2      [ ]         DGRAM                    17227  @/org/freedesktop/hal/udev_event</span><br></pre></td></tr></table></figure>
<p>显示所有有效连接的列表，包括ESTABLISHED、LISTENING的连接。</p>
<ul>
<li>netstat -nu</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address               Foreign Address             State</span><br></pre></td></tr></table></figure>
<p>显示当前UDP的连接情况</p>
<ul>
<li>netstat -apu</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address       Foreign Address             State       PID/Program name </span><br><span class="line">udp        0      0 *:947               *:*                                     1200/rpcbind     </span><br><span class="line">udp        0      0 *:domain            *:*                                     9306/dnsmasq     </span><br><span class="line">udp        0      0 *:983               *:*                                     1231/rpc.statd   </span><br><span class="line">udp        0      0 *:sunrpc            *:*                                     1200/rpcbind     </span><br><span class="line">udp        0      0 *:ipp               *:*                                     1141/portreserve </span><br><span class="line">udp        0      0 hcdn-others-worker-dev10:ntp *:*                            4247/ntpd       </span><br><span class="line">udp        0      0 localhost:ntp       *:*                                     4247/ntpd       </span><br><span class="line">udp        0      0 *:ntp               *:*                                     4247/ntpd       </span><br><span class="line">udp        0      0 *:62630             *:*                                     1231/rpc.statd</span><br></pre></td></tr></table></figure>
<p>显示UDP端口号的使用情况</p>
<ul>
<li>netstat -i</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Kernel Interface table</span><br><span class="line">Iface       MTU Met    RX-OK RX-ERR RX-DRP RX-OVR    TX-OK TX-ERR TX-DRP TX-OVR Flg</span><br><span class="line">eth0       1500   0 2334710561      0      0      0 2493027803      0      0      0 BMRU</span><br><span class="line">lo        65536   0 199796252      0      0      0 199796252      0      0      0 LRU</span><br></pre></td></tr></table></figure>
<p>显示网卡列表</p>
<ul>
<li>netstat -g</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IPv6/IPv4 Group Memberships</span><br><span class="line">Interface       RefCnt Group</span><br><span class="line">--------------- ------ ---------------------</span><br><span class="line">lo              1      all-systems.mcast.net</span><br><span class="line">eth0            1      all-systems.mcast.net</span><br></pre></td></tr></table></figure>
<p>显示组播组的关系</p>
<ul>
<li>netstat -s</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Ip:</span><br><span class="line">    2402314477 total packets received</span><br><span class="line">    0 forwarded</span><br><span class="line">    0 incoming packets discarded</span><br><span class="line">    2331780718 incoming packets delivered</span><br><span class="line">    2692824123 requests sent out</span><br><span class="line">Icmp:</span><br><span class="line">    484304 ICMP messages received</span><br><span class="line">    0 input ICMP message failed.</span><br><span class="line">    ICMP input histogram:</span><br><span class="line">        destination unreachable: 159</span><br><span class="line">        timeout in transit: 3</span><br><span class="line">        echo requests: 83130</span><br><span class="line">        echo replies: 400987</span><br><span class="line">        timestamp request: 25</span><br><span class="line">    505861 ICMP messages sent</span><br><span class="line">    0 ICMP messages failed</span><br><span class="line">    ICMP output histogram:</span><br><span class="line">        destination unreachable: 21437</span><br><span class="line">        echo request: 401269</span><br><span class="line">        echo replies: 83130</span><br><span class="line">        timestamp replies: 25</span><br><span class="line">IcmpMsg:</span><br><span class="line">        InType0: 400987</span><br><span class="line">        InType3: 159</span><br><span class="line">        InType8: 83130</span><br><span class="line">        InType11: 3</span><br><span class="line">        InType13: 25</span><br><span class="line">        OutType0: 83130</span><br><span class="line">        OutType3: 21437</span><br><span class="line">        OutType8: 401269</span><br><span class="line">        OutType14: 25</span><br><span class="line">Tcp:</span><br><span class="line">    62593872 active connections openings</span><br><span class="line">    177834 passive connection openings</span><br><span class="line">    153086 failed connection attempts</span><br><span class="line">    999 connection resets received</span><br><span class="line">    89 connections established</span><br><span class="line">    2250692557 segments received</span><br><span class="line">    2608392230 segments send out</span><br><span class="line">    3325843 segments retransmited</span><br><span class="line">    132 bad segments received.</span><br><span class="line">    610130 resets sent</span><br><span class="line">Udp:</span><br><span class="line">    80565656 packets received</span><br><span class="line">    21451 packets to unknown port received.</span><br><span class="line">    0 packet receive errors</span><br><span class="line">    80600189 packets sent</span><br><span class="line">UdpLite:</span><br><span class="line">TcpExt:</span><br><span class="line">    1100 invalid SYN cookies received</span><br><span class="line">    361 resets received for embryonic SYN_RECV sockets</span><br><span class="line">    466 packets pruned from receive queue because of socket buffer overrun</span><br><span class="line">    61819153 TCP sockets finished time wait in fast timer</span><br><span class="line">    2987 TCP sockets finished time wait in slow timer</span><br><span class="line">    660268 delayed acks sent</span><br><span class="line">    260 delayed acks further delayed because of locked socket</span><br><span class="line">    Quick ack mode was activated 1051984 times</span><br><span class="line">    25934905 packets directly queued to recvmsg prequeue.</span><br><span class="line">    911172308 packets directly received from backlog</span><br><span class="line">    3173278514 packets directly received from prequeue</span><br><span class="line">    1186216864 packets header predicted</span><br><span class="line">    3170682 packets header predicted and directly queued to user</span><br><span class="line">    357381509 acknowledgments not containing data received</span><br><span class="line">    411743100 predicted acknowledgments</span><br><span class="line">    1093102 times recovered from packet loss due to SACK data</span><br><span class="line">    Detected reordering 12642 times using FACK</span><br><span class="line">    Detected reordering 14884 times using SACK</span><br><span class="line">    Detected reordering 11 times using time stamp</span><br><span class="line">    13885 congestion windows fully recovered</span><br><span class="line">    252 congestion windows partially recovered using Hoe heuristic</span><br><span class="line">    TCPDSACKUndo: 193430</span><br><span class="line">    51009 congestion windows recovered after partial ack</span><br><span class="line">    168112 TCP data loss events</span><br><span class="line">    TCPLostRetransmit: 14829</span><br><span class="line">    108524 timeouts after SACK recovery</span><br><span class="line">    4274 timeouts in loss state</span><br><span class="line">    2496500 fast retransmits</span><br><span class="line">    158451 forward retransmits</span><br><span class="line">    230933 retransmits in slow start</span><br><span class="line">    280735 other TCP timeouts</span><br><span class="line">    38730 sack retransmits failed</span><br><span class="line">    23520 packets collapsed in receive queue due to low socket buffer</span><br><span class="line">    1051963 DSACKs sent for old packets</span><br><span class="line">    20 DSACKs sent for out of order packets</span><br><span class="line">    365231 DSACKs received</span><br><span class="line">    692 DSACKs for out of order packets received</span><br><span class="line">    414 connections reset due to unexpected data</span><br><span class="line">    896 connections reset due to early user close</span><br><span class="line">    761 connections aborted due to timeout</span><br><span class="line">    TCPDSACKIgnoredOld: 509</span><br><span class="line">    TCPDSACKIgnoredNoUndo: 425</span><br><span class="line">    TCPSackShiftFallback: 22772083</span><br><span class="line">    TCPBacklogDrop: 2192</span><br><span class="line">    TCPChallengeACK: 125</span><br><span class="line">    TCPSYNChallenge: 125</span><br><span class="line">    TCPFromZeroWindowAdv: 85</span><br><span class="line">    TCPToZeroWindowAdv: 85</span><br><span class="line">    TCPWantZeroWindowAdv: 163030</span><br><span class="line">IpExt:</span><br><span class="line">    InBcastPkts: 1232</span><br><span class="line">    InOctets: 1540584137119</span><br><span class="line">    OutOctets: 1474239597014</span><br><span class="line">    InBcastOctets: 191368</span><br></pre></td></tr></table></figure>
<p>显示网络统计信息</p>
<ul>
<li>netstat -l</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address               Foreign Address             State      </span><br><span class="line">tcp        0      0 *:tproxy                    *:*                         LISTEN      </span><br><span class="line">tcp        0      0 *:us-cli                    *:*                         LISTEN      </span><br><span class="line">tcp        0      0 *:us-srv                    *:*                         LISTEN      </span><br><span class="line">tcp        0      0 *:intu-ec-svcdisc           *:*                         LISTEN      </span><br><span class="line">tcp        0      0 *:intu-ec-client            *:*                         LISTEN      </span><br><span class="line">tcp        0      0 *:domain                    *:*                         LISTEN      </span><br><span class="line">tcp        0      0 *:oa-system                 *:*                         LISTEN      </span><br><span class="line">tcp        0      0 *:ssh                       *:*                         LISTEN      </span><br><span class="line">tcp        0      0 *:8023                      *:*                         LISTEN      </span><br><span class="line">tcp        0      0 localhost:smtp              *:*                         LISTEN      </span><br><span class="line">tcp        0      0 *:12602                     *:*                         LISTEN      </span><br><span class="line">tcp        0      0 hcdn-others-worker-de:27162 *:*                         LISTEN      </span><br><span class="line">tcp        0      0 *:30050                     *:*                         LISTEN      </span><br><span class="line">tcp        0      0 *:xmltec-xmlmail            *:*                         LISTEN      </span><br><span class="line">tcp        0      0 hcdn-others-worker-de:21988 *:*                         LISTEN      </span><br><span class="line">tcp        0      0 *:eforward                  *:*                         LISTEN      </span><br><span class="line">tcp        0      0 *:svn                       *:*                         LISTEN      </span><br><span class="line">tcp        0      0 *:16010                     *:*                         LISTEN      </span><br><span class="line">tcp        0      0 *:6379                      *:*                         LISTEN      </span><br><span class="line">tcp        0      0 *:23212                     *:*                         LISTEN      </span><br><span class="line">tcp        0      0 hcdn-others-worker-de:28271 *:*                         LISTEN      </span><br><span class="line">tcp        0      0 *:sunrpc                    *:*                         LISTEN      </span><br><span class="line">tcp        0      0 *:http                      *:*                         LISTEN      </span><br><span class="line">udp        0      0 *:947                       *:*                                     </span><br><span class="line">udp        0      0 *:domain                    *:*                                     </span><br><span class="line">udp        0      0 *:983                       *:*                                     </span><br><span class="line">udp        0      0 *:sunrpc                    *:*                                     </span><br><span class="line">udp        0      0 *:ipp                       *:*                                     </span><br><span class="line">udp        0      0 hcdn-others-worker-dev10:ntp *:*                                     </span><br><span class="line">udp        0      0 localhost:ntp               *:*                                     </span><br><span class="line">udp        0      0 *:ntp                       *:*                                     </span><br><span class="line">udp        0      0 *:62630                     *:*                                     </span><br><span class="line">Active UNIX domain sockets (only servers)</span><br><span class="line">Proto RefCnt Flags       Type       State         I-Node Path</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     12688527 /var/run/abrt/abrt.socket</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     288268830 /tmp/supervisor.sock.3241</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     7341   @/com/ubuntu/upstart</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     17201  @/var/run/hald/dbus-vA2CSxY4CU</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     17196  @/var/run/hald/dbus-5pcejJb6np</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     9429   /var/run/rpcbind.sock</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     9644   /var/run/cgred.socket</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     16960  /var/run/dbus/system_bus_socket</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     17142  /var/run/acpid.socket</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     17754  /var/run/mcelog-client</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     18360  public/cleanup</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     18367  private/tlsmgr</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     18376  private/rewrite</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     18384  private/bounce</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     18388  private/defer</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     18392  private/trace</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     18397  private/verify</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     18401  public/flush</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     18405  private/proxymap</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     18409  private/proxywrite</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     18413  private/smtp</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     18417  private/relay</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     18421  public/showq</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     18425  private/error</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     18429  private/retry</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     18433  private/discard</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     18437  private/local</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     18441  private/virtual</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     18445  private/lmtp</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     18449  private/anvil</span><br><span class="line">unix  2      [ ACC ]     STREAM     LISTENING     18453  private/scache</span><br></pre></td></tr></table></figure>
<p>显示监听的套接口</p>
<ul>
<li>netstat -ap | grep python3</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcp        0      0 *:us-srv            *:*                         LISTEN      15484/python3   </span><br><span class="line">tcp        0      0 *:xmltec-xmlmail    *:*                         LISTEN      14886/python3</span><br></pre></td></tr></table></figure>
<p>显示程序运行的端口</p>
<p>然后利用<code>ps -ef | grep &#39;15484&#39;</code> 命令可查找该端口运行的程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root      6262   946  0 15:45 pts/0    00:00:00 grep 15484</span><br><span class="line">root     15484     1  0  2017 ?        00:00:01 python3 /home/ly/atsbtsp/app.py</span><br></pre></td></tr></table></figure>
<p>Read More：</p>
<blockquote>
<p><a href="http://www.cnblogs.com/peida/archive/2013/03/08/2949194.html" target="_blank" rel="noopener">每天一个linux命令（56）：netstat命令</a> <a href="http://www.runoob.com/linux/linux-comm-netstat.html" target="_blank" rel="noopener">Linux netstat命令</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>Linux/Unix</category>
      </categories>
      <tags>
        <tag>命令</tag>
        <tag>Linux</tag>
        <tag>netstat</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令 - ls</title>
    <url>/2018/04/15/linuxls/</url>
    <content><![CDATA[<p>Linux ls命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录），在Linux中是使用率较高的命令，ls命令的输出信息可以进行彩色加亮显示，以区分不同类型的文件。</p>
<h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure>
<h4 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h4><p>列出目标目录中所有的子目录和文件。</p>
<h4 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h4><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>显示所有文件及目录（ls内定将文件名或目录名称开头为”.”的视为隐藏档，不会列出）</td>
</tr>
<tr>
<td>-A</td>
<td>同 -a ，但不列出 “.”（当前目录）及 “..”（父目录）</td>
</tr>
<tr>
<td>-C</td>
<td>多列显示输出结果。这是默认选项</td>
</tr>
<tr>
<td>-l</td>
<td>除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</td>
</tr>
<tr>
<td>-F</td>
<td>在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“</td>
</tr>
<tr>
<td>-c</td>
<td>与”-lt”选项连用时，按照文件状态时间排序输出目录内容，排序的依据是文件的索引节点中的ctime字段。与”-l”选项连用时，则排序的一句是文件的状态改变时间</td>
</tr>
<tr>
<td>-d</td>
<td>仅显示目录名，而不显示目录下的内容列表。显示符号链接文件本身，而不显示其所指向的目录列表</td>
</tr>
<tr>
<td>-f</td>
<td>此参数的效果和同时指定”aU”参数相同，并关闭”lst”参数的效果；</td>
</tr>
<tr>
<td>-i</td>
<td>显示文件索引节点号（inode）。一个索引节点代表一个文件</td>
</tr>
<tr>
<td>-k</td>
<td>以KB（千字节）为单位显示文件大小</td>
</tr>
<tr>
<td>-m</td>
<td>用”,”号区隔每个文件和目录的名称</td>
</tr>
<tr>
<td>-n</td>
<td>以用户识别码和群组识别码替代其名称</td>
</tr>
<tr>
<td>-r</td>
<td>将文件以相反次序显示(原定依英文字母次序)</td>
</tr>
<tr>
<td>-s</td>
<td>显示文件和目录的大小，以区块为单位</td>
</tr>
<tr>
<td>-t</td>
<td>将文件依建立时间之先后次序列出</td>
</tr>
<tr>
<td>-L</td>
<td>如果遇到性质为符号链接的文件或目录，直接列出该链接所指向的原始文件或目录</td>
</tr>
<tr>
<td>-R</td>
<td>递归列出该目录中的所有文件</td>
</tr>
<tr>
<td>–full-time</td>
<td>列出完整的日期与时间</td>
</tr>
<tr>
<td>–color[=WHEN] (WHEN=never/always/auto)</td>
<td>使用不同的颜色高亮显示不同类型的</td>
</tr>
<tr>
<td>-g</td>
<td>类似 -l，但不列出所有者</td>
</tr>
<tr>
<td>-h</td>
<td>以容易理解的格式列出文件大小 (例如 1K 234M 2G)</td>
</tr>
<tr>
<td>-S</td>
<td>根据文件大小排序</td>
</tr>
<tr>
<td>-X</td>
<td>根据扩展名排序</td>
</tr>
<tr>
<td>-x</td>
<td>逐行列出项目而不是逐栏列出</td>
</tr>
</tbody>
</table>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><ul>
<li><code>ls -l ly</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt home]# ls -l ly</span><br><span class="line">total 48</span><br><span class="line">drwxr-xr-x  8 root root 4096 Dec 14 11:49 analysisweb</span><br><span class="line">drwxr-xr-x  9 root root 4096 Dec 28 16:19 atsbtsp</span><br><span class="line">drwxr-xr-x  2 root root 4096 Sep 12 14:37 auth_server_ratio</span><br><span class="line">drwxr-xr-x  7 root root 4096 Jan  2 10:10 datawritehbase</span><br><span class="line">drwxr-xr-x 10 root root 4096 Dec 13 14:54 hbasequeryweb</span><br><span class="line">drwxr-xr-x  7 root root 4096 Oct  9 18:46 live_alarm_monitor</span><br><span class="line">drwxr-xr-x  9 root root 4096 Oct 27 11:59 openrestywork</span><br><span class="line">drwxr-xr-x  9 root root 4096 Dec 27 16:20 prepullvidcs</span><br><span class="line">drwxr-xr-x  2 root root 4096 Nov 23 20:26 push_ffmpeg</span><br><span class="line">drwxr-xr-x  3 root root 4096 Jan  4 18:46 testkafka</span><br><span class="line">drwxr-xr-x  3 root root 4096 Nov 29 14:32 virtualenv</span><br><span class="line">drwxr-xr-x  5 root root 4096 Oct 12 10:27 xiu_server_stat</span><br></pre></td></tr></table></figure>
<p>单列显示某目录。</p>
<ul>
<li><code>ls</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt home]# ls</span><br><span class="line">ly  zabbix</span><br></pre></td></tr></table></figure>
<p>显示当前目录下非影藏文件与目录</p>
<ul>
<li><code>ls -a</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt home]# ls -a</span><br><span class="line">.  ..  ly  zabbix</span><br></pre></td></tr></table></figure>
<p>显示当前目录下包括影藏文件在内的所有文件列表</p>
<ul>
<li><code>ls -l</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt home]# </span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt home]# ls -l</span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x  15 root   root   4096 Jan  3 18:05 ly</span><br><span class="line">drwxr-xr-x.  2 zabbix zabbix 4096 Dec 21 18:05 zabbix</span><br></pre></td></tr></table></figure>
<p>输出长格式列表</p>
<ul>
<li><code>ls -i -l</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt home]# ls -i -l</span><br><span class="line">total 8</span><br><span class="line">393222 drwxr-xr-x  15 root   root   4096 Jan  3 18:05 ly</span><br><span class="line">393219 drwxr-xr-x.  2 zabbix zabbix 4096 Dec 21 18:05 zabbix</span><br></pre></td></tr></table></figure>
<p>输出文件的inode信息</p>
<ul>
<li><code>ls -m</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt home]# ls -m</span><br><span class="line">ly, zabbix</span><br></pre></td></tr></table></figure>
<p>水平输出文件列表</p>
<ul>
<li><code>ls -t -l</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt ~]# ls -t -l</span><br><span class="line">total 303312</span><br><span class="line">drwxr-xr-x   2 root root       4096 Jan  4 17:54 testtar</span><br><span class="line">drwxrwxr-x  10 root root       4096 Jan  4 15:21 librdkafka-0.11.1</span><br><span class="line">drwxr-xr-x  11 root root       4096 Jan  4 14:26 pykafka</span><br><span class="line">drwxr-xr-x   8 root root      12288 Jan  3 13:31 sarama</span><br><span class="line">drwxr-xr-x  10 root root       4096 Jan  3 13:26 go_kafka_client</span><br><span class="line">-rw-r--r--   1 root root     859238 Jan  3 13:01 librdkafka-0.11.1.tar.gz</span><br><span class="line">drwxrwxr-x   7  500   500      4096 Jan  2 11:40 node-v8.9.3-linux-x64</span><br><span class="line">drwxr-xr-x  10  502 games      4096 Jan  2 11:13 node-v8.9.3</span><br><span class="line">-rw-r--r--   1 root root   31121503 Dec  8 23:23 node-v8.9.3.tar.gz</span><br><span class="line">-rw-r--r--   1 root root   11395380 Dec  8 22:11 node-v8.9.3-linux-x64.tar.xz</span><br><span class="line">-rw-r--r--   1 root root    1723533 Dec  5 01:02 redis-4.0.6.tar.gz</span><br><span class="line">drwxrwxr-x   6 root root       4096 Dec  5 01:01 redis-4.0.6</span><br><span class="line">drwxrwxr-x   6 1000  1000      4096 Oct 27 11:35 openresty-1.11.2.5</span><br><span class="line">-rw-r--r--   1 root root    4183884 Oct 27 10:55 openresty-1.11.2.5.tar.gz</span><br><span class="line">drwxr-xr-x   9 1001  1001      4096 Aug 30 20:05 nginx-1.12.1</span><br><span class="line">drwxr-xr-x   9 1169  1169     12288 Aug 30 20:02 pcre-8.38</span><br><span class="line">-rw-r--r--   1 root root    2053336 Aug 30 19:55 pcre-8.38.tar.gz</span><br><span class="line">drwxr-xr-x  18 1000  1000      4096 Aug 28 15:15 Python-2.7.13</span><br><span class="line">drwxr-xr-x  11 1000 ftp        4096 Aug 22 12:01 thrift-0.10.0</span><br><span class="line">drwxr-xr-x  26 root root       4096 Aug 22 11:04 hbase-1.2.6</span><br><span class="line">drwxr-xr-x   7  501 games      4096 Aug 11 09:26 Twisted-17.5.0</span><br><span class="line">drwxr-xr-x  18  501   501      4096 Aug 11 09:13 Python-3.6.1</span><br><span class="line">-rw-r--r--   1 root root     981093 Jul 11 23:45 nginx-1.12.1.tar.gz</span><br><span class="line">-rw-r--r--   1 root root  194351104 Jul  7 15:25 long.flv</span><br><span class="line">-rw-r--r--   1 root root    3340748 Jun 20  2017 thrift-0.10.0.tar.gz</span><br><span class="line">-rw-r--r--   1 root root    2993816 Jun 11  2017 Twisted-17.5.0.tar.bz2</span><br><span class="line">-rw-r--r--   1 root root   16054584 May 29  2017 hbase-1.2.6-src.tar.gz</span><br><span class="line">-rw-r--r--   1 root root   22540566 Mar 21  2017 Python-3.6.1.tgz</span><br><span class="line">-rw-r--r--   1 root root   17076672 Dec 18  2016 Python-2.7.13.tgz</span><br><span class="line">-rw-r--r--   1 root root    1595408 Nov  7  2016 get-pip.py</span><br><span class="line">-rw-------.  1 root root       1267 Mar 12  2014 anaconda-ks.cfg</span><br><span class="line">-rw-r--r--   1 root root     197981 Apr 25  2009 pyOpenSSL-0.9.tar.gz</span><br><span class="line">drwxr-xr-x   9 1125  1125      4096 Apr 25  2009 pyOpenSSL-0.9</span><br></pre></td></tr></table></figure>
<p>最近修改的文件显示在最前面</p>
<ul>
<li><code>ls -F -l</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt ~]# ls -F -l</span><br><span class="line">total 303312</span><br><span class="line">-rw-------.  1 root root       1267 Mar 12  2014 anaconda-ks.cfg</span><br><span class="line">-rw-r--r--   1 root root    1595408 Nov  7  2016 get-pip.py</span><br><span class="line">drwxr-xr-x  10 root root       4096 Jan  3 13:26 go_kafka_client/</span><br><span class="line">drwxr-xr-x  26 root root       4096 Aug 22 11:04 hbase-1.2.6/</span><br><span class="line">-rw-r--r--   1 root root   16054584 May 29  2017 hbase-1.2.6-src.tar.gz</span><br><span class="line">drwxrwxr-x  10 root root       4096 Jan  4 15:21 librdkafka-0.11.1/</span><br><span class="line">-rw-r--r--   1 root root     859238 Jan  3 13:01 librdkafka-0.11.1.tar.gz</span><br><span class="line">-rw-r--r--   1 root root  194351104 Jul  7 15:25 long.flv</span><br><span class="line">drwxr-xr-x   9 1001  1001      4096 Aug 30 20:05 nginx-1.12.1/</span><br><span class="line">-rw-r--r--   1 root root     981093 Jul 11 23:45 nginx-1.12.1.tar.gz</span><br><span class="line">drwxr-xr-x  10  502 games      4096 Jan  2 11:13 node-v8.9.3/</span><br><span class="line">drwxrwxr-x   7  500   500      4096 Jan  2 11:40 node-v8.9.3-linux-x64/</span><br><span class="line">-rw-r--r--   1 root root   11395380 Dec  8 22:11 node-v8.9.3-linux-x64.tar.xz</span><br><span class="line">-rw-r--r--   1 root root   31121503 Dec  8 23:23 node-v8.9.3.tar.gz</span><br><span class="line">drwxrwxr-x   6 1000  1000      4096 Oct 27 11:35 openresty-1.11.2.5/</span><br><span class="line">-rw-r--r--   1 root root    4183884 Oct 27 10:55 openresty-1.11.2.5.tar.gz</span><br><span class="line">drwxr-xr-x   9 1169  1169     12288 Aug 30 20:02 pcre-8.38/</span><br><span class="line">-rw-r--r--   1 root root    2053336 Aug 30 19:55 pcre-8.38.tar.gz</span><br><span class="line">drwxr-xr-x  11 root root       4096 Jan  4 14:26 pykafka/</span><br><span class="line">drwxr-xr-x   9 1125  1125      4096 Apr 25  2009 pyOpenSSL-0.9/</span><br><span class="line">-rw-r--r--   1 root root     197981 Apr 25  2009 pyOpenSSL-0.9.tar.gz</span><br><span class="line">drwxr-xr-x  18 1000  1000      4096 Aug 28 15:15 Python-2.7.13/</span><br><span class="line">-rw-r--r--   1 root root   17076672 Dec 18  2016 Python-2.7.13.tgz</span><br><span class="line">drwxr-xr-x  18  501   501      4096 Aug 11 09:13 Python-3.6.1/</span><br><span class="line">-rw-r--r--   1 root root   22540566 Mar 21  2017 Python-3.6.1.tgz</span><br><span class="line">drwxrwxr-x   6 root root       4096 Dec  5 01:01 redis-4.0.6/</span><br><span class="line">-rw-r--r--   1 root root    1723533 Dec  5 01:02 redis-4.0.6.tar.gz</span><br><span class="line">drwxr-xr-x   8 root root      12288 Jan  3 13:31 sarama/</span><br><span class="line">drwxr-xr-x   2 root root       4096 Jan  4 17:54 testtar/</span><br><span class="line">drwxr-xr-x  11 1000 ftp        4096 Aug 22 12:01 thrift-0.10.0/</span><br><span class="line">-rw-r--r--   1 root root    3340748 Jun 20  2017 thrift-0.10.0.tar.gz</span><br><span class="line">drwxr-xr-x   7  501 games      4096 Aug 11 09:26 Twisted-17.5.0/</span><br><span class="line">-rw-r--r--   1 root root    2993816 Jun 11  2017 Twisted-17.5.0.tar.bz2</span><br></pre></td></tr></table></figure>
<p>安装特殊字符对文件进行分类</p>
<ul>
<li><code>ls -l --color=auto | ls -l --color=never | ls -l --color=always</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt ~]# ls -l --color=auto</span><br><span class="line">total 303312</span><br><span class="line">-rw-------.  1 root root       1267 Mar 12  2014 anaconda-ks.cfg</span><br><span class="line">-rw-r--r--   1 root root    1595408 Nov  7  2016 get-pip.py</span><br><span class="line">drwxr-xr-x  10 root root       4096 Jan  3 13:26 go_kafka_client</span><br><span class="line">drwxr-xr-x  26 root root       4096 Aug 22 11:04 hbase-1.2.6</span><br><span class="line">-rw-r--r--   1 root root   16054584 May 29  2017 hbase-1.2.6-src.tar.gz</span><br><span class="line">drwxrwxr-x  10 root root       4096 Jan  4 15:21 librdkafka-0.11.1</span><br><span class="line">-rw-r--r--   1 root root     859238 Jan  3 13:01 librdkafka-0.11.1.tar.gz</span><br><span class="line">-rw-r--r--   1 root root  194351104 Jul  7 15:25 long.flv</span><br><span class="line">drwxr-xr-x   9 1001  1001      4096 Aug 30 20:05 nginx-1.12.1</span><br><span class="line">-rw-r--r--   1 root root     981093 Jul 11 23:45 nginx-1.12.1.tar.gz</span><br><span class="line">drwxr-xr-x  10  502 games      4096 Jan  2 11:13 node-v8.9.3</span><br><span class="line">drwxrwxr-x   7  500   500      4096 Jan  2 11:40 node-v8.9.3-linux-x64</span><br><span class="line">-rw-r--r--   1 root root   11395380 Dec  8 22:11 node-v8.9.3-linux-x64.tar.xz</span><br><span class="line">-rw-r--r--   1 root root   31121503 Dec  8 23:23 node-v8.9.3.tar.gz</span><br><span class="line">drwxrwxr-x   6 1000  1000      4096 Oct 27 11:35 openresty-1.11.2.5</span><br><span class="line">-rw-r--r--   1 root root    4183884 Oct 27 10:55 openresty-1.11.2.5.tar.gz</span><br><span class="line">drwxr-xr-x   9 1169  1169     12288 Aug 30 20:02 pcre-8.38</span><br><span class="line">-rw-r--r--   1 root root    2053336 Aug 30 19:55 pcre-8.38.tar.gz</span><br><span class="line">drwxr-xr-x  11 root root       4096 Jan  4 14:26 pykafka</span><br><span class="line">drwxr-xr-x   9 1125  1125      4096 Apr 25  2009 pyOpenSSL-0.9</span><br><span class="line">-rw-r--r--   1 root root     197981 Apr 25  2009 pyOpenSSL-0.9.tar.gz</span><br><span class="line">drwxr-xr-x  18 1000  1000      4096 Aug 28 15:15 Python-2.7.13</span><br><span class="line">-rw-r--r--   1 root root   17076672 Dec 18  2016 Python-2.7.13.tgz</span><br><span class="line">drwxr-xr-x  18  501   501      4096 Aug 11 09:13 Python-3.6.1</span><br><span class="line">-rw-r--r--   1 root root   22540566 Mar 21  2017 Python-3.6.1.tgz</span><br><span class="line">drwxrwxr-x   6 root root       4096 Dec  5 01:01 redis-4.0.6</span><br><span class="line">-rw-r--r--   1 root root    1723533 Dec  5 01:02 redis-4.0.6.tar.gz</span><br><span class="line">drwxr-xr-x   8 root root      12288 Jan  3 13:31 sarama</span><br><span class="line">drwxr-xr-x   2 root root       4096 Jan  4 17:54 testtar</span><br><span class="line">drwxr-xr-x  11 1000 ftp        4096 Aug 22 12:01 thrift-0.10.0</span><br><span class="line">-rw-r--r--   1 root root    3340748 Jun 20  2017 thrift-0.10.0.tar.gz</span><br><span class="line">drwxr-xr-x   7  501 games      4096 Aug 11 09:26 Twisted-17.5.0</span><br><span class="line">-rw-r--r--   1 root root    2993816 Jun 11  2017 Twisted-17.5.0.tar.bz2</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt ~]# ls -l --color=never</span><br><span class="line">total 303312</span><br><span class="line">-rw-------.  1 root root       1267 Mar 12  2014 anaconda-ks.cfg</span><br><span class="line">-rw-r--r--   1 root root    1595408 Nov  7  2016 get-pip.py</span><br><span class="line">drwxr-xr-x  10 root root       4096 Jan  3 13:26 go_kafka_client</span><br><span class="line">drwxr-xr-x  26 root root       4096 Aug 22 11:04 hbase-1.2.6</span><br><span class="line">-rw-r--r--   1 root root   16054584 May 29  2017 hbase-1.2.6-src.tar.gz</span><br><span class="line">drwxrwxr-x  10 root root       4096 Jan  4 15:21 librdkafka-0.11.1</span><br><span class="line">-rw-r--r--   1 root root     859238 Jan  3 13:01 librdkafka-0.11.1.tar.gz</span><br><span class="line">-rw-r--r--   1 root root  194351104 Jul  7 15:25 long.flv</span><br><span class="line">drwxr-xr-x   9 1001  1001      4096 Aug 30 20:05 nginx-1.12.1</span><br><span class="line">-rw-r--r--   1 root root     981093 Jul 11 23:45 nginx-1.12.1.tar.gz</span><br><span class="line">drwxr-xr-x  10  502 games      4096 Jan  2 11:13 node-v8.9.3</span><br><span class="line">drwxrwxr-x   7  500   500      4096 Jan  2 11:40 node-v8.9.3-linux-x64</span><br><span class="line">-rw-r--r--   1 root root   11395380 Dec  8 22:11 node-v8.9.3-linux-x64.tar.xz</span><br><span class="line">-rw-r--r--   1 root root   31121503 Dec  8 23:23 node-v8.9.3.tar.gz</span><br><span class="line">drwxrwxr-x   6 1000  1000      4096 Oct 27 11:35 openresty-1.11.2.5</span><br><span class="line">-rw-r--r--   1 root root    4183884 Oct 27 10:55 openresty-1.11.2.5.tar.gz</span><br><span class="line">drwxr-xr-x   9 1169  1169     12288 Aug 30 20:02 pcre-8.38</span><br><span class="line">-rw-r--r--   1 root root    2053336 Aug 30 19:55 pcre-8.38.tar.gz</span><br><span class="line">drwxr-xr-x  11 root root       4096 Jan  4 14:26 pykafka</span><br><span class="line">drwxr-xr-x   9 1125  1125      4096 Apr 25  2009 pyOpenSSL-0.9</span><br><span class="line">-rw-r--r--   1 root root     197981 Apr 25  2009 pyOpenSSL-0.9.tar.gz</span><br><span class="line">drwxr-xr-x  18 1000  1000      4096 Aug 28 15:15 Python-2.7.13</span><br><span class="line">-rw-r--r--   1 root root   17076672 Dec 18  2016 Python-2.7.13.tgz</span><br><span class="line">drwxr-xr-x  18  501   501      4096 Aug 11 09:13 Python-3.6.1</span><br><span class="line">-rw-r--r--   1 root root   22540566 Mar 21  2017 Python-3.6.1.tgz</span><br><span class="line">drwxrwxr-x   6 root root       4096 Dec  5 01:01 redis-4.0.6</span><br><span class="line">-rw-r--r--   1 root root    1723533 Dec  5 01:02 redis-4.0.6.tar.gz</span><br><span class="line">drwxr-xr-x   8 root root      12288 Jan  3 13:31 sarama</span><br><span class="line">drwxr-xr-x   2 root root       4096 Jan  4 17:54 testtar</span><br><span class="line">drwxr-xr-x  11 1000 ftp        4096 Aug 22 12:01 thrift-0.10.0</span><br><span class="line">-rw-r--r--   1 root root    3340748 Jun 20  2017 thrift-0.10.0.tar.gz</span><br><span class="line">drwxr-xr-x   7  501 games      4096 Aug 11 09:26 Twisted-17.5.0</span><br><span class="line">-rw-r--r--   1 root root    2993816 Jun 11  2017 Twisted-17.5.0.tar.bz2</span><br><span class="line">[root@hcdn-others-worker-dev100-bjlt ~]# ls -l --color=always</span><br><span class="line">total 303312</span><br><span class="line">-rw-------.  1 root root       1267 Mar 12  2014 anaconda-ks.cfg</span><br><span class="line">-rw-r--r--   1 root root    1595408 Nov  7  2016 get-pip.py</span><br><span class="line">drwxr-xr-x  10 root root       4096 Jan  3 13:26 go_kafka_client</span><br><span class="line">drwxr-xr-x  26 root root       4096 Aug 22 11:04 hbase-1.2.6</span><br><span class="line">-rw-r--r--   1 root root   16054584 May 29  2017 hbase-1.2.6-src.tar.gz</span><br><span class="line">drwxrwxr-x  10 root root       4096 Jan  4 15:21 librdkafka-0.11.1</span><br><span class="line">-rw-r--r--   1 root root     859238 Jan  3 13:01 librdkafka-0.11.1.tar.gz</span><br><span class="line">-rw-r--r--   1 root root  194351104 Jul  7 15:25 long.flv</span><br><span class="line">drwxr-xr-x   9 1001  1001      4096 Aug 30 20:05 nginx-1.12.1</span><br><span class="line">-rw-r--r--   1 root root     981093 Jul 11 23:45 nginx-1.12.1.tar.gz</span><br><span class="line">drwxr-xr-x  10  502 games      4096 Jan  2 11:13 node-v8.9.3</span><br><span class="line">drwxrwxr-x   7  500   500      4096 Jan  2 11:40 node-v8.9.3-linux-x64</span><br><span class="line">-rw-r--r--   1 root root   11395380 Dec  8 22:11 node-v8.9.3-linux-x64.tar.xz</span><br><span class="line">-rw-r--r--   1 root root   31121503 Dec  8 23:23 node-v8.9.3.tar.gz</span><br><span class="line">drwxrwxr-x   6 1000  1000      4096 Oct 27 11:35 openresty-1.11.2.5</span><br><span class="line">-rw-r--r--   1 root root    4183884 Oct 27 10:55 openresty-1.11.2.5.tar.gz</span><br><span class="line">drwxr-xr-x   9 1169  1169     12288 Aug 30 20:02 pcre-8.38</span><br><span class="line">-rw-r--r--   1 root root    2053336 Aug 30 19:55 pcre-8.38.tar.gz</span><br><span class="line">drwxr-xr-x  11 root root       4096 Jan  4 14:26 pykafka</span><br><span class="line">drwxr-xr-x   9 1125  1125      4096 Apr 25  2009 pyOpenSSL-0.9</span><br><span class="line">-rw-r--r--   1 root root     197981 Apr 25  2009 pyOpenSSL-0.9.tar.gz</span><br><span class="line">drwxr-xr-x  18 1000  1000      4096 Aug 28 15:15 Python-2.7.13</span><br><span class="line">-rw-r--r--   1 root root   17076672 Dec 18  2016 Python-2.7.13.tgz</span><br><span class="line">drwxr-xr-x  18  501   501      4096 Aug 11 09:13 Python-3.6.1</span><br><span class="line">-rw-r--r--   1 root root   22540566 Mar 21  2017 Python-3.6.1.tgz</span><br><span class="line">drwxrwxr-x   6 root root       4096 Dec  5 01:01 redis-4.0.6</span><br><span class="line">-rw-r--r--   1 root root    1723533 Dec  5 01:02 redis-4.0.6.tar.gz</span><br><span class="line">drwxr-xr-x   8 root root      12288 Jan  3 13:31 sarama</span><br><span class="line">drwxr-xr-x   2 root root       4096 Jan  4 17:54 testtar</span><br><span class="line">drwxr-xr-x  11 1000 ftp        4096 Aug 22 12:01 thrift-0.10.0</span><br><span class="line">-rw-r--r--   1 root root    3340748 Jun 20  2017 thrift-0.10.0.tar.gz</span><br><span class="line">drwxr-xr-x   7  501 games      4096 Aug 11 09:26 Twisted-17.5.0</span><br><span class="line">-rw-r--r--   1 root root    2993816 Jun 11  2017 Twisted-17.5.0.tar.bz2</span><br></pre></td></tr></table></figure>
<p>单列列出文件并标记颜色</p>
<ul>
<li><code>ls -l n*</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@hcdn-others-worker-dev100-bjlt ~]# ls -l n*</span><br><span class="line">-rw-r--r--  1 root root    981093 Jul 11 23:45 nginx-1.12.1.tar.gz</span><br><span class="line">-rw-r--r--  1 root root  11395380 Dec  8 22:11 node-v8.9.3-linux-x64.tar.xz</span><br><span class="line">-rw-r--r--  1 root root  31121503 Dec  8 23:23 node-v8.9.3.tar.gz</span><br><span class="line"></span><br><span class="line">nginx-1.12.1:</span><br><span class="line">total 732</span><br><span class="line">drwxr-xr-x 6 1001 1001   4096 Aug 30 20:00 auto</span><br><span class="line">-rw-r--r-- 1 1001 1001 277349 Jul 11 21:24 CHANGES</span><br><span class="line">-rw-r--r-- 1 1001 1001 422542 Jul 11 21:24 CHANGES.ru</span><br><span class="line">drwxr-xr-x 2 1001 1001   4096 Aug 30 20:00 conf</span><br><span class="line">-rwxr-xr-x 1 1001 1001   2481 Jul 11 21:24 configure</span><br><span class="line">drwxr-xr-x 4 1001 1001   4096 Aug 30 20:00 contrib</span><br><span class="line">drwxr-xr-x 2 1001 1001   4096 Aug 30 20:00 html</span><br><span class="line">-rw-r--r-- 1 1001 1001   1397 Jul 11 21:24 LICENSE</span><br><span class="line">-rw-r--r-- 1 root root    376 Aug 30 20:11 Makefile</span><br><span class="line">drwxr-xr-x 2 1001 1001   4096 Aug 30 20:00 man</span><br><span class="line">drwxr-xr-x 3 root root   4096 Aug 30 20:12 objs</span><br><span class="line">-rw-r--r-- 1 1001 1001     49 Jul 11 21:24 README</span><br><span class="line">drwxr-xr-x 9 1001 1001   4096 Aug 30 20:00 src</span><br><span class="line"></span><br><span class="line">node-v8.9.3:</span><br><span class="line">total 596</span><br><span class="line">-rwxr-xr-x  1  502 games  1944 Dec  8 23:22 android-configure</span><br><span class="line">-rw-r--r--  1  502 games 62552 Dec  8 23:22 AUTHORS</span><br><span class="line">drwxr-xr-x 32  502 games  4096 Jan  2 11:13 benchmark</span><br><span class="line">-rw-r--r--  1  502 games   263 Dec  8 23:22 BSDmakefile</span><br><span class="line">-rw-r--r--  1  502 games 13117 Dec  8 23:22 BUILDING.md</span><br><span class="line">-rw-r--r--  1  502 games 53576 Dec  8 23:22 CHANGELOG.md</span><br><span class="line">-rw-r--r--  1  502 games   181 Dec  8 23:22 CODE_OF_CONDUCT.md</span><br><span class="line">-rw-r--r--  1  502 games 30242 Dec  8 23:22 COLLABORATOR_GUIDE.md</span><br><span class="line">-rw-r--r--  1  502 games 14659 Dec  8 23:22 common.gypi</span><br><span class="line">-rw-r--r--  1 root root   2748 Jan  2 11:13 config.gypi</span><br><span class="line">-rw-r--r--  1 root root    223 Jan  2 11:13 config.mk</span><br><span class="line">-rwxr-xr-x  1  502 games 50245 Dec  8 23:22 configure</span><br><span class="line">-rw-r--r--  1  502 games 37017 Dec  8 23:22 CONTRIBUTING.md</span><br><span class="line">-rw-r--r--  1  502 games  3454 Dec  8 23:22 CPP_STYLE_GUIDE.md</span><br><span class="line">drwxr-xr-x 13  502 games  4096 Jan  2 11:13 deps</span><br><span class="line">drwxr-xr-x  6  502 games  4096 Jan  2 11:13 doc</span><br><span class="line">-rw-r--r--  1  502 games  5832 Dec  8 23:22 GOVERNANCE.md</span><br><span class="line">-rw-r--r--  1 root root  60153 Jan  2 11:13 icu_config.gypi</span><br><span class="line">drwxr-xr-x  3  502 games  4096 Jan  2 11:13 lib</span><br><span class="line">-rw-r--r--  1  502 games 59059 Dec  8 23:22 LICENSE</span><br><span class="line">-rw-r--r--  1  502 games 37468 Dec  8 23:22 Makefile</span><br><span class="line">-rw-r--r--  1  502 games 24881 Dec  8 23:23 node.gyp</span><br><span class="line">-rw-r--r--  1  502 games 10585 Dec  8 23:23 node.gypi</span><br><span class="line">drwxr-xr-x  5 root root   4096 Jan  2 11:14 out</span><br><span class="line">-rw-r--r--  1  502 games 26525 Dec  8 23:22 README.md</span><br><span class="line">drwxr-xr-x  4  502 games  4096 Jan  2 11:13 src</span><br><span class="line">drwxr-xr-x 22  502 games  4096 Jan  2 11:13 test</span><br><span class="line">drwxr-xr-x  9  502 games  4096 Jan  2 11:13 tools</span><br><span class="line">-rw-r--r--  1  502 games 24869 Dec  8 23:23 vcbuild.bat</span><br><span class="line"></span><br><span class="line">node-v8.9.3-linux-x64:</span><br><span class="line">total 164</span><br><span class="line">drwxrwxr-x 2  500  500  4096 Jan  2 12:14 bin</span><br><span class="line">-rw-rw-r-- 1  500  500 53576 Dec  8 22:10 CHANGELOG.md</span><br><span class="line">drwxr-xr-x 2 root root  4096 Jan  2 11:40 etc</span><br><span class="line">drwxrwxr-x 3  500  500  4096 Dec  8 22:10 include</span><br><span class="line">drwxrwxr-x 3  500  500  4096 Dec  8 22:10 lib</span><br><span class="line">-rw-rw-r-- 1  500  500 59059 Dec  8 22:10 LICENSE</span><br><span class="line">-rw-rw-r-- 1  500  500 26525 Dec  8 22:10 README.md</span><br><span class="line">drwxrwxr-x 5  500  500  4096 Dec  8 22:10 share</span><br></pre></td></tr></table></figure>
<p>单列列出以某个字符开头的文件和目录的详细内容</p>
<p>Read More: </p>
<blockquote>
<p><a href="http://www.cnblogs.com/peida/archive/2012/10/23/2734829.html" target="_blank" rel="noopener">每天一个linux命令(1)：ls命令</a> <a href="http://www.runoob.com/linux/linux-comm-ls.html" target="_blank" rel="noopener">Linux ls命令</a> <a href="http://man.linuxde.net/ls" target="_blank" rel="noopener">ls命令</a>  </p>
</blockquote>
]]></content>
      <categories>
        <category>Linux/Unix</category>
      </categories>
      <tags>
        <tag>命令</tag>
        <tag>Linux</tag>
        <tag>ls</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法总结</title>
    <url>/2017/04/11/phpsortalgorithm/</url>
    <content><![CDATA[<p>各种排序算法稳定性以及时间复杂度总结：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>排序方法</th>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>交换排序</td>
<td>冒泡排序</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>交换排序</td>
<td>快排</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n^2)</td>
<td>O(nlogn)</td>
<td>不稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>直接选择排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>堆排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>直接插入排序</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>希尔排序</td>
<td>O(n^1.5)</td>
<td>O(n)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>未分类</td>
<td>归并排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td>未分类</td>
<td>基数排序</td>
<td>O(d(n+r))</td>
<td>O(d(n+rd))</td>
<td>O(d(n+r))</td>
<td>O(rd+n)</td>
<td>稳定</td>
</tr>
</tbody>
</table>
<p><strong>Note</strong>：logn代表以2为底n的对数。</p>
<p>当原表有序或基本有序时，<strong>直接插入排序</strong>和<strong>冒泡排序</strong>将大大减少比较次数和移动记录的次数，时间复杂度可降至O(n)；而<strong>快速排序</strong>则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为O(n^2)；原表是否有序，对<strong>直接选择排序</strong>、<strong>堆排序</strong>、<strong>归并排序</strong>和<strong>基数排序</strong>的时间复杂度影响不大。</p>
<h3 id="排序算法的稳定性说明"><a href="#排序算法的稳定性说明" class="headerlink" title="排序算法的稳定性说明"></a><strong>排序算法的稳定性说明</strong></h3><p>若待排序的序列中，存在多个具有相同关键字的记录，经过排序，这些记录的相对次序保持不变，则称该算法是稳定的；若经排序后，记录的相对次序发生了改变，则称该算法是不稳定的。 Example：</p>
<p>如果 Ai = Aj 且 Ai 原来在位置前，排序后Ai 还是要在 Aj 位置前。</p>
<p>稳定性的好处：排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用。基数排序就是这样，先按低位排序，逐次按高位排序，低位相同的元素，其顺序在高位也相同时是不会改变的。另外，如果排序算法稳定，可以避免多余的比较；Example：</p>
<p><img src="/images/2017-4-11 185017.png" alt="2017-4-11 185017"></p>
<p>对于不稳定的算法我们可以这样改进：</p>
<p>在每个输入元素加一个 index，表示初始时的数组索引，当不稳定的算法排好序后，对于相同的元素对 index 排序即可。</p>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再把他们交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。</p>
<h4 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h4><p>快速排序有两个方向，左边的i下标一直往右走，当 a[i] &lt;= a[center_index]，其中 center_index 是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当 a[j] &gt; a[center_index]。如果i和j都走不动了，i &lt;= j，交换 a[i] 和 a[j]，重复上面的过程，直到i &gt; j。 交换a[j]和a[center_index]，完成一趟快速排序。在中枢元素和 a[j] 交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为5 3 3 4 3 8 9 10 11，现在中枢元素5和3（第5个元素，下标从1开始计）交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和 a[j] 交换的时刻。</p>
<h4 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h4><p>选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第 n 个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。</p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p>我们知道堆的结构是节点 i 的孩子为2 <em> i和2 </em> i + 1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n / 2开始和其子节点共3个值选择最大（大顶堆）或者最小（小顶堆），这3个元素之间的选择当然不会破坏稳定性。但当为n / 2 - 1， n / 2 - 2， … 1这些个父节点选择元素时，就会破坏稳定性。有可能第n / 2个父节点交换把后面一个元素交换过去了，而第n / 2 - 1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。</p>
<h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。</p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比O(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以希尔排序是不稳定的。</p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p>归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素（认为直接有序）或者2个序列（1次比较和交换），然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是否受到破坏？没有，合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，这样就保证了稳定性。所以，归并排序也是稳定的排序算法。</p>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。</p>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="冒泡排序-1"><a href="#冒泡排序-1" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p><strong>基本思想</strong></p>
<p>两个数比较大小，较大的数下沉，较小的数冒起来。</p>
<p><strong>过程</strong></p>
<p>比较相邻的两个数据，如果第二个数小，就交换位置；</p>
<p>从后向前两两比较，一直到比较最前两个数据。最终最小数被交换到起始的位置，这样第一个最小数的位置就排好了；<br>继续重复上述过程，依次将第2、3、……、n-1 个最小数排好位置。</p>
<p><img src="/images/2017-4-11 191243.png" alt="2017-4-11 191243"></p>
<p><strong>PHP代码实现</strong>、</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function MaoPao($sort_array)&#123;</span><br><span class="line">        for ($i = 0; $i &lt; count($sort_array); $i++) &#123;</span><br><span class="line">            for ($j = 0; $j &lt; count($sort_array) - $i - 1; $j++) &#123;</span><br><span class="line">                if ($sort_array[$j] &gt; $sort_array[$j + 1])&#123;</span><br><span class="line">                    $tmp = $sort_array[$j];</span><br><span class="line">                    $sort_array[$j] = $sort_array[$j + 1];</span><br><span class="line">                    $sort_array[$j + 1] = $tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return $sort_array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>优化</strong></p>
<p>冒泡排序的问题在于，数据的顺序排好之后，冒泡算法仍然会继续进行下一轮的比较，直到 count($sort_array)-1 次，后面的比较是没有意义的。</p>
<p>解决办法：我们可以设置标志位flag，如果发生了交换flag设置为true；如果没有交换就设置为false。这样当一轮比较结束后如果flag仍为false，即：这一轮没有发生交换，说明数据的顺序已经排好，没有必要继续进行下去。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function MaoPao($sort_array)&#123;</span><br><span class="line">        for ($i = 0; $i &lt; count($sort_array); $i++) &#123;</span><br><span class="line">            $flag = 0;</span><br><span class="line">            for ($j = 0; $j &lt; count($sort_array) - $i - 1; $j++) &#123;</span><br><span class="line">                if ($sort_array[$j] &gt; $sort_array[$j + 1])&#123;</span><br><span class="line">                    $tmp = $sort_array[$j];</span><br><span class="line">                    $sort_array[$j] = $sort_array[$j + 1];</span><br><span class="line">                    $sort_array[$j + 1] = $tmp;</span><br><span class="line">                    $flag = 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if ($flag == 0)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return $sort_array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="快排-1"><a href="#快排-1" class="headerlink" title="快排"></a>快排</h4><p><strong>基本思想</strong>：分治</p>
<p>先从数列中取出一个数作为key值；<br>将比这个数小的数全部放在它的左边，大于或等于它的数全部放在它的右边；<br>对左右两个小数列重复第二步，直至各区间只有1个数。</p>
<p><strong>PHP代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function Fast($sort_array)&#123;</span><br><span class="line">        $left_array = array();</span><br><span class="line">        $right_array = array();</span><br><span class="line">        $index = 1;</span><br><span class="line">        if (!is_array($sort_array))&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (count($sort_array) &lt;= 1)&#123;</span><br><span class="line">          return $sort_array;</span><br><span class="line">        &#125;</span><br><span class="line">        while ($index &lt; count($sort_array))&#123;</span><br><span class="line">            if ($sort_array[$index] &gt; $sort_array[0])&#123;</span><br><span class="line">                $right_array[] = $sort_array[$index];</span><br><span class="line">            &#125; elseif ($sort_array[$index] &lt;= $sort_array[0])&#123;</span><br><span class="line">                $left_array[] = $sort_array[$index];</span><br><span class="line">            &#125;</span><br><span class="line">            $index++;</span><br><span class="line">        &#125;</span><br><span class="line">        $left_array = $this-&gt;Fast($left_array);</span><br><span class="line">        $right_array = $this-&gt;Fast($right_array);</span><br><span class="line">        return array_merge($left_array, array($sort_array[0]), $right_array);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="直接选择排序-1"><a href="#直接选择排序-1" class="headerlink" title="直接选择排序"></a>直接选择排序</h4><p><strong>基本思想</strong></p>
<p>在长度为 n 的无序数组中，第一次遍历 n-1 个数，找到最小的数值与第一个元素交换；</p>
<p>第二次遍历 n-2 个数，找到最小的数值与第二个元素交换；</p>
<p>……</p>
<p>第 n-1 次遍历，找到最小的数值与第 n-1 个元素交换，排序完成。</p>
<p><strong>过程</strong></p>
<p><img src="/images/2017-4-11 194803.jpg" alt="2017-4-11 194803"></p>
<p><strong>PHP代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function Select($sort_array)&#123;</span><br><span class="line">        for ($i = 0; $i &lt; count($sort_array); $i++)&#123;</span><br><span class="line">            $min = $i;</span><br><span class="line">            for ($j = $i + 1; $j &lt; count($sort_array); $j++)&#123;</span><br><span class="line">                if ($sort_array[$min] &gt; $sort_array[$j])&#123;</span><br><span class="line">                    $min = $j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            $tmp = $sort_array[$min];</span><br><span class="line">            $sort_array[$min] = $sort_array[$i];</span><br><span class="line">            $sort_array[$i] = $tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        return $sort_array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h4><p><strong>基本思想</strong></p>
<p><img src="/images/2017-4-11 194932.jpg" alt="2017-4-11 194932"></p>
<p><strong>过程</strong></p>
<p>图示： （88,85,83,73,72,60,57,48,42,6）</p>
<p><img src="/images/2017-4-11 195018.jpg" alt="2017-4-11 195018"></p>
<p><strong>PHP代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function DuiPaiXu($sort_array)&#123;</span><br><span class="line">        $this-&gt;buildHeap($sort_array);</span><br><span class="line">        $count = count($sort_array);</span><br><span class="line">        while ($count &gt; 1) &#123;</span><br><span class="line">            $this-&gt;swap($sort_array, $count - 1, 0);</span><br><span class="line">            $count--;</span><br><span class="line">            $this-&gt;adjustHeap($sort_array, $count, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        return $sort_array;</span><br><span class="line">    &#125;</span><br><span class="line"> public function buildHeap(&amp;$arr)&#123;</span><br><span class="line">        $node = floor(count($arr) / 2) - 1;</span><br><span class="line">        for ($i = $node; $i &gt;= 0; $i--) &#123;</span><br><span class="line">            $this-&gt;adjustHeap($arr, count($arr), $i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public function adjustHeap(&amp;$arr, $maxLen, $node)&#123;</span><br><span class="line">        $left_child = 2 * $node + 1;</span><br><span class="line">        $right_child = 2 * $node + 2;</span><br><span class="line">        $max = $node;</span><br><span class="line">        while ($left_child &lt; $maxLen || $right_child &lt; $maxLen) &#123;</span><br><span class="line">            if ($left_child &lt; $maxLen &amp;&amp; $arr[$left_child] &gt; $arr[$max]) &#123;</span><br><span class="line">                $max = $left_child;</span><br><span class="line">            &#125;</span><br><span class="line">            if ($right_child &lt; $maxLen &amp;&amp; $arr[$right_child] &gt; $arr[$max]) &#123;</span><br><span class="line">                $max = $right_child;</span><br><span class="line">            &#125;</span><br><span class="line">            if ($max != $node) &#123;</span><br><span class="line">                $this-&gt;swap($arr, $max, $node);</span><br><span class="line">                $node   = $max;</span><br><span class="line">                $left_child = 2 * $node + 1;</span><br><span class="line">                $right_child = 2 * $node + 2;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">public function swap(&amp;$arr, $m, $n)&#123;</span><br><span class="line">        $arr[$m] = $arr[$m] ^ $arr[$n];</span><br><span class="line">        $arr[$n] = $arr[$n] ^ $arr[$m];</span><br><span class="line">        $arr[$m] = $arr[$m] ^ $arr[$n];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="直接插入排序-1"><a href="#直接插入排序-1" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p><strong>基本思想</strong></p>
<p>在要排序的一组数中，假定前 n-1 个数已经排好序，现在将第 n 个数插到前面的有序数列中，使得这 n 个数也是排好顺序的。如此反复循环，直到全部排好顺序。</p>
<p><strong>过程</strong></p>
<p><img src="/images/2017-4-11 195224.jpg" alt="2017-4-11 195224"></p>
<p><img src="/images/2017-4-11 195257.jpg" alt="2017-4-11 195257"></p>
<p><strong>PHP代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function ChaRu($sort_array)&#123;</span><br><span class="line">        for ($i = 2; $i &lt; count($sort_array); $i++)&#123;</span><br><span class="line">            $j = $i - 1;</span><br><span class="line">            $key = $sort_array[$i];</span><br><span class="line">            while ($j &gt;= 0 &amp;&amp; $sort_array[$j] &gt; $key)&#123;</span><br><span class="line">                $sort_array[$j + 1] = $sort_array[$j];</span><br><span class="line">                $j--;</span><br><span class="line">            &#125;</span><br><span class="line">            $sort_array[$j + 1] = $key;</span><br><span class="line">        &#125;</span><br><span class="line">        return $sort_array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="希尔排序-1"><a href="#希尔排序-1" class="headerlink" title="希尔排序"></a>希尔排序</h4><p><strong>基本思想</strong></p>
<p>在要排序的一组数中，根据某一增量分为若干子序列，并对子序列分别进行插入排序。然后逐渐将增量减小,并重复上述过程。直至增量为1,此时数据序列基本有序,最后进行插入排序。</p>
<p><strong>过程</strong></p>
<p><img src="/images/2017-4-11 195422.jpg" alt="2017-4-11 195422"></p>
<p><strong>PHP代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function XiErPaiXu($sort_array)&#123;</span><br><span class="line">        if (!is_array($sort_array))</span><br><span class="line">            return false;</span><br><span class="line">        $n = count($sort_array);</span><br><span class="line">        for ($gap = floor($n / 2); $gap &gt; 0; $gap = floor($gap /= 2)) &#123;</span><br><span class="line">            for ($i = $gap; $i &lt; $n; ++$i) &#123;</span><br><span class="line">                for ($j = $i - $gap; $j &gt;= 0 &amp;&amp; $sort_array[$j + $gap] &lt; $sort_array[$j]; $j -= $gap) &#123;</span><br><span class="line">                    $temp = $sort_array[$j];</span><br><span class="line">                    $sort_array[$j] = $sort_array[$j + $gap];</span><br><span class="line">                    $sort_array[$j + $gap] = $temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return $sort_array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h4><p><strong>基本思想</strong></p>
<p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。</p>
<p>首先考虑下如何将2个有序数列合并。这个非常简单，只要从比较2个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。</p>
<p>解决了上面的合并有序数列问题，再来看归并排序，其的基本思路就是将数组分成2组A，B，如果这2组组内的数据都是有序的，那么就可以很方便的将这2组数据进行排序。如何让这2组组内数据有序了？<br>可以将A，B组各自再分成2组。依次类推，当分出来的小组只有1个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的2个小组就可以了。这样通过<strong>先递归的分解数列</strong>，<strong>再合并数列</strong>就完成了归并排序。</p>
<p><strong>过程</strong></p>
<p><img src="/images/2017-4-11 195640.jpg" alt="2017-4-11 195640"></p>
<p><strong>PHP代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function GuiBing($sort_array)&#123;</span><br><span class="line">        $len = count($sort_array);</span><br><span class="line">        if($len &lt;= 1)</span><br><span class="line">            return $sort_array;</span><br><span class="line">        $mid = intval($len/2);</span><br><span class="line">        $left_arr = array_slice($sort_array, 0, $mid);</span><br><span class="line">        $right_arr = array_slice($sort_array, $mid);</span><br><span class="line">        $left_arr = $this-&gt;GuiBing($left_arr);</span><br><span class="line">        $right_arr = $this-&gt;GuiBing($right_arr);</span><br><span class="line">        $sort_array = $this-&gt;GuiBing_child($left_arr, $right_arr);</span><br><span class="line">        return $sort_array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public function GuiBing_child($arrA, $arrB)&#123;</span><br><span class="line">        $arrC = array();</span><br><span class="line">        while(count($arrA) &amp;&amp; count($arrB))&#123;</span><br><span class="line">            $arrC[] = $arrA[&apos;0&apos;] &lt; $arrB[&apos;0&apos;] ? array_shift($arrA) : array_shift($arrB);</span><br><span class="line">        &#125;</span><br><span class="line">        return array_merge($arrC, $arrA, $arrB);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="基数排序-1"><a href="#基数排序-1" class="headerlink" title="基数排序"></a>基数排序</h4><p><strong>基本思想</strong></p>
<p>我们知道，任何一个阿拉伯数，它的各个位数上的基数都是以0~9来表示的。假设我们有编号0~9的10个桶，遍历需要进行排序的各个值的个位，然后根据个位的数值放进相应的桶中，分类后，我们在从各个桶中，将这些数按照从编号0到编号9的顺序依次将所有数取出来。这时，得到的序列就是个位数上呈递增趋势的序列。 接下来，可以对十位数、百位数也按照这种方法进行排序，最后就能得到排序完成的序列。</p>
<p>基数排序适用于对位数较少的排序，位数较长会浪费空间。</p>
<p>基数排序的平均时间复杂度为O(d(n+r))，其中 d 表示位数，r为基数（d的取值范围）。</p>
<p>LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好。MSD的方式与LSD相反，是由高位数为基底开始进行分配，但在分配之后并不马上合并回一个数组中，而是在每个“桶子”中建立“子桶”，将每个桶子中的数值按照下一数位的值分配到“子桶”中。在进行完最低位数的分配后再合并回单一的数组中。</p>
<p>本文介绍的是LSD模式。</p>
<p><strong>过程</strong></p>
<p><img src="/images/2017-4-11 200834.jpg" alt="2017-4-11 200834"></p>
<p><img src="/images/2017-4-11 200911.jpg" alt="2017-4-11 200911"></p>
<p><strong>PHP代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function GetNumInPos($num, $pos)&#123;</span><br><span class="line">        $temp = 1;</span><br><span class="line">        for ($i = 0; $i &lt; $pos - 1; $i++)</span><br><span class="line">            $temp *= 10;</span><br><span class="line">        return ($num / $temp) % 10;</span><br><span class="line">    &#125;</span><br><span class="line">public function JiShu($sort_array, $pos) &#123;</span><br><span class="line">        $l = count($sort_array);</span><br><span class="line">        $bucket = array();</span><br><span class="line">        for($i = 0; $i &lt; 10; $i++)</span><br><span class="line">            $bucket[$i] = array(0);</span><br><span class="line"></span><br><span class="line">        for($p = 1; $p &lt;= $pos; $p++) &#123;</span><br><span class="line">            for($i = 0; $i &lt; $l; $i++) &#123;</span><br><span class="line">                $n = $this-&gt;GetNumInPos($sort_array[$i], $p);</span><br><span class="line">                $index = ++$bucket[$n][0];</span><br><span class="line">                $bucket[$n][$index] = $sort_array[$i];</span><br><span class="line">            &#125;</span><br><span class="line">            for($i=0, $j=0; $i&lt;10; $i++) &#123;</span><br><span class="line">                for($num = 1; $num&lt;=$bucket[$i][0]; $num++) &#123;</span><br><span class="line">                    $sort_array[$j++] = $bucket[$i][$num];</span><br><span class="line">                &#125;</span><br><span class="line">                $bucket[$i][0] = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return $sort_array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Read More:</p>
<blockquote>
<p><a href="http://www.runoob.com/w3cnote/sort-algorithm-summary.html" target="_blank" rel="noopener">排序算法总结</a>  <a href="http://blog.csdn.net/hguisu/article/details/7776068" target="_blank" rel="noopener">八大排序算法</a>  <a href="http://blog.csdn.net/xiazdong/article/details/8462393" target="_blank" rel="noopener">九大排序算法再总结</a>  <a href="http://www.cnblogs.com/codingmylife/archive/2012/10/21/2732980.html" target="_blank" rel="noopener">稳定排序和不稳定排序</a>  <a href="http://baike.baidu.com/link?url=jd48mIg-3sWzLsPo9c5TgY2BjZGzlDn8SR5c6Zp_SF0feCIUUI6rZw5ITJVAezCshxLCBXFF5QFCaeixlW8oQe9siEyEj2PX2ciyZ5DQsmPEFmzH5_j86ISkUy6XiGJ6#1" target="_blank" rel="noopener">基数排序</a>  <a href="http://www.cnblogs.com/jingmoxukong/p/4311237.html" target="_blank" rel="noopener">排序八 基数排序</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>算法</tag>
        <tag>排序</tag>
        <tag>时间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP协议入门篇</title>
    <url>/2017/04/03/tcpip/</url>
    <content><![CDATA[<p>写这篇文章的主要动机是，自己在做项目的时候用到了网络编程的内容，然后自己简单学习了一下TCP/IP的东西，属于很基础的那种，在实习面试中，面试官也是问到了这块内容，但是自己理解比较浅，所以回答的也不是很好。想着系统的学习一下网络编程中TCP/IP协议这块，本篇作为入门，简单介绍一下TCP/IP协议。</p>
<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>TCP/IP：<strong>Transmission Control Protocol/Internet Protocol</strong> 的简写，中译名为<strong>传输控制协议/因特网互联协议</strong>，又名网络通讯协议，是Internet最基本的协议、Internet国际互联网络的基础，由网络层的IP协议和传输层的TCP协议组成。是一种<strong>面向连接的</strong>、<strong>可靠的</strong>、<strong>基于字节流的</strong>传输层（Transport layer）通信协议。是专门为了在不可靠的互联网络上提供一个可靠的端到端字节流而设计的。互联网络与单个网络不同，因为互联网络的不同部分可能有着截然不同的拓扑、带宽、延迟、分组大小和其他参数。TCP的设计目标是能够动态的适应互联网络的这些特性，而且当面对多种失败的时候仍然能够健壮。</p>
<blockquote>
<p> TCP/IP协议不是TCP和IP这两个协议的合称，而是指因特网整个TCP/IP协议族。</p>
</blockquote>
<h3 id="参考模型"><a href="#参考模型" class="headerlink" title="参考模型"></a>参考模型</h3><p>了解TCP/IP参考模型之前，先来看一下OSI模型。</p>
<h4 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h4><p>OSI模型是ISO的建议，是为了使各层上的协议国际标准化而发展起来的。OSI参考模型全称是开放系统互连参考模型(Open System Interconnection Reference Model)。这一参考模型共分为七层：物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。</p>
<table>
<thead>
<tr>
<th>层次</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>物理层</td>
<td>处理机械的、电气的和过程的接口，以及物理层下的物理传输介质等</td>
</tr>
<tr>
<td>数据链路层</td>
<td>加强物理层的功能，使其对网络层显示为一条无错的线路</td>
</tr>
<tr>
<td>网络层</td>
<td>确定分组从源端到目的端的路由选择。路由可以选用网络中固定的静态路由表，也可以在每一次会话时决定，还可以根据当前的网络负载状况，灵活地为每一个分组分别决定。</td>
</tr>
<tr>
<td>传输层</td>
<td>从会话层接收数据，并传输给网络层，同时确保到达目的端的各段信息正确无误，而且使会话层不受硬件变化的影响</td>
</tr>
<tr>
<td>会话层</td>
<td>允许不同机器上的用户之间建立会话关系，既可以进行类似传输层的普通数据传输，也可以被用于远程登录到分时系统或在两台机器间传递文件</td>
</tr>
<tr>
<td>表示层</td>
<td>用于完成一些特定的功能，这些功能由于经常被请求，因此人们希望有通用的解决办法，而不是由每个用户各自实现</td>
</tr>
<tr>
<td>应用层</td>
<td>包含了大量人们普遍需要的协议。不同的文件系统有不同的文件命名原则和不同的文本行表示方法等，不同的系统之间传输文件还有各种不兼容问题，这些都将由应用层来处理。此外，应用层还有虚拟终端、电子邮件和新闻组等各种通用和专用的功能</td>
</tr>
</tbody>
</table>
<h4 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h4><p>TCP/IP参考模型共分为四层：网络访问层、互联网层、传输层和应用层。</p>
<table>
<thead>
<tr>
<th>层次</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td>包含所有的高层协议，包括：虚拟终端协议(TELNET)、文件传输协议(FTP)、电子邮件传输协议(SMTP)、域名服务(DNS)、网上新闻传输协议(NNTP)和超文本传送协议(HTTP)等</td>
</tr>
<tr>
<td>传输层</td>
<td>源端和目的端机器上的对等实体可以进行会话。在这一层定义了两个端到端的协议：传输控制协议(TCP)和用户数据报协议(UDP)。TCP是面向连接的协议，它提供可靠的报文传输和对上层应用的连接服务。为此，除了基本的数据传输外，它还有可靠性保证、流量控制、多路复用、优先权和安全性控制等功能。UDP是面向无连接的不可靠传输的协议，主要用于不需要TCP的排序和流量控制等功能的应用程序。</td>
</tr>
<tr>
<td>互联网层</td>
<td>整个体系结构的关键部分，其功能是使主机可以把分组发往任何网络，并使分组独立地传向目标，TCP/IP参考模型的互联网层和OSI参考模型的网络层在功能上非常相似。</td>
</tr>
<tr>
<td>网络访问层</td>
<td>指出主机必须使用某种协议与网络相连</td>
</tr>
</tbody>
</table>
<h3 id="TCP-IP协议层次"><a href="#TCP-IP协议层次" class="headerlink" title="TCP/IP协议层次"></a>TCP/IP协议层次</h3><p><img src="/images/2017-4-3 140143.png" alt="2017-4-3 140143"></p>
<h4 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h4><p>链路层是负责接收IP数据包并通过网络发送，或者从网络上接收物理帧，抽出IP数据包，交给IP层。</p>
<p>ARP是正向地址解析协议，通过已知的IP，寻找对应主机的MAC地址。<br>RARP是反向地址解析协议，通过MAC地址确定IP地址。比如无盘工作站还有DHCP服务。</p>
<p><strong>ARP、RARP属于网络层协议，工作在链路层</strong></p>
<h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>负责相邻计算机之间的通信。其功能包括三方面。</p>
<blockquote>
<p> 处理来自传输层的分组发送请求，收到请求后，将分组装入IP数据报，填充报头，选择去往信宿机的路径，然后将数据报发往适当的网络接口。</p>
</blockquote>
<blockquote>
<p> 处理输入数据报：首先检查其合法性，然后进行寻径–假如该数据报已到达信宿机，则去掉报头，将剩下部分交给适当的传输协议；假如该数据报尚未到达信宿，则转发该数据报。</p>
</blockquote>
<blockquote>
<p> 处理路径、流控、拥塞等问题。</p>
</blockquote>
<h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>提供应用程序间的通信。其功能包括：格式化信息流；提供可靠传输。</p>
<p>为实现可靠传输，传输层协议规定接收端必须发回确认，并且假如分组丢失，必须重新发送，即耳熟能详的“三次握手”过程，从而提供可靠的数据传输。</p>
<h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>向用户提供一组常用的应用程序，比如电子邮件、文件传输访问、远程登录等。远程登录TELNET使用TELNET协议提供在网络其它主机上注册的接口。TELNET会话提供了基于字符的虚拟终端。文件传输访问FTP使用FTP协议来提供网络内机器间的文件拷贝功能。</p>
<p>FTP 是文件传输协议，一般上传下载用FTP服务，数据端口是20H，控制端口是21H。</p>
<p>Telnet 服务是用户远程登录服务，使用23H端口，使用明码传送，保密性差、简单方便。</p>
<p>DNS 是域名解析服务，提供域名到IP地址之间的转换，使用端口53。</p>
<p>SMTP 是简单邮件传输协议，用来控制信件的发送、中转，使用端口25。</p>
<p>NFS 是网络文件系统，用于网络中不同主机间的文件共享。</p>
<p>HTTP 是超文本传输协议，用于实现互联网中的WWW服务，使用端口80。</p>
<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><h4 id="TCP头格式"><a href="#TCP头格式" class="headerlink" title="TCP头格式"></a>TCP头格式</h4><p><img src="/images/2017-4-3 141518.png" alt="2017-4-3 141518"></p>
<p><strong>端口号[16bit]</strong></p>
<p>网络实现的是不同主机的进程间通信。在一个操作系统中，有很多进程，当数据到来时要提交给哪个进程进行处理呢？这就需要用到端口号。在TCP头中，有源端口号(Source Port)和目标端口号(Destination Port)。源端口号标识了发送主机的进程，目标端口号标识接受方主机的进程。</p>
<p><strong>序号[32bit]</strong></p>
<p>序号分为发送序号SN (Sequence Number)和确认序号ACK (Acknowledgment Number)。</p>
<p>发送序号：用来标识从 TCP源端向 TCP目的端发送的数据字节流，它表示在这个报文段中的第一个数据字节的顺序号。</p>
<p>如果将字节流看作在两个应用程序间的单向流动，则 TCP用顺序号对每个字节进行计数。序号是 32bit的无符号数，序号到达 2^32-1后又从 0开始。当建立一个新的连接时， SYN标志变 1，顺序号字段包含由这个主机选择的该连接的初始顺序号 ISN (Initial Sequence Number)。</p>
<p>确认序号：包含发送确认的一端所期望收到的下一个顺序号。因此，确认序号应当是上次已成功收到数据字节顺序号加 1。只有 ACK标志为 1时确认序号字段才有效。 TCP为应用层提供全双工服务，这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据顺序号。</p>
<p><strong>偏移[4bit]</strong></p>
<p>这里的偏移实际指的是TCP首部的长度，它用来表明TCP首部中32 bit字的数目，通过它可以知道一个TCP包它的用户数据是从哪里开始的。这个字段占4bit，如4bit的值是0101，则说明TCP首部长度是5 * 4 = 20字节。 所以TCP的首部长度最大为15 * 4 = 60字节。然而没有可选字段，正常长度为20字节。</p>
<p><strong>Reserved [6bit]</strong></p>
<p>目前没有使用，它的值都为0</p>
<p><strong>标志[6bit]</strong></p>
<p>在TCP首部中有6个标志比特。他们中的多个可同时被置为1 。</p>
<p>URG         紧急指针(urgent pointer)有效</p>
<p>ACK          确认序号有效</p>
<p>PSH          指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满</p>
<p>RST           一般表示断开一个连接</p>
<p>SYN          同步序号用来发起一个连接</p>
<p>FIN            发送端完成发送任务(即断开连接)</p>
<p><strong>窗口大小(window)[16bit]</strong></p>
<p>窗口的大小，表示源方法最多能接受的字节数。</p>
<p><strong>校验和[16bit]</strong></p>
<p>校验和覆盖了整个的TCP报文段:TCP首部和TCP数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。</p>
<p><strong>紧急指针[16bit]</strong></p>
<p>只有当URG标志置为1时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。TCP的紧急方式是发送端向另一端发送紧急数据的一种方式。</p>
<p><strong>TCP选项</strong></p>
<p>是可选的。</p>
<h4 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="三次握手建立连接"></a>三次握手建立连接</h4><p><img src="/images/2017-4-3 143008.png" alt="2017-4-3 143008"></p>
<p><strong>第一次握手</strong>：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p>
<p><strong>第二次握手</strong>：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p>
<p><strong>第三次握手</strong>：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p>
<h4 id="三次握手连接成功的标准"><a href="#三次握手连接成功的标准" class="headerlink" title="三次握手连接成功的标准"></a>三次握手连接成功的标准</h4><p>客户端发完第三次ACK，就立马成为established状态，即使第三次ACK丢失，客户端并不关心，可以发送数据，格式为ACK+Data，当到达服务器时，服务器状态虽然为SYN_RCVD，它依然可以将Data缓存下来，客户端捎带过来的ACK，这个ACK就是对服务器SYN+ACK又一次确认，所以服务器端立马切换为established状态，然后将缓存下来的客户端Data提交给应用程序。</p>
<p>所以客户端只要发送了三次握手的ACK即认为自己为established状态，对应的就是connect成功返回，同时可以接受用户数据。</p>
<p>而服务器端没有收到客户端的ACK，accept依然为阻塞状态，直到由于客户端发送数据+ACK，或自己超时重传+ACK并接收到客户端ACK，accept才会返回。</p>
<h4 id="TCP连接为什么需要三次握手"><a href="#TCP连接为什么需要三次握手" class="headerlink" title="TCP连接为什么需要三次握手"></a>TCP连接为什么需要三次握手</h4><p>在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。在另一部经典的《计算机网络》一书中讲“三次握手”的目的是为了解决“网络中存在延迟的重复分组”的问题。这两种不用的表述其实阐明的是同一个问题。</p>
<p>谢希仁版《计算机网络》中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”</p>
<p>在Google Groups的TopLanguage中看到一帖讨论TCP“三次握手”觉得很有意思。贴主提出“TCP建立连接为什么是三次握手？”的问题，在众多回复中，有一条回复写道：“这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题,  无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足”在不可靠信道上可靠地传输信息”这一需求所导致的. 请注意这里的本质需求,信道不可靠, 数据传输要可靠. 三次达到了, 那后面你想接着握手也好, 发数据也好, 跟进行可靠信息传输的需求就没关系了. 因此,如果信道是可靠的, 即无论什么时候发出消息, 对方一定能收到, 或者你不关心是否要保证对方收到你的消息, 那就能像UDP那样直接发送消息就可以了.”。这可视为对“三次握手”目的的另一种解答思路。</p>
<p>原文地址：<a href="http://www.cnblogs.com/TechZi/archive/2011/10/18/2216751.html" target="_blank" rel="noopener">TCP连接建立过程中为什么需要三次握手</a></p>
<h4 id="四次挥手释放连接"><a href="#四次挥手释放连接" class="headerlink" title="四次挥手释放连接"></a>四次挥手释放连接</h4><p>由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</p>
<p><img src="/images/2017-4-3 145434.png" alt="2017-4-3 145434"></p>
<p><strong>第一次挥手</strong>：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p>
<p><strong>第二次挥手</strong>：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。</p>
<p><strong>第三次挥手</strong>：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p>
<p><strong>第四次挥手</strong>：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p>
<h4 id="TCP断开为什么需要四次挥手"><a href="#TCP断开为什么需要四次挥手" class="headerlink" title="TCP断开为什么需要四次挥手"></a>TCP断开为什么需要四次挥手</h4><p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</p>
<h4 id="TCP可靠性的保证"><a href="#TCP可靠性的保证" class="headerlink" title="TCP可靠性的保证"></a>TCP可靠性的保证</h4><p>TCP采用一种名为“带重传功能的肯定确认”的技术作为提供可靠数据传输服务的基础。这项技术要求接收方收到数据之后向源站回送确认信息ACK。发送方对发出的每个分组都保存一份记录，在发送下一个分组之前等待确认信息。发送方还在送出分组的同时启动一个定时器，并在定时器的定时期满而确认信息还没有到达的情况下，重发刚才发出的分组。</p>
<p>图3-5表示带重传功能的肯定确认协议传输数据的情况，图</p>
<p>3-6表示分组丢失引起超时和重传。</p>
<p>为了避免由于网络延迟引起迟到的确认和重复的确认，协议规定在确认信息中稍带一个分组的序号，使接收方能正确将分组与确认关联起来。</p>
<p>从图 3-5可以看出，虽然网络具有同时进行双向通信的能力，但由于在接到前一个分组的确认信息之前必须推迟下一个分组的发送，简单的肯定确认协议浪费了大量宝贵的网络带宽。为此， TCP使用滑动窗口的机制来提高网络吞吐量，同时解决端到端的流量控制。</p>
<p><img src="/images/2017-4-3 145924.png" alt="2017-4-3 145924"></p>
<h4 id="滑动窗口技术"><a href="#滑动窗口技术" class="headerlink" title="滑动窗口技术"></a>滑动窗口技术</h4><p>滑动窗口技术是简单的带重传的肯定确认机制的一个更复杂的变形，它允许发送方在等待一个确认信息之前可以发送多个分组。如图 3-7所示，发送方要发送一个分组序列，滑动窗口协议在分组序列中放置一个固定长度的窗口，然后将窗口内的所有分组都发送出去；当发送方收到对窗口内第一个分组的确认信息时，它可以向后滑动并发送下一个分组；随着确认的不断到达，窗口也在不断的向后滑动。</p>
<p><img src="/images/2017-4-3 150129.png" alt="2017-4-3 150129"></p>
<h3 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h3><p><strong>基本区别</strong></p>
<p>基于连接与无连接（TCP有连接，UDP无连接）；</p>
<p>对系统资源的要求（TCP较多，UDP少）；</p>
<p>UDP程序结构较简单；</p>
<p>流模式与数据报模式（TCP属于流模式，UDP属于数据报模式）；</p>
<p>TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。</p>
<p><strong>UDP应用场景</strong></p>
<p>面向数据报方式；</p>
<p>网络数据大多为短消息 ；</p>
<p>拥有大量Client；</p>
<p>对数据安全性无特殊要求；</p>
<p>网络负担非常重，但对响应速度要求高。</p>
<p><strong>TCP编程的服务器端一般步骤</strong></p>
<p>创建一个socket，用函数socket()； </p>
<p>设置socket属性，用函数setsockopt()； * 可选 </p>
<p>绑定IP地址、端口等信息到socket上，用函数bind()；</p>
<p>开启监听，用函数listen()； </p>
<p>接收客户端上来的连接，用函数accept()； </p>
<p>收发数据，用函数send()和recv()，或者read()和write(); </p>
<p>关闭网络连接； </p>
<p>关闭监听； </p>
<p><strong>TCP编程的客户端一般步骤</strong></p>
<p>创建一个socket，用函数socket()； </p>
<p>设置socket属性，用函数setsockopt()；* 可选 </p>
<p>绑定IP地址、端口等信息到socket上，用函数bind()；* 可选 </p>
<p>设置要连接的对方的IP地址和端口等属性； </p>
<p>连接服务器，用函数connect()； </p>
<p>收发数据，用函数send()和recv()，或者read()和write()；</p>
<p>关闭网络连接；</p>
<p><strong>UDP编程的服务器端一般步骤</strong></p>
<p>创建一个socket，用函数socket()； </p>
<p>设置socket属性，用函数setsockopt()；* 可选 </p>
<p>绑定IP地址、端口等信息到socket上，用函数bind()；</p>
<p>循环接收数据，用函数recvfrom()；</p>
<p>关闭网络连接； </p>
<p><strong>UDP编程的客户端一般步骤</strong>　</p>
<p>创建一个socket，用函数socket()； </p>
<p>设置socket属性，用函数setsockopt()；* 可选 </p>
<p>绑定IP地址、端口等信息到socket上，用函数bind()；* 可选 </p>
<p>设置对方的IP地址和端口等属性；</p>
<p>发送数据，用函数sendto()；</p>
<p>关闭网络连接；</p>
<p><strong>UDP补充</strong></p>
<p>UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。</p>
<p>它是将应用程序发来的数据在收到的那一刻，立刻按照原样发送到网络上的一种机制。即使是出现网络拥堵的情况下，</p>
<p>UDP也无法进行流量控制等避免网络拥塞的行为。</p>
<p>传输途中如果出现了丢包，UDO也不负责重发。甚至当出现包的到达顺序乱掉时也没有纠正的功能。如果需要这些细节控制，那么不得不交给由采用UDO的应用程序去处理。换句话说，UDP将部分控制转移到应用程序去处理，自己却只提供作为传输层协议的最基本功能。</p>
<p><strong>TCP补充</strong></p>
<p>TCP充分实现了数据传输时各种控制功能，可以进行丢包的重发控制，还可以对次序乱掉的分包进行顺序控制。而这些在UDP中都没有。此外，TCP作为一种面向有连接的协议，只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。TCP通过检验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。</p>
<p>Read More:</p>
<blockquote>
<p><a href="http://blog.csdn.net/li_ning_/article/details/52117463" target="_blank" rel="noopener">TCP和UDP的最完整的区别</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/22516664" target="_blank" rel="noopener">计算机网络入门基础篇</a></p>
<p><a href="http://baike.baidu.com/link?url=XlOHwI18XnbZTaGjg2WLtpmrwq2IsMVyoEggNVDOW6jaU-3qOLaoLleiSan-SBod0GTS8cAyOz99BAplna-wd3khoGaLvNPcniIX0dMGkg_oS2JsNmLR74DqcVoS5TgS#3" target="_blank" rel="noopener">TCP/IP协议</a></p>
<p><a href="https://www.zhihu.com/question/49619919/answer/116941333" target="_blank" rel="noopener">tcp 编程中，connect 连接成功的标准是什么？</a></p>
<p><a href="https://www.zhihu.com/question/20583641" target="_blank" rel="noopener">如何通俗地解释一下 TCP/UDP 协议和 HTTP、FTP、SMTP 等协议之间的区别？</a></p>
<p><a href="http://blog.chinaunix.net/uid-26833883-id-3627644.html" target="_blank" rel="noopener">TCP、UDP、IP 协议分析</a> </p>
</blockquote>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>Laravel学习笔记-深入理解控制反转(IoC)和依赖注入(DI)</title>
    <url>/2017/04/27/laraveliocanddi/</url>
    <content><![CDATA[<p>容器，字面上理解就是装东西的东西。常见的变量、对象属性等都可以算是容器。一个容器能够装什么，全部取决于你对该容器的定义。当然，有这样一种容器，它存放的不是文本、数值，而是对象、对象的描述（类、接口）或者是提供对象的回调，通过这种容器，我们得以实现许多高级的功能，其中最常提到的，就是 “解耦” 、“依赖注入(DI)”。本文就从这里开始。</p>
<h3 id="IoC-容器-Laravel-的核心"><a href="#IoC-容器-Laravel-的核心" class="headerlink" title="IoC 容器 - Laravel 的核心"></a>IoC 容器 - Laravel 的核心</h3><p>Laravel 的核心就是一个 IoC 容器，根据文档，称其为“服务容器”，顾名思义，该容器提供了整个框架中需要的一系列服务。作为初学者，很多人会在这一个概念上犯难，因此，我打算从一些基础的内容开始讲解，通过理解面向对象开发中依赖的产生和解决方法，来逐渐揭开“依赖注入”的面纱，逐渐理解这一神奇的设计理念。</p>
<p>本文一大半内容都是通过举例来让读者去理解什么是 IoC（控制反转） 和 DI（依赖注入），通过理解这些概念，来更加深入。更多关于 Laravel 服务容器的用法建议阅读文档即可。</p>
<h3 id="IoC-容器诞生的故事"><a href="#IoC-容器诞生的故事" class="headerlink" title="IoC 容器诞生的故事"></a>IoC 容器诞生的故事</h3><p>讲解 IoC 容器有很多的文章，我之前也写过。但现在我打算利用当下的灵感重新来过，那么开始吧。</p>
<h4 id="超人和超能力，依赖的产生"><a href="#超人和超能力，依赖的产生" class="headerlink" title="超人和超能力，依赖的产生"></a>超人和超能力，依赖的产生</h4><p>面向对象编程，有以下几样东西无时不刻的接触：接口、类还有对象。这其中，接口是类的原型，一个类必须要遵守其实现的接口；对象则是一个类实例化后的产物，我们称其为一个实例。当然这样说肯定不利于理解，我们就实际的写点中看不中用的代码辅助学习。</p>
<blockquote>
<p>怪物横行的世界，总归需要点超级人物来摆平。</p>
</blockquote>
<p>我们把一个“超人”作为一个类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Superman &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以想象，一个超人诞生的时候肯定拥有至少一个超能力，这个超能力也可以抽象为一个对象，为这个对象定义一个描述他的类吧。一个超能力肯定有多种属性、（操作）方法，这个尽情的想象，但是目前我们先大致定义一个只有属性的“超能力”，至于能干啥，我们以后再丰富：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Power &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 能力值</span><br><span class="line">     */</span><br><span class="line">    protected $ability;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 能力范围或距离</span><br><span class="line">     */</span><br><span class="line">    protected $range;</span><br><span class="line"></span><br><span class="line">    public function __construct($ability, $range)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;ability = $ability;</span><br><span class="line">        $this-&gt;range = $range;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候我们回过头，修改一下之前的“超人”类，让一个“超人”创建的时候被赋予一个超能力：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Superman</span><br><span class="line">&#123;</span><br><span class="line">    protected $power;</span><br><span class="line"></span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;power = new Power(999, 100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，当我们创建一个“超人”实例的时候，同时也创建了一个“超能力”的实例，但是，我们看到了一点，“超人”和“超能力”之间不可避免的产生了一个依赖。</p>
<p>所谓“依赖”，就是 “我若依赖你，我就不能离开你”。</p>
<p>在一个贯彻面向对象编程的项目中，这样的依赖随处可见。少量的依赖并不会有太过直观的影响，我们随着这个例子逐渐铺开，让大家慢慢意识到，当依赖达到一个量级时，是怎样一番噩梦般的体验。当然，我也会自然而然的讲述如何解决问题。</p>
<h4 id="一堆乱麻，可怕的依赖"><a href="#一堆乱麻，可怕的依赖" class="headerlink" title="一堆乱麻，可怕的依赖"></a>一堆乱麻，可怕的依赖</h4><p>之前的例子中，超能力类实例化后是一个具体的超能力，但是我们知道，超人的超能力是多元化的，每种超能力的方法、属性都有不小的差异，没法通过一种类描述完全。我们现在进行修改，我们假设超人可以有以下多种超能力：</p>
<ul>
<li>飞行，属性有：飞行速度、持续飞行时间</li>
<li>蛮力，属性有：力量值</li>
<li>能量弹，属性有：伤害值、射击距离、同时射击个数</li>
</ul>
<p>我们创建了如下类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Flight</span><br><span class="line">&#123;</span><br><span class="line">    protected $speed;</span><br><span class="line">    protected $holdtime;</span><br><span class="line">    public function __construct($speed, $holdtime) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Force</span><br><span class="line">&#123;</span><br><span class="line">    protected $force;</span><br><span class="line">    public function __construct($force) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Shot</span><br><span class="line">&#123;</span><br><span class="line">    protected $atk;</span><br><span class="line">    protected $range;</span><br><span class="line">    protected $limit;</span><br><span class="line">    public function __construct($atk, $range, $limit) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了省事儿我没有详细写出 <code>__construct()</code>  这个构造函数的全部，只写了需要传递的参数。</p>
<p>好了，这下我们的超人有点“忙”了。在超人初始化的时候，我们会根据需要来实例化其拥有的超能力，大致如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Superman</span><br><span class="line">&#123;</span><br><span class="line">    protected $power;</span><br><span class="line"></span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;power = new Fight(9, 100);</span><br><span class="line">        // $this-&gt;power = new Force(45);</span><br><span class="line">        // $this-&gt;power = new Shot(99, 50, 2);</span><br><span class="line">        /*</span><br><span class="line">        $this-&gt;power = array(</span><br><span class="line">            new Force(45),</span><br><span class="line">            new Shot(99, 50, 2)</span><br><span class="line">        );</span><br><span class="line">        */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要自己手动的在构造函数内（或者其他方法里）实例化一系列需要的类，这样并不好。可以想象，假如需求变更（不同的怪物横行地球），需要更多的有针对性的新的超能力，或者需要变更超能力的方法，我们必须 重新改造 超人。换句话说就是，改变超能力的同时，我还得重新制造个超人。效率太低了！新超人还没创造完成世界早已被毁灭。</p>
<p>这时，灵机一动的人想到：为什么不可以这样呢？超人的能力可以被随时更换，只需要添加或者更新一个芯片或者其他装置啥的（想到钢铁侠没）。这样的话就不要整个重新来过了。</p>
<p>对，就是这样的。</p>
<p>我们不应该手动在 “超人” 类中固化了他的 “超能力” 初始化的行为，而转由外部负责，由外部创造超能力模组、装置或者芯片等（我们后面统一称为 “模组”），植入超人体内的某一个接口，这个接口是一个既定的，只要这个 “模组” 满足这个接口的装置都可以被超人所利用，可以提升、增加超人的某一种能力。这种由外部负责其依赖需求的行为，我们可以称其为 “控制反转（IoC）”。</p>
<h4 id="工厂模式，转移依赖"><a href="#工厂模式，转移依赖" class="headerlink" title="工厂模式，转移依赖"></a>工厂模式，转移依赖</h4><p>当然，实现控制反转的方法有几种。在这之前，不如我们先了解一些好玩的东西。</p>
<blockquote>
<p>我们可以想到，组件、工具（或者超人的模组），是一种可被生产的玩意儿，生产的地方当然是 “工厂（Factory）”，于是有人就提出了这样一种模式： 工厂模式。</p>
</blockquote>
<p>工厂模式，顾名思义，就是一个类所依赖的外部事物的实例，都可以被一个或多个 “工厂” 创建的这样一种开发模式，就是 “工厂模式”。</p>
<p>我们为了给超人制造超能力模组，我们创建了一个工厂，它可以制造各种各样的模组，且仅需要通过一个方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SuperModuleFactory</span><br><span class="line">&#123;</span><br><span class="line">    public function makeModule($moduleName, $options)</span><br><span class="line">    &#123;</span><br><span class="line">        switch ($moduleName) &#123;</span><br><span class="line">            case &apos;Fight&apos;: </span><br><span class="line">                return new Fight($options[0], $options[1]);</span><br><span class="line">            case &apos;Force&apos;: </span><br><span class="line">                return new Force($options[0]);</span><br><span class="line">            case &apos;Shot&apos;: </span><br><span class="line">                return new Shot($options[0], $options[1], $options[2]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候，超人 创建之初就可以使用这个工厂：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Superman</span><br><span class="line">&#123;</span><br><span class="line">    protected $power;</span><br><span class="line"></span><br><span class="line">    public function __construct()</span><br><span class="line">    &#123;</span><br><span class="line">        // 初始化工厂</span><br><span class="line">        $factory = new SuperModuleFactory;</span><br><span class="line"></span><br><span class="line">        // 通过工厂提供的方法制造需要的模块</span><br><span class="line">        $this-&gt;power = $factory-&gt;makeModule(&apos;Fight&apos;, [9, 100]);</span><br><span class="line">        // $this-&gt;power = $factory-&gt;makeModule(&apos;Force&apos;, [45]);</span><br><span class="line">        // $this-&gt;power = $factory-&gt;makeModule(&apos;Shot&apos;, [99, 50, 2]);</span><br><span class="line">        /*</span><br><span class="line">        $this-&gt;power = array(</span><br><span class="line">            $factory-&gt;makeModule(&apos;Force&apos;, [45]),</span><br><span class="line">            $factory-&gt;makeModule(&apos;Shot&apos;, [99, 50, 2])</span><br><span class="line">        );</span><br><span class="line">        */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看得出，我们不再需要在超人初始化之初，去初始化许多第三方类，只需初始化一个工厂类，即可满足需求。但这样似乎和以前区别不大，只是没有那么多 new 关键字。其实我们稍微改造一下这个类，你就明白，工厂类的真正意义和价值了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Superman</span><br><span class="line">&#123;</span><br><span class="line">    protected $power;</span><br><span class="line"></span><br><span class="line">    public function __construct(array $modules)</span><br><span class="line">    &#123;</span><br><span class="line">        // 初始化工厂</span><br><span class="line">        $factory = new SuperModuleFactory;</span><br><span class="line"></span><br><span class="line">        // 通过工厂提供的方法制造需要的模块</span><br><span class="line">        foreach ($modules as $moduleName =&gt; $moduleOptions) &#123;</span><br><span class="line">            $this-&gt;power[] = $factory-&gt;makeModule($moduleName, $moduleOptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建超人</span><br><span class="line">$superman = new Superman([</span><br><span class="line">    &apos;Fight&apos; =&gt; [9, 100],</span><br><span class="line">    &apos;Shot&apos; =&gt; [99, 50, 2]</span><br><span class="line">]);</span><br></pre></td></tr></table></figure>
<p>现在修改的结果令人满意。现在，“超人” 的创建不再依赖任何一个 “超能力” 的类，我们如若修改了或者增加了新的超能力，只需要针对修改 SuperModuleFactory 即可。扩充超能力的同时不再需要重新编辑超人的类文件，使得我们变得很轻松。但是，这才刚刚开始。</p>
<h3 id="IoC-容器的重要组成-依赖注入"><a href="#IoC-容器的重要组成-依赖注入" class="headerlink" title="IoC 容器的重要组成 - 依赖注入"></a>IoC 容器的重要组成 - 依赖注入</h3><p>由 “超人” 对 “超能力” 的依赖变成 “超人” 对 “超能力模组工厂” 的依赖后，对付小怪兽们变得更加得心应手。但这也正如你所看到的，依赖并未解除，只是由原来对多个外部的依赖变成了对一个 “工厂” 的依赖。假如工厂出了点麻烦，问题变得就很棘手。</p>
<blockquote>
<p>其实大多数情况下，工厂模式已经足够了。工厂模式的缺点就是：接口未知（即没有一个很好的契约模型，关于这个我马上会有解释）、产生对象类型单一。总之就是，还是不够灵活。虽然如此，工厂模式依旧十分优秀，并且适用于绝大多数情况。不过我们为了讲解后面的依赖注入 ，这里就先夸大一下工厂模式的缺陷咯。</p>
</blockquote>
<p>我们知道，超人依赖的模组，我们要求有统一的接口，这样才能和超人身上的注入接口对接，最终起到提升超能力的效果。</p>
<p>事实上，我之前说谎了，不仅仅只有一堆小怪兽，还有更多的大怪兽。嘿嘿。额，这时候似乎工厂的生产能力显得有些不足 —— 由于工厂模式下，所有的模组都已经在工厂类中安排好了，如果有新的、高级的模组加入，我们必须修改工厂类（好比增加新的生产线）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SuperModuleFactory</span><br><span class="line">&#123;</span><br><span class="line">    public function makeModule($moduleName, $options)</span><br><span class="line">    &#123;</span><br><span class="line">        switch ($moduleName) &#123;</span><br><span class="line">            case &apos;Fight&apos;: </span><br><span class="line">                return new Fight($options[0], $options[1]);</span><br><span class="line">            case &apos;Force&apos;: </span><br><span class="line">                return new Force($options[0]);</span><br><span class="line">            case &apos;Shot&apos;: </span><br><span class="line">                return new Shot($options[0], $options[1], $options[2]);</span><br><span class="line">            // case &apos;more&apos;: .......</span><br><span class="line">            // case &apos;and more&apos;: .......</span><br><span class="line">            // case &apos;and more&apos;: .......</span><br><span class="line">            // case &apos;oh no! its too many!&apos;: .......</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到没。。。噩梦般的感受！</p>
<blockquote>
<p>其实灵感就差一步！你可能会想到更为灵活的办法！对，下一步就是我们今天的主要配角 —— DI （依赖注入）</p>
</blockquote>
<p>由于对超能力模组的需求不断增大，我们需要集合整个世界的高智商人才，一起解决问题，不应该仅仅只有几个工厂垄断负责。不过高智商人才们都非常自负，认为自己的想法是对的，创造出的超能力模组没有统一的接口，自然而然无法被正常使用。这时我们需要提出一种契约，这样无论是谁创造出的模组，都符合这样的接口，自然就可被正常使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface SuperModuleInterface</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * 超能力激活方法</span><br><span class="line">     *</span><br><span class="line">     * 任何一个超能力都得有该方法，并拥有一个参数</span><br><span class="line">     *@param array $target 针对目标，可以是一个或多个，自己或他人</span><br><span class="line">     */</span><br><span class="line">    public function activate(array $target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上文中，我们定下了一个接口 （超能力模组的规范、契约），所有被创造的模组必须遵守该规范，才能被生产。</p>
<p>其实，这就是 php 中接口（ interface ）的用处和意义！很多人觉得，为什么 php 需要接口这种东西？难道不是 java 、 C# 之类的语言才有的吗？这么说，只要是一个正常的面向对象编程语言（虽然 php 可以面向过程），都应该具备这一特性。因为一个 对象（object） 本身是由他的模板或者原型 —— 类 （class） ，经过实例化后产生的一个具体事物，而有时候，实现统一种方法且不同功能（或特性）的时候，会存在很多的类（class），这时候就需要有一个契约，让大家编写出可以被随时替换却不会产生影响的接口。这种由编程语言本身提出的硬性规范，会增加更多优秀的特性。</p>
<p>虽然有些绕，但通过我们接下来的实例，大家会慢慢领会接口带来的好处。</p>
<p>这时候，那些提出更好的超能力模组的高智商人才，遵循这个接口，创建了下述（模组）类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * X-超能量</span><br><span class="line"> */</span><br><span class="line">class XPower implements SuperModuleInterface</span><br><span class="line">&#123;</span><br><span class="line">    public function activate(array $target)</span><br><span class="line">    &#123;</span><br><span class="line">        // 这只是个例子。。具体自行脑补</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 终极炸弹</span><br><span class="line"> */</span><br><span class="line">class UltraBomb implements SuperModuleInterface</span><br><span class="line">&#123;</span><br><span class="line">    public function activate(array $target)</span><br><span class="line">    &#123;</span><br><span class="line">        // 这只是个例子。。具体自行脑补</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，为了防止有些 “砖家” 自作聪明，或者一些叛徒恶意捣蛋，不遵守契约胡乱制造模组，影响超人，我们对超人初始化的方法进行改造：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Superman</span><br><span class="line">&#123;</span><br><span class="line">    protected $module;</span><br><span class="line"></span><br><span class="line">    public function __construct(SuperModuleInterface $module)</span><br><span class="line">    &#123;</span><br><span class="line">        $this-&gt;module = $module;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改造完毕！现在，当我们初始化 “超人” 类的时候，提供的模组实例必须是一个<code>SuperModuleInterface</code> 接口的实现。否则就会提示错误。</p>
<p>正是由于超人的创造变得容易，一个超人也就不需要太多的超能力，我们可以创造多个超人，并分别注入需要的超能力模组即可。这样的话，虽然一个超人只有一个超能力，但超人更容易变多，我们也不怕怪兽啦！</p>
<p>现在有人疑惑了，你要讲的依赖注入呢？</p>
<p>其实，上面讲的内容，正是依赖注入。</p>
<h4 id="什么叫做依赖注入？"><a href="#什么叫做依赖注入？" class="headerlink" title="什么叫做依赖注入？"></a>什么叫做依赖注入？</h4><p>本文从开头到现在提到的一系列依赖，只要不是由内部生产（比如初始化、构造函数 __construct 中通过工厂方法、自行手动 new 的），而是由外部以参数或其他形式注入的，都属于依赖注入（DI） 。是不是豁然开朗？事实上，就是这么简单。下面就是一个典型的依赖注入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 超能力模组</span><br><span class="line">$superModule = new XPower;</span><br><span class="line">// 初始化一个超人，并注入一个超能力模组依赖</span><br><span class="line">$superMan = new Superman($superModule);</span><br></pre></td></tr></table></figure>
<p>关于依赖注入这个本文的主要配角，也就这么多需要讲的。理解了依赖注入，我们就可以继续深入问题。</p>
<h3 id="更为先进的工厂-IoC容器"><a href="#更为先进的工厂-IoC容器" class="headerlink" title="更为先进的工厂 - IoC容器"></a>更为先进的工厂 - IoC容器</h3><p>刚刚列了一段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$superModule = new XPower;</span><br><span class="line">$superMan = new Superman($superModule);</span><br></pre></td></tr></table></figure>
<p>读者应该看出来了，手动的创建了一个超能力模组、手动的创建超人并注入了刚刚创建超能力模组。呵呵，手动。</p>
<blockquote>
<p>现代社会，应该是高效率的生产，干净的车间，完美的自动化装配。</p>
</blockquote>
<p>一群怪兽来了，如此低效率产出超人是不现实，我们需要自动化 —— 最多一条指令，千军万马来相见。我们需要一种高级的生产车间，我们只需要向生产车间提交一个脚本，工厂便能够通过指令自动化生产。这种更为高级的工厂，就是工厂模式的升华 —— IoC 容器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Container</span><br><span class="line">&#123;</span><br><span class="line">    protected $binds;</span><br><span class="line"></span><br><span class="line">    protected $instances;</span><br><span class="line"></span><br><span class="line">    public function bind($abstract, $concrete)</span><br><span class="line">    &#123;</span><br><span class="line">    	// Todo: 向 container 添加一种对象的的生产方式</span><br><span class="line"> </span><br><span class="line">    	// $abstract: 第一个参数 $abstract, 一般为一个字符串(有时候也会是一个接口), </span><br><span class="line">    	// 当你需要 make 这个类的对象的时候, 传入这个字符串(或者接口), 这样make 就知道制造什么样的对象了</span><br><span class="line">    	// $concrete: 第二个参数 $concrete, 一般为一个 Closure 或者 一个单例对象, 用于说明制造这个对象的方式</span><br><span class="line">        </span><br><span class="line">        if ($concrete instanceof Closure) &#123;</span><br><span class="line">            $this-&gt;binds[$abstract] = $concrete;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $this-&gt;instances[$abstract] = $concrete;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public function make($abstract, $parameters = [])</span><br><span class="line">    &#123;</span><br><span class="line">    	// Todo: 生产一种对象</span><br><span class="line"> </span><br><span class="line">    	// $abstract: 在bind方法中已经介绍过</span><br><span class="line">    	// $parameters: 生产这种对象所需要的参数</span><br><span class="line">    	</span><br><span class="line">        if (isset($this-&gt;instances[$abstract])) &#123;</span><br><span class="line">            return $this-&gt;instances[$abstract];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        array_unshift($parameters, $this);</span><br><span class="line"></span><br><span class="line">        return call_user_func_array($this-&gt;binds[$abstract], $parameters);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候，一个十分粗糙的容器就诞生了。现在的确很简陋，但不妨碍我们进一步提升他。先着眼现在，看看这个容器如何使用吧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 创建一个容器（后面称作超级工厂）</span><br><span class="line">$container = new Container;</span><br><span class="line"></span><br><span class="line">// 向该超级工厂添加超人的生产脚本</span><br><span class="line">$container-&gt;bind(&apos;superman&apos;, function($container, $moduleName) &#123;</span><br><span class="line">    return new Superman($container-&gt;make($moduleName));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 向该超级工厂添加超能力模组的生产脚本</span><br><span class="line">$container-&gt;bind(&apos;xpower&apos;, function($container) &#123;</span><br><span class="line">    return new XPower;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 同上</span><br><span class="line">$container-&gt;bind(&apos;ultrabomb&apos;, function($container) &#123;</span><br><span class="line">    return new UltraBomb;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// ****************** 华丽丽的分割线 **********************</span><br><span class="line">// 开始启动生产</span><br><span class="line">$superman_1 = $container-&gt;make(&apos;superman&apos;, [&apos;xpower&apos;]);</span><br><span class="line">$superman_2 = $container-&gt;make(&apos;superman&apos;, [&apos;ultrabomb&apos;]);</span><br><span class="line">$superman_3 = $container-&gt;make(&apos;superman&apos;, [&apos;xpower&apos;]);</span><br><span class="line">// ......</span><br></pre></td></tr></table></figure>
<p>看到没？通过最初的 绑定（<code>bind</code>） 操作，我们向 超级工厂 注册了一些生产脚本，这些生产脚本在生产指令下达之时便会执行。发现没有？我们彻底的解除了 超人 与 超能力模组 的依赖关系，更重要的是，容器类也丝毫没有和他们产生任何依赖！我们通过注册、绑定的方式向容器中添加一段可以被执行的回调（可以是匿名函数、非匿名函数、类的方法）作为生产一个类的实例的 脚本 ，只有在真正的 生产（<code>make</code>） 操作被调用执行时，才会触发。</p>
<p>这样一种方式，使得我们更容易在创建一个实例的同时解决其依赖关系，并且更加灵活。当有新的需求，只需另外绑定一个“生产脚本”即可。</p>
<p>实际上，真正的 IoC 容器更为高级。我们现在的例子中，还是需要手动提供超人所需要的模组参数，但真正的 IoC 容器会根据类的依赖需求，自动在注册、绑定的一堆实例中搜寻符合的依赖需求，并自动注入到构造函数参数中去。Laravel 框架的服务容器正是这么做的。</p>
<p>不过我告诉大家，这种自动搜寻依赖需求的功能，是通过反射（Reflection）实现的，恰好的，php 完美的支持反射机制！关于反射，php 官方文档有详细的资料，并且中文翻译基本覆盖，足够学习和研究：</p>
<p>现在，到目前为止，我们已经不再惧怕怪兽们了。高智商人才集思广益，井井有条，根据接口契约创造规范的超能力模组。超人开始批量产出。最终，人人都是超人，你也可以是哦！</p>
<h3 id="重新审视-Laravel-的核心"><a href="#重新审视-Laravel-的核心" class="headerlink" title="重新审视 Laravel 的核心"></a>重新审视 Laravel 的核心</h3><p>现在，我们开始慢慢解读 Laravel 的核心。其实，Laravel 的核心就是一个 IoC 容器，也恰好是我之前所说的高级的 IoC 容器。</p>
<p>可以说，Laravel 的核心本身十分轻量，并没有什么很神奇很实质性的应用功能。很多人用到的各种功能模块比如 Route（路由）、Eloquent ORM（数据库 ORM 组件）、Request（请求）以及 Response（响应）等等等等，实际上都是与核心无关的类模块提供的，这些类从注册到实例化，最终被你所使用，其实都是 Laravel 的服务容器负责的。</p>
<p>我们以大家最常见的 Route 类作为例子。大家可能经常见到路由定义是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Route::get(&apos;/&apos;, function() &#123;</span><br><span class="line">    // ......</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>实际上， Route 类被定义在这个命名空间：<code>Illuminate\Routing\Router</code>，文件 <code>vendor/laravel/framework/src/Illuminate/Routing/Router.php</code>。</p>
<p>我们通过打开发现，这个类的这一系列方法，如 <code>get</code>，<code>post</code>，<code>any</code> 等都不是静态（<code>static</code>）方法，这是怎么一回事儿？不要急，我们继续。</p>
<h4 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h4><p>我们在前文介绍 IoC 容器的部分中，提到了，一个类需要绑定、注册至容器中，才能被“制造”。</p>
<p>对，一个类要被容器所能够提取，必须要先注册至这个容器。既然 Laravel 称这个容器叫做服务容器，那么我们需要某个服务，就得先注册、绑定这个服务到容器，那么提供服务并绑定服务至容器的东西，就是服务提供者（Service Provider）。</p>
<p>虽然，绑定一个类到容器不一定非要通过服务提供者。</p>
<p>但是，我们知道，有时候我们的类、模块会有需要其他类和组件的情况，为了保证初始化阶段不会出现所需要的模块和组件没有注册的情况，Laravel 将注册和初始化行为进行拆分，注册的时候就只能注册，初始化的时候就是初始化。拆分后的产物就是现在的服务提供者。</p>
<p>服务提供者主要分为两个部分，<code>register</code>（注册） 和<code>boot</code>（引导、初始化），具体参考文档。<code>register</code> 负责进行向容器注册“脚本”，但要注意注册部分不要有对未知事物的依赖，如果有，就要移步至 <code>boot</code> 部分。</p>
<h4 id="门面（Facade）"><a href="#门面（Facade）" class="headerlink" title="门面（Facade）"></a>门面（Facade）</h4><p>我们现在解答之前关于<code>Route</code> 的方法为何能以静态方法访问的问题。实际上这个问题文档上有写，简单说来就是模拟一个类，提供一个静态魔术方法<code>__callStatic</code>，并将该静态方法映射到真正的方法上。</p>
<p>我们使用的 <code>Route</code> 类实际上是 <code>Illuminate\Support\Facades\Route</code> 通过 <code>class_alias()</code> 函数创造的别名而已，这个类被定义在文件 <code>vendor/laravel/framework/src/Illuminate/Support/Facades/Route.php</code> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">    namespace Illuminate\Support\Facades;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @see \Illuminate\Routing\Router</span><br><span class="line">     */</span><br><span class="line">    class Route extends Facade &#123;</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Get the registered name of the component.</span><br><span class="line">         *</span><br><span class="line">         * @return string</span><br><span class="line">         */</span><br><span class="line">        protected static function getFacadeAccessor()</span><br><span class="line">        &#123;</span><br><span class="line">            return &apos;router&apos;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这个类之后，并没有找到之前 Route 调用的 <code>get</code> 方法，此时我们再看里面的这行注释， <code>@see\Illuminate\Routing\Router</code> ，他提示我们去找这个位置，那我们就去找一下，我们又发现了一个 Router 类，而这个 Router 类中，是有 <code>get</code> 方法的，看起来这里似乎就是 Route 的真实身份了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace Illuminate\Routing;</span><br><span class="line">class Router implements RegistrarContract &#123;</span><br><span class="line">    ...</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * Register a new GET route with the router.</span><br><span class="line">     *</span><br><span class="line">     * @param  string  $uri</span><br><span class="line">     * @param  \Closure|array|string|null  $action</span><br><span class="line">     * @return \Illuminate\Routing\Route</span><br><span class="line">     */</span><br><span class="line">    public function get($uri, $action = null)</span><br><span class="line">    &#123;</span><br><span class="line">        return $this-&gt;addRoute([&apos;GET&apos;, &apos;HEAD&apos;], $uri, $action);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那 Laravel 是如何为 <code>Illuminate\Support\Facades\Route::class</code> 这个类找到他的真实身份的呢？</p>
<p>首先， <code>class Route extends Facade</code>， <code>Route</code> 继承自 <code>Facade</code> 类，<code>Route</code> 类又调用了静态的 <code>get</code> 方法，我们在 <code>Route</code> 类，或者是他的父类 <code>Facade</code> 中都是无法找到这个 <code>get</code> 方法的。 但是在 <code>Facade</code> 类中，我们可以发现有一个 <code>__callStatic()</code> 魔术方法 ，这个方法的作用就是：如果你想要调用的静态方法在类的定义中并没有声明，那么就会执行 <code>__callStatic()</code> 。在我们当前的情景中，静态方法 <code>get</code> 并没有被声明，那么当然，我们的类就会转而调用 <code>__callStatic()</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static function __callStatic($method, $args)</span><br><span class="line">&#123;</span><br><span class="line">    $instance = static::getFacadeRoot();</span><br><span class="line"> </span><br><span class="line">    if (! $instance) &#123;</span><br><span class="line">        throw new RuntimeException(&apos;A facade root has not been set.&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    switch (count($args)) &#123;</span><br><span class="line">        case 0:</span><br><span class="line">            return $instance-&gt;$method();</span><br><span class="line">        case 1:</span><br><span class="line">            return $instance-&gt;$method($args[0]);</span><br><span class="line">        case 2:</span><br><span class="line">            return $instance-&gt;$method($args[0], $args[1]);</span><br><span class="line">        case 3:</span><br><span class="line">            return $instance-&gt;$method($args[0], $args[1], $args[2]);</span><br><span class="line">        case 4:</span><br><span class="line">            return $instance-&gt;$method($args[0], $args[1], $args[2], $args[3]);</span><br><span class="line">        default:</span><br><span class="line">            return call_user_func_array([$instance, $method], $args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们看 <code>__callStatic()</code> 的执行过程。首先看 <code>getFacadeRoot()</code> 是如何执行的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static function getFacadeRoot()  </span><br><span class="line">&#123;</span><br><span class="line">    return static::resolveFacadeInstance(static::getFacadeAccessor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在最初，定义 Route 类时，我们只实现了一个方法 <code>getFacadeAccessor()</code> ，这时我们当初定义的字符串，就会在此处用到了，所以上面这个函数，实际上返回的内容就是 <code>static::resolveFacadeInstance(&quot;router&quot;);</code></p>
<p>我们继续看 <code>resolveFacadeInstance</code> 这个函数的执行过程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected static function resolveFacadeInstance($name)</span><br><span class="line">&#123;  </span><br><span class="line">    //判断是否为对象，当然不是了，$name 是字符串</span><br><span class="line">    if (is_object($name)) &#123;</span><br><span class="line">        return $name;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    //判断 resolvedInstance 这个数组中是否存了 $name 相关的信息，当然也没有，因为我们假设程序是第一次执行这里</span><br><span class="line">    if (isset(static::$resolvedInstance[$name])) &#123;</span><br><span class="line">        return static::$resolvedInstance[$name];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 返回 static::$app[$name]，同时把得到的结果保存到上面验证的数组中</span><br><span class="line">    return static::$resolvedInstance[$name] = static::$app[$name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以我们的程序执行了最后的一个 return， 返回了 <code>static::$app[‘router’]</code> 这个值。</p>
<p>$app 就是前面说过的 Laravel Application 类的实例化对象，这个类是一个 IOC Container，实例化过程发生在 Laravel 最开始的时候。</p>
<p>在 Facade 初始化的时候，也让自己有了一个 <code>static::$app</code> 这个就是 Application 类的实例化对象。</p>
<p>而 $app 其实并没有 ‘router’ 这个属性，那为什么可以这样调用呢？ 是因为 Application 继承了 Container， 而 Container 又继承了 ArrayAccess 这个类。正是由于 ArrayAccess 的存在，以及 Container 实现了 ArrayAccess 的下面这个方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function offsetGet($key)</span><br><span class="line">&#123;</span><br><span class="line">  return $this-&gt;make($key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，当我们使用 <code>$app[&#39;router&#39;]</code> 时，实际上是执行了 <code>$app-&gt;make(‘router’)</code>，到这里已经比较明显了，这里就是从 $app 这个 IOC Container 中， <code>make</code> 了一个 router 的实例。</p>
<p>已经绕的有点远了，不过还好，我们终于要回去了。到最初的 <code>__callStatic()</code> 中的：</p>
<p><code>$instance = static::getFacadeRoot();</code></p>
<p>也就相当于</p>
<p><code>$instance = $app-&gt;make(‘router’)</code></p>
<p><code>__callStatic()</code> 继续往下执行，想一下我们最初的那条代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Route::get(&apos;/&apos;, function() &#123;</span><br><span class="line">    // ......</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>有2个参数，所以会执行到 case 2 这条语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return $instance-&gt;$method($args[0], $args[1]);</span><br></pre></td></tr></table></figure>
<p>到这里，我们的 $instance 就是我们的 IOC Container make 出的具有实际功能的实例，这个实例将会执行这个实例的类所声明过的 get 方法。</p>
<p>Read More:</p>
<blockquote>
<p><a href="http://laravelacademy.org/post/769.html/comment-page-5#comment-17821" target="_blank" rel="noopener">Laravel 服务容器实例教程 —— 深入理解控制反转（IoC）和依赖注入（DI）</a>  <a href="http://www.tuicool.com/articles/jy6RviE" target="_blank" rel="noopener">Laravel 从 1 行代码开始，带你系统性的理解 Laravel Service Container 的核心概念</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Laravel</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
        <tag>控制反转(IoC)</tag>
        <tag>依赖注入(DI)</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis系列 - 分布式锁</title>
    <url>/2018/05/06/distlock/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>进入正题之前，先来说说问题的产生背景。目前绝大多数的业务都跑在高并发的情境下，而数据库（大多数是mysql）数据一致性的问题是不可避免的，笔者同样遇到了这种问题：</p>
<blockquote>
<p>高并发情境下数据库的数据重复写入问题</p>
</blockquote>
<p>数据的重复写入实际上就是对共享资源的竞争操作，导致数据出现不一致，给线上业务带来影响。解决这种问题，最直接的思路是在数据库层面寻求解决方案，借助数据库的锁机制，或者在业务上通过数据库语句的限制避免重复数据，如：</p>
<ul>
<li>insert ignore into 语句；</li>
<li>on duplicate key update 语句；</li>
<li>insert … select … where not exist 语句；</li>
<li>replace into 语句。</li>
</ul>
<p>以上语句在简单业务中避免mysql插入重复数据是有一定效果的，但是在复杂场景下并不能满足需求。因为高并发业务除了要求数据一致性外，对性能、稳定性的要求也较高，单纯使用数据库语句很难达到预期效果，因此，从单机锁发展而来的分布式锁提供了一种新的解决方案。</p>
<h3 id="SQL语句解决方案"><a href="#SQL语句解决方案" class="headerlink" title="SQL语句解决方案"></a>SQL语句解决方案</h3><p>insert ignore into</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]</span><br><span class="line">    [INTO] tbl_name</span><br><span class="line">    [PARTITION (partition_name [, partition_name] ...)]</span><br><span class="line">    [(col_name [, col_name] ...)]</span><br><span class="line">    SELECT ...</span><br><span class="line">    [ON DUPLICATE KEY UPDATE assignment_list]</span><br><span class="line"></span><br><span class="line">value:</span><br><span class="line">    &#123;expr | DEFAULT&#125;</span><br><span class="line"></span><br><span class="line">assignment:</span><br><span class="line">    col_name = value</span><br><span class="line"></span><br><span class="line">assignment_list:</span><br><span class="line">    assignment [, assignment] ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Specify <strong>IGNORE</strong> to ignore rows that would cause duplicate-key violations. </p>
</blockquote>
<p>通过mysql给出的官方解释：IGNORE 关键字会忽略重复键的行。当插入数据时，如出现错误（重复数据），将不返回错误，只以警告形式返回。所以使用 IGNORE 请确保语句本身没有问题，否则语句的其他错误也会被忽略掉。如果使用 IGNORE 关键字，则插入的字段必须是主键或唯一索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; show tables;</span><br><span class="line">+----------------------------+</span><br><span class="line">| Tables_in_openlivedb       |</span><br><span class="line">+----------------------------+</span><br><span class="line">| admin                      |</span><br><span class="line">| auth_group                 |</span><br><span class="line">| auth_group_permissions     |</span><br><span class="line">| auth_permission            |</span><br><span class="line">| auth_user                  |</span><br><span class="line">| auth_user_groups           |</span><br><span class="line">| auth_user_user_permissions |</span><br><span class="line">| cmd_template               |</span><br><span class="line">| cutter_node                |</span><br><span class="line">| django_admin_log           |</span><br><span class="line">| django_content_type        |</span><br><span class="line">| django_migrations          |</span><br><span class="line">| django_session             |</span><br><span class="line">| flv_slice                  |</span><br><span class="line">| mp4_slice                  |</span><br><span class="line">| test_table                 |</span><br><span class="line">| ts_slice                   |</span><br><span class="line">+----------------------------+</span><br><span class="line">17 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from admin;</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">| id | username          | password                         |</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">|  1 | liuxiaoyang       | 96e79218965eb72c92a549dd5a330112 |</span><br><span class="line">|  4 | liuxiaoyang_test2 |                                  |</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT IGNORE INTO admin (username) VALUES (&apos;liuxiaoyang_test2&apos;);</span><br><span class="line">Query OK, 0 rows affected, 2 warnings (0.09 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from admin;</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">| id | username          | password                         |</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">|  1 | liuxiaoyang       | 96e79218965eb72c92a549dd5a330112 |</span><br><span class="line">|  4 | liuxiaoyang_test2 |                                  |</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT IGNORE INTO admin (username) VALUES (&apos;liuxiaoyang_test3&apos;);</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.11 sec)</span><br></pre></td></tr></table></figure>
<p>以上操作可以看出，插入重复数据时，显示 <code>Query OK, 0 rows affected, 2 warnings (0.09 sec)</code> 表明出现了警告，当在业务中直接执行时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">am = AdminManager()</span><br><span class="line">r = am.execute(&quot;select * from admin&quot;)</span><br><span class="line">for i in r:</span><br><span class="line">    print(i.username)</span><br><span class="line">r2 = am.execute(&quot;INSERT IGNORE INTO admin (username, password) VALUES (&apos;liuxiaoyang_test2&apos;, &apos;123&apos;)&quot;)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">liuxiaoyang</span><br><span class="line">liuxiaoyang_test2</span><br><span class="line">/usr/local/lib/python3.5/dist-packages/pymysql/cursors.py:165: Warning: (1062, &quot;Duplicate entry &apos;liuxiaoyang_test2&apos; for key &apos;username_unique&apos;&quot;)</span><br><span class="line">  result = self._query(query)</span><br></pre></td></tr></table></figure>
<p>同样返回了警告信息。</p>
<p>on duplicate key update</p>
<blockquote>
<p>If you specify an <strong>ON DUPLICATE KEY UPDATE</strong> clause and a row to be inserted would cause a duplicate value in a UNIQUE index or PRIMARY KEY, an UPDATE of the old row occurs.</p>
</blockquote>
<p>当遇到重复键时，对旧行执行 UPDATE 语句，否则插入新行。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from admin;</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">| id | username          | password                         |</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">|  1 | liuxiaoyang       | 96e79218965eb72c92a549dd5a330112 |</span><br><span class="line">|  4 | liuxiaoyang_test2 | 123                              |</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">2 rows in set (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT IGNORE INTO admin (username) VALUES (&apos;liuxiaoyang_test2&apos;) ON DUPLICATE KEY UPDATE password=&apos;345&apos;;</span><br><span class="line">Query OK, 2 rows affected, 1 warning (0.09 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from admin;</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">| id | username          | password                         |</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">|  1 | liuxiaoyang       | 96e79218965eb72c92a549dd5a330112 |</span><br><span class="line">|  4 | liuxiaoyang_test2 | 345                              |</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>对于on duplicate key update语句，必需主键或唯一索引。</p>
<p>insert … select … where not exist</p>
<p>该方法利用了子查询，写法比较繁琐，性能较差，不推荐使用。</p>
<p>replace into </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REPLACE [LOW_PRIORITY | DELAYED]</span><br><span class="line">    [INTO] tbl_name</span><br><span class="line">    [PARTITION (partition_name [, partition_name] ...)]</span><br><span class="line">    [(col_name [, col_name] ...)]</span><br><span class="line">    &#123;VALUES | VALUE&#125; (value_list) [, (value_list)] ...</span><br><span class="line"></span><br><span class="line">value:</span><br><span class="line">    &#123;expr | DEFAULT&#125;</span><br><span class="line"></span><br><span class="line">value_list:</span><br><span class="line">    value [, value] ...</span><br><span class="line"></span><br><span class="line">assignment:</span><br><span class="line">    col_name = value</span><br><span class="line"></span><br><span class="line">assignment_list:</span><br><span class="line">    assignment [, assignment] ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>REPLACE works exactly like INSERT, except that if an old row in the table has the same value as a new row for a PRIMARY KEY or a UNIQUE index, the old row is deleted before the new row is inserted. </p>
</blockquote>
<p>replace into 语句与insert语句类似，只不过它在插入时，如果存在主键或唯一键相同的记录，则会先删除，然后再插入新记录。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from admin;</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">| id | username          | password                         |</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">|  1 | liuxiaoyang       | 96e79218965eb72c92a549dd5a330112 |</span><br><span class="line">|  5 | liuxiaoyang_test2 | 789                              |</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; replace into admin(username, password) values(&apos;liuxiaoyang_test2&apos;, &apos;1111&apos;);</span><br><span class="line">Query OK, 2 rows affected (0.10 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from admin;</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">| id | username          | password                         |</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">|  1 | liuxiaoyang       | 96e79218965eb72c92a549dd5a330112 |</span><br><span class="line">|  6 | liuxiaoyang_test2 | 1111                             |</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>MySQL uses the following algorithm for REPLACE:</p>
<ol>
<li>try to insert the new row into the table        </li>
<li>While the insertion fails because a duplicate-key error occurs for a primary key or unique index:<ul>
<li>Delete from the table the conflicting row that has the duplicate key value;</li>
<li>try again to insert the new row into the table.</li>
</ul>
</li>
</ol>
</blockquote>
<p>以上方法也会有些限制，如目前大多数业务的删除只是逻辑删除，并不做物理删除，在这种场景下就需要寻找其他方案。除了以上方法，mysql还提供了共享锁、排他锁等机制，mysql的锁机制会单独进行介绍，在此就不赘述。</p>
<h3 id="分布式锁解决方案"><a href="#分布式锁解决方案" class="headerlink" title="分布式锁解决方案"></a>分布式锁解决方案</h3><h4 id="何为锁"><a href="#何为锁" class="headerlink" title="何为锁"></a>何为锁</h4><p>在单进程的系统中，当存在多个线程可以同时改变某个变量（可变共享变量）时，就需要对变量或代码块做同步，使其在修改这种变量时能够线性执行消除并发修改变量；</p>
<p>而同步的本质是通过锁来实现的。为了实现多个线程在一个时刻同一个代码块只能有一个线程可执行，那么需要在某个地方做个标记，这个标记必须每个线程都能看到，当标记不存在时可以设置该标记，其余后续线程发现已经有标记了则等待拥有标记的线程结束同步代码块取消标记后再去尝试设置标记。这个标记可以理解为锁，不同地方实现锁的方式也不一样，只要能满足所有线程都能看得到标记即可；</p>
<p>除了利用内存数据做锁，其实任何互斥的都能做锁（只考虑互斥情况），如流水表中流水号与时间结合做幂等校验可以看作是一个不会释放的锁，或者使用某个文件是否存在作为锁等。只需要满足在对标记进行修改能保证原子性和内存可见性即可。</p>
<h4 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式"></a>什么是分布式</h4><p>分布式的 CAP 理论告诉我们：</p>
<blockquote>
<p>任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。</p>
</blockquote>
<p>目前很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。基于 CAP理论，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证最终一致性。</p>
<p>分布式场景</p>
<blockquote>
<p>此处主要指集群模式下，多个相同服务同时运行</p>
</blockquote>
<p>在许多的场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如<strong>分布式事务</strong>、<strong>分布式锁</strong>等。很多时候我们需要保证一个方法在同一时间内只能被同一个线程执行。在单机环境中，通过线程安全队列或者其他方式解决，但是在分布式环境下，这并不是一件容易的事儿。</p>
<ul>
<li>分布式与单机情况下最大的不同在于其不是多线程而是<strong>多进程</strong>；</li>
<li>多线程由于可以共享堆内存，因此可以简单的采取内存作为标记存储位置。而进程之间甚至可能都不在同一台物理机上，因此需要将标记存储在一个所有进程都能看到的地方。</li>
</ul>
<p>分布式锁</p>
<ul>
<li>当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数；</li>
<li>与单机模式下的锁不仅需要保证进程可见，还需要考虑进程与锁之间的网络问题；</li>
<li>分布式锁还是可以将标记存在内存，只是该内存不是某个进程分配的内存而是公共内存如 Redis、Memcache。至于利用数据库、文件等做锁与单机的实现是一样的，只要保证标记能互斥就行。</li>
</ul>
<h4 id="我们需要怎样的分布式锁"><a href="#我们需要怎样的分布式锁" class="headerlink" title="我们需要怎样的分布式锁"></a>我们需要怎样的分布式锁</h4><ul>
<li>在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行； </li>
<li>高可用的获取锁与释放锁； </li>
<li>高性能的获取锁与释放锁； </li>
<li>具备可重入特性； </li>
<li>具备锁失效机制，防止死锁； </li>
<li>具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。</li>
</ul>
<h4 id="分布式锁-基于数据库"><a href="#分布式锁-基于数据库" class="headerlink" title="分布式锁-基于数据库"></a>分布式锁-基于数据库</h4><p>乐观锁 - 基于表主键唯一做分布式锁</p>
<p>利用主键唯一的特性，如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，当方法执行完毕之后，想要释放锁的话，删除这条数据库记录即可。</p>
<p>这种简单的实现有以下几个问题：</p>
<ul>
<li>这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用；</li>
<li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁；</li>
<li>这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作；</li>
<li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了；</li>
<li>这把锁是非公平锁，所有等待锁的线程凭运气去争夺锁；</li>
<li>在 mysql 数据库中采用主键冲突防重，在大并发情况下有可能会造成锁表现象。</li>
</ul>
<p>当然，我们也可以有其他方式解决上面的问题。</p>
<ul>
<li>数据库是单点？搞两个数据库，数据之前双向同步，一旦挂掉快速切换到备库上；</li>
<li>没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍；</li>
<li>非阻塞的？搞一个 while 循环，直到 insert 成功再返回成功；</li>
<li>非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了；</li>
<li>非公平的？再建一张中间表，将等待锁的线程全记录下来，并根据创建时间排序，只有最先创建的允许获取锁；</li>
<li>比较好的办法是在程序中生产主键进行防重。</li>
</ul>
<p>乐观锁 - 基于表字段版本号做分布式锁</p>
<p>这个策略源于 mysql 的 mvcc 机制，使用这个策略其实本身没有什么问题，唯一的问题就是对数据表侵入较大，我们要为每个表设计一个版本号字段，然后写一条判断 sql 每次进行判断，增加了数据库操作的次数，在高并发的要求下，对数据库连接的开销也是无法忍受的。</p>
<p>悲观锁 - 基于数据库排他锁做分布式锁</p>
<p>在查询语句后面增加 <code>for update</code>，数据库会在查询过程中给数据库表增加排他锁 （注意： InnoDB 引擎在加锁的时候，只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。这里我们希望使用行级锁，就要给要执行的方法字段名添加索引，值得注意的是，这个索引一定要创建成唯一索引，否则会出现多个重载方法之间无法同时被访问的问题。重载方法的话建议把参数类型也加上）。当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。</p>
<p>我们可以认为获得排他锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，通过 <code>connection.commit()</code> 操作来释放锁。</p>
<p>这种方法可以有效的解决上面提到的无法释放锁和阻塞锁的问题。</p>
<ul>
<li>阻塞锁？ <code>for update</code>语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功；</li>
<li>锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉。</li>
</ul>
<p>但是还是无法直接解决数据库单点和可重入问题。虽然我们对方法字段名使用了唯一索引，并且显示使用 <code>for update</code>来使用行级锁。但是，MySQL 会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。</p>
<p>还有一个问题，就是我们要使用排他锁来进行分布式锁的 lock，那么一个排他锁长时间不提交，就会占用数据库连接。一旦类似的连接变得多了，就可能把数据库连接池撑爆。</p>
<h4 id="分布式锁-基于Redis"><a href="#分布式锁-基于Redis" class="headerlink" title="分布式锁-基于Redis"></a>分布式锁-基于Redis</h4><p>Redis分布式锁主要使用其SETNX()、EXPIRE() 方法实现。</p>
<blockquote>
<p>SETNX key value : 将 <code>key</code> 的值设为 <code>value</code> ，当且仅当 <code>key</code> 不存在。若给定的 <code>key</code> 已经存在，则 ＳETNX 不做任何动作。SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p>
<p>EXPIRE key seconds : 为给定 <code>key</code> 设置生存时间，当 <code>key</code> 过期时(生存时间为 <code>0</code> )，它会被自动删除。</p>
</blockquote>
<p>但是从 Redis 2.6.12 版本开始， SET 命令的行为可以通过一系列参数来修改：</p>
<ul>
<li><code>EX second</code> ：设置键的过期时间为 <code>second</code> 秒。 <code>SET key value EX second</code> 效果等同于 <code>SETEX key second value</code> 。</li>
<li><code>PX millisecond</code> ：设置键的过期时间为 <code>millisecond</code> 毫秒。 <code>SET key value PX millisecond</code> 效果等同于 <code>PSETEX key millisecondvalue</code> 。</li>
<li><code>NX</code> ：只在键不存在时，才对键进行设置操作。 <code>SET key value NX</code> 效果等同于 <code>SETNX key value</code> 。</li>
<li><code>XX</code> ：只在键已经存在时，才对键进行设置操作。</li>
</ul>
<p>所以SETNX()、EXPIRE() 方法被融合进了SET方法，而<a href="http://redisdoc.com/string/set.html" target="_blank" rel="noopener">官网</a> 给出</p>
<blockquote>
<p>因为 <a href="http://redisdoc.com/string/set.html#set" target="_blank" rel="noopener">SET</a> 命令可以通过参数来实现和 <a href="http://redisdoc.com/string/setnx.html#setnx" target="_blank" rel="noopener">SETNX</a> 、 <a href="http://redisdoc.com/string/setex.html#setex" target="_blank" rel="noopener">SETEX</a> 和 <a href="http://redisdoc.com/string/psetex.html#psetex" target="_blank" rel="noopener">PSETEX</a> 三个命令的效果，所以将来的 Redis 版本可能会废弃并最终移除<a href="http://redisdoc.com/string/setnx.html#setnx" target="_blank" rel="noopener">SETNX</a> 、 <a href="http://redisdoc.com/string/setex.html#setex" target="_blank" rel="noopener">SETEX</a> 和 <a href="http://redisdoc.com/string/psetex.html#psetex" target="_blank" rel="noopener">PSETEX</a> 这三个命令。</p>
</blockquote>
<p>在使用Redis实现分布式锁时，我们可以通过SET来实现。</p>
<p>设计思路</p>
<blockquote>
<p>获取锁：</p>
<ul>
<li>调用 set 尝试获取锁，如果设置成功，表示获取到了锁；</li>
<li>设置失败，<ul>
<li>等待一定时间后，再次尝试获取锁；</li>
<li>若已达到最大获取锁时间未获取到锁，获取锁失败。</li>
</ul>
</li>
</ul>
<p>释放锁：</p>
<ul>
<li>确保每个客户端释放的是自己的锁；</li>
<li>确保释放锁操作的原子性。</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import time</span><br><span class="line">import traceback</span><br><span class="line"></span><br><span class="line">from contextlib import contextmanager</span><br><span class="line">from lib.utils import get_logger</span><br><span class="line">from tornado import gen</span><br><span class="line"></span><br><span class="line">DEFAULT_EXPIRES = 3</span><br><span class="line">ACQUIRE_TIMEOUT = 1</span><br><span class="line"></span><br><span class="line">lock_logger = get_logger(&quot;redis_netlock&quot;)</span><br><span class="line"></span><br><span class="line">@contextmanager</span><br><span class="line">def dist_lock(key, client, unique_id acquire_timeout=ACQUIRE_TIMEOUT):</span><br><span class="line">    key = &apos;lock_%s&apos; % key</span><br><span class="line">    try:</span><br><span class="line">        t = _acquire_lock(key, client, unique_id, acquire_timeout)</span><br><span class="line">        yield t</span><br><span class="line">    finally:</span><br><span class="line">        _release_lock(key, client, t)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def _acquire_lock(key, client, unique_id, acquire_timeout):</span><br><span class="line">    end = time.time() + acquire_timeout</span><br><span class="line">    while time.time() &lt; end:</span><br><span class="line">        if client.set(key, unique_id, ex=DEFAULT_EXPIRES, nx=True):</span><br><span class="line">            return unique_id</span><br><span class="line">        else:</span><br><span class="line">            gen.sleep(.01)</span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def _release_lock(key, client, t):</span><br><span class="line">    try:</span><br><span class="line">        lua_command = &quot;&quot;&quot;</span><br><span class="line">            if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1]</span><br><span class="line">            then</span><br><span class="line">                return redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line">            else</span><br><span class="line">                return 0</span><br><span class="line">            end</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        lua_script = client.register_script(lua_command)</span><br><span class="line">        lock_logger.debug(lua_script(keys=[key], args=[t]))</span><br><span class="line">    except Exception as e:</span><br><span class="line">        lock_logger.error(traceback.format_exc())</span><br></pre></td></tr></table></figure>
<p>unique_id：uuid1() 提供的全球唯一值，保证每个客户端释放的是自己的锁。</p>
<p>使用lua脚本释放锁是为了保证释放锁操作的原子性：</p>
<blockquote>
<p><strong>Atomicity of scripts</strong></p>
<p>Redis uses the same Lua interpreter to run all the commands. Also Redis guarantees that a script is executed in an atomic way: no other script or Redis command will be executed while a script is being executed. This semantic is similar to the one of MULTI / EXEC. From the point of view of all the other clients the effects of a script are either still not visible or already completed.</p>
<p>However this also means that executing slow scripts is not a good idea. It is not hard to create fast scripts, as the script overhead is very low, but if you are going to use slow scripts you should be aware that while the script is running no other client can execute commands.</p>
</blockquote>
<p>获取锁时，给定超时时间是１s，避免出现死锁现象。</p>
<p>使用redis分布式锁的问题是，失效时间的设置。如果设置的失效时间太短，方法没等执行完，锁就自动释放了，那么就会产生并发问题。</p>
<h4 id="分布式锁-基于RedLock"><a href="#分布式锁-基于RedLock" class="headerlink" title="分布式锁-基于RedLock"></a>分布式锁-基于RedLock</h4><p>Redlock 是 Redis 的作者 antirez 给出的集群模式的 Redis 分布式锁，它基于 N 个完全独立的 Redis 节点（通常情况下 N 可以设置成 5）。</p>
<p>算法的步骤如下：</p>
<ol>
<li>客户端获取当前时间，以毫秒为单位；</li>
<li>客户端尝试获取 N 个节点的锁，（每个节点获取锁的方式和前面说的缓存锁一样），N 个节点以相同的 key 和 value 获取锁。客户端需要设置接口访问超时，接口超时时间需要远远小于锁超时时间，比如锁自动释放的时间是 10s，那么接口超时大概设置 5-50ms。这样可以在有 redis 节点宕机后，访问该节点时能尽快超时，而减小锁的正常使用；</li>
<li>客户端计算在获得锁的时候花费了多少时间，方法是用当前时间减去在步骤一获取的时间，只有客户端获得了超过 3 个节点的锁，而且获取锁的时间小于锁的超时时间，客户端才获得了分布式锁；</li>
<li>客户端获取的锁的时间为设置的锁超时时间减去步骤三计算出的获取锁花费时间；</li>
<li>如果客户端获取锁失败了，客户端会依次删除所有的锁。</li>
</ol>
<p>使用 Redlock 算法，可以保证在挂掉最多 2 个节点的时候，分布式锁服务仍然能工作，这相比之前的数据库锁和缓存锁大大提高了可用性，由于 redis 的高效性能，分布式缓存锁性能并不比数据库锁差。</p>
<h4 id="分布式锁-基于Zookeeper"><a href="#分布式锁-基于Zookeeper" class="headerlink" title="分布式锁-基于Zookeeper"></a>分布式锁-基于Zookeeper</h4><p>ZooKeeper的架构通过冗余服务实现高可用性。因此，如果第一次无应答，客户端就可以询问另一台ZooKeeper主机。ZooKeeper节点将它们的数据存储于一个分层的命名空间，非常类似于一个文件系统或一个前缀树结构。客户端可以在节点读写，从而以这种方式拥有一个共享的配置服务，更新是全序的。</p>
<p> <img src="/images/2018-05-06T184140.png" alt="2018-05-06T184140"></p>
<p>上图为系统架构，左边区域表示一个ZooKeeper集群，locker是ZooKeeper的一个持久节点，node_1、node_2、node_3是locker这个持久节点下面的临时顺序节点。client_1、client_2、client_3表示多个客户端，Share_Service表示需要互斥访问的共享资源。</p>
<p>Zookeeper实现分布式锁的思路：</p>
<ol>
<li>多个客户端竞争创建 lock 临时节点；</li>
<li>其中某个客户端成功创建 lock 节点，其他客户端对 lock 节点设置 watcher；</li>
<li>持有锁的客户端删除 lock 节点或该客户端崩溃，由 Zookeeper 删除 lock 节点；</li>
<li>其他客户端获得 lock 节点被删除的通知；</li>
<li><p>重复上述4个步骤，直至无客户端在等待获取锁了。</p>
<p><img src="/images/2018-05-06T190223.png" alt="2018-05-06T190223"></p>
</li>
</ol>
<p>Zookeeper方式性能上可能并没有缓存服务那么高，因为每次在创建锁和释放锁的过程中，都要动态创建、销毁临时节点来实现锁功能。ZK 中创建和删除节点只能通过 Leader 服务器来执行，然后将数据同步到所有的 Follower 机器上。</p>
<p>由于目前理解有限，一些细节需要进一步确定和实践，不当之处请指正。</p>
<p>Read More:</p>
<blockquote>
<p><a href="https://www.cnblogs.com/austinspark-jessylu/p/8043726.html" target="_blank" rel="noopener">分布式锁的几种实现方式</a> <a href="http://www.importnew.com/27477.html" target="_blank" rel="noopener">Redis分布式锁的正确实现方式（Java版）</a> <a href="https://mp.weixin.qq.com/s/JTsJCDuasgIJ0j95K8Ay8w" target="_blank" rel="noopener">基于Redis的分布式锁到底安全吗（上）？</a> <a href="http://www.54tianzhisheng.cn/2018/04/24/Distributed_lock/#%E5%9F%BA%E4%BA%8E-Redlock-%E5%81%9A%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81" target="_blank" rel="noopener">分布式锁看这篇就够了</a> <a href="https://segmentfault.com/a/1190000010895869" target="_blank" rel="noopener">基于 Zookeeper 的分布式锁实现</a> <a href="http://redisdoc.com/" target="_blank" rel="noopener">Redis命令参考</a> <a href="https://redis.io/commands/eval" target="_blank" rel="noopener">Redis Lua scripting</a> <a href="https://dev.mysql.com/doc/" target="_blank" rel="noopener">mysql document</a></p>
</blockquote>
]]></content>
      <categories>
        <category>分布式锁</category>
      </categories>
      <tags>
        <tag>分布式锁</tag>
        <tag>数据库</tag>
        <tag>redis</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Transitions-Python状态机库</title>
    <url>/2017/05/26/transitionstranslate/</url>
    <content><![CDATA[<p>由于项目需要，使用到了Python的状态机库 <a href="https://github.com/tyarkoni/transitions" target="_blank" rel="noopener">Transitions</a> ，但GitHub上是英文文档，使用过后觉得还不错，遂手工翻译一下，加深理解，水平有限，如有翻译不当之处请Email (<a href="mailto:kevin920902@gmail.com" target="_blank" rel="noopener">kevin920902@gmail.com</a>) 我。</p>
<h2 id="Transitions"><a href="#Transitions" class="headerlink" title="Transitions"></a>Transitions</h2><p>Python 实现的轻量级、面向对象状态机，兼容Python 2.7+ 和 Python 3.0+。</p>
<h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><p>方法一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install transitions</span><br></pre></td></tr></table></figure>
<p>方法二</p>
<p>直接在 <a href="https://github.com/tyarkoni/transitions" target="_blank" rel="noopener">GitHub</a> 上clone仓库到本地，然后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>俗话说，接触一个新的工具库，100页的API文档、一千字的描述文档或更多的解释说明都不如一个简单的Demo，虽然这个说法我们无法验证真伪，但下面的例子会让你快速了解 <code>Transitions</code> 的基本用法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from transitions import Machine</span><br><span class="line">import random</span><br><span class="line"></span><br><span class="line">class NarcolepticSuperhero(object):</span><br><span class="line"></span><br><span class="line">    # Define some states. Most of the time, narcoleptic superheroes are just like</span><br><span class="line">    # everyone else. Except for...</span><br><span class="line">    states = [&apos;asleep&apos;, &apos;hanging out&apos;, &apos;hungry&apos;, &apos;sweaty&apos;, &apos;saving the world&apos;]</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line"></span><br><span class="line">        # No anonymous superheroes on my watch! Every narcoleptic superhero gets</span><br><span class="line">        # a name. Any name at all. SleepyMan. SlumberGirl. You get the idea.</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">        # What have we accomplished today?</span><br><span class="line">        self.kittens_rescued = 0</span><br><span class="line"></span><br><span class="line">        # Initialize the state machine</span><br><span class="line">        self.machine = Machine(model=self, states=NarcolepticSuperhero.states, initial=&apos;asleep&apos;)</span><br><span class="line"></span><br><span class="line">        # Add some transitions. We could also define these using a static list of</span><br><span class="line">        # dictionaries, as we did with states above, and then pass the list to</span><br><span class="line">        # the Machine initializer as the transitions= argument.</span><br><span class="line"></span><br><span class="line">        # At some point, every superhero must rise and shine.</span><br><span class="line">        self.machine.add_transition(trigger=&apos;wake_up&apos;, source=&apos;asleep&apos;, dest=&apos;hanging out&apos;)</span><br><span class="line"></span><br><span class="line">        # Superheroes need to keep in shape.</span><br><span class="line">        self.machine.add_transition(&apos;work_out&apos;, &apos;hanging out&apos;, &apos;hungry&apos;)</span><br><span class="line"></span><br><span class="line">        # Those calories won&apos;t replenish themselves!</span><br><span class="line">        self.machine.add_transition(&apos;eat&apos;, &apos;hungry&apos;, &apos;hanging out&apos;)</span><br><span class="line"></span><br><span class="line">        # Superheroes are always on call. ALWAYS. But they&apos;re not always</span><br><span class="line">        # dressed in work-appropriate clothing.</span><br><span class="line">        self.machine.add_transition(&apos;distress_call&apos;, &apos;*&apos;, &apos;saving the world&apos;,</span><br><span class="line">                         before=&apos;change_into_super_secret_costume&apos;)</span><br><span class="line"></span><br><span class="line">        # When they get off work, they&apos;re all sweaty and disgusting. But before</span><br><span class="line">        # they do anything else, they have to meticulously log their latest</span><br><span class="line">        # escapades. Because the legal department says so.</span><br><span class="line">        self.machine.add_transition(&apos;complete_mission&apos;, &apos;saving the world&apos;, &apos;sweaty&apos;,</span><br><span class="line">                         after=&apos;update_journal&apos;)</span><br><span class="line"></span><br><span class="line">        # Sweat is a disorder that can be remedied with water.</span><br><span class="line">        # Unless you&apos;ve had a particularly long day, in which case... bed time!</span><br><span class="line">        self.machine.add_transition(&apos;clean_up&apos;, &apos;sweaty&apos;, &apos;asleep&apos;, conditions=[&apos;is_exhausted&apos;])</span><br><span class="line">        self.machine.add_transition(&apos;clean_up&apos;, &apos;sweaty&apos;, &apos;hanging out&apos;)</span><br><span class="line"></span><br><span class="line">        # Our NarcolepticSuperhero can fall asleep at pretty much any time.</span><br><span class="line">        self.machine.add_transition(&apos;nap&apos;, &apos;*&apos;, &apos;asleep&apos;)</span><br><span class="line"></span><br><span class="line">    def update_journal(self):</span><br><span class="line">        &quot;&quot;&quot; Dear Diary, today I saved Mr. Whiskers. Again. &quot;&quot;&quot;</span><br><span class="line">        self.kittens_rescued += 1</span><br><span class="line"></span><br><span class="line">    def is_exhausted(self):</span><br><span class="line">        &quot;&quot;&quot; Basically a coin toss. &quot;&quot;&quot;</span><br><span class="line">        return random.random() &lt; 0.5</span><br><span class="line"></span><br><span class="line">    def change_into_super_secret_costume(self):</span><br><span class="line">        print(&quot;Beauty, eh?&quot;)</span><br></pre></td></tr></table></figure>
<p>现在我们已经建立了一个 <code>NarcolepticSuperhero</code> 状态机，来看看具体怎么使用吧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; batman = NarcolepticSuperhero(&quot;Batman&quot;)</span><br><span class="line">&gt;&gt;&gt; batman.state</span><br><span class="line">&apos;asleep&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; batman.wake_up()</span><br><span class="line">&gt;&gt;&gt; batman.state</span><br><span class="line">&apos;hanging out&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; batman.nap()</span><br><span class="line">&gt;&gt;&gt; batman.state</span><br><span class="line">&apos;asleep&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; batman.clean_up()</span><br><span class="line">MachineError: &quot;Can&apos;t trigger event clean_up from state asleep!&quot;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; batman.wake_up()</span><br><span class="line">&gt;&gt;&gt; batman.work_out()</span><br><span class="line">&gt;&gt;&gt; batman.state</span><br><span class="line">&apos;hungry&apos;</span><br><span class="line"></span><br><span class="line"># Batman still hasn&apos;t done anything useful...</span><br><span class="line">&gt;&gt;&gt; batman.kittens_rescued</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line"># We now take you live to the scene of a horrific kitten entreement...</span><br><span class="line">&gt;&gt;&gt; batman.distress_call()</span><br><span class="line">&apos;Beauty, eh?&apos;</span><br><span class="line">&gt;&gt;&gt; batman.state</span><br><span class="line">&apos;saving the world&apos;</span><br><span class="line"></span><br><span class="line"># Back to the crib.</span><br><span class="line">&gt;&gt;&gt; batman.complete_mission()</span><br><span class="line">&gt;&gt;&gt; batman.state</span><br><span class="line">&apos;sweaty&apos;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; batman.clean_up()</span><br><span class="line">&gt;&gt;&gt; batman.state</span><br><span class="line">&apos;asleep&apos;   # Too tired to shower!</span><br><span class="line"></span><br><span class="line"># Another productive day, Alfred.</span><br><span class="line">&gt;&gt;&gt; batman.kittens_rescued</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<h2 id="详细文档"><a href="#详细文档" class="headerlink" title="详细文档"></a>详细文档</h2><h3 id="基本初始化方式"><a href="#基本初始化方式" class="headerlink" title="基本初始化方式"></a>基本初始化方式</h3><p>使状态机正常运行非常简单。 假设你有一个对象 <code>lump</code> ( <code>Matter</code> 类的一个实例) ，并且你想要管理它的状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Matter(object):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">lump = Matter()</span><br></pre></td></tr></table></figure>
<p>我们将 <code>lump</code> 绑定到状态机上来初始化一个<strong>最小状态机</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from transitions import Machine</span><br><span class="line">machine = Machine(model=lump, states=[&apos;solid&apos;, &apos;liquid&apos;, &apos;gas&apos;, &apos;plasma&apos;], initial=&apos;solid&apos;)</span><br><span class="line"></span><br><span class="line"># Lump now has state!</span><br><span class="line">lump.state</span><br><span class="line">&gt;&gt;&gt; &apos;solid&apos;</span><br></pre></td></tr></table></figure>
<p> 之所以称之为<strong>最小状态机</strong>，因为这种状态机在技术上是可操作的，状态机初试状态为 <code>solid</code> ，但因为我们没有增加任何的转移动作(transitions：这应该是个动词，我在这翻译为转移动作)， 所以它实际上什么也没做。</p>
<p>下面我们来定义更多的状态和转移动作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># The states</span><br><span class="line">states=[&apos;solid&apos;, &apos;liquid&apos;, &apos;gas&apos;, &apos;plasma&apos;]</span><br><span class="line"></span><br><span class="line"># And some transitions between states. We&apos;re lazy, so we&apos;ll leave out</span><br><span class="line"># the inverse phase transitions (freezing, condensation, etc.).</span><br><span class="line">transitions = [</span><br><span class="line">    &#123; &apos;trigger&apos;: &apos;melt&apos;, &apos;source&apos;: &apos;solid&apos;, &apos;dest&apos;: &apos;liquid&apos; &#125;,</span><br><span class="line">    &#123; &apos;trigger&apos;: &apos;evaporate&apos;, &apos;source&apos;: &apos;liquid&apos;, &apos;dest&apos;: &apos;gas&apos; &#125;,</span><br><span class="line">    &#123; &apos;trigger&apos;: &apos;sublimate&apos;, &apos;source&apos;: &apos;solid&apos;, &apos;dest&apos;: &apos;gas&apos; &#125;,</span><br><span class="line">    &#123; &apos;trigger&apos;: &apos;ionize&apos;, &apos;source&apos;: &apos;gas&apos;, &apos;dest&apos;: &apos;plasma&apos; &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># Initialize</span><br><span class="line">machine = Machine(lump, states=states, transitions=transitions, initial=&apos;liquid&apos;)</span><br><span class="line"></span><br><span class="line"># Now lump maintains state...</span><br><span class="line">lump.state</span><br><span class="line">&gt;&gt;&gt; &apos;liquid&apos;</span><br><span class="line"></span><br><span class="line"># And that state can change...</span><br><span class="line">lump.evaporate()</span><br><span class="line">lump.state</span><br><span class="line">&gt;&gt;&gt; &apos;gas&apos;</span><br><span class="line">lump.trigger(&apos;ionize&apos;)</span><br><span class="line">lump.state</span><br><span class="line">&gt;&gt;&gt; &apos;plasma&apos;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：我们为 <code>Matter</code>  实例 <code>lump</code> 绑定了 <code>evaporate()</code>  <code>ionize()</code> 等方法，每个方法触发相应的状态转换，你不必在任何地方明确定义这些方法，每个转换的名称通过绑定到模型上来传递给状态机初始化函数(<code>lump</code>)。<code>evaporate()</code>  <code>ionize()</code>另等方法都是静态来触发状态转移，如果我们想实现动态转移，可以使用<code>trigger</code> 方法。</p>
<h3 id="状态集"><a href="#状态集" class="headerlink" title="状态集"></a>状态集</h3><p>毫无疑问，状态机的核心是状态集，上述介绍中我们通过传递给 <code>Machine</code> 初始化函数字符串列表来定义有效的模型状态，但是在 <code>Machine</code> 内部，状态以 <code>State</code> 对象的形式存储。</p>
<p>我们可以通过多种方式初始化和跟新状态，比如：</p>
<ul>
<li>传递一个给定状态名的字符串给 <code>Machine</code> 初始化函数；</li>
<li>直接初始化每个新的 <code>State</code> 对象；</li>
<li>传递具有初始化参数的字典。</li>
</ul>
<p>以下代码片段说明了实现相同目标的几种方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Create a list of 3 states to pass to the Machine</span><br><span class="line"># initializer. We can mix types; in this case, we</span><br><span class="line"># pass one State, one string, and one dict.</span><br><span class="line">states = [</span><br><span class="line">    State(name=&apos;solid&apos;),</span><br><span class="line">    &apos;liquid&apos;,</span><br><span class="line">    &#123; &apos;name&apos;: &apos;gas&apos;&#125;</span><br><span class="line">    ]</span><br><span class="line">machine = Machine(lump, states)</span><br><span class="line"></span><br><span class="line"># This alternative example illustrates more explicit</span><br><span class="line"># addition of states and state callbacks, but the net</span><br><span class="line"># result is identical to the above.</span><br><span class="line">machine = Machine(lump)</span><br><span class="line">solid = State(&apos;solid&apos;)</span><br><span class="line">liquid = State(&apos;liquid&apos;)</span><br><span class="line">gas = State(&apos;gas&apos;)</span><br><span class="line">machine.add_states([solid, liquid, gas])</span><br></pre></td></tr></table></figure>
<h4 id="回调方法"><a href="#回调方法" class="headerlink" title="回调方法"></a>回调方法</h4><p>我们可以给一个状态添加一系列的”进入“和”退出“的回调函数，还可以在初始化期间指定回调，或者稍后再添加回调。</p>
<p>为方便起见，每当新的状态被添加到 <code>Machine</code> 中时，方法 <code>on_enter_«state name»</code> 和 <code>on_exit_«state name»</code> 都是在 <code>Machine</code> 上（而不是 <code>Model</code> 上）上动态创建的，并且允许我们动态地添加新的进入和退出回调函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Our old Matter class, now with  a couple of new methods we</span><br><span class="line"># can trigger when entering or exit states.</span><br><span class="line">class Matter(object):</span><br><span class="line">    def say_hello(self): print(&quot;hello, new state!&quot;)</span><br><span class="line">    def say_goodbye(self): print(&quot;goodbye, old state!&quot;)</span><br><span class="line"></span><br><span class="line">lump = Matter()</span><br><span class="line"></span><br><span class="line"># Same states as above, but now we give StateA an exit callback</span><br><span class="line">states = [</span><br><span class="line">    State(name=&apos;solid&apos;, on_exit=[&apos;say_goodbye&apos;]),</span><br><span class="line">    &apos;liquid&apos;,</span><br><span class="line">    &#123; &apos;name&apos;: &apos;gas&apos; &#125;</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">machine = Machine(lump, states=states)</span><br><span class="line">machine.add_transition(&apos;sublimate&apos;, &apos;solid&apos;, &apos;gas&apos;)</span><br><span class="line"></span><br><span class="line"># Callbacks can also be added after initialization using</span><br><span class="line"># the dynamically added on_enter_ and on_exit_ methods.</span><br><span class="line"># Note that the initial call to add the callback is made</span><br><span class="line"># on the Machine and not on the model.</span><br><span class="line">machine.on_enter_gas(&apos;say_hello&apos;)</span><br><span class="line"></span><br><span class="line"># Test out the callbacks...</span><br><span class="line">machine.set_state(&apos;solid&apos;)</span><br><span class="line">lump.sublimate()</span><br><span class="line">&gt;&gt;&gt; &apos;goodbye, old state!&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;hello, new state!&apos;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：首次初始化状态机时， <code>on_enter_«state name»</code> 回调函数是不会触发的。例如，我们定义了一个回调函数 <code>on_enter_A()</code> ，并给状态机初始化状态为 <code>initial=&#39;A&#39;</code> ，<code>on_enter_A()</code> 会在下次进入状态A的时候出发，首次并不会触发。如果我们想在初始化的时候就触发 <code>on_enter_A()</code> 方法，可以创建一个虚拟的初始状态，然后调用 <code>to_A()</code> 方法，而不是 <code>__init__</code> 方法。 </p>
<p>除了在初始化状态机传递回调或动态添加回调，为增加代码的清晰度，还可以在模型类本身中定义回调。例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Matter(object):</span><br><span class="line">    def say_hello(self): print(&quot;hello, new state!&quot;)</span><br><span class="line">    def say_goodbye(self): print(&quot;goodbye, old state!&quot;)</span><br><span class="line">    def on_enter_A(self): print(&quot;We&apos;ve just entered state A!&quot;)</span><br><span class="line"></span><br><span class="line">lump = Matter()</span><br><span class="line">machine = Machine(lump, states=[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;])</span><br></pre></td></tr></table></figure>
<p>现在，任何时候 <code>lump</code> 转移到状态A，类<code>Matter</code> 中的 <code>on_enter_A()</code> 方法总是会触发。</p>
<h4 id="检查状态"><a href="#检查状态" class="headerlink" title="检查状态"></a>检查状态</h4><p>我们可以随时通过以下方式检查模型的当前状态</p>
<ul>
<li>检查 <code>.state</code> 属性；</li>
<li>调用 <code>is_«state name»()</code>  方法。</li>
</ul>
<p>如果要检索当前状态的实际状态对象，可以通过 <code>Machine</code> 实例的 <code>get_state()</code> 方法来实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lump.state</span><br><span class="line">&gt;&gt;&gt; &apos;solid&apos;</span><br><span class="line">lump.is_gas()</span><br><span class="line">&gt;&gt;&gt; False</span><br><span class="line">lump.is_solid()</span><br><span class="line">&gt;&gt;&gt; True</span><br><span class="line">machine.get_state(lump.state).name</span><br><span class="line">&gt;&gt;&gt; &apos;solid&apos;</span><br></pre></td></tr></table></figure>
<h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>上面的一些例子已经说明了状态转移的使用，但是在这里我们将更详细地探讨它们。</p>
<p>与状态一样，每个状态转换在内部用 <code>Transitions</code> 对象来表示，我们可以传递一个字典或字典列表来快速初始化状态转换集合。</p>
<p>如上面我们已经写过的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transitions = [</span><br><span class="line">    &#123; &apos;trigger&apos;: &apos;melt&apos;, &apos;source&apos;: &apos;solid&apos;, &apos;dest&apos;: &apos;liquid&apos; &#125;,</span><br><span class="line">    &#123; &apos;trigger&apos;: &apos;evaporate&apos;, &apos;source&apos;: &apos;liquid&apos;, &apos;dest&apos;: &apos;gas&apos; &#125;,</span><br><span class="line">    &#123; &apos;trigger&apos;: &apos;sublimate&apos;, &apos;source&apos;: &apos;solid&apos;, &apos;dest&apos;: &apos;gas&apos; &#125;,</span><br><span class="line">    &#123; &apos;trigger&apos;: &apos;ionize&apos;, &apos;source&apos;: &apos;gas&apos;, &apos;dest&apos;: &apos;plasma&apos; &#125;</span><br><span class="line">]</span><br><span class="line">machine = Machine(model=Matter(), states=states, transitions=transitions)</span><br></pre></td></tr></table></figure>
<p>使用字典定义转换有利于代码的清晰，但显得比较笨重。比较简单的方法是使用列表定义转换，只需确保每个列表中的元素与 <code>Transition</code> 初始化中的位置参数的顺序相同(比如 <code>trigger</code>, <code>source</code>, <code>destination</code> 等)</p>
<p>我们可以这样定义转换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transitions = [</span><br><span class="line">    [&apos;melt&apos;, &apos;solid&apos;, &apos;liquid&apos;],</span><br><span class="line">    [&apos;evaporate&apos;, &apos;liquid&apos;, &apos;gas&apos;],</span><br><span class="line">    [&apos;sublimate&apos;, &apos;solid&apos;, &apos;gas&apos;],</span><br><span class="line">    [&apos;ionize&apos;, &apos;gas&apos;, &apos;plasma&apos;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>另外，我们也可以在状态机初始化之后添加转换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">machine = Machine(model=lump, states=states, initial=&apos;solid&apos;)</span><br><span class="line">machine.add_transition(&apos;melt&apos;, source=&apos;solid&apos;, dest=&apos;liquid&apos;)</span><br></pre></td></tr></table></figure>
<p> <code>trigger</code> 参数定义了绑定到模型上的触发方法的名称，当回调这个方法的时候，状态机会执行相应的状态转换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; lump.melt()</span><br><span class="line">&gt;&gt;&gt; lump.state</span><br><span class="line">&apos;liquid&apos;</span><br></pre></td></tr></table></figure>
<p>当我们调用非法的转换时，<code>Machine</code> 会抛出异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; lump.to_gas()</span><br><span class="line">&gt;&gt;&gt; # This won&apos;t work because only objects in a solid state can melt</span><br><span class="line">&gt;&gt;&gt; lump.melt()</span><br><span class="line">transitions.core.MachineError: &quot;Can&apos;t trigger event melt from state gas!&quot;</span><br></pre></td></tr></table></figure>
<p>这种做法通常是可取的，因为它有助于提醒代码中的问题。但是在某些情况下，我们希望忽略这些非法转换，这时可以设置 <code>ignore_invalid_triggers=True</code> (可以全部忽略，也可忽略特定一条)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; # Globally suppress invalid trigger exceptions</span><br><span class="line">&gt;&gt;&gt; m = Machine(lump, states, initial=&apos;solid&apos;, ignore_invalid_triggers=True)</span><br><span class="line">&gt;&gt;&gt; # ...or suppress for only one group of states</span><br><span class="line">&gt;&gt;&gt; states = [&apos;new_state1&apos;, &apos;new_state2&apos;]</span><br><span class="line">&gt;&gt;&gt; m.add_states(states, ignore_invalid_triggers=True)</span><br><span class="line">&gt;&gt;&gt; # ...or even just for a single state. Here, exceptions will only be suppressed when the current state is A.</span><br><span class="line">&gt;&gt;&gt; states = [State(&apos;A&apos;, ignore_invalid_triggers=True), &apos;B&apos;, &apos;C&apos;]</span><br><span class="line">&gt;&gt;&gt; m = Machine(lump, states)</span><br></pre></td></tr></table></figure>
<p>如果在做状态转换之前，希望知道在当前状态下，哪些是合法的转换，可以使用 <code>get_triggers()</code> 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">m.get_triggers(&apos;solid&apos;)</span><br><span class="line">&gt;&gt;&gt; [&apos;melt&apos;, &apos;sublimate&apos;]</span><br><span class="line">m.get_triggers(&apos;liquid&apos;)</span><br><span class="line">&gt;&gt;&gt; [&apos;evaporate&apos;]</span><br><span class="line">m.get_triggers(&apos;plasma&apos;)</span><br><span class="line">&gt;&gt;&gt; []</span><br><span class="line"># you can also query several states at once</span><br><span class="line">m.get_triggers(&apos;solid&apos;, &apos;liquid&apos;, &apos;gas&apos;, &apos;plasma&apos;)</span><br><span class="line">&gt;&gt;&gt; [&apos;melt&apos;, &apos;evaporate&apos;, &apos;sublimate&apos;, &apos;ionize&apos;]</span><br></pre></td></tr></table></figure>
<h4 id="自动转换所有状态"><a href="#自动转换所有状态" class="headerlink" title="自动转换所有状态"></a>自动转换所有状态</h4><p>除了显式添加的任何转换之外，每当将状态添加到 <code>Machine</code> 实例时，都会自动创建一个 <code>to_«state»()</code> 方法，该方法无论状态机当前处于哪种状态，都会转换到目标状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lump.to_liquid()</span><br><span class="line">lump.state</span><br><span class="line">&gt;&gt;&gt; &apos;liquid&apos;</span><br><span class="line">lump.to_solid()</span><br><span class="line">lump.state</span><br><span class="line">&gt;&gt;&gt; &apos;solid&apos;</span><br></pre></td></tr></table></figure>
<p>我们可以在状态机初始化的时候设置 <code>auto_transitions=False</code> 禁用这个功能。</p>
<h4 id="多状态转换"><a href="#多状态转换" class="headerlink" title="多状态转换"></a>多状态转换</h4><p>给定的触发器可以附加到多个转换，其中一些可以在相同的状态下潜在地开始或结束。比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">machine.add_transition(&apos;transmogrify&apos;, [&apos;solid&apos;, &apos;liquid&apos;, &apos;gas&apos;], &apos;plasma&apos;)</span><br><span class="line">machine.add_transition(&apos;transmogrify&apos;, &apos;plasma&apos;, &apos;solid&apos;)</span><br><span class="line"># This next transition will never execute</span><br><span class="line">machine.add_transition(&apos;transmogrify&apos;, &apos;plasma&apos;, &apos;gas&apos;)</span><br></pre></td></tr></table></figure>
<p>在这种情况下，如果当前状态是 <code>plasma</code> 调用 <code>transmogrify()</code> ，会转换到 <code>solid</code> 状态，然后继续转换到 <code>plasma</code> 状态。<strong>注意</strong>：只有第一个匹配的转换将执行，因此，上述最后一行中定义的转换将不会做任何事情。</p>
<p>我们还可以通过使用 <code>*</code> 通配符来引发触发器从所有状态转换到特定状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">machine.add_transition(&apos;to_liquid&apos;, &apos;*&apos;, &apos;liquid&apos;)</span><br></pre></td></tr></table></figure>
<p>一个反身触发（触发器具有与源和目标相同的状态）可以使用“=”来表示目的状态，比如通过 <code>touch</code> 触发，<code>solid</code> 的目标状态为自身。如果我们希望同一个反身触发器应用到多个状态中，使用“=”是比较方便的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">machine.add_transition(&apos;touch&apos;, [&apos;liquid&apos;, &apos;gas&apos;, &apos;plasma&apos;], &apos;=&apos;, after=&apos;change_shape&apos;)</span><br></pre></td></tr></table></figure>
<p>通过上面的语句， <code>&#39;liquid&#39;, &#39;gas&#39;, &#39;plasma&#39;</code> 三个状态通过 <code>touch</code> 触发器，可以到达的目的状态分别是 <code>&#39;liquid&#39;, &#39;gas&#39;, &#39;plasma&#39;</code> 。</p>
<h4 id="有序转换"><a href="#有序转换" class="headerlink" title="有序转换"></a>有序转换</h4><p>比如我们现在有这样一个需求，状态的转换是遵循自定义的序列的，如给定状态 <code>[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</code>，我们可能需要这样的状态转换 <code>A → B, B → C, C → A</code> （没有其他的非法转换）。为了实现这个功能，<code>Transitions</code> 在 <code>Machine</code> 类中提供了 <code>add_ordered_transitions()</code> 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">states = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]</span><br><span class="line"> # See the &quot;alternative initialization&quot; section for an explanation of the 1st argument to init</span><br><span class="line">machine = Machine(states=states, initial=&apos;A&apos;)</span><br><span class="line">machine.add_ordered_transitions()</span><br><span class="line">machine.next_state()</span><br><span class="line">print(machine.state)</span><br><span class="line">&gt;&gt;&gt; &apos;B&apos;</span><br><span class="line"># We can also define a different order of transitions</span><br><span class="line">machine = Machine(states=states, initial=&apos;A&apos;)</span><br><span class="line">machine.add_ordered_transitions([&apos;A&apos;, &apos;C&apos;, &apos;B&apos;])</span><br><span class="line">machine.next_state()</span><br><span class="line">print(machine.state)</span><br><span class="line">&gt;&gt;&gt; &apos;C&apos;</span><br></pre></td></tr></table></figure>
<h4 id="排队转换"><a href="#排队转换" class="headerlink" title="排队转换"></a>排队转换</h4><p>Transitions中的默认行为是立即处理事件。也就是说，调用绑定在 <code>after</code> 上的回调函数之前， <code>on_enter</code> 方法中的事件会预先处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def go_to_C():</span><br><span class="line">    global machine</span><br><span class="line">    machine.to_C()</span><br><span class="line"></span><br><span class="line">def after_advance():</span><br><span class="line">    print(&quot;I am in state B now!&quot;)</span><br><span class="line"></span><br><span class="line">def entering_C():</span><br><span class="line">    print(&quot;I am in state C now!&quot;)</span><br><span class="line"></span><br><span class="line">states = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]</span><br><span class="line">machine = Machine(states=states)</span><br><span class="line"></span><br><span class="line"># we want a message when state transition to B has been completed</span><br><span class="line">machine.add_transition(&apos;advance&apos;, &apos;A&apos;, &apos;B&apos;, after=after_advance)</span><br><span class="line"></span><br><span class="line"># call transition from state B to state C</span><br><span class="line">machine.on_enter_B(go_to_C)</span><br><span class="line"></span><br><span class="line"># we also want a message when entering state C</span><br><span class="line">machine.on_enter_C(entering_C)</span><br><span class="line">machine.advance()</span><br><span class="line">&gt;&gt;&gt; &apos;I am in state C now!&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;I am in state B now!&apos; # what?</span><br></pre></td></tr></table></figure>
<p>上述状态机的执行顺序为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">prepare -&gt; before -&gt; on_enter_B -&gt; on_enter_C -&gt; after.</span><br></pre></td></tr></table></figure>
<p>如果启用排队处理，则在触发下一个转换之前，转换将完成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">machine = Machine(states=states, queued=True)</span><br><span class="line">...</span><br><span class="line">machine.advance()</span><br><span class="line">&gt;&gt;&gt; &apos;I am in state B now!&apos;</span><br><span class="line">&gt;&gt;&gt; &apos;I am in state C now!&apos; # That&apos;s better!</span><br></pre></td></tr></table></figure>
<p>执行顺序为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">prepare -&gt; before -&gt; on_enter_B -&gt; queue(to_C) -&gt; after  -&gt; on_enter_C.</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：当使用排队处理事件时，触发器的调用始终返回True，所以在排队执行过程中，无法确定一个包含排队回调函数的转换最终是否能成功，即使是在处理一个事件的时候。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">machine.add_transition(&apos;jump&apos;, &apos;A&apos;, &apos;C&apos;, conditions=&apos;will_fail&apos;)</span><br><span class="line">...</span><br><span class="line"># queued=False</span><br><span class="line">machine.jump()</span><br><span class="line">&gt;&gt;&gt; False</span><br><span class="line"># queued=True</span><br><span class="line">machine.jump()</span><br><span class="line">&gt;&gt;&gt; True</span><br></pre></td></tr></table></figure>
<h4 id="条件转换"><a href="#条件转换" class="headerlink" title="条件转换"></a>条件转换</h4><p>在某些情况下，我们可能需要在某些条件成立的时候去执行特定的转换，这个时候，<code>conditions</code> 就派上用场了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Our Matter class, now with a bunch of methods that return booleans.</span><br><span class="line">class Matter(object):</span><br><span class="line">    def is_flammable(self): return False</span><br><span class="line">    def is_really_hot(self): return True</span><br><span class="line"></span><br><span class="line">machine.add_transition(&apos;heat&apos;, &apos;solid&apos;, &apos;gas&apos;, conditions=&apos;is_flammable&apos;)</span><br><span class="line">machine.add_transition(&apos;heat&apos;, &apos;solid&apos;, &apos;liquid&apos;, conditions=[&apos;is_really_hot&apos;])</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，如果模型初始化的状态为 <code>solid</code> ，当条件 <code>is_flammable</code> 成立时，调用 <code>heat()</code> 会转换到 <code>gas</code> 状态。同样，如果条件 <code>is_really_hot</code> 成立，调用 <code>heat()</code> 会转换到 <code>liquid</code> 状态。</p>
<p>我们还可能在某些条件不成立的条件下，转换到另一状态，<code>Transitions</code> 为我们提供了 <code>unless</code> 方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">machine.add_transition(&apos;heat&apos;, &apos;solid&apos;, &apos;gas&apos;, unless=[&apos;is_flammable&apos;, &apos;is_really_hot&apos;])</span><br></pre></td></tr></table></figure>
<p>这时，如果 <code>is_flammable(), is_really_hot()</code> 返回的都是 <code>False</code> ，模型调用 <code>heat()</code> 会从 <code>solid</code> 转换到 <code>gas</code> 状态。</p>
<p><strong>注意</strong>：条件检查方法会被动接收传递给触发函数的参数或数据对象。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lump.heat(temp=74)</span><br><span class="line"># equivalent to lump.trigger(&apos;heat&apos;, temp=74)</span><br></pre></td></tr></table></figure>
<p>这样会将 <code>temp=74</code> 的可选参数传递给 <code>is_flammable()</code> 方法（以 <code>EventData</code> 实例的方式），参数的传递我们在后面会介绍。</p>
<h4 id="回调方法-1"><a href="#回调方法-1" class="headerlink" title="回调方法"></a>回调方法</h4><p>我们可以将回调方法绑定到状态集和转换集上，每一个转换都包含 <code>before</code> 和 <code>after</code> 属性，这也是我们比较常用的，这两个属性包含了一系列在状态转换前后可以调用的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Matter(object):</span><br><span class="line">    def make_hissing_noises(self): print(&quot;HISSSSSSSSSSSSSSSS&quot;)</span><br><span class="line">    def disappear(self): print(&quot;where&apos;d all the liquid go?&quot;)</span><br><span class="line"></span><br><span class="line">transitions = [</span><br><span class="line">    &#123; &apos;trigger&apos;: &apos;melt&apos;, &apos;source&apos;: &apos;solid&apos;, &apos;dest&apos;: &apos;liquid&apos;, &apos;before&apos;: &apos;make_hissing_noises&apos;&#125;,</span><br><span class="line">    &#123; &apos;trigger&apos;: &apos;evaporate&apos;, &apos;source&apos;: &apos;liquid&apos;, &apos;dest&apos;: &apos;gas&apos;, &apos;after&apos;: &apos;disappear&apos; &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">lump = Matter()</span><br><span class="line">machine = Machine(lump, states, transitions=transitions, initial=&apos;solid&apos;)</span><br><span class="line">lump.melt()</span><br><span class="line">&gt;&gt;&gt; &quot;HISSSSSSSSSSSSSSSS&quot;</span><br><span class="line">lump.evaporate()</span><br><span class="line">&gt;&gt;&gt; &quot;where&apos;d all the liquid go?&quot;</span><br></pre></td></tr></table></figure>
<p>在状态转换一开始，在其他转换开始执行之前，我们也可以使用 <code>prepare</code> 回调函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Matter(object):</span><br><span class="line">    heat = False</span><br><span class="line">    attempts = 0</span><br><span class="line">    def count_attempts(self): self.attempts += 1</span><br><span class="line">    def is_really_hot(self): return self.heat</span><br><span class="line">    def heat_up(self): self.heat = random.random() &lt; 0.25</span><br><span class="line">    def stats(self): print(&apos;It took you %i attempts to melt the lump!&apos; %self.attempts)</span><br><span class="line"></span><br><span class="line">states=[&apos;solid&apos;, &apos;liquid&apos;, &apos;gas&apos;, &apos;plasma&apos;]</span><br><span class="line"></span><br><span class="line">transitions = [</span><br><span class="line">    &#123; &apos;trigger&apos;: &apos;melt&apos;, &apos;source&apos;: &apos;solid&apos;, &apos;dest&apos;: &apos;liquid&apos;, &apos;prepare&apos;: [&apos;heat_up&apos;, &apos;count_attempts&apos;], &apos;conditions&apos;: &apos;is_really_hot&apos;, &apos;after&apos;: &apos;stats&apos;&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">lump = Matter()</span><br><span class="line">machine = Machine(lump, states, transitions=transitions, initial=&apos;solid&apos;)</span><br><span class="line">lump.melt()</span><br><span class="line">lump.melt()</span><br><span class="line">lump.melt()</span><br><span class="line">lump.melt()</span><br><span class="line">&gt;&gt;&gt; &quot;It took you 4 attempts to melt the lump!&quot;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：除非当前状态是定义在转换集上有效的状态，否则，<code>prepare</code> 回调是不会起作用的。</p>
<p>如果在每一个转换执行之前或之后都需要进行一些默认操作，我们可以在状态机初始化的时候显示使用 <code>before_state_change</code>  和 <code>after_state_change</code>  属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Matter(object):</span><br><span class="line">    def make_hissing_noises(self): print(&quot;HISSSSSSSSSSSSSSSS&quot;)</span><br><span class="line">    def disappear(self): print(&quot;where&apos;d all the liquid go?&quot;)</span><br><span class="line"></span><br><span class="line">states=[&apos;solid&apos;, &apos;liquid&apos;, &apos;gas&apos;, &apos;plasma&apos;]</span><br><span class="line"></span><br><span class="line">lump = Matter()</span><br><span class="line">m = Machine(lump, states, before_state_change=&apos;make_hissing_noises&apos;, after_state_change=&apos;disappear&apos;)</span><br><span class="line">lump.to_gas()</span><br><span class="line">&gt;&gt;&gt; &quot;HISSSSSSSSSSSSSSSS&quot;</span><br><span class="line">&gt;&gt;&gt; &quot;where&apos;d all the liquid go?&quot;</span><br></pre></td></tr></table></figure>
<p>还有一些可以独立使用的关键字：</p>
<ul>
<li><code>prepare_event</code> ：通过 <code>prepare_event</code> 关键字传递给状态机的回调方法，在处理可能发生的状态转换（包括私有的 <code>prepare</code> 回调方法）之前，仅执行一次；</li>
<li><code>finalize_event</code> ：通过 <code>finalize_event</code> 关键字传递给状态机的回调方法，不管转换是否成功，都会被执行；</li>
<li><code>send_event</code> ：如果在状态转换过程中出现了错误，这个错误会绑定到 <code>event_data</code> 上，我们可以使用 <code>send_event=True</code> 来检索错误 。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from transitions import Machine</span><br><span class="line"></span><br><span class="line">class Matter(object):</span><br><span class="line">    def raise_error(self, event): raise ValueError(&quot;Oh no&quot;)</span><br><span class="line">    def prepare(self, event): print(&quot;I am ready!&quot;)</span><br><span class="line">    def finalize(self, event): print(&quot;Result: &quot;, type(event.error), event.error)</span><br><span class="line"></span><br><span class="line">states=[&apos;solid&apos;, &apos;liquid&apos;, &apos;gas&apos;, &apos;plasma&apos;]</span><br><span class="line"></span><br><span class="line">lump = Matter()</span><br><span class="line">m = Machine(lump, states, prepare_event=&apos;prepare&apos;, before_state_change=&apos;raise_error&apos;,</span><br><span class="line">            finalize_event=&apos;finalize&apos;, send_event=True)</span><br><span class="line">try:</span><br><span class="line">    lump.to_gas()</span><br><span class="line">except ValueError:</span><br><span class="line">    pass</span><br><span class="line">print(lump.state)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; I am ready!</span><br><span class="line">&gt;&gt;&gt; Result:  &lt;class &apos;ValueError&apos;&gt; Oh no</span><br><span class="line">&gt;&gt;&gt; initial</span><br></pre></td></tr></table></figure>
<h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><p>以下是转换集上回调方法可以执行的命令：</p>
<table>
<thead>
<tr>
<th>回调</th>
<th>状态</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>machine.prepare_event</code></td>
<td>源状态</td>
<td>在私有转换执行之前仅执行一次</td>
</tr>
<tr>
<td><code>transition.prepare</code></td>
<td>源状态</td>
<td>转换一开始就执行</td>
</tr>
<tr>
<td><code>transition.conditions</code></td>
<td>源状态</td>
<td>可使转换失败或停止</td>
</tr>
<tr>
<td><code>transition.unless</code></td>
<td>源状态</td>
<td>可使转换失败或停止</td>
</tr>
<tr>
<td><code>machine.before_state_change</code></td>
<td>源状态</td>
<td>声明在模型上的默认回调方法</td>
</tr>
<tr>
<td><code>transition.before</code></td>
<td>源状态</td>
<td></td>
</tr>
<tr>
<td><code>state.on_exit</code></td>
<td>源状态</td>
<td>声明在源状态上的回调方法</td>
</tr>
<tr>
<td><code>&lt;STATE CHANGE&gt;</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>state.on_enter</code></td>
<td>目的状态</td>
<td>声明在目的状态上的回调方法</td>
</tr>
<tr>
<td><code>transition.after</code></td>
<td>目的状态</td>
<td></td>
</tr>
<tr>
<td><code>machine.after_state_change</code></td>
<td>目的状态</td>
<td>声明在模型上的默认回调方法</td>
</tr>
<tr>
<td><code>machine.finalize_event</code></td>
<td>源状态/目的状态</td>
<td>即使出现错误或异常，回调方法也会执行</td>
</tr>
</tbody>
</table>
<h3 id="传递数据"><a href="#传递数据" class="headerlink" title="传递数据"></a>传递数据</h3><p>在大多数情况下，我们需要传递给注册在状态机中的回调方法一些参数，来反应当前模型的状态和进行一些必要计算。<code>Transitions</code> 提供了两种方法。</p>
<p>第一种方法（默认方法）：</p>
<p>我们可以直接传递参数给触发器方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Matter(object):</span><br><span class="line">    def __init__(self): self.set_environment()</span><br><span class="line">    def set_environment(self, temp=0, pressure=101.325):</span><br><span class="line">        self.temp = temp</span><br><span class="line">        self.pressure = pressure</span><br><span class="line">    def print_temperature(self): print(&quot;Current temperature is %d degrees celsius.&quot; % self.temp)</span><br><span class="line">    def print_pressure(self): print(&quot;Current pressure is %.2f kPa.&quot; % self.pressure)</span><br><span class="line"></span><br><span class="line">lump = Matter()</span><br><span class="line">machine = Machine(lump, [&apos;solid&apos;, &apos;liquid&apos;], initial=&apos;solid&apos;)</span><br><span class="line">machine.add_transition(&apos;melt&apos;, &apos;solid&apos;, &apos;liquid&apos;, before=&apos;set_environment&apos;)</span><br><span class="line"></span><br><span class="line">lump.melt(45)  # positional arg;</span><br><span class="line"># equivalent to lump.trigger(&apos;melt&apos;, 45)</span><br><span class="line">lump.print_temperature()</span><br><span class="line">&gt;&gt;&gt; &apos;Current temperature is 45 degrees celsius.&apos;</span><br><span class="line"></span><br><span class="line">machine.set_state(&apos;solid&apos;)  # reset state so we can melt again</span><br><span class="line">lump.melt(pressure=300.23)  # keyword args also work</span><br><span class="line">lump.print_pressure()</span><br><span class="line">&gt;&gt;&gt; &apos;Current pressure is 300.23 kPa.&apos;</span><br></pre></td></tr></table></figure>
<p>我们通过这种方法传递任何参数给触发器方法。</p>
<p>但是这种方式有一种局限性：状态转换触发的每一个回调方法都必须处理所有的参数。如果我们的不同回调方法需要不同的参数，这样就会导致一些不必要的麻烦。</p>
<p>为了解决这个问题，<code>Transitions</code> 提供了另一种方法，上文中我们提到过，参数可以以<code>EventData</code> 实例的方式传递。在<code>Machine</code> 初始化的时候设置 <code>send_event=True</code> ，这样，所有传递给非触发器的参数都以<code>EventData</code> 实例的方式传递给回调方法，为了方便我们随时访问与事件相关的源状态、模型、转换、触发等参数，<code>EventData</code> 实例会维护这些参数的内部引用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Matter(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.temp = 0</span><br><span class="line">        self.pressure = 101.325</span><br><span class="line"></span><br><span class="line">    # Note that the sole argument is now the EventData instance.</span><br><span class="line">    # This object stores positional arguments passed to the trigger method in the</span><br><span class="line">    # .args property, and stores keywords arguments in the .kwargs dictionary.</span><br><span class="line">    def set_environment(self, event):</span><br><span class="line">        self.temp = event.kwargs.get(&apos;temp&apos;, 0)</span><br><span class="line">        self.pressure = event.kwargs.get(&apos;pressure&apos;, 101.325)</span><br><span class="line"></span><br><span class="line">    def print_pressure(self): print(&quot;Current pressure is %.2f kPa.&quot; % self.pressure)</span><br><span class="line"></span><br><span class="line">lump = Matter()</span><br><span class="line">machine = Machine(lump, [&apos;solid&apos;, &apos;liquid&apos;], send_event=True, initial=&apos;solid&apos;)</span><br><span class="line">machine.add_transition(&apos;melt&apos;, &apos;solid&apos;, &apos;liquid&apos;, before=&apos;set_environment&apos;)</span><br><span class="line"></span><br><span class="line">lump.melt(temp=45, pressure=1853.68)  # keyword args</span><br><span class="line">lump.print_pressure()</span><br><span class="line">&gt;&gt;&gt; &apos;Current pressure is 1853.68 kPa.&apos;</span><br></pre></td></tr></table></figure>
<h3 id="其他初始化方式"><a href="#其他初始化方式" class="headerlink" title="其他初始化方式"></a>其他初始化方式</h3><p>在以上所有的示例中，我们将新的 <code>Machine</code> 实例绑定到一个单独的模型上（<code>Matter</code> 类的实例 <code>lump</code>），虽然这种方式可以使我们的类和回调方法比较整洁，但是我们必须能跟踪到状态机上调用的方法，并且知道模型调用的这些方法绑定了哪个状态机（比如： <code>lump.on_enter_StateA()</code> vs <code>machine.add_transition()</code>）</p>
<p>庆幸的是，<code>Transitions</code> 为我们提供了两种不同的初始化方式。</p>
<p>第一种方式，我们可以创建一个独立的状态机，完全不需要其他模型，在初始化的时候忽略模型参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">machine = Machine(states=states, transitions=transitions, initial=&apos;solid&apos;)</span><br><span class="line">machine.melt()</span><br><span class="line">machine.state</span><br><span class="line">&gt;&gt;&gt; &apos;liquid&apos;</span><br></pre></td></tr></table></figure>
<p>如果我们使用这种方式初始化状态机，我们就可以直接绑定所有的触发事件和回调方法到 <code>Machine</code> 实例上。</p>
<p>这种方法有利于在一个地方整合所有的状态机功能，但如果考虑到状态逻辑应该包含在模型本身中，而不是单独出来，这种方式恐怕也不是最好的。</p>
<p>一种替代的办法是让 <code>Machine</code> 要绑定的模型继承 <code>Machine</code> 类，只要重写 <code>Machine</code> 的 <code>__init__()</code> 方法即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Matter(Machine):</span><br><span class="line">    def say_hello(self): print(&quot;hello, new state!&quot;)</span><br><span class="line">    def say_goodbye(self): print(&quot;goodbye, old state!&quot;)</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        states = [&apos;solid&apos;, &apos;liquid&apos;, &apos;gas&apos;]</span><br><span class="line">        Machine.__init__(self, states=states, initial=&apos;solid&apos;)</span><br><span class="line">        self.add_transition(&apos;melt&apos;, &apos;solid&apos;, &apos;liquid&apos;)</span><br><span class="line"></span><br><span class="line">lump = Matter()</span><br><span class="line">lump.state</span><br><span class="line">&gt;&gt;&gt; &apos;solid&apos;</span><br><span class="line">lump.melt()</span><br><span class="line">lump.state</span><br><span class="line">&gt;&gt;&gt; &apos;liquid&apos;</span><br></pre></td></tr></table></figure>
<p>现在我们已经整合所有的状态机功能到 <code>lump</code> 模型中，这比将功能独立出来让人感觉更舒服。</p>
<p>如果我们绑定多个模型到 <code>Machine</code> 中，状态机也是可以处理的。如果想要添加模型和 <code>Machine</code> 实例本身，我们可以在初始化的时候使用 <code>self</code> 关键字（ <code>Machine(model=[&#39;self&#39;, model1, ...])</code>），也可以创建一个单独的状态机，然后通过 <code>machine.add_model</code> 动态注册模型到状态机中，如果模型不再使用的情况下，应该调用  <code>machine.remove_model</code>  来回收模型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Matter():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">lump1 = Matter()</span><br><span class="line">lump2 = Matter()</span><br><span class="line"></span><br><span class="line">machine = Machine(states=states, transitions=transitions, initial=&apos;solid&apos;, add_self=False)</span><br><span class="line"></span><br><span class="line">machine.add_model(lump1)</span><br><span class="line">machine.add_model(lump2, initial=&apos;liquid&apos;)</span><br><span class="line"></span><br><span class="line">lump1.state</span><br><span class="line">&gt;&gt;&gt; &apos;solid&apos;</span><br><span class="line">lump2.state</span><br><span class="line">&gt;&gt;&gt; &apos;liquid&apos;</span><br><span class="line"></span><br><span class="line">machine.remove_model([lump1, lump2])</span><br><span class="line">del lump1  # lump1 is garbage collected</span><br><span class="line">del lump2  # lump2 is garbage collected</span><br></pre></td></tr></table></figure>
<p>如果在状态机初始化的时候没有提供初始状态，在添加模型的时候就必须提供这个初始状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">machine = Machine(states=states, transitions=transitions, add_self=False)</span><br><span class="line"></span><br><span class="line">machine.add_model(Matter())</span><br><span class="line">&gt;&gt;&gt; &quot;MachineError: No initial state configured for machine, must specify when adding model.&quot;</span><br><span class="line">machine.add_model(Matter(), initial=&apos;liquid&apos;)</span><br></pre></td></tr></table></figure>
<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p><code>Transitions</code> 提供一些基本的日志功能，使用 <code>Python</code> 标准的 <code>logging</code> 模块将一些如状态转换、转换触发、条件检查等信息作为 <code>INFO</code> 级别的信息记录下来，我们可以在脚本中轻松地将日志记录配置为标准输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Set up logging</span><br><span class="line">import logging</span><br><span class="line">from transitions import logger</span><br><span class="line">logger.setLevel(logging.INFO)</span><br><span class="line"></span><br><span class="line"># Business as usual</span><br><span class="line">machine = Machine(states=states, transitions=transitions, initial=&apos;solid&apos;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="存储-恢复状态机实例"><a href="#存储-恢复状态机实例" class="headerlink" title="存储/恢复状态机实例"></a>存储/恢复状态机实例</h3><p>如果想要存储或加载状态机，必须使用<code>Python3.3</code> 或较早版本的 <code>dill</code> 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import dill as pickle # only required for Python 3.3 and earlier</span><br><span class="line"></span><br><span class="line">m = Machine(states=[&apos;A&apos;, &apos;B&apos;, &apos;C&apos;], initial=&apos;A&apos;)</span><br><span class="line">m.to_B()</span><br><span class="line">m.state  </span><br><span class="line">&gt;&gt;&gt; B</span><br><span class="line"></span><br><span class="line"># store the machine</span><br><span class="line">dump = pickle.dumps(m)</span><br><span class="line"></span><br><span class="line"># load the Machine instance again</span><br><span class="line">m2 = pickle.loads(dump)</span><br><span class="line"></span><br><span class="line">m2.state</span><br><span class="line">&gt;&gt;&gt; B</span><br><span class="line"></span><br><span class="line">m2.states.keys()</span><br><span class="line">&gt;&gt;&gt; [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]</span><br></pre></td></tr></table></figure>
<p>以上介绍了 <code>Transitions</code> 的基本使用方法，手工翻译难免有些晦涩难懂之处，敬请谅解。除了这些基本用法之外，<code>Transitions</code> 还提供了一些扩展方法，比如图表可视化机器的当前状态、用于嵌套和重用的分层状态机、并行执行的线程安全锁等，这里暂时就不介绍了，先欠着吧，等以后深入使用 <code>Transitions</code> 库的时候再去学习。</p>
<p><code>Transitions</code> 英文完整版介绍请移步 <a href="https://github.com/tyarkoni/transitions" target="_blank" rel="noopener">Transitions</a> </p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Transitions</tag>
        <tag>状态机库</tag>
      </tags>
  </entry>
</search>
