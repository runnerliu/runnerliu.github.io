<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LiuYang&#39;s BLOG</title>
  
  <subtitle>On the way to become a Software Architect</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://runnerliu.github.io/"/>
  <updated>2020-11-22T11:50:10.675Z</updated>
  <id>http://runnerliu.github.io/</id>
  
  <author>
    <name>william</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python库-celery</title>
    <link href="http://runnerliu.github.io/2020/11/18/python-lib-celery/"/>
    <id>http://runnerliu.github.io/2020/11/18/python-lib-celery/</id>
    <published>2020-11-18T06:31:44.000Z</published>
    <updated>2020-11-22T11:50:10.675Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个分布式异步计算框架，Celery虽然常用于Web框架中，但也可以单独使用。常规搭配的消息队列是RabbitMQ、Redis。</p><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ tree your_project</span><br><span class="line">your_project</span><br><span class="line">├── __init__.py</span><br><span class="line">├── celery.py</span><br><span class="line">├── config.py</span><br><span class="line">└── tasks.py</span><br><span class="line"></span><br><span class="line">0 directories, 4 files</span><br></pre></td></tr></table></figure><p>其中<code>celery.py</code>是主文件，定义celery app，<code>config.py</code>是celery的配置，<code>tasks.py</code> 是异步任务的具体实现。</p><p><code>celery.py</code>文件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from __funture__ import absolute_import</span><br><span class="line">from celery import Celery, platform</span><br><span class="line"></span><br><span class="line">platform.C_FORCE_ROOT = true</span><br><span class="line"></span><br><span class="line">app = Celery(&apos;your project name&apos;)</span><br><span class="line">app.config_from_object(config)</span><br></pre></td></tr></table></figure><p><code>config.py</code>文件内容可参考下一节</p><p><code>tasks.py</code>文件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from __funture__ import absolute_import</span><br><span class="line"></span><br><span class="line">from .app import app</span><br><span class="line"></span><br><span class="line">@app.task</span><br><span class="line">def add(x, y):</span><br><span class="line">    return x + y</span><br><span class="line">    </span><br><span class="line">@app.task</span><br><span class="line">def sub(x, y):</span><br><span class="line">    return x - y</span><br></pre></td></tr></table></figure><p>运行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup /usr/local/python3.6/bin/python3.6 -m celery worker --loglevel=DEBUG --app=$&#123;PROGRAM_NAME&#125; --queues=$1 --hostname=$2 --pidfile=$3 1&gt;/dev/null 2&gt;/dev/null &amp;</span><br></pre></td></tr></table></figure><p>其中运行可参考后续章节。</p><h4 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h4><p>一次Task从触发到完成，序列图如下：</p><p><img src="/images/2020-11-22194305.jpg" alt="2020-11-22194305.png"></p><p>其中，<code>main</code>代表业务代码主进程。它可能是Django、Flask这类Web服务，也可能是一个其它类型的进程。<code>worker</code>就是指Celery的Worker。</p><p><code>main</code>发送消息后，会得到一个<code>AsyncResult</code>，其中包含<code>task_id</code>。仅通过<code>task_id</code>，也可以自己构造一个<code>AsyncResult</code>，查询相关信息。其中，代表运行过程的，主要是<code>state</code>。</p><p><code>worker</code>会持续保持对Redis（或其它消息队列，如RabbitMQ）的关注，查询新的消息。如果获得新消息，将其消费后，开始运行<code>do_sth</code>。</p><p>运行完成会把返回值对应的结果，以及一些运行信息，回写到Redis（或其它backend，如Django数据库等）上。在系统的任何地方，通过对应的<code>AsyncResult(task_id)</code>就可以查询到结果。</p><h4 id="celery-task的状态"><a href="#celery-task的状态" class="headerlink" title="celery task的状态"></a>celery task的状态</h4><p><img src="/images/2020-11-22194435.jpg" alt="2020-11-22194435.png"></p><p>其中，除<code>SUCCESS</code>外，还有失败（<code>FAILURE</code>）、取消（<code>REVOKED</code>）两个结束状态。而<code>RETRY</code>则是在设置了重试机制后，进入的临时等待状态。</p><p>另外，如果保存在Redis的结果信息被清理（默认仅保存1天），那么任务状态又会变成<code>PENDING</code>。这在设计上是个巨大的问题，使用时要做对应容错。</p><h4 id="celery常用配置"><a href="#celery常用配置" class="headerlink" title="celery常用配置"></a>celery常用配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># 指定任务接受的内容类型(序列化)</span><br><span class="line"># pickle/json/yaml/msgpack</span><br><span class="line">CELERY_ACCEPT_CONTENT = [&apos;json&apos;]</span><br><span class="line"></span><br><span class="line"># 时区</span><br><span class="line">CELERY_TIMEZONE = &apos;Asia/Shanghai&apos;</span><br><span class="line"></span><br><span class="line"># 调度任务</span><br><span class="line">CELERY_INCLUDE = [&apos;celerys.task&apos;]</span><br><span class="line"></span><br><span class="line"># 调度器 </span><br><span class="line">CELERYBEAT_SCHEDULER = &apos;celery.beat:PersistentScheduler&apos;</span><br><span class="line"></span><br><span class="line"># 调度器存储最后运行定时任务的时间</span><br><span class="line">CELERYBEAT_SCHEDULE_FILENAME = &apos;log/celery.db&apos;</span><br><span class="line"></span><br><span class="line"># 消息代理</span><br><span class="line">BROKER_URL = LBT_CONFIG_OTHER[&apos;BROKER_URL&apos;]</span><br><span class="line"></span><br><span class="line"># 广播前缀设置，由仅活动的虚拟机接收任务消息</span><br><span class="line">BROKER_TRANSPORT_OPTIONS = &#123;&apos;fanout_prefix&apos;: True&#125;</span><br><span class="line"></span><br><span class="line"># 结果存储地址</span><br><span class="line">CELERY_RESULT_BACKEND = BROKER_URL</span><br><span class="line"></span><br><span class="line"># 任务执行结果序列化方式</span><br><span class="line">CELERY_RESULT_SERIALIZER = &apos;json&apos;</span><br><span class="line"></span><br><span class="line"># 结果是否持久化，默认关闭</span><br><span class="line">CELERY_RESULT_PERSISTENT = False</span><br><span class="line"></span><br><span class="line"># 任务过期时间，单位秒</span><br><span class="line">CELERY_TASK_RESULT_EXPIRES = 60 * 60</span><br><span class="line"></span><br><span class="line"># 任务序列化方式</span><br><span class="line">CELERY_TASK_SERIALIZER = &apos;json&apos;</span><br><span class="line"></span><br><span class="line"># 任务执行最大时间，单位秒，超过会将worker杀死</span><br><span class="line">CELERY_TASK_TIME_LIMIT = 60 * 60</span><br><span class="line"></span><br><span class="line"># 不关心任务执行结果，无需持久化结果</span><br><span class="line">CELERY_TASK_IGNORE_RESULT = True</span><br><span class="line"></span><br><span class="line"># 并发worker数量，默认为cpu核数</span><br><span class="line">CELERYD_CONCURRENCY = 6</span><br><span class="line"></span><br><span class="line"># worker被杀死前执行的最大任务数</span><br><span class="line">CELERYD_MAX_TASKS_PER_CHILD = 1024</span><br><span class="line"></span><br><span class="line"># redis最大连接数</span><br><span class="line">CELERY_REDIS_MAX_CONNECTIONS = 1024</span><br></pre></td></tr></table></figure><p>更多配置参数请移步<a href="https://docs.celeryproject.org/en/stable/userguide/configuration.html" target="_blank" rel="noopener">Configuration and defaults</a></p><h4 id="worker命令行参数"><a href="#worker命令行参数" class="headerlink" title="worker命令行参数"></a>worker命令行参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">Global Options:</span><br><span class="line">  -A APP, --app APP</span><br><span class="line">  -b BROKER, --broker BROKER</span><br><span class="line">  --result-backend RESULT_BACKEND</span><br><span class="line">  --loader LOADER</span><br><span class="line">  --config CONFIG</span><br><span class="line">  --workdir WORKDIR     Optional directory to change to after detaching.</span><br><span class="line">  --no-color, -C</span><br><span class="line">  --quiet, -q</span><br><span class="line"></span><br><span class="line">Worker Options:</span><br><span class="line">  -n HOSTNAME, --hostname HOSTNAME</span><br><span class="line">                        Set custom hostname (e.g., &apos;w1@%h&apos;). Expands: %h</span><br><span class="line">                        (hostname), %n (name) and %d, (domain).</span><br><span class="line">  -D, --detach          Start worker as a background process.</span><br><span class="line">  -S STATEDB, --statedb STATEDB</span><br><span class="line">                        Path to the state database. The extension &apos;.db&apos; may be</span><br><span class="line">                        appended to the filename. Default: None</span><br><span class="line">  -l LOGLEVEL, --loglevel LOGLEVEL</span><br><span class="line">                        Logging level, choose between DEBUG, INFO, WARNING,</span><br><span class="line">                        ERROR, CRITICAL, or FATAL.</span><br><span class="line">  -O OPTIMIZATION</span><br><span class="line">  --prefetch-multiplier PREFETCH_MULTIPLIER</span><br><span class="line">                        Set custom prefetch multiplier value for this worker</span><br><span class="line">                        instance.</span><br><span class="line"></span><br><span class="line">Pool Options:</span><br><span class="line">  -c CONCURRENCY, --concurrency CONCURRENCY</span><br><span class="line">                        Number of child processes processing the queue. The</span><br><span class="line">                        default is the number of CPUs available on your</span><br><span class="line">                        system.</span><br><span class="line">  -P POOL, --pool POOL  Pool implementation: prefork (default), eventlet,</span><br><span class="line">                        gevent, threads or solo. 注意：threads只能在4.4.0以上版本使用</span><br><span class="line">  -E, --task-events, --events</span><br><span class="line">                        Send task-related events that can be captured by</span><br><span class="line">                        monitors like celery events, celerymon, and others.</span><br><span class="line">  --time-limit TIME_LIMIT</span><br><span class="line">                        Enables a hard time limit (in seconds int/float) for</span><br><span class="line">                        tasks.</span><br><span class="line">  --soft-time-limit SOFT_TIME_LIMIT</span><br><span class="line">                        Enables a soft time limit (in seconds int/float) for</span><br><span class="line">                        tasks.</span><br><span class="line">  --max-tasks-per-child MAX_TASKS_PER_CHILD, --maxtasksperchild MAX_TASKS_PER_CHILD</span><br><span class="line">                        Maximum number of tasks a pool worker can execute</span><br><span class="line">                        before it&apos;s terminated and replaced by a new worker.</span><br><span class="line">  --max-memory-per-child MAX_MEMORY_PER_CHILD, --maxmemperchild MAX_MEMORY_PER_CHILD</span><br><span class="line">                        Maximum amount of resident memory, in KiB, that may be</span><br><span class="line">                        consumed by a child process before it will be replaced</span><br><span class="line">                        by a new one. If a single task causes a child process</span><br><span class="line">                        to exceed this limit, the task will be completed and</span><br><span class="line">                        the child process will be replaced afterwards.</span><br><span class="line">                        Default: no limit.</span><br><span class="line"></span><br><span class="line">Queue Options:</span><br><span class="line">  --purge, --discard    Purges all waiting tasks before the daemon is started.</span><br><span class="line">                        **WARNING**: This is unrecoverable, and the tasks will</span><br><span class="line">                        be deleted from the messaging server.</span><br><span class="line">  --queues QUEUES, -Q QUEUES</span><br><span class="line">                        List of queues to enable for this worker, separated by</span><br><span class="line">                        comma. By default all configured queues are enabled.</span><br><span class="line">                        Example: -Q video,image</span><br><span class="line">  --exclude-queues EXCLUDE_QUEUES, -X EXCLUDE_QUEUES</span><br><span class="line">                        List of queues to disable for this worker, separated</span><br><span class="line">                        by comma. By default all configured queues are</span><br><span class="line">                        enabled. Example: -X video,image.</span><br><span class="line">  --include INCLUDE, -I INCLUDE</span><br><span class="line">                        Comma separated list of additional modules to import.</span><br><span class="line">                        Example: -I foo.tasks,bar.tasks</span><br><span class="line"></span><br><span class="line">Features:</span><br><span class="line">  --without-gossip      Don&apos;t subscribe to other workers events.</span><br><span class="line">  --without-mingle      Don&apos;t synchronize with other workers at start-up.</span><br><span class="line">  --without-heartbeat   Don&apos;t send event heartbeats.</span><br><span class="line">  --heartbeat-interval HEARTBEAT_INTERVAL</span><br><span class="line">                        Interval in seconds at which to send worker heartbeat</span><br><span class="line">  --autoscale AUTOSCALE</span><br><span class="line">                        Enable autoscaling by providing max_concurrency,</span><br><span class="line">                        min_concurrency. Example:: --autoscale=10,3 (always</span><br><span class="line">                        keep 3 processes, but grow to 10 if necessary)</span><br><span class="line"></span><br><span class="line">Daemonization Options:</span><br><span class="line">  -f LOGFILE, --logfile LOGFILE</span><br><span class="line">                        Path to log file. If no logfile is specified, stderr</span><br><span class="line">                        is used.</span><br><span class="line">  --pidfile PIDFILE     Optional file used to store the process pid. The</span><br><span class="line">                        program won&apos;t start if this file already exists and</span><br><span class="line">                        the pid is still alive.</span><br><span class="line">  --uid UID             User id, or user name of the user to run as after</span><br><span class="line">                        detaching.</span><br><span class="line">  --gid GID             Group id, or group name of the main group to change to</span><br><span class="line">                        after detaching.</span><br><span class="line">  --umask UMASK         Effective umask(1) (in octal) of the process after</span><br><span class="line">                        detaching. Inherits the umask(1) of the parent process</span><br><span class="line">                        by default.</span><br><span class="line">  --executable EXECUTABLE</span><br><span class="line">                        Executable to use for the detached process.</span><br><span class="line"></span><br><span class="line">Embedded Beat Options:</span><br><span class="line">  -B, --beat            Also run the celery beat periodic task scheduler.</span><br><span class="line">                        Please note that there must only be one instance of</span><br><span class="line">                        this service. .. note:: -B is meant to be used for</span><br><span class="line">                        development purposes. For production environment, you</span><br><span class="line">                        need to start celery beat separately.</span><br><span class="line">  -s SCHEDULE_FILENAME, --schedule-filename SCHEDULE_FILENAME, --schedule SCHEDULE_FILENAME</span><br><span class="line">                        Path to the schedule database if running with the -B</span><br><span class="line">                        option. Defaults to celerybeat-schedule. The extension</span><br><span class="line">                        &quot;.db&quot; may be appended to the filename. Apply</span><br><span class="line">                        optimization profile. Supported: default, fair</span><br><span class="line">  --scheduler SCHEDULER</span><br><span class="line">                        Scheduler class to use. Default is</span><br><span class="line">                        celery.beat.PersistentScheduler</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一个分布式异步计算框架，Celery虽然常用于Web框架中，但也可以单独使用。常规搭配的消息队列是RabbitMQ、Redis。&lt;/p&gt;
&lt;h4 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Python" scheme="http://runnerliu.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://runnerliu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令-jq</title>
    <link href="http://runnerliu.github.io/2020/11/12/linuxjq/"/>
    <id>http://runnerliu.github.io/2020/11/12/linuxjq/</id>
    <published>2020-11-12T11:31:04.000Z</published>
    <updated>2020-11-15T03:16:40.077Z</updated>
    
    <content type="html"><![CDATA[<p>jq可以对json数据进行分片、过滤、映射和转换，和sed、awk、grep等命令一样，都可以让你轻松地把玩文本。它能轻松地把你拥有的数据转换成你期望的格式，而且需要写的程序通常也比你期望的更加简短。github地址：<a href="https://stedolan.github.io/jq/" target="_blank" rel="noopener">https://stedolan.github.io/jq/</a></p><p>json示例文件jq.txt为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;&quot;name&quot;:&quot;站长工具&quot;,&quot;url&quot;:&quot;http://tool.chinaz.com&quot;,&quot;address&quot;:&#123;&quot;city&quot;:&quot;厦门&quot;,&quot;country&quot;:&quot;中国&quot;&#125;,&quot;arrayBrowser&quot;:[&#123;&quot;name&quot;:&quot;Google&quot;,&quot;url&quot;:&quot;http://www.google.com&quot;&#125;,&#123;&quot;name&quot;:&quot;Baidu&quot;,&quot;url&quot;&quot;http://www.baidu.com&quot;&#125;]&#125;,&#123;&quot;name&quot;:&quot;站长之家&quot;,&quot;url&quot;:&quot;http://tool.zzhome.com&quot;,&quot;address&quot;:&#123;&quot;city&quot;:&quot;大连&quot;,&quot;country&quot;:&quot;中国&quot;&#125;,&quot;arrayBrowser&quot;:[&#123;&quot;name&quot;:&quot;360&quot;,&quot;url&quot;:&quot;http://www.so.com&quot;&#125;,&#123;&quot;nme&quot;:&quot;bing&quot;,&quot;url&quot;:&quot;http://www.bing.com&quot;&#125;]&#125;]</span><br></pre></td></tr></table></figure><p>命令：<code>cat jq.txt|jq &#39;.&#39;</code></p><p>效果如下：</p><p><img src="/images/2020-11-15T103330.png" alt="2020-11-15T103330.png"></p><p>输出列表中的第一个元素，可以使用[index]：</p><p>命令：<code>cat jq.txt|jq &#39;.[0]&#39;</code></p><p>效果如下：</p><p><img src="/images/2020-11-15T103331.png" alt="2020-11-15T103331.png"></p><p>jq支持管道线<code>|</code>，它如同linux命令中的管道线——把前面命令的输出当作是后面命令的输入。如下命令把<code>.[0]</code>作为<code>{...}</code>的输入，进而访问嵌套的属性，如<code>.name</code>和<code>.address.city</code>。</p><p>命令：<code>cat jq.txt |jq &#39;.[0] | {name:.name,address:.address}&#39;</code></p><p>效果如下：</p><p><img src="/images/2020-11-15T103332.png" alt="2020-11-15T103332.png"></p><p>命令：<code>cat jq.txt |jq &#39;.[0] | {name:.name,city:.address.city}&#39;</code></p><p>效果如下：</p><p><img src="/images/2020-11-15T103333.png" alt="2020-11-15T103333.png"></p><p>命令：<code>cat jq.txt |jq &#39;.[0] | {name:.arrayBrowser[1],city:.address.city}&#39;</code></p><p>效果如下：</p><p><img src="/images/2020-11-15T103334.png" alt="2020-11-15T103334.png"></p><p>如果希望把jq的输出当作一个数组，可以在前后加上<code>[]</code>：</p><p>命令：<code>cat jq.txt |jq &quot;[.[] |{name:.arrayBrowser[1].name,city:.address.city}]&quot;</code></p><p>效果如下：</p><p><img src="/images/2020-11-15T103336.png" alt="2020-11-15T103336.png"></p><p>在{}中，冒号前面的名字是映射的名称，你可以任意修改，如： </p><p>命令：<code>cat jq.txt |jq &quot;[.[] |{name_001:.arrayBrowser[1].name,city_002:.address.city}]&quot;</code></p><p>效果如下：</p><p><img src="/images/2020-11-15T103335.png" alt="2020-11-15T103335.png"></p><p>参考：</p><blockquote><p><a href="https://www.jianshu.com/p/6de3cfdbdb0e" target="_blank" rel="noopener">给力的linux命令–jq简易教程</a></p><p><a href="http://einverne.github.io/post/2018/12/jq-command-line-json-processor.html" target="_blank" rel="noopener">每天学习一个命令：jq 命令行下处理 JSON</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;jq可以对json数据进行分片、过滤、映射和转换，和sed、awk、grep等命令一样，都可以让你轻松地把玩文本。它能轻松地把你拥有的数据转换成你期望的格式，而且需要写的程序通常也比你期望的更加简短。github地址：&lt;a href=&quot;https://stedolan.gi
      
    
    </summary>
    
      <category term="Linux/Unix" scheme="http://runnerliu.github.io/categories/Linux-Unix/"/>
    
    
      <category term="命令" scheme="http://runnerliu.github.io/tags/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Linux" scheme="http://runnerliu.github.io/tags/Linux/"/>
    
      <category term="jq" scheme="http://runnerliu.github.io/tags/jq/"/>
    
  </entry>
  
  <entry>
    <title>Python库-watchdog</title>
    <link href="http://runnerliu.github.io/2020/11/11/python-lib-watchdog/"/>
    <id>http://runnerliu.github.io/2020/11/11/python-lib-watchdog/</id>
    <published>2020-11-11T01:56:04.000Z</published>
    <updated>2020-11-15T02:26:10.629Z</updated>
    
    <content type="html"><![CDATA[<p>库地址：<a href="https://pypi.org/project/watchdog/" target="_blank" rel="noopener">pypi</a> <a href="https://github.com/gorakhargosh/watchdog" target="_blank" rel="noopener">github</a></p><p>库功能：文件监控</p><p>使用示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">from watchdog.events import FileSystemEventHandler</span><br><span class="line">from watchdog.observers import Observer</span><br><span class="line"></span><br><span class="line">class FileEventHandler(FileSystemEventHandler):</span><br><span class="line">    </span><br><span class="line">    def __init__(self, callback_func):</span><br><span class="line">        super(FileEventHandler, self).__init__()</span><br><span class="line">        self.callback_func = callback_func</span><br><span class="line"></span><br><span class="line">def on_moved(self, event):</span><br><span class="line">        what = &apos;directory&apos; if event.is_directory else &apos;file&apos;</span><br><span class="line">        self.callback_func(src_path, what)</span><br><span class="line"></span><br><span class="line">    def on_created(self, event):</span><br><span class="line">        what = &apos;directory&apos; if event.is_directory else &apos;file&apos;</span><br><span class="line">        self.callback_func(src_path, what)</span><br><span class="line"></span><br><span class="line">    def on_deleted(self, event):</span><br><span class="line">        what = &apos;directory&apos; if event.is_directory else &apos;file&apos;</span><br><span class="line">        self.callback_func(src_path, what)</span><br><span class="line"></span><br><span class="line">    def on_modified(self, event):</span><br><span class="line">        what = &apos;directory&apos; if event.is_directory else &apos;file&apos;</span><br><span class="line">        self.callback_func(src_path, what)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TaskHandler(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.file_observer = None</span><br><span class="line">        self.file_observer_path = None</span><br><span class="line"></span><br><span class="line">    def observer_start(self):</span><br><span class="line">        if not os.path.exists(self.file_observer_path):</span><br><span class="line">            os.makedirs(self.file_observer_path)</span><br><span class="line">        event_handler = FileEventHandler(self.callback)</span><br><span class="line">        self.file_observer = Observer()</span><br><span class="line">        self.file_observer.schedule(event_handler, self.file_observer_path)</span><br><span class="line">        self.file_observer.start()</span><br><span class="line"></span><br><span class="line">    def observer_stop(self):</span><br><span class="line">        if self.file_observer:</span><br><span class="line">            self.file_observer.stop()</span><br><span class="line">            self.file_observer.join()</span><br><span class="line">    </span><br><span class="line">    def observer_restart(self):</span><br><span class="line">        self.observer_stop()</span><br><span class="line">        self.observer_start()</span><br><span class="line"></span><br><span class="line">    def callback(self, src_path):</span><br><span class="line">        self.logger.debug(&apos;file changed. &#123;&#125;&apos;.format(src_path))</span><br><span class="line">        </span><br><span class="line">    def run(self):</span><br><span class="line">        self.observer_start()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;库地址：&lt;a href=&quot;https://pypi.org/project/watchdog/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pypi&lt;/a&gt; &lt;a href=&quot;https://github.com/gorakhargosh/watchdo
      
    
    </summary>
    
      <category term="Python" scheme="http://runnerliu.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://runnerliu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python常见异常</title>
    <link href="http://runnerliu.github.io/2020/11/10/python-except-enum/"/>
    <id>http://runnerliu.github.io/2020/11/10/python-except-enum/</id>
    <published>2020-11-10T09:19:12.000Z</published>
    <updated>2020-11-15T02:24:39.477Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TypeError"><a href="#TypeError" class="headerlink" title="TypeError"></a>TypeError</h4><p><code>&#39;builtin_function_or_method&#39; object is not subscriptable</code></p><p>此异常一般是上下文代码中有语法错误，缺少()。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;TypeError&quot;&gt;&lt;a href=&quot;#TypeError&quot; class=&quot;headerlink&quot; title=&quot;TypeError&quot;&gt;&lt;/a&gt;TypeError&lt;/h4&gt;&lt;p&gt;&lt;code&gt;&amp;#39;builtin_function_or_method&amp;#39;
      
    
    </summary>
    
      <category term="Python" scheme="http://runnerliu.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://runnerliu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Linux CentOS 系统时间校对</title>
    <link href="http://runnerliu.github.io/2020/10/27/linux-centos-sys-time/"/>
    <id>http://runnerliu.github.io/2020/10/27/linux-centos-sys-time/</id>
    <published>2020-10-27T14:28:58.000Z</published>
    <updated>2020-11-15T02:24:39.470Z</updated>
    
    <content type="html"><![CDATA[<h4 id="CentOS系统时间、时区查看"><a href="#CentOS系统时间、时区查看" class="headerlink" title="CentOS系统时间、时区查看"></a>CentOS系统时间、时区查看</h4><p>查看系统时间：date</p><p>查看硬件时间：hwclock</p><p>查看系统详细时间：timedatectl</p><p>查看系统所有时区：timedatectl list-timezones</p><p>将硬件时钟调整为与本地时钟一致：timedatectl set-local-rtc 1（其中 0 表示UTC时间）</p><p>设置系统时区为上海：timedatectl set-timezone Asia/Shanghai</p><h4 id="校正系统时间"><a href="#校正系统时间" class="headerlink" title="校正系统时间"></a>校正系统时间</h4><p>确认是否安装utpdate工具：<code>yum list installed|grep ntpdate</code></p><p>如未安装，需执行 <code>yum -y install ntpdate</code> </p><p>执行 <code>ntpdate -u  pool.ntp.org</code> 进行时间校正</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;CentOS系统时间、时区查看&quot;&gt;&lt;a href=&quot;#CentOS系统时间、时区查看&quot; class=&quot;headerlink&quot; title=&quot;CentOS系统时间、时区查看&quot;&gt;&lt;/a&gt;CentOS系统时间、时区查看&lt;/h4&gt;&lt;p&gt;查看系统时间：date&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="Linux" scheme="http://runnerliu.github.io/categories/Linux/"/>
    
    
      <category term="CentOS" scheme="http://runnerliu.github.io/tags/CentOS/"/>
    
      <category term="系统时间" scheme="http://runnerliu.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/"/>
    
      <category term="Linux" scheme="http://runnerliu.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>GF-CLI学习系列</title>
    <link href="http://runnerliu.github.io/2020/10/27/gf-cli-series-0-md/"/>
    <id>http://runnerliu.github.io/2020/10/27/gf-cli-series-0-md/</id>
    <published>2020-10-27T07:13:50.000Z</published>
    <updated>2020-11-15T02:24:39.465Z</updated>
    
    <content type="html"><![CDATA[<h4 id="gen"><a href="#gen" class="headerlink" title="gen"></a>gen</h4><p>该命令用以自动化从数据库直接生成模型文件。</p><p>该命令将会根据数据表名（注意：所以要先在数据里建好表）生成对应的目录，该目录名称即数据表包名。</p><p>目录下自动生成3个文件：</p><ul><li>数据表名.go 自定义文件，开发者可以自由定义填充的代码文件，仅会生成一次，每一次模型生成不会覆盖</li><li>数据表名_entity.go 表结构文件，根据数据表结构生成的结构体定义文件，包含字段注释。数据表在外部变更后，可使用gen命令重复生成更新该文件</li><li>数据表名_model.go 表模型文件，为数据表提供了许多便捷的CURD操作方法，并可直接查询返回该表的结构体对象。数据表在外部变更后，可使用gen命令重复生成更新该文件</li></ul><p>使用方式：<code>gf gen model ./app/model -c config/config.toml -p sys_ -t sys_users</code></p><p>命令说明：</p><ul><li>./app/model：在model生成的路径</li><li>-c config/config.toml：在这个配置里找database数据库连接配置 需要写好mysql的配置信息</li><li>-p sys_：去除生成文件目录的sys前缀 如果不加这个参数就会按数据库名生成目录和文件名 如：sys_users</li><li>-t sys_users：要生成model的数据表文件名</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;gen&quot;&gt;&lt;a href=&quot;#gen&quot; class=&quot;headerlink&quot; title=&quot;gen&quot;&gt;&lt;/a&gt;gen&lt;/h4&gt;&lt;p&gt;该命令用以自动化从数据库直接生成模型文件。&lt;/p&gt;
&lt;p&gt;该命令将会根据数据表名（注意：所以要先在数据里建好表）生成对应的目录，该目
      
    
    </summary>
    
      <category term="gf-cli" scheme="http://runnerliu.github.io/categories/gf-cli/"/>
    
    
      <category term="gf" scheme="http://runnerliu.github.io/tags/gf/"/>
    
      <category term="gf-cli" scheme="http://runnerliu.github.io/tags/gf-cli/"/>
    
  </entry>
  
  <entry>
    <title>GO学习系列0 - 学习资料</title>
    <link href="http://runnerliu.github.io/2020/10/26/go-series-0/"/>
    <id>http://runnerliu.github.io/2020/10/26/go-series-0/</id>
    <published>2020-10-26T10:31:25.000Z</published>
    <updated>2020-11-15T02:24:39.466Z</updated>
    
    <content type="html"><![CDATA[<h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p><a href="https://github.com/golang/go" target="_blank" rel="noopener">github.com/golang/go</a></p><p><a href="https://learnku.com/docs/gobyexample/2020" target="_blank" rel="noopener">Go 编程实例 Go by Example</a></p><p><a href="https://learnku.com/docs/the-way-to-go" target="_blank" rel="noopener">Go 入门指南</a></p><h4 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h4><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><h5 id="Go-Frame"><a href="#Go-Frame" class="headerlink" title="Go Frame"></a>Go Frame</h5><ul><li><a href="https://goframe.org/index" target="_blank" rel="noopener">框架介绍</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;文档&quot;&gt;&lt;a href=&quot;#文档&quot; class=&quot;headerlink&quot; title=&quot;文档&quot;&gt;&lt;/a&gt;文档&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/golang/go&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
      
    
    </summary>
    
      <category term="GO" scheme="http://runnerliu.github.io/categories/GO/"/>
    
    
      <category term="GO" scheme="http://runnerliu.github.io/tags/GO/"/>
    
  </entry>
  
  <entry>
    <title>HTTP1.0、HTTP1.1、HTTP2.0的区别</title>
    <link href="http://runnerliu.github.io/2020/10/25/tcpdiff/"/>
    <id>http://runnerliu.github.io/2020/10/25/tcpdiff/</id>
    <published>2020-10-25T06:52:48.000Z</published>
    <updated>2020-11-15T02:24:39.480Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP发展史"><a href="#HTTP发展史" class="headerlink" title="HTTP发展史"></a>HTTP发展史</h3><p><img src="/images/2020-10-25T150500.png" alt="2020-10-25T150500.png"></p><h3 id="HTTP的优化"><a href="#HTTP的优化" class="headerlink" title="HTTP的优化"></a>HTTP的优化</h3><p>影响一个HTTP网络请求的因素主要有两个：带宽和延迟。</p><p><strong>带宽</strong></p><p>现在的网络基础建设已使得带宽得到极大的提升，在影响网速的因素中，带宽所占比重越来越少。</p><p><strong>延迟</strong></p><p>浏览器阻塞：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。</p><p>DNS 解析：浏览器需要知道目标服务器的 IP 才能建立连接。此过程为DNS解析，可参考<a href="https://runnerliu.github.io/2017/06/22/urlrequestprocess/">从输入 URL 到页面展示到底发生了什么</a>，这个通常可以利用DNS缓存结果来达到减少这个时间的目的。</p><p>建立连接：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能携带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</p><h3 id="HTTP1-0、HTTP1-1"><a href="#HTTP1-0、HTTP1-1" class="headerlink" title="HTTP1.0、HTTP1.1"></a>HTTP1.0、HTTP1.1</h3><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别体现在：</p><p><strong>缓存处理</strong></p><p>在HTTP1.0中主要使用header里的If-Modified-Since、Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag、If-Unmodified-Since、If-Match、If-None-Match等更多可供选择的缓存头来控制缓存策略。</p><p><strong>带宽优化及网络连接</strong></p><p>HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p><p><strong>错误通知的管理</strong></p><p>在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突、410（Gone）表示服务器上的某个资源被永久性的删除。</p><p><strong>Host头处理</strong></p><p>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p><p><strong>长连接</strong></p><p>HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection: keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p><h3 id="HTTPS、HTTP的区别"><a href="#HTTPS、HTTP的区别" class="headerlink" title="HTTPS、HTTP的区别"></a>HTTPS、HTTP的区别</h3><ul><li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费</li><li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的</li><li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443</li><li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题</li></ul><p><img src="/images/2020-10-25T152300.png" alt="2020-10-25T152300.png"></p><h3 id="说说SPDY"><a href="#说说SPDY" class="headerlink" title="说说SPDY"></a>说说SPDY</h3><p>其实 SPDY 并不是新的一种协议，而是在 HTTP 之前做了一层会话层。</p><p><img src="/images/2020-10-25T152800.png" alt="2020-10-25T152800.png"></p><p>SPDY是一个由 Google 主导的研究项目发明的HTTP替代协议。SPDY位于HTTP之下、TCP/SSL之上，这样可以轻松兼容老版本的HTTP协议，同时可以使用已有的SSL功能。SPDY优化了HTTP1.X的请求延迟，解决了HTTP1.X的安全性，具体如下：</p><p><strong>降低延迟</strong></p><p>针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。</p><p><strong>请求优先级</strong></p><p>多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。</p><p><strong>header压缩</strong></p><p>前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</p><p><strong>传输协议</strong></p><p>基于HTTPS的加密协议传输，大大提高了传输数据的可靠性。</p><p><strong>服务端推送</strong></p><p>采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。</p><h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><p>HTTP2.0是基于SPDY设计的，但与SPDY 仍有不同的地方，如下：</p><ul><li>HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</li><li>HTTP2.0 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE</li></ul><h4 id="HTTP2-0的新特性"><a href="#HTTP2-0的新特性" class="headerlink" title="HTTP2.0的新特性"></a>HTTP2.0的新特性</h4><h5 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h5><p>HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</p><p><img src="/images/2020-10-25T154700.png" alt="2020-10-25T154700.png"></p><p>在应用层与传输层之间增加一个二进制分帧层，以此达到在不改动 HTTP 的语义，HTTP 方法、状态码、URI 及首部字段的情况下，突破HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。在二进制分帧层上，HTTP2.0 会将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，其中 HTTP1.x 的首部信息会被封装到 Headers 帧，而我们的 request body 则封装到 Data 帧里面。</p><h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><p>即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</p><p><img src="/images/2020-10-25T154800.png" alt="2020-10-25T154800.png"></p><h5 id="header压缩"><a href="#header压缩" class="headerlink" title="header压缩"></a>header压缩</h5><p>如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p><p><img src="/images/2020-10-25T154900.png" alt="2020-10-25T154900.png"></p><h5 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h5><p>同SPDY一样，HTTP2.0也具有server push功能。</p><p>客户端请求的过程：</p><p><img src="/images/2020-10-25T155200.png" alt="2020-10-25T155200.png"></p><p>服务端推送的过程：</p><p><img src="/images/2020-10-25T155300.png" alt="2020-10-25T155300.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>HTTP1.0到HTTP1.1，是无连接到长连接的发展</p></li><li><p>HTTP1.x到HTTP2.0，是二进制分帧、多路复用的发展</p></li></ul><p>参考：</p><blockquote><p><a href="https://www.jianshu.com/p/be29d679cbff" target="_blank" rel="noopener">HTTP1.0、HTTP1.1和HTTP2.0的区别</a></p><p><a href="https://juejin.im/post/6844903824390537230" target="_blank" rel="noopener">HTTP1.0，HTTP1.1，HTTPS和HTTP2.0的区别</a></p><p><a href="https://juejin.im/post/6844903712113360903" target="_blank" rel="noopener">HTTP 的前世今生：一次性搞懂 HTTP、HTTPS、SPDY、HTTP2</a></p><p><a href="https://zh.wikipedia.org/wiki/HTTP/2" target="_blank" rel="noopener">HTTP/2</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;HTTP发展史&quot;&gt;&lt;a href=&quot;#HTTP发展史&quot; class=&quot;headerlink&quot; title=&quot;HTTP发展史&quot;&gt;&lt;/a&gt;HTTP发展史&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/2020-10-25T150500.png&quot; alt=&quot;2020
      
    
    </summary>
    
      <category term="HTTP" scheme="http://runnerliu.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://runnerliu.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>CentOS编译安装Python3</title>
    <link href="http://runnerliu.github.io/2018/06/26/centosinstallpython3/"/>
    <id>http://runnerliu.github.io/2018/06/26/centosinstallpython3/</id>
    <published>2018-06-26T14:25:22.000Z</published>
    <updated>2020-11-15T02:24:39.464Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 下大部分系统默认自带 python2.x 的版本，最常见的是 python2.6 或 python2.7 版本，默认的python 被系统很多程序所依赖，比如 CentOS 下的 yum 就是 python2.x 写的，所以默认版本不要轻易删除，否则会有一些问题。如果需要使用最新的 Python3 那么我们可以编译安装源码包到独立目录，这和系统默认环境之间是没有任何影响的，Python3 和 Python2 两个环境并存即可。</p><p>首先去 Python 官网下载 Python3 的源码包，<a href="https://www.python.org/" target="_blank" rel="noopener">传送门</a> </p><p>进去之后点击导航栏的 Downloads，也可以鼠标放到 Downloads 上弹出菜单选择 Source code，表示源码包，这里选择最新版本 3.6.5，当然下面也有很多其他历史版本，点进去之后页面下方可以看到下载链接，包括源码包、Mac OSX 安装包、Windows 安装包等。Linux 系统可以直接使用以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz</span><br></pre></td></tr></table></figure><p>接下来，如果是全新的 Linux 系统，可能需要安装一些 Python 的依赖，如 openssl、readline等模块。需要的依赖主要如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yum -y install zlib zlib-devel</span><br><span class="line">yum -y install bzip2 bzip2-devel</span><br><span class="line">yum -y install ncurses ncurses-devel</span><br><span class="line">yum -y install readline readline-devel</span><br><span class="line">yum -y install openssl openssl-devel</span><br><span class="line">yum -y install openssl-static</span><br><span class="line">yum -y install xz lzma xz-devel</span><br><span class="line">yum -y install sqlite sqlite-devel</span><br><span class="line">yum -y install gdbm gdbm-devel</span><br><span class="line">yum -y install tk tk-devel</span><br></pre></td></tr></table></figure><p>如果不是全新的 Linux 系统，可以查看是否安装了以上依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum list installed | grep zlib</span><br><span class="line">yum list installed | grep zlib-devel</span><br><span class="line">yum list installed | grep bzip2</span><br><span class="line">yum list installed | grep bzip2-devel</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>解压文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf Python-3.6.5.tgz</span><br></pre></td></tr></table></figure><p>进入目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd Python-3.6.5/</span><br></pre></td></tr></table></figure><p>配置编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/python3.6.5 --enable-shared CFLAGS=-fPIC</span><br></pre></td></tr></table></figure><p>因为上面依赖包是用 yum 安装而不是自己编译的，所以都是安装在系统默认目录下，因此各种选项不用加默认即可生效。<code>--enable-shared</code> 和 <code>-fPIC</code> 之后可以将 Python3 的动态链接库编译出来，默认情况编译完 lib 下面只有 Python3.xm.a 这样的文件，python本身可以正常使用，但是如果编译第三方库需要python 接口的比如 caffe 等，则会报错；所以这里建议按照上面的方式配置。</p><p>然后编译并安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>整个过程大约5分钟，安装成功之后，安装目录就在 <code>/usr/local/python3.6.5/</code> 。</p><p>一般为了系统环境的干净，不需要将 python3、pip3 加入到系统环境变量中，使用全路径运行 Python 文件或安装第三方库即可，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/python3.6.5/bin/python3.6 xxx.py</span><br><span class="line">/usr/local/python3.6.5/bin/pip3.6 install twisted</span><br></pre></td></tr></table></figure><p>但是一般在开发机上时，加入环境变量会更加方便，建立软连接如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/python3.6.5/bin/python3.6 /usr/bin/python36</span><br><span class="line">ln -s /usr/python3.6.5/bin/pip3 /usr/bin/pip3</span><br></pre></td></tr></table></figure><p>然后可以直接使用软连接运行 Python 文件或安装第三方库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python36 xxx.py</span><br><span class="line">pip3 install twisted</span><br></pre></td></tr></table></figure><p>如上在 CentOS 上安装 Python3 就完成了，安装其他版本的 Python 解释器同理。</p><p>Read More:</p><blockquote><p><a href="https://www.cnblogs.com/freeweb/p/5181764.html" target="_blank" rel="noopener">Linux下编译安装python3</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux 下大部分系统默认自带 python2.x 的版本，最常见的是 python2.6 或 python2.7 版本，默认的python 被系统很多程序所依赖，比如 CentOS 下的 yum 就是 python2.x 写的，所以默认版本不要轻易删除，否则会有一些问题
      
    
    </summary>
    
      <category term="Linux/Unix" scheme="http://runnerliu.github.io/categories/Linux-Unix/"/>
    
    
      <category term="Linux/Unix" scheme="http://runnerliu.github.io/tags/Linux-Unix/"/>
    
      <category term="Python3" scheme="http://runnerliu.github.io/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Tornado5.0.2翻译文档 - Queue示例:一个并发网络爬虫</title>
    <link href="http://runnerliu.github.io/2018/06/18/tornado502-concurrentwebspider/"/>
    <id>http://runnerliu.github.io/2018/06/18/tornado502-concurrentwebspider/</id>
    <published>2018-06-18T06:59:43.000Z</published>
    <updated>2020-11-15T02:24:39.481Z</updated>
    
    <content type="html"><![CDATA[<p>Tornado的 <a href="http://tornado-zh.readthedocs.io/zh/latest/queues.html#module-tornado.queues" target="_blank" rel="noopener"><code>tornado.queues</code></a> 模块实现了异步生产者/消费者模式的协程，类似于通过Python 标准库的 <a href="https://docs.python.org/3.4/library/queue.html#module-queue" target="_blank" rel="noopener"><code>queue</code></a> 实现线程模式。</p><p>一个yields <a href="http://tornado-zh.readthedocs.io/zh/latest/queues.html#tornado.queues.Queue.get" target="_blank" rel="noopener"><code>Queue.get</code></a> 的协程直到队列中有值的时候才会暂停。如果队列设置了最大长度，yields <a href="http://tornado-zh.readthedocs.io/zh/latest/queues.html#tornado.queues.Queue.put" target="_blank" rel="noopener"><code>Queue.put</code></a> 的协程直到队列中有空间才会暂停。</p><p>一个 <a href="http://tornado-zh.readthedocs.io/zh/latest/queues.html#tornado.queues.Queue" target="_blank" rel="noopener"><code>Queue</code></a> 从0开始对未完成的任务进行计数， <a href="http://tornado-zh.readthedocs.io/zh/latest/queues.html#tornado.queues.Queue.put" target="_blank" rel="noopener"><code>put</code></a> 加计数； <a href="http://tornado-zh.readthedocs.io/zh/latest/queues.html#tornado.queues.Queue.task_done" target="_blank" rel="noopener"><code>task_done</code></a> 减少计数。</p><p>这里的网络爬虫的例子，队列开始的时候只包含 base_url。当一个 worker 抓取到一个页面它会解析链接并把它添加到队列中，然后调用 <a href="http://tornado-zh.readthedocs.io/zh/latest/queues.html#tornado.queues.Queue.task_done" target="_blank" rel="noopener"><code>task_done</code></a> 减少计数一次。最后，当一个 worker 抓取到的页面 URL 都是之前抓取到过的并且队列中没有任务了。于是 worker 调用 <a href="http://tornado-zh.readthedocs.io/zh/latest/queues.html#tornado.queues.Queue.task_done" target="_blank" rel="noopener"><code>task_done</code></a> 把计数减到0。等待 <a href="http://tornado-zh.readthedocs.io/zh/latest/queues.html#tornado.queues.Queue.join" target="_blank" rel="noopener"><code>join</code></a> 的主协程取消暂停并且完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line">from datetime import timedelta</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    from HTMLParser import HTMLParser</span><br><span class="line">    from urlparse import urljoin, urldefrag</span><br><span class="line">except ImportError:</span><br><span class="line">    from html.parser import HTMLParser</span><br><span class="line">    from urllib.parse import urljoin, urldefrag</span><br><span class="line"></span><br><span class="line">from tornado import httpclient, gen, ioloop, queues</span><br><span class="line"></span><br><span class="line">base_url = &apos;http://www.tornadoweb.org/en/stable/&apos;</span><br><span class="line">concurrency = 10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@gen.coroutine</span><br><span class="line">def get_links_from_url(url):</span><br><span class="line">    &quot;&quot;&quot;Download the page at `url` and parse it for links.</span><br><span class="line"></span><br><span class="line">    Returned links have had the fragment after `#` removed, and have been made</span><br><span class="line">    absolute so, e.g. the URL &apos;gen.html#tornado.gen.coroutine&apos; becomes</span><br><span class="line">    &apos;http://www.tornadoweb.org/en/stable/gen.html&apos;.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    try:</span><br><span class="line">        response = yield httpclient.AsyncHTTPClient().fetch(url)</span><br><span class="line">        print(&apos;fetched %s&apos; % url)</span><br><span class="line"></span><br><span class="line">        html = response.body if isinstance(response.body, str) \</span><br><span class="line">            else response.body.decode(errors=&apos;ignore&apos;)</span><br><span class="line">        urls = [urljoin(url, remove_fragment(new_url))</span><br><span class="line">                for new_url in get_links(html)]</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(&apos;Exception: %s %s&apos; % (e, url))</span><br><span class="line">        raise gen.Return([])</span><br><span class="line"></span><br><span class="line">    raise gen.Return(urls)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def remove_fragment(url):</span><br><span class="line">    pure_url, frag = urldefrag(url)</span><br><span class="line">    return pure_url</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_links(html):</span><br><span class="line">    class URLSeeker(HTMLParser):</span><br><span class="line">        def __init__(self):</span><br><span class="line">            HTMLParser.__init__(self)</span><br><span class="line">            self.urls = []</span><br><span class="line"></span><br><span class="line">        def handle_starttag(self, tag, attrs):</span><br><span class="line">            href = dict(attrs).get(&apos;href&apos;)</span><br><span class="line">            if href and tag == &apos;a&apos;:</span><br><span class="line">                self.urls.append(href)</span><br><span class="line"></span><br><span class="line">    url_seeker = URLSeeker()</span><br><span class="line">    url_seeker.feed(html)</span><br><span class="line">    return url_seeker.urls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@gen.coroutine</span><br><span class="line">def main():</span><br><span class="line">    q = queues.Queue()</span><br><span class="line">    start = time.time()</span><br><span class="line">    fetching, fetched = set(), set()</span><br><span class="line"></span><br><span class="line">    @gen.coroutine</span><br><span class="line">    def fetch_url():</span><br><span class="line">        current_url = yield q.get()</span><br><span class="line">        try:</span><br><span class="line">            if current_url in fetching:</span><br><span class="line">                return</span><br><span class="line"></span><br><span class="line">            print(&apos;fetching %s&apos; % current_url)</span><br><span class="line">            fetching.add(current_url)</span><br><span class="line">            urls = yield get_links_from_url(current_url)</span><br><span class="line">            fetched.add(current_url)</span><br><span class="line"></span><br><span class="line">            for new_url in urls:</span><br><span class="line">                # Only follow links beneath the base URL</span><br><span class="line">                if new_url.startswith(base_url):</span><br><span class="line">                    yield q.put(new_url)</span><br><span class="line"></span><br><span class="line">        finally:</span><br><span class="line">            q.task_done()</span><br><span class="line"></span><br><span class="line">    @gen.coroutine</span><br><span class="line">    def worker():</span><br><span class="line">        while True:</span><br><span class="line">            yield fetch_url()</span><br><span class="line"></span><br><span class="line">    q.put(base_url)</span><br><span class="line"></span><br><span class="line">    # Start workers, then wait for the work queue to be empty.</span><br><span class="line">    for _ in range(concurrency):</span><br><span class="line">        worker()</span><br><span class="line">    yield q.join(timeout=timedelta(seconds=300))</span><br><span class="line">    assert fetching == fetched</span><br><span class="line">    print(&apos;Done in %d seconds, fetched %s URLs.&apos; % (</span><br><span class="line">        time.time() - start, len(fetched)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    io_loop = ioloop.IOLoop.current()</span><br><span class="line">    io_loop.run_sync(main)</span><br></pre></td></tr></table></figure><p>Read More:</p><blockquote><p><a href="http://www.tornadoweb.org/en/stable/guide/queues.html" target="_blank" rel="noopener"><code>Queue</code> example - a concurrent web spider</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Tornado的 &lt;a href=&quot;http://tornado-zh.readthedocs.io/zh/latest/queues.html#module-tornado.queues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;torn
      
    
    </summary>
    
      <category term="Tornado" scheme="http://runnerliu.github.io/categories/Tornado/"/>
    
    
      <category term="Tornado" scheme="http://runnerliu.github.io/tags/Tornado/"/>
    
      <category term="翻译文档" scheme="http://runnerliu.github.io/tags/%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3/"/>
    
      <category term="并发网络爬虫" scheme="http://runnerliu.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Tornado5.0.2翻译文档 - 协程</title>
    <link href="http://runnerliu.github.io/2018/06/18/tornado502-coroutines/"/>
    <id>http://runnerliu.github.io/2018/06/18/tornado502-coroutines/</id>
    <published>2018-06-18T05:36:42.000Z</published>
    <updated>2020-11-15T02:24:39.482Z</updated>
    
    <content type="html"><![CDATA[<p>Tornado中推荐使用 <strong>协程</strong> 编写异步代码，协程使用了Python的 <code>yield</code> 关键字代替链式回调来将程序挂起和恢复执行(像在 <a href="http://www.gevent.org/" target="_blank" rel="noopener">gevent</a> 中出现的轻量级线程合作方式有时也被称为协程，但是在Tornado中所有的协程使用明确的上下文切换，并被称为异步函数)。</p><p>使用协程几乎像写同步代码一样简单，并且不需要浪费额外的线程。它们还通过减少上下文切换来 <a href="https://glyph.twistedmatrix.com/2014/02/unyielding.html" target="_blank" rel="noopener">使并发编程更简单</a> 。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from tornado import gen</span><br><span class="line"></span><br><span class="line">@gen.coroutine</span><br><span class="line">def fetch_coroutine(url):</span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    response = yield http_client.fetch(url)</span><br><span class="line">    # In Python versions prior to 3.3, returning a value from</span><br><span class="line">    # a generator is not allowed and you must use</span><br><span class="line">    #   raise gen.Return(response.body)</span><br><span class="line">    # instead.</span><br><span class="line">    return response.body</span><br></pre></td></tr></table></figure><h3 id="Python-3-5-async-和-await"><a href="#Python-3-5-async-和-await" class="headerlink" title="Python 3.5: async 和 await"></a>Python 3.5: <code>async</code> 和 <code>await</code></h3><p>Python 3.5 引入了 <code>async</code> 和 <code>await</code> 关键字(使用这些关键字的函数也被称为”原生协程”)。从Tornado 4.3，你可以用它们代替 <code>yield</code> 为基础的协程。只需要简单的使用 <code>async def foo()</code> 在函数定义的时候代替 <a href="mailto:`@gen.coroutine" target="_blank" rel="noopener">`@gen.coroutine</a><code>装饰器，用</code>await<code>代替 yield。本文档的其他部分会继续使用</code>yield<code>的风格来和旧版本的Python兼容，但是如果</code>async<code>和</code>await` 可用的话，它们运行起来会更快：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async def fetch_coroutine(url):</span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    response = await http_client.fetch(url)</span><br><span class="line">    return response.body</span><br></pre></td></tr></table></figure><p><code>await</code> 关键字比 <code>yield</code> 关键字功能要少一些。例如，在一个使用 <code>yield</code> 的协程中，你可以得到 <code>Futures</code> 列表，但是在原生协程中，你必须把列表用 <a href="http://tornado-zh.readthedocs.io/zh/latest/gen.html#tornado.gen.multi" target="_blank" rel="noopener"><code>tornado.gen.multi</code></a> 包起来。同时也去掉了与 <a href="https://docs.python.org/3.6/library/concurrent.futures.html#module-concurrent.futures" target="_blank" rel="noopener"><code>concurrent.futures</code></a> 的集成。你也可以使用 <a href="http://tornado-zh.readthedocs.io/zh/latest/gen.html#tornado.gen.convert_yielded" target="_blank" rel="noopener"><code>tornado.gen.convert_yielded</code></a> 来把任何使用 <code>yield</code> 工作的代码转换成使用 <code>await</code> 的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">async def f():</span><br><span class="line">    executor = concurrent.futures.ThreadPoolExecutor()</span><br><span class="line">    await tornado.gen.convert_yielded(executor.submit(g))</span><br></pre></td></tr></table></figure><h3 id="它如何工作"><a href="#它如何工作" class="headerlink" title="它如何工作"></a>它如何工作</h3><p>包含了 <code>yield</code> 关键字的函数是一个 <strong>生成器(generator)</strong> 。所有的生成器都是异步的；当调用它们的时候，会返回一个生成器对象，而不是一个执行完的结果。 <a href="mailto:`@gen.coroutine" target="_blank" rel="noopener">`@gen.coroutine</a><code>装饰器通过</code>yield<code>表达式和生成器进行交流，而且通过返回一个 [</code>Future`](<a href="http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future" target="_blank" rel="noopener">http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future</a>) 与协程的调用方进行交互。</p><p>下面是一个协程装饰器内部循环的简单版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Simplified inner loop of tornado.gen.Runner</span><br><span class="line">def run(self):</span><br><span class="line">    # send(x) makes the current yield return x.</span><br><span class="line">    # It returns when the next yield is reached</span><br><span class="line">    future = self.gen.send(self.next)</span><br><span class="line">    def callback(f):</span><br><span class="line">        self.next = f.result()</span><br><span class="line">        self.run()</span><br><span class="line">    future.add_done_callback(callback)</span><br></pre></td></tr></table></figure><p>装饰器从生成器接收一个 <a href="http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future" target="_blank" rel="noopener"><code>Future</code></a> 对象，等待(非阻塞的)这个 <a href="http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future" target="_blank" rel="noopener"><code>Future</code></a> 对象执行完成，然后“解开(unwraps)” 这个 <a href="http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future" target="_blank" rel="noopener"><code>Future</code></a> 对象，并把结果作为 <code>yield</code> 表达式的结果传回给生成器。大多数异步代码从来不会直接接触 <a href="http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future" target="_blank" rel="noopener"><code>Future</code></a> 类 除非 <a href="http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future" target="_blank" rel="noopener"><code>Future</code></a> 立即通过异步函数返回给 <code>yield</code> 表达式。</p><h3 id="如何调用协程"><a href="#如何调用协程" class="headerlink" title="如何调用协程"></a>如何调用协程</h3><p>协程一般不会抛出异常：它们抛出的任何异常将被 <a href="http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future" target="_blank" rel="noopener"><code>Future</code></a> 捕获直到它被得到，这意味着用正确的方式调用协程是重要的，否则你可能有被忽略的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@gen.coroutine</span><br><span class="line">def divide(x, y):</span><br><span class="line">    return x / y</span><br><span class="line"></span><br><span class="line">def bad_call():</span><br><span class="line">    # This should raise a ZeroDivisionError, but it won&apos;t because</span><br><span class="line">    # the coroutine is called incorrectly.</span><br><span class="line">    divide(1, 0)</span><br></pre></td></tr></table></figure><p>几乎所有的情况下，任何一个调用协程的函数都必须是协程它自身，并且在调用的时候使用 <code>yield</code> 关键字。当你重写超类中的方法，请参阅文档，看看协程是否支持(文档应该会写该方法 “可能是一个协程” 或者 “可能返回 一个 <a href="http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future" target="_blank" rel="noopener"><code>Future</code></a> ”)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@gen.coroutine</span><br><span class="line">def good_call():</span><br><span class="line">    # yield will unwrap the Future returned by divide() and raise</span><br><span class="line">    # the exception.</span><br><span class="line">    yield divide(1, 0)</span><br></pre></td></tr></table></figure><p>有时你可能想要对一个协程”一劳永逸”而且不等待它的结果。在这种情况下，建议使用 <a href="http://tornado-zh.readthedocs.io/zh/latest/ioloop.html#tornado.ioloop.IOLoop.spawn_callback" target="_blank" rel="noopener"><code>IOLoop.spawn_callback</code></a> ，它使得 <a href="http://tornado-zh.readthedocs.io/zh/latest/ioloop.html#tornado.ioloop.IOLoop" target="_blank" rel="noopener"><code>IOLoop</code></a> 负责调用。如果它失败了， <a href="http://tornado-zh.readthedocs.io/zh/latest/ioloop.html#tornado.ioloop.IOLoop" target="_blank" rel="noopener"><code>IOLoop</code></a> 会在日志中把调用栈记录下来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># The IOLoop will catch the exception and print a stack trace in</span><br><span class="line"># the logs. Note that this doesn&apos;t look like a normal call, since</span><br><span class="line"># we pass the function object to be called by the IOLoop.</span><br><span class="line">IOLoop.current().spawn_callback(divide, 1, 0)</span><br></pre></td></tr></table></figure><p>如果函数使用了 <a href="mailto:`@gen.coroutine" target="_blank" rel="noopener">`@gen.coroutine</a><code>，则推荐以上方式使用 [</code>IOLoop.spawn_callback<code>](http://www.tornadoweb.org/en/stable/ioloop.html#tornado.ioloop.IOLoop.spawn_callback) ，但如果函数使用</code>async def` ，则必须使用以上方式(否则协程不会运行)。</p><p>最后，在程序顶层，如果 IOLoop 尚未运行，你可以启动 <a href="http://tornado-zh.readthedocs.io/zh/latest/ioloop.html#tornado.ioloop.IOLoop" target="_blank" rel="noopener"><code>IOLoop</code></a> 执行协程，然后使用 <a href="http://tornado-zh.readthedocs.io/zh/latest/ioloop.html#tornado.ioloop.IOLoop.run_sync" target="_blank" rel="noopener"><code>IOLoop.run_sync</code></a> 方法停止 <a href="http://tornado-zh.readthedocs.io/zh/latest/ioloop.html#tornado.ioloop.IOLoop" target="_blank" rel="noopener"><code>IOLoop</code></a> 。这通常被用来启动面向批处理程序的 <code>main</code> 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># run_sync() doesn&apos;t take arguments, so we must wrap the</span><br><span class="line"># call in a lambda.</span><br><span class="line">IOLoop.current().run_sync(lambda: divide(1, 0))</span><br></pre></td></tr></table></figure><h3 id="协程模式"><a href="#协程模式" class="headerlink" title="协程模式"></a>协程模式</h3><h4 id="调用阻塞函数"><a href="#调用阻塞函数" class="headerlink" title="调用阻塞函数"></a>调用阻塞函数</h4><p>从一个协程调用阻塞函数最简单的方式是使用 <code>IOLoop.run_in_executor</code> ，它将返回和协程兼容的<code>Futures</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@gen.coroutine</span><br><span class="line">def call_blocking():</span><br><span class="line">    yield IOLoop.current().run_in_executor(blocking_func, args)</span><br></pre></td></tr></table></figure><h4 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h4><p>协程装饰器能识别列表或者字典对象中各自的 <code>Futures</code> ，并且并行的等待这些 <code>Futures</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@gen.coroutine</span><br><span class="line">def parallel_fetch(url1, url2):</span><br><span class="line">    resp1, resp2 = yield [http_client.fetch(url1),</span><br><span class="line">                          http_client.fetch(url2)]</span><br><span class="line"></span><br><span class="line">@gen.coroutine</span><br><span class="line">def parallel_fetch_many(urls):</span><br><span class="line">    responses = yield [http_client.fetch(url) for url in urls]</span><br><span class="line">    # responses is a list of HTTPResponses in the same order</span><br><span class="line"></span><br><span class="line">@gen.coroutine</span><br><span class="line">def parallel_fetch_dict(urls):</span><br><span class="line">    responses = yield &#123;url: http_client.fetch(url)</span><br><span class="line">                        for url in urls&#125;</span><br><span class="line">    # responses is a dict &#123;url: HTTPResponse&#125;</span><br></pre></td></tr></table></figure><p>如果使用 <code>await</code> 关键字，列表和字典必须使用 <a href="http://www.tornadoweb.org/en/stable/gen.html#tornado.gen.multi" target="_blank" rel="noopener"><code>tornado.gen.multi</code></a> 包装起来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">async def parallel_fetch(url1, url2):</span><br><span class="line">    resp1, resp2 = await gen.multi([http_client.fetch(url1),</span><br><span class="line">                                    http_client.fetch(url2)])</span><br></pre></td></tr></table></figure><h4 id="交叉存取"><a href="#交叉存取" class="headerlink" title="交叉存取"></a>交叉存取</h4><p>有时候我们需要保存<code>Future</code> 而不是立即返回，所以可以在等待之前执行其他操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@gen.coroutine</span><br><span class="line">def get(self):</span><br><span class="line">    fetch_future = self.fetch_next_chunk()</span><br><span class="line">    while True:</span><br><span class="line">        chunk = yield fetch_future</span><br><span class="line">        if chunk is None: break</span><br><span class="line">        self.write(chunk)</span><br><span class="line">        fetch_future = self.fetch_next_chunk()</span><br><span class="line">        yield self.flush()</span><br></pre></td></tr></table></figure><p>这种模式最适用于 <a href="mailto:`@gen.coroutine" target="_blank" rel="noopener">`@gen.coroutine</a><code>，如果</code>fetch_next_chunk()<code>使用</code>async def<code>，则必须如下调用：</code>fetch_future = tornado.gen.convert_yielded(self.fetch_next_chunk())`才能启动后台进程。</p><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>在原生协程中，可以使用<code>aysnc for</code> 。在老版本的Python中，协程的循环是棘手的，因为没有办法在 <code>for</code> 循环或者 <code>while</code> 循环 <code>yield</code> 迭代器，并且捕获 yield 的结果。相反，你需要将循环条件从访问结果中分离出来，下面是一个使用 <a href="http://motor.readthedocs.org/en/stable/" target="_blank" rel="noopener">Motor</a> 的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import motor</span><br><span class="line">db = motor.MotorClient().test</span><br><span class="line"></span><br><span class="line">@gen.coroutine</span><br><span class="line">def loop_example(collection):</span><br><span class="line">    cursor = db.collection.find()</span><br><span class="line">    while (yield cursor.fetch_next):</span><br><span class="line">        doc = cursor.next_object()</span><br></pre></td></tr></table></figure><h4 id="在后台运行"><a href="#在后台运行" class="headerlink" title="在后台运行"></a>在后台运行</h4><p><a href="http://tornado-zh.readthedocs.io/zh/latest/ioloop.html#tornado.ioloop.PeriodicCallback" target="_blank" rel="noopener"><code>PeriodicCallback</code></a> 通常不使用协程。相反，一个协程可以包含一个 <code>while True:</code> 循环并使用<a href="http://tornado-zh.readthedocs.io/zh/latest/gen.html#tornado.gen.sleep" target="_blank" rel="noopener"><code>tornado.gen.sleep</code></a> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@gen.coroutine</span><br><span class="line">def minute_loop():</span><br><span class="line">    while True:</span><br><span class="line">        yield do_something()</span><br><span class="line">        yield gen.sleep(60)</span><br><span class="line"></span><br><span class="line"># Coroutines that loop forever are generally started with</span><br><span class="line"># spawn_callback().</span><br><span class="line">IOLoop.current().spawn_callback(minute_loop)</span><br></pre></td></tr></table></figure><p>有时可能会遇到一个更复杂的循环。例如，上一个循环运行每次花费 <code>60+N</code> 秒，其中 <code>N</code> 是 <code>do_something()</code> 花费的时间。为了 准确的每60秒运行，使用上面的交叉模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@gen.coroutine</span><br><span class="line">def minute_loop2():</span><br><span class="line">    while True:</span><br><span class="line">        nxt = gen.sleep(60)   # Start the clock.</span><br><span class="line">        yield do_something()  # Run while the clock is ticking.</span><br><span class="line">        yield nxt             # Wait for the timer to run out.</span><br></pre></td></tr></table></figure><p>Read More:</p><blockquote><p><a href="http://www.tornadoweb.org/en/stable/guide/coroutines.html" target="_blank" rel="noopener">Coroutines</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Tornado中推荐使用 &lt;strong&gt;协程&lt;/strong&gt; 编写异步代码，协程使用了Python的 &lt;code&gt;yield&lt;/code&gt; 关键字代替链式回调来将程序挂起和恢复执行(像在 &lt;a href=&quot;http://www.gevent.org/&quot; target=&quot;
      
    
    </summary>
    
      <category term="Tornado" scheme="http://runnerliu.github.io/categories/Tornado/"/>
    
    
      <category term="Tornado" scheme="http://runnerliu.github.io/tags/Tornado/"/>
    
      <category term="翻译文档" scheme="http://runnerliu.github.io/tags/%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3/"/>
    
      <category term="协程" scheme="http://runnerliu.github.io/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Requests库 - 会话对象</title>
    <link href="http://runnerliu.github.io/2018/06/10/requests-session/"/>
    <id>http://runnerliu.github.io/2018/06/10/requests-session/</id>
    <published>2018-06-10T14:01:44.000Z</published>
    <updated>2020-11-15T02:24:39.479Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>一个简单的需求是，向一个 host 地址+端口定时 post 一定量数据，程序使用 <a href="http://www.python-requests.org/en/master/" target="_blank" rel="noopener">requests</a> 的 post 方式，傻瓜式同步执行，因为没有时间限制。但是在执行后出现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TimeoutError: [Errno 110] Connection timed out</span><br></pre></td></tr></table></figure><p>显示连接超时了，程序每次运行 post 了大概500条数据，而这个错误只会出现一次，猜测可能是 HTTP 短连接的问题。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>其实对于     向同一主机发送多个请求 这种场景，使用 HTTP 的长连接效率会更高，复用底层的 TCP 连接。Requests 库同样提供了这样的方式，即会话对象 - <a href="http://www.python-requests.org/en/master/user/advanced/#session-objects" target="_blank" rel="noopener">Session</a> ，使用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = requests.Session()</span><br><span class="line">r = s.get(&apos;http://www.baidu.com&apos;)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure><p><a href="http://docs.python-requests.org/en/master/_modules/requests/adapters/?highlight=HTTPAdapter" target="_blank" rel="noopener">源码</a>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Session(SessionRedirectMixin):</span><br><span class="line"> </span><br><span class="line">    def __init__(self):</span><br><span class="line">        ...</span><br><span class="line">        self.max_redirects = DEFAULT_REDIRECT_LIMIT</span><br><span class="line">        self.cookies = cookiejar_from_dict(&#123;&#125;)</span><br><span class="line">        self.adapters = OrderedDict()</span><br><span class="line">        self.mount(&apos;https://&apos;, HTTPAdapter())</span><br><span class="line">        self.mount(&apos;http://&apos;, HTTPAdapter())</span><br><span class="line">        self.redirect_cache = RecentlyUsedContainer(REDIRECT_CACHE_SIZE)</span><br><span class="line"> </span><br><span class="line">class HTTPAdapter(BaseAdapter):</span><br><span class="line"> </span><br><span class="line">    def __init__(self, pool_connections=DEFAULT_POOLSIZE,</span><br><span class="line">                 pool_maxsize=DEFAULT_POOLSIZE, max_retries=DEFAULT_RETRIES,</span><br><span class="line">                 pool_block=DEFAULT_POOLBLOCK):</span><br><span class="line">        if max_retries == DEFAULT_RETRIES:</span><br><span class="line">            self.max_retries = Retry(0, read=False)</span><br><span class="line">        else:</span><br><span class="line">            self.max_retries = Retry.from_int(max_retries)</span><br><span class="line">        self.config = &#123;&#125;</span><br><span class="line">        self.proxy_manager = &#123;&#125;</span><br><span class="line"> </span><br><span class="line">        super(HTTPAdapter, self).__init__()</span><br><span class="line"> </span><br><span class="line">        self._pool_connections = pool_connections</span><br><span class="line">        self._pool_maxsize = pool_maxsize</span><br><span class="line">        self._pool_block = pool_block</span><br><span class="line">        self.init_poolmanager(pool_connections, pool_maxsize, block=pool_block) </span><br><span class="line"> </span><br><span class="line">DEFAULT_POOLBLOCK = False  #是否阻塞连接池</span><br><span class="line">DEFAULT_POOLSIZE = 10  # 默认连接池</span><br><span class="line">DEFAULT_RETRIES = 0   # 默认重试次数</span><br><span class="line">DEFAULT_POOL_TIMEOUT = None  # 超时时间</span><br></pre></td></tr></table></figure><p>默认情况下，Session 连接池大小为10，请求失败重试次数为0，但是一般情况下我们会需要稍大容量的连接池，从源码中可以看到，session 绑定了 <code>HTTPAdapter</code> 对象，所以我们可以自定义一个符合预期参数的 <code>HTTPAdapter</code> 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def get_http_session(self, pool_connections, pool_maxsize, max_retries):</span><br><span class="line">    session = requests.Session()</span><br><span class="line">    # 创建一个适配器，连接池的数量pool_connections, 最大数量pool_maxsize, 失败重试的次数max_retries</span><br><span class="line">    adapter = requests.adapters.HTTPAdapter(pool_connections = pool_connections,</span><br><span class="line">            pool_maxsize = pool_maxsize, max_retries = max_retries)</span><br><span class="line">    # 告诉requests，http协议和https协议都使用这个适配器</span><br><span class="line">    session.mount(&apos;http://&apos;, adapter)</span><br><span class="line">    session.mount(&apos;https://&apos;, adapter)</span><br><span class="line">    return session</span><br></pre></td></tr></table></figure><p>然后就可以使用 session 的各个功能了。So Easy!</p><p>Read More:</p><blockquote><p><a href="http://www.python-requests.org/en/master/user/advanced/#session-objects" target="_blank" rel="noopener">Advanced Usage</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h3&gt;&lt;p&gt;一个简单的需求是，向一个 host 地址+端口定时 post 一定量数据，程序使用 &lt;a href=&quot;http://www.
      
    
    </summary>
    
      <category term="requests" scheme="http://runnerliu.github.io/categories/requests/"/>
    
    
      <category term="requests" scheme="http://runnerliu.github.io/tags/requests/"/>
    
      <category term="session" scheme="http://runnerliu.github.io/tags/session/"/>
    
      <category term="会话对象" scheme="http://runnerliu.github.io/tags/%E4%BC%9A%E8%AF%9D%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Tornado5.0.2翻译文档 - 异步和非阻塞I/O</title>
    <link href="http://runnerliu.github.io/2018/06/10/tornado502-asnon/"/>
    <id>http://runnerliu.github.io/2018/06/10/tornado502-asnon/</id>
    <published>2018-06-10T13:09:37.000Z</published>
    <updated>2020-11-15T02:24:39.481Z</updated>
    
    <content type="html"><![CDATA[<p>实时web功能需要为每个用户提供一个多数时间被闲置的长连接，在传统的同步 web 服务器中，这意味着要为每个用户提供一个线程，当然每个线程的开销都是很昂贵的。</p><p>为了尽量减少并发连接造成的开销，Tornado 使用了一种单线程事件循环的方式。这就意味着所有的应用代码都应该是异步非阻塞的，因为在同一时间只有一个操作是有效的。</p><p>异步和非阻塞是非常相关的并且这两个术语经常交换使用，但它们不是完全相同的事情。</p><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>一个函数在等待某些事情返回值的时候会被阻塞，导致函数阻塞的原因有很多：网络 I/O，磁盘 I/O，互斥锁等。事实上每个函数在运行和使用 CPU 的时候都或多或少被阻塞(举个极端的例子来说明为什么对待 CPU 阻塞要和对待一般阻塞一样的严肃：比如密码哈希函数 <a href="http://bcrypt.sourceforge.net/" target="_blank" rel="noopener">bcrypt</a> ，需要消耗几百毫秒的 CPU 时间，这已 经远远超过了一般的网络或者磁盘请求时间了)。</p><p>一个函数可以在某个方面被阻塞但在其他方面不被阻塞，在 Tornado 的上下文中，我们一般讨论网络 I/O 上下文的阻塞，尽管各种阻塞已经被最小化。</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>异步函数在会在其完成之前返回，在应用中触发下一个动作之前通常会在后台执行一些工作(和正常的同步函数在返回前就执行完所有的事情不同)。这里列举了几种不同的异步接口：</p><ul><li>回调参数；</li><li>返回一个占位符(<a href><code>Future</code></a> <a href><code>Promise</code></a> <a href><code>Deferred</code></a>)；</li><li>传送给一个队列；</li><li>回调注册表(POSIX 信号)。</li></ul><p>不论使用哪种类型的接口，按照定义，异步函数与他们的调用者都有着不同的交互方式；也没有什么对调用者透明的方式使得同步函数变得异步(类似 <a href="http://www.gevent.org/" target="_blank" rel="noopener">gevent</a> 使用轻量级线程的系统性能虽然堪比异步系统，但它们并没有真正的让事情异步)。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>这是一个简单的同步函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from tornado.httpclient import HTTPClient</span><br><span class="line"></span><br><span class="line">def synchronous_fetch(url):</span><br><span class="line">    http_client = HTTPClient()</span><br><span class="line">    response = http_client.fetch(url)</span><br><span class="line">    return response.body</span><br></pre></td></tr></table></figure><p>下面是使用回调参数重写的具有同样功能的异步函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from tornado.httpclient import AsyncHTTPClient</span><br><span class="line"></span><br><span class="line">def asynchronous_fetch(url, callback):</span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    def handle_response(response):</span><br><span class="line">        callback(response.body)</span><br><span class="line">    http_client.fetch(url, callback=handle_response)</span><br></pre></td></tr></table></figure><p>使用 <a href><code>Future</code></a> 代替回调：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from tornado.concurrent import Future</span><br><span class="line">from tornado.httpclient import AsyncHTTPClient</span><br><span class="line"></span><br><span class="line">def async_fetch_future(url):</span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    my_future = Future()</span><br><span class="line">    fetch_future = http_client.fetch(url)</span><br><span class="line">    fetch_future.add_done_callback(</span><br><span class="line">        lambda f: my_future.set_result(f.result()))</span><br><span class="line">    return my_future</span><br></pre></td></tr></table></figure><p><a href><code>Future</code></a> 版本更加复杂，但是 <a href><code>Futures</code></a> 却是 Tornado 中推荐的写法，因为它有两个主要的优势：一是错误处理更加一致，<a href><code>Future.result</code></a> 方法可以简单的抛出异常(相较于常见的回调函数接口中需特别指定错误处理方式)，二是 <a href><code>Futures</code></a> 很适合与协程一起使用。我们稍后会更加深入的讨论协程，以下是例子的协程版本，类似原始的同步版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from tornado import gen</span><br><span class="line"></span><br><span class="line">@gen.coroutine</span><br><span class="line">def fetch_coroutine(url):</span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    response = yield http_client.fetch(url)</span><br><span class="line">    raise gen.Return(response.body)</span><br></pre></td></tr></table></figure><p><code>raise gen.Return(response.body)</code> 声明是在 Python 2 环境下人为执行的，因为生成器不允许有返回值，为了解决这个问题，Tornado 的协程抛出了一种称为 <code>Return</code> 的异常，协程捕获这个异常并将其作为返回值。在 Python 3.3+版本，使用 <code>return response.body</code> 可以得到相同的结果。</p><p>Read More:</p><blockquote><p><a href="http://www.tornadoweb.org/en/stable/guide/async.html" target="_blank" rel="noopener">Asynchronous and non-Blocking I/O</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实时web功能需要为每个用户提供一个多数时间被闲置的长连接，在传统的同步 web 服务器中，这意味着要为每个用户提供一个线程，当然每个线程的开销都是很昂贵的。&lt;/p&gt;
&lt;p&gt;为了尽量减少并发连接造成的开销，Tornado 使用了一种单线程事件循环的方式。这就意味着所有的应用
      
    
    </summary>
    
      <category term="Tornado" scheme="http://runnerliu.github.io/categories/Tornado/"/>
    
    
      <category term="Tornado" scheme="http://runnerliu.github.io/tags/Tornado/"/>
    
      <category term="翻译文档" scheme="http://runnerliu.github.io/tags/%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>Tornado5.0.2翻译文档 - 介绍</title>
    <link href="http://runnerliu.github.io/2018/06/10/tornado502-introduction/"/>
    <id>http://runnerliu.github.io/2018/06/10/tornado502-introduction/</id>
    <published>2018-06-10T12:48:11.000Z</published>
    <updated>2020-11-15T02:24:39.482Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.tornadoweb.org/" target="_blank" rel="noopener">Tornado</a> 是一个 Python web 框架和异步网络库，起初由 <a href="http://friendfeed.com/" target="_blank" rel="noopener">FriendFeed</a> 开发。通过使用非阻塞网络 I/O，Tornado 可以支持上万级的连接，处理<a href="http://en.wikipedia.org/wiki/Push_technology#Long_polling" target="_blank" rel="noopener">长连接</a> <a href="http://en.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">WebSockets</a> 和其他需要与每个用户保持长久连接的应用。</p><p>Tornado 大体上可以被分为4个主要的部分：</p><ul><li>web 框架 - 包括创建 web 应用的 <a href><code>RequestHandler</code></a> 类，和其他支持类；</li><li>HTTP 客户端和服务端的实现(<a href><code>HTTPServer</code></a> 和 <a href><code>AsyncHTTPClient</code></a>)；</li><li>异步网络库(<a href><code>IOLoop</code></a> 和 <a href><code>IOStream</code></a>)，为 HTTP 组件提供构建模块，也可以用来实现其他协议；</li><li>协程库 (<a href><code>tornado.gen</code></a>) 允许异步代码写的更直接而不用链式回调的方式。</li></ul><p>Tornado web 框架和 HTTP server 一起为 <a href="http://www.python.org/dev/peps/pep-3333/" target="_blank" rel="noopener">WSGI</a> 提供了一个全栈式的选择，在 WSGI 容器 (<a href><code>WSGIAdapter</code></a>) 中使用 Tornado web 框架或者使用 Tornado HTTP server 作为一个其他 WSGI 框架(<a href><code>WSGIContainer</code></a>)的容器，这样的组合方式都是有局限性的。为了充分利用Tornado的特性，你需要一起使用 Tornado 的 web 框架和 HTTP server。</p><p>Read More:</p><blockquote><p><a href="http://www.tornadoweb.org/en/stable/guide/intro.html" target="_blank" rel="noopener">Introduction</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.tornadoweb.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tornado&lt;/a&gt; 是一个 Python web 框架和异步网络库，起初由 &lt;a href=&quot;http://friendfeed.co
      
    
    </summary>
    
      <category term="Tornado" scheme="http://runnerliu.github.io/categories/Tornado/"/>
    
    
      <category term="Tornado" scheme="http://runnerliu.github.io/tags/Tornado/"/>
    
      <category term="翻译文档" scheme="http://runnerliu.github.io/tags/%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>Tornado5.0.2翻译文档 - 用户指南</title>
    <link href="http://runnerliu.github.io/2018/06/10/tornado502-userguide/"/>
    <id>http://runnerliu.github.io/2018/06/10/tornado502-userguide/</id>
    <published>2018-06-10T10:50:44.000Z</published>
    <updated>2020-11-15T02:24:39.482Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用户指南"><a href="#用户指南" class="headerlink" title="用户指南"></a>用户指南</h3><ul><li><a href="https://runnerliu.github.io/2018/06/10/tornado502-introduction/">介绍</a></li><li><a href="https://runnerliu.github.io/2018/06/10/tornado502-asnon/#more">异步和非阻塞I/O</a><ul><li><a href="https://runnerliu.github.io/2018/06/10/tornado502-asnon/#more">阻塞</a></li><li><a href="https://runnerliu.github.io/2018/06/10/tornado502-asnon/#more">异步</a></li><li><a href="https://runnerliu.github.io/2018/06/10/tornado502-asnon/#more">例子</a></li></ul></li><li><a href="https://runnerliu.github.io/2018/06/18/tornado502-coroutines/#more">协程</a><ul><li><a href="https://runnerliu.github.io/2018/06/18/tornado502-coroutines/#more">Python3.5: async 和 await </a></li><li><a href="https://runnerliu.github.io/2018/06/18/tornado502-coroutines/#more">它如何工作</a></li><li><a href="https://runnerliu.github.io/2018/06/18/tornado502-coroutines/#more">如何调用协程</a></li><li><a href="https://runnerliu.github.io/2018/06/18/tornado502-coroutines/#more">协程模式</a><ul><li><a href>调用阻塞函数</a></li><li><a href>并行</a></li><li><a href>交叉存取</a></li><li><a href>循环</a></li><li><a href>在后台运行</a></li></ul></li></ul></li><li><a href="https://runnerliu.github.io/2018/06/18/tornado502-concurrentwebspider/#more">Queue 示例-一个并发网络爬虫</a></li><li><a href>Tornado Web应用的结构</a><ul><li><a href>Application 对象</a></li><li><a href>RequestHandler 子类</a></li><li><a href>处理输入请求</a></li><li><a href>重写 RequestHandler 方法</a></li><li><a href>错误处理</a></li><li><a href>重定向</a></li><li><a href>异步处理</a></li></ul></li><li><a href>模板和 UI</a><ul><li><a href>配置模板</a></li><li><a href>模板语法</a></li><li><a href>国际化</a></li><li><a href>UI 模块</a></li></ul></li><li><a href>认证和安全</a><ul><li><a href>Cookies 和 secure cookies</a></li><li><a href>用户认证</a></li><li><a href>第三方用户认证</a></li><li><a href>跨站请求伪造(防护)</a></li><li><a href>DNS 重绑定</a></li></ul></li><li><a href>运行和部署</a><ul><li><a href>进程和端口</a></li><li><a href>运行在负载均衡器后面</a></li><li><a href>静态文件和文件缓存</a></li><li><a href>Debug 模式和自动重载</a></li><li><a href>WSGI 和 Google App Engine</a></li></ul></li></ul><p>Read More:</p><blockquote><p><a href="http://www.tornadoweb.org/en/stable/guide.html" target="_blank" rel="noopener">User’s guide</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;用户指南&quot;&gt;&lt;a href=&quot;#用户指南&quot; class=&quot;headerlink&quot; title=&quot;用户指南&quot;&gt;&lt;/a&gt;用户指南&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://runnerliu.github.io/2018/06/10/tornado5
      
    
    </summary>
    
      <category term="Tornado" scheme="http://runnerliu.github.io/categories/Tornado/"/>
    
    
      <category term="Tornado" scheme="http://runnerliu.github.io/tags/Tornado/"/>
    
      <category term="翻译文档" scheme="http://runnerliu.github.io/tags/%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3/"/>
    
      <category term="用户指南" scheme="http://runnerliu.github.io/tags/%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97/"/>
    
  </entry>
  
  <entry>
    <title>Tornado5.0.2翻译文档 - Tornado</title>
    <link href="http://runnerliu.github.io/2018/06/03/tornado502_start/"/>
    <id>http://runnerliu.github.io/2018/06/03/tornado502_start/</id>
    <published>2018-06-03T09:27:51.000Z</published>
    <updated>2020-11-15T02:24:39.482Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.tornadoweb.org/" target="_blank" rel="noopener">Tornado</a> 是一个 Python 的 Web 框架和异步网络库，最初由 <a href="http://friendfeed.com/" target="_blank" rel="noopener">FriendFeed </a>开发。通过使用非阻塞网络I/O，Tornado 可以支持数以万计的连接，非常适合<a href="http://en.wikipedia.org/wiki/Push_technology#Long_polling" target="_blank" rel="noopener">长轮询</a>、<a href="http://en.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">WebSockets</a> 和其他需要与每个用户建立长连接的应用程序。</p><h3 id="快速链接"><a href="#快速链接" class="headerlink" title="快速链接"></a>快速链接</h3><ul><li>当前版本：5.0.2(<a href="https://pypi.python.org/pypi/tornado" target="_blank" rel="noopener">download from PyPi</a> <a href="http://www.tornadoweb.org/en/stable/releases.html" target="_blank" rel="noopener">release notes</a>)</li><li><a href="https://github.com/tornadoweb/tornado" target="_blank" rel="noopener">源代码</a></li><li>邮件列表：<a href="http://groups.google.com/group/python-tornado" target="_blank" rel="noopener">discussion</a> 和 <a href="http://groups.google.com/group/python-tornado-announce" target="_blank" rel="noopener">announcements</a></li><li><a href="http://stackoverflow.com/questions/tagged/tornado" target="_blank" rel="noopener">Stack Overflow</a></li><li><a href="https://github.com/tornadoweb/tornado/wiki/Links" target="_blank" rel="noopener">Wiki</a></li></ul><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello, World"></a>Hello, World</h3><p>以下是利用 Tornado 实现的一个简单的 “Hello, World” 应用程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import tornado.ioloop</span><br><span class="line">import tornado.web</span><br><span class="line"></span><br><span class="line">class MainHandler(tornado.web.RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        self.write(&quot;Hello, world&quot;)</span><br><span class="line"></span><br><span class="line">def make_app():</span><br><span class="line">    return tornado.web.Application([</span><br><span class="line">        (r&quot;/&quot;, MainHandler),</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app = make_app()</span><br><span class="line">    app.listen(8888)</span><br><span class="line">    tornado.ioloop.IOLoop.current().start()</span><br></pre></td></tr></table></figure><p>以上例子没有使用 Tornado 的任何异步特性，异步特性可以移步 <a href="https://github.com/tornadoweb/tornado/tree/stable/demos/chat" target="_blank" rel="noopener">simple char room</a>。</p><h3 id="线程和-WSGI"><a href="#线程和-WSGI" class="headerlink" title="线程和 WSGI"></a>线程和 WSGI</h3><p>Tornado 与其他大多 Python web 框架不同，它不基于 <a href="https://wsgi.readthedocs.io/en/latest/" target="_blank" rel="noopener">WSGI</a> 且每个进程只能运行一个 Tornado 线程，移步 <a href>用户手册</a> 了解更多 Tornado 的异步编程方式。</p><p>然而 WSGI 支持的一些方法可以在 <a href>tornado.wsgi</a> 模块中找到，但这并不是 Tornado 后续发展的重点，大多数 Tornado 应用应该直接使用其自带的接口（例如 <a href>tornado.web</a>）而不是 WSGI。</p><p>一般来说，Tornado 的应用代码并不是线程安全的，Tornado 中唯一可以安全地从其他线程调用的方法是 <a href>IOLoop.add_callback</a> 。你也可以使用 <a href>IOLoop.run_in_executor</a> 在另一个线程上异步运行阻塞函数，但请注意，传给 <a href>run_in_executor</a> 的函数不能引用任何 Tornado 对象。与阻塞函数进行交互时，推荐使用 <a href>run_in_executor</a> 。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install tornado</span><br></pre></td></tr></table></figure><p>Tornado 在 <a href="http://pypi.python.org/pypi/tornado" target="_blank" rel="noopener">PyPi</a> 可获取安装列表中，所以可以直接使用 <code>pip</code> 方式进行安装。请注意，源代码发行版包含演示应用程序，当以这种方式安装 Tornado 时，这些演示应用程序将不会存在，因此您可能希望下载源代码 tar 包或克隆 <a href="https://github.com/tornadoweb/tornado" target="_blank" rel="noopener">git repository</a>。</p><p><strong>安装条件</strong>：Tornado 运行在 Python 2.7 和 Python 3.4+上。 Python 2.7.9 中需要对 ssl 模块进行更新（在某些发行版中，这些更新可能在较早的 Python 版本中可用）。除了 <code>pip</code> 或 <code>setup.py</code> 自动安装的依赖外，以下可选软件包可能会有用：</p><ul><li><a href="http://pycurl.sourceforge.net/" target="_blank" rel="noopener">pycurl</a> 在 <a href>tornado.curl_httpclient</a> 中需要使用，需要 Libcurl 7.22或更高版本；</li><li><a href="http://www.twistedmatrix.com/" target="_blank" rel="noopener">Twisted</a> 在 <a href>tornado.platform.twisted</a> 的诸多类中会使用到；</li><li><a href="https://pypi.python.org/pypi/pycares" target="_blank" rel="noopener">pycares</a> 是一个可选的非阻塞 DNS 解析器，可以在线程不适用时使用；</li><li><a href="https://pypi.python.org/pypi/monotonic" target="_blank" rel="noopener">monotonic</a> 或 <a href="https://pypi.python.org/pypi/Monotime" target="_blank" rel="noopener">Monotime</a> 添加对单调时钟的支持，从而提高时钟频繁调整场景下的可靠性。 在Python 3中不再需要。</li></ul><p><strong>平台</strong>：尽管为了获得最佳性能和可扩展性，Tornado 应该可以在任何类Unix平台上运行，但对于生产部署，建议只使用Linux（with <code>epoll</code>）和 BSD（with <code>kqueue</code>）（尽管 Mac OS X 源自 BSD 并支持 kqueue，但其网络 性能一般很差，所以建议仅用于开发使用）。Tornado 也可以在 Windows 上运行，这种配置没有官方的支持，只推荐用于开发。 如果不修改 Tornado IOLoop 接口，就不可能添加本地 Tornado Windows IOLoop 实现，且不能利用像 AsyncIO 或 Twisted 等框架的 Windows 的 IOCP 支持。</p><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><ul><li><a href="https://runnerliu.github.io/2018/06/10/tornado502-userguide/#more">用户指南</a><ul><li><a href="https://runnerliu.github.io/2018/06/10/tornado502-introduction/">介绍</a></li><li><a href="https://runnerliu.github.io/2018/06/10/tornado502-asnon/#more">异步和非阻塞 I/O</a></li><li><a href="https://runnerliu.github.io/2018/06/18/tornado502-coroutines/#more">协程</a></li><li><a href="https://runnerliu.github.io/2018/06/18/tornado502-concurrentwebspider/#more">Queue 示例-一个并发网络爬虫</a></li><li><a href>Tornado 的 web 应用程序结构</a></li><li><a href>模板和UI</a></li><li><a href>认证和安全</a></li><li><a href>运行和部署</a></li></ul></li><li><a href>Web 框架</a><ul><li><a href>tornado.web - RequestHandler Application 类</a></li><li><a href>tornado.template - 灵活的输出生成</a></li><li><a href>tornado.routing - 基本的路由实现</a></li><li><a href>tornado.escape - 转义和字符串操作</a></li><li><a href>tornado.locale - 国际化支持</a></li><li><a href>tornado.websocket - 与浏览器的双向通信</a></li></ul></li><li><a href>HTTP 服务器和客户端</a><ul><li><a href>tornado.httpserver - 非阻塞 HTTP 服务器</a></li><li><a href>tornado.httpclient - 异步 HTTP 客户端</a></li><li><a href>tornado.httputil - 操作HTTP标头和URL</a></li><li><a href>tornado.httpconnection - HTTP/1.x客户端/服务器实现</a></li></ul></li><li><a href>异步网络</a><ul><li><a href>tornado.ioloop - 主时间循环</a></li><li><a href>tornado.iostream - 对非阻塞 socket 的简易包装</a></li><li><a href>tronado.netutil - 网络实用程序</a></li><li><a href>tornado.tcpclient - IOStream 连接工厂</a></li><li><a href>tornado.tcpserver - 基于 TCP 服务器的 IOStream</a></li></ul></li><li><a href>协程和并发</a><ul><li><a href>tornado.gen - 基于生成器的协程</a></li><li><a href>tornado.locks - 同步原语</a></li><li><a href>tornado.queues - 协程队列</a></li><li><a href>tornado.process - 多进程的实用程序</a></li></ul></li><li><a href>与其他服务集成</a><ul><li><a href>tornado.auth - 集成 OpenID 和 OAuth 的第三方登录服务</a></li><li><a href>tornado.wsgi - 与其他 Python 框架和服务器的互操作性</a></li><li><a href>tornado.platform.caresresolver - 使用 C-Ares 的异步DNS解析器</a></li><li><a href>tornado.platform.twisted - 兼容 Tornado 和 Twisted</a></li><li><a href>tornado.asyncio - 兼容 Tornado 和 asyncio</a></li></ul></li><li><a href>通用工具</a><ul><li><a href>tornado.authoreload - 开发环境中自动检测代码变化</a></li><li><a href>tornado.concrrent - 与 Future 对象交互</a></li><li><a href>tornado.log - 日志支持</a></li><li><a href>tornado.options - 命令行解析</a></li><li><a href>tornado.stack_context - 异步回调异常处理</a></li><li><a href>tornado.testing - 异步代码的单元测试</a></li><li><a href>tornado.util - 通用程序</a></li></ul></li></ul><h3 id="讨论和支持"><a href="#讨论和支持" class="headerlink" title="讨论和支持"></a>讨论和支持</h3><p>你可以在 <a href="http://groups.google.com/group/python-tornado" target="_blank" rel="noopener">the Tornado developer mailing list</a> 参与 Tornado 的讨论，在 <a href="https://github.com/tornadoweb/tornado/issues" target="_blank" rel="noopener">GitHub issue tracker</a> 上提交你的bug，更多资源可以在 <a href="https://github.com/tornadoweb/tornado/wiki/Links" target="_blank" rel="noopener">Tornado wiki</a> 找到，新版本发布在 <a href="http://groups.google.com/group/python-tornado-announce" target="_blank" rel="noopener">announcements mailing list</a>。</p><p>Read More:</p><blockquote><p><a href="http://www.tornadoweb.org/en/stable/index.html" target="_blank" rel="noopener">Tornado</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.tornadoweb.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tornado&lt;/a&gt; 是一个 Python 的 Web 框架和异步网络库，最初由 &lt;a href=&quot;http://friendfeed.
      
    
    </summary>
    
      <category term="Tornado" scheme="http://runnerliu.github.io/categories/Tornado/"/>
    
    
      <category term="Tornado" scheme="http://runnerliu.github.io/tags/Tornado/"/>
    
      <category term="翻译文档" scheme="http://runnerliu.github.io/tags/%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>Datatables使用系列-基础配置</title>
    <link href="http://runnerliu.github.io/2018/05/27/datatables1/"/>
    <id>http://runnerliu.github.io/2018/05/27/datatables1/</id>
    <published>2018-05-27T08:48:21.000Z</published>
    <updated>2020-11-15T02:24:39.465Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://datatables.net/" target="_blank" rel="noopener">Datatables</a> 为是 <a href="https://jquery.com/" target="_blank" rel="noopener">JQuery</a> 的一款表格插件库，是一个高度灵活的工具，可以将任何 HTML 表格添加高级的交互功能。特别是后台开发者，对前端相关框架或知识并不是很熟悉，在做一些内部使用的工具时，总会涉及到页面展示的功能，<a href="http://www.bootcss.com/p/buttons/" target="_blank" rel="noopener">Buttons</a> 同样是一个高度可定制的、免费并且开源的按钮 CSS 样式库。类似插件对于后台开发者来说，简直是福音。本文主要介绍 <a href="https://datatables.net/" target="_blank" rel="noopener">Datatables</a> 的基本配置和使用。</p><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>从 <a href="https://datatables.net/download/" target="_blank" rel="noopener">Download</a> 页面可下载需要使用的 JS 文件和其他的插件，可以根据需求选择不同的样式、包文件和扩展文件，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Step 1. Choose a styling framework</span><br><span class="line">    Bootstrap 4</span><br><span class="line">Step 2. Select packages</span><br><span class="line">    jQuery 3</span><br><span class="line">    Bootstrap 4</span><br><span class="line">    DataTables</span><br><span class="line">Extensions</span><br><span class="line">    可选</span><br><span class="line">Step 3. Pick a download method</span><br><span class="line">    Minify</span><br><span class="line">    Concatenate</span><br><span class="line">    下载方式常用是CDN和本地文件方式（推荐）</span><br></pre></td></tr></table></figure><p>然后我们下载打包好的文件到本地就可以了。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>将文件打包下载后，因为一般页面都是在 web 应用中使用，所以笔者创建了一个简单的 <a href="http://www.tornadoweb.org/en/stable/" target="_blank" rel="noopener">Tornado</a> 应用，将所有的静态文件放到了 <code>/static</code> 目录下：</p><p> <img src="/images/2018-05-27T222132.png" alt="2018-05-27T222132"></p><p><strong>注意：</strong> <code>jquery.js</code> 文件是必需的，目前使用 <code>3.0</code> 版本。</p><p>然后我们可以创建一个简单的 HTML 静态页面，引入基本的 <code>js</code>  文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Datatables&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;static/js/Bootstrap-4-4.0.0/css/bootstrap.css&quot;/&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;static/js/DataTables-1.10.16/css/dataTables.bootstrap4.css&quot;/&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;static/css/datatables.min.css&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src=&quot;static/js/jquery.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;static/js/Bootstrap-4-4.0.0/js/bootstrap.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;static/js/DataTables-1.10.16/js/jquery.dataTables.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;static/js/DataTables-1.10.16/js/dataTables.bootstrap4.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 如果在调试过程中，出现表格显示错误，请检查 <code>css</code> 文件和 <code>js</code>  文件的引用顺序。</p><p>接下来创建一个 <code>div</code> 作为表格区域：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;table id=&quot;test_dt&quot; class=&quot;table table-striped table-bordered&quot; cellspacing=&quot;0&quot; style=&quot;width: 100%&quot;&gt;</span><br><span class="line">        &lt;thead&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;id&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;username&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;sex&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;address&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;age&lt;/th&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;/thead&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><code>table</code> 中的 <code>class</code> 属性都是在 <code>css</code> 文件中定义好的，直接引用即可。</p><p>然后就是通过 <code>js</code> 为 <code>test_dt</code> 表格填充数据，数据源一般 <a href="https://datatables.net/examples/data_sources/" target="_blank" rel="noopener">Data sources</a> 这些，我们在 <code>web</code> 应用中使用最多的就是 <a href="https://datatables.net/examples/ajax/" target="_blank" rel="noopener">Ajax</a> 方式了，可以局部刷新页面。</p><p>本文数据源方式使用 <a href="https://datatables.net/examples/ajax/objects.html" target="_blank" rel="noopener">Ajax data source (objects)</a> 这种方式，<code>js</code> 代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">function init_table()&#123;</span><br><span class="line">    $(&apos;#test_dt&apos;).DataTable(&#123;</span><br><span class="line">        order: [[ 0, &quot;desc&quot;]],</span><br><span class="line">        searching: true,</span><br><span class="line">        stateSave: true,</span><br><span class="line">        paging: true,</span><br><span class="line">        pagingType: &apos;full_numbers&apos;,</span><br><span class="line">        autoWidth: true,</span><br><span class="line">        responsive: false,</span><br><span class="line">        pageLength: 10,</span><br><span class="line">        destroy: true,</span><br><span class="line">        ajax: &#123;</span><br><span class="line">            &apos;url&apos;: &apos;/index&apos;,</span><br><span class="line">            &apos;dataSrc&apos;: handle_data_src,</span><br><span class="line">            &apos;type&apos;: &apos;POST&apos;,</span><br><span class="line">            &apos;async&apos;: false,</span><br><span class="line">            &apos;data&apos;: &#123;&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        columns:[</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;data&quot;:&quot;id&quot;,</span><br><span class="line">                &quot;width&quot;: &quot;10%&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;data&quot;:&quot;username&quot;,</span><br><span class="line">                &quot;width&quot;: &quot;10%&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;data&quot;:&quot;sex&quot;,</span><br><span class="line">                &quot;width&quot;: &quot;10%&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;data&quot;:&quot;address&quot;,</span><br><span class="line">                &quot;width&quot;: &quot;10%&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;data&quot;:&quot;age&quot;,</span><br><span class="line">                &quot;width&quot;: &quot;10%&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>POST</code> 方式获取表格数据，方便表格的刷新操作。其中 <code>dataSrc</code> 参数可以对请求的数据在显示到表格前做其他处理。</p><p>效果图基本如下：</p><p><img src="/images/2018-05-27T223227.png" alt="2018-05-27T223227"></p><h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><p>Datatables 支持参数配置方式以提供各种场景下对表格的需求，目前笔者主要使用的参数如下：</p><table><thead><tr><th>参数</th><th>含义</th><th>可选值</th></tr></thead><tbody><tr><td>order</td><td>表格在初始化的时候的排序</td><td><a href="https://datatables.net/reference/option/order" target="_blank" rel="noopener">order</a></td></tr><tr><td>searching</td><td>允许表格搜索</td><td>true false</td></tr><tr><td>stateSave</td><td>允许浏览器缓存 Datatables，以便下次恢复之前的状态</td><td>true false</td></tr><tr><td>paging</td><td>允许表格分页</td><td>true false</td></tr><tr><td>pagingType</td><td>分页按钮显示选项</td><td><a href="http://www.datatables.club/reference/option/pagingType.html" target="_blank" rel="noopener">pagingType</a></td></tr><tr><td>autoWidth</td><td>定义是否由控件自动控制列宽</td><td>true false</td></tr><tr><td>pageLength</td><td>单页显示的数据条数</td><td>integer</td></tr><tr><td>destroy</td><td>销毁已经存在的 Datatables 实例并替换新的选项</td><td>true false</td></tr><tr><td>ajax</td><td>异步获取数据填充到表格显示</td><td><a href="http://www.datatables.club/reference/option/ajax.html" target="_blank" rel="noopener">ajax</a></td></tr><tr><td>columns</td><td>设定列的所有初始属性</td><td><a href="http://www.datatables.club/reference/option/columns.html" target="_blank" rel="noopener">columns</a></td></tr><tr><td>info</td><td>控制总数信息（标准界面右下角显示总数和过滤条数的控件）的显隐</td><td>true false</td></tr></tbody></table><p>其他参数设置可参考 <a href="https://datatables.net/manual/options" target="_blank" rel="noopener">Options</a> 。</p><h3 id="Tips-持续更新"><a href="#Tips-持续更新" class="headerlink" title="Tips[持续更新]"></a>Tips[持续更新]</h3><p><strong>ajax.reload()</strong></p><p>场景：间隔一定时间进行局部刷新。</p><p>该场景下如果每次都初始化 datatables ，则会使表格在刷新时失去鼠标控制，用户体验较差。使用 <code>ajax.reload(callback, resetPaging)</code> 方式可以在重复初始化 <code>datatables</code> 下重新加载数据，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#test_dt&apos;).DataTable().ajax.reload(null, false);</span><br></pre></td></tr></table></figure><p>当使用该方式时，如果 <code>ajax</code> 提交的请求 <code>data</code> 字段带的参数值需要动态更新的话，可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&apos;data&apos;: function(d)&#123;</span><br><span class="line">    d.test_name = test_name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>js</code> 函数动态更新参数值，这样在 <code>reload</code> 表格时，提交的参数就是动态获取的了。</p><p><strong>render</strong></p><p>场景：获取数据后，需要根据某列值对数据进行预处理。</p><p>我们可以在 <code>dataSrc</code> 中对数据进行处理，但是 <code>Datatables</code> 提供了另外一种更加方便的处理方式，即 <a href="https://datatables.net/reference/option/columns.render" target="_blank" rel="noopener">columns.render</a> 方法，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;:&quot;address&quot;,</span><br><span class="line">    render: function (data, type, row, meta) &#123;</span><br><span class="line">        var node = &quot;&lt;span &quot;;</span><br><span class="line">        if (data &lt;= bw_warn) &#123;</span><br><span class="line">            node += &quot;style=&apos;color:red;font-weight: bold;&apos;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        node += &quot;&gt;&quot; + data + &quot;&lt;/span&gt;&quot;</span><br><span class="line">        return node;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;width&quot;: &quot;10%&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>可以根据列值，对该列的显示添加其他的 <code>css</code> 属性。</p><p><strong>自定义排序</strong></p><p>Datatables 可以根据指定的列进行排序，但是实际场景中某列值可能较为复杂，而我们只需使用其中的一部分进行排序，例如：去掉前缀。Datatables 的扩展插件提供了很多较为强大的<a href="https://datatables.net/plug-ins/sorting/" target="_blank" rel="noopener">自定义排序功能</a>。</p><p>例如：去掉前缀字符 <code>prefix</code> ，将剩下字符作为整型排序，可以参考 <a href="https://datatables.net/plug-ins/sorting/anti-the" target="_blank" rel="noopener">Anti-the</a>。</p><p>首先新建一个名为 jquery.datatable.sort.plugin.js 文件，将以下 copy 到文件中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend( jQuery.fn.dataTableExt.oSort, &#123;</span><br><span class="line">    &quot;anti-prefix-pre&quot;: function ( a ) &#123;</span><br><span class="line">        var x = a.replace(/^prefix /i, &quot;&quot;);</span><br><span class="line">        return parseInt(x);</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    &quot;anti-prefix-asc&quot;: function ( a, b ) &#123;</span><br><span class="line">        return ((a &lt; b) ? -1 : ((a &gt; b) ? 1 : 0));</span><br><span class="line">    &#125;,</span><br><span class="line"> </span><br><span class="line">    &quot;anti-prefix-desc&quot;: function ( a, b ) &#123;</span><br><span class="line">        return ((a &lt; b) ? 1 : ((a &gt; b) ? -1 : 0));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><p>然后在页面中按照如下方式引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/path/jquery.datatable.sort.plugin.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>最后在 Datatables 中加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">columnDefs: [</span><br><span class="line">    &#123; type: &apos;anti-prefix&apos;, targets: 0 &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>其中：targets 表示列编号，从0开始。</p><p>Example：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#example&apos;).dataTable( &#123;</span><br><span class="line">    columnDefs: [</span><br><span class="line">        &#123; type: &apos;anti-the&apos;, targets: 0 &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><p>Read More:</p><blockquote><p><a href="https://datatables.net/" target="_blank" rel="noopener">Datatables</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://datatables.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Datatables&lt;/a&gt; 为是 &lt;a href=&quot;https://jquery.com/&quot; target=&quot;_blank&quot; rel=&quot;noo
      
    
    </summary>
    
      <category term="前端" scheme="http://runnerliu.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="datatables" scheme="http://runnerliu.github.io/tags/datatables/"/>
    
      <category term="jquery" scheme="http://runnerliu.github.io/tags/jquery/"/>
    
      <category term="前端" scheme="http://runnerliu.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>SQLAlchemy bug系列(一)</title>
    <link href="http://runnerliu.github.io/2018/05/13/sqlalchemybug1/"/>
    <id>http://runnerliu.github.io/2018/05/13/sqlalchemybug1/</id>
    <published>2018-05-13T07:13:50.000Z</published>
    <updated>2020-11-15T02:24:39.480Z</updated>
    
    <content type="html"><![CDATA[<p>项目框架采用 Tornado ，SQLAlchemy 作为数据库ORM，简陋的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def query(self, filters, orders=&apos;&apos;):</span><br><span class="line">    try:</span><br><span class="line">        if not isinstance(filters, str) or not isinstance(orders, str):</span><br><span class="line">            return False</span><br><span class="line">        if not len(orders):</span><br><span class="line">            return self.s.query(Node).filter(filters).first()</span><br><span class="line">        else:</span><br><span class="line">            r = self.s.query(Node).filter(filters).order_by(orders).all()</span><br><span class="line">            if len(r):</span><br><span class="line">                return r[0]</span><br><span class="line">            return None</span><br><span class="line">    except Exception as e:</span><br><span class="line">        self.logger.error(traceback.format_exc())</span><br><span class="line">        return None</span><br><span class="line">    finally:</span><br><span class="line">        Session.remove()</span><br></pre></td></tr></table></figure><p>但是在跑了一段时间后出现了如下问题：</p><blockquote><p>(sqlalchemy.exc.InvalidRequestError) Can’t reconnect until invalid transaction is rolled back</p></blockquote><p>错误中很明显是数据库的连接由于事务某些错误出现了问题，SQLAlchemy 在尝试重新连接时失败了。</p><p>几经翻找资料后，问题产生原因如下：</p><p>从数据库连接池（pool）中获取的 <code>connection</code> 没有以 <code>session.commit()</code> 或 <code>session.rollback()</code> 或 <code>session.close()</code> 的某一种放回 pool 中。这时 <code>connection</code> 的事务（<code>transaction</code> ）没有完结，而在后续与数据库交互中，由于某些原因（如死锁、超时）数据库连接池中的 <code>connection</code> 又死掉了，当获取到这个连接时，SQLAlchemy 尝试重新连接。但由于 <code>transaction</code> 还没完结，无法重连。就抛出了上述错误。</p><p>解决办法：</p><ol><li><p>显示调用事务结束</p><p>使用 <code>try...except...</code> 代码块，<code>except</code> 中捕获到异常时，调用 <code>session.rollback()</code> 回滚事务。</p></li><li><p>打开 <code>autocommit</code></p><p>使用 SQLAlchemy 的初始化方式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Base = declarative_base()</span><br><span class="line">engine = create_engine(</span><br><span class="line">    &quot;mysql+pymysql://&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;/&#123;&#125;&quot;.format(</span><br><span class="line">        mysql_config[&apos;default&apos;][&apos;user&apos;],</span><br><span class="line">        mysql_config[&apos;default&apos;][&apos;password&apos;],</span><br><span class="line">        mysql_config[&apos;default&apos;][&apos;host&apos;],</span><br><span class="line">        mysql_config[&apos;default&apos;][&apos;port&apos;],</span><br><span class="line">        mysql_config[&apos;default&apos;][&apos;name&apos;],</span><br><span class="line">    ),</span><br><span class="line">    encoding=&quot;utf-8&quot;,</span><br><span class="line">    echo=False,</span><br><span class="line">    pool_recycle=mysql_config[&apos;connect_pool&apos;][&apos;pool_recycle&apos;],</span><br><span class="line">    pool_size=mysql_config[&apos;connect_pool&apos;][&apos;pool_size&apos;]</span><br><span class="line">)</span><br><span class="line">Session = scoped_session(sessionmaker(bind=engine))</span><br></pre></td></tr></table></figure><p>默认是使用事务操作，我们可以在初始化语句中加上 <code>autocommit=true</code> 关闭事务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">engine = create_engine(</span><br><span class="line">    &quot;mysql+pymysql://&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;/&#123;&#125;?autocommit=true&quot;.format(</span><br><span class="line">        mysql_config[&apos;default&apos;][&apos;user&apos;],</span><br><span class="line">        mysql_config[&apos;default&apos;][&apos;password&apos;],</span><br><span class="line">        mysql_config[&apos;default&apos;][&apos;host&apos;],</span><br><span class="line">        mysql_config[&apos;default&apos;][&apos;port&apos;],</span><br><span class="line">        mysql_config[&apos;default&apos;][&apos;name&apos;],</span><br><span class="line">    ),</span><br><span class="line">    encoding=&quot;utf-8&quot;,</span><br><span class="line">    echo=False,</span><br><span class="line">    pool_recycle=mysql_config[&apos;connect_pool&apos;][&apos;pool_recycle&apos;],</span><br><span class="line">    pool_size=mysql_config[&apos;connect_pool&apos;][&apos;pool_size&apos;]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这样生成的查询语句就会立即执行。<strong>注意：</strong>个人感觉这并不是一个好方法，还是老老实实捕获异常吧。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;项目框架采用 Tornado ，SQLAlchemy 作为数据库ORM，简陋的代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;
      
    
    </summary>
    
      <category term="SQLAlchemy" scheme="http://runnerliu.github.io/categories/SQLAlchemy/"/>
    
    
      <category term="SQLAlchemy" scheme="http://runnerliu.github.io/tags/SQLAlchemy/"/>
    
      <category term="bug" scheme="http://runnerliu.github.io/tags/bug/"/>
    
  </entry>
  
  <entry>
    <title>HTTP POST提交数据分常见方式</title>
    <link href="http://runnerliu.github.io/2018/05/13/httppostmethod/"/>
    <id>http://runnerliu.github.io/2018/05/13/httppostmethod/</id>
    <published>2018-05-13T06:17:00.000Z</published>
    <updated>2020-11-15T02:24:39.467Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.ietf.org/rfc/rfc2616.txt" target="_blank" rel="noopener">HTTP/1.1协议</a> 规定的 HTTP 请求方法有 OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT这几种。其中 POST 一般用来向服务端提交数据，我们在写类似接口文档这种被业务方调用的服务时，涉及到 POST 的默认提交方式基本都是：<code>application/x-www-form-urlencoded</code> 。本 文主要讨论 POST 提交数据的几种方式。</p><p>我们知道，HTTP 协议是以 <strong>ASCII</strong> 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。类似于下面这样：</p><blockquote><p><method> <request-url> <version></version></request-url></method></p><headers><p><entity-body></entity-body></p></headers></blockquote><p>协议规定 POST 提交的数据必须放在消息主体（<code>entity-body</code>）中，但协议并没有规定数据必须使用什么编码方式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。</p><p>但是，数据发送出去，还要服务端解析成功才有意义。一般服务端语言如 java php python 等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 <code>Content-Type</code>字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 POST 提交数据方案，包含了 <code>Content-Type</code> 和消息主体编码方式两部分。下面进入正题。</p><h3 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application/x-www-form-urlencoded"></a>application/x-www-form-urlencoded</h3><p>这种方式是最常见的 POST 提交数据的方式。浏览器的原生 <code>&lt;form&gt;</code> 表单，如果不设置 <code>enctype</code> 属性，那么最终就会以 <code>application/x-www-form-urlencoded</code> 方式提交数据。请求类似于下面这样（无关的请求头在本文中都省略掉了）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST http://www.example.com HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded;charset=utf-8</span><br><span class="line">title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3</span><br></pre></td></tr></table></figure><p>首先，Content-Type 被指定为 <code>application/x-www-form-urlencoded</code> ；其次，提交的数据按照 <code>key1=val1&amp;key2=val2</code> 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。</p><p>通常，我们用 Ajax 提交数据时，也是使用这种方式。例如 <a href="http://jquery.com/" target="_blank" rel="noopener">JQuery</a> 和 <a href="http://www.qwrap.com/" target="_blank" rel="noopener">QWrap</a> 的 Ajax，<code>Content-Type</code> 默认值都是 <code>application/x-www-form-urlencoded;charset=utf-8</code> 。</p><h3 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a>multipart/form-data</h3><p>在使用表单上传文件时，必须让 <code>&lt;form&gt;</code> 表单的 <code>enctype</code> 等于 <code>multipart/form-data</code>。直接来看一个请求示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST http://www.example.com HTTP/1.1</span><br><span class="line">Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line">Content-Disposition: form-data; name=&quot;text&quot;</span><br><span class="line"></span><br><span class="line">title</span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;</span><br><span class="line">Content-Type: image/png</span><br><span class="line"></span><br><span class="line">PNG ... content of chrome.png ...</span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA--</span><br></pre></td></tr></table></figure><p>这个例子稍微复杂点。首先生成了一个 <code>boundary</code> 用于分割不同的字段，为了避免与正文内容重复，<code>boundary</code> 很长很复杂。然后 <code>Content-Type</code> 里指明了数据是以 <code>multipart/form-data</code> 来编码，本次请求的 <code>boundary</code> 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 <code>--boundary</code> 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 <code>--boundary--</code> 标示结束。关于 <code>multipart/form-data</code> 的详细定义，请前往 <a href="http://www.ietf.org/rfc/rfc1867.txt" target="_blank" rel="noopener">rfc1867</a> 查看。这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。</p><p>以上提到的两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 \&lt;form> 表单也 <a href="http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4" target="_blank" rel="noopener">只支持这两种方式</a>（通过 <code>&lt;form&gt;</code> 元素的 <code>enctype</code> 属性指定，默认为 <code>application/x-www-form-urlencoded</code>。其实 <code>enctype</code> 还支持 <code>text/plain</code>，不过用得非常少）。</p><p>随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，给开发带来更多便利。</p><h3 id="application-json"><a href="#application-json" class="headerlink" title="application/json"></a>application/json</h3><p><code>application/json</code> 这个 <code>Content-Type</code> 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。JSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用。</p><p>Google 的 <a href="http://angularjs.org/" target="_blank" rel="noopener">AngularJS</a> 中的 Ajax 功能，默认就是提交 JSON 字符串。例如下面这段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var data = &#123;&apos;title&apos;:&apos;test&apos;, &apos;sub&apos; : [1,2,3]&#125;;</span><br><span class="line">$http.post(url, data).success(function(result) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最终发送的请求是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST http://www.example.com HTTP/1.1 </span><br><span class="line">Content-Type: application/json;charset=utf-8</span><br><span class="line"></span><br><span class="line">&#123;&quot;title&quot;:&quot;test&quot;,&quot;sub&quot;:[1,2,3]&#125;</span><br></pre></td></tr></table></figure><p>这种方案，可以方便的提交复杂的结构化数据，特别适合 RESTful 的接口。各大抓包工具如 Chrome 自带的开发者工具、Firebug、Fiddler，都会以树形结构展示 JSON 数据，非常友好。但也有些服务端语言还没有支持这种方式，例如 php 就无法通过 $_POST 对象从上面的请求中获得内容。这时候，需要自己动手处理下：在请求头中 <code>Content-Type</code> 为 <code>application/json</code> 时，从 <code>php://input</code> 里获得原始输入流，再 <code>json_decode</code> 成对象。一些 php 框架已经开始这么做了。</p><p>当然 AngularJS 也可以配置为使用 <code>x-www-form-urlencoded</code> 方式提交数据。如有需要，可以参考 <a href="http://victorblog.com/2012/12/20/make-angularjs-http-service-behave-like-jquery-ajax/" target="_blank" rel="noopener">这里</a>。</p><h3 id="text-xml"><a href="#text-xml" class="headerlink" title="text/xml"></a>text/xml</h3><p>这种方式目前几乎很少在用，因为 JSON 方式更加灵活方便，而 xml 方式显得比较臃肿和繁琐。<code>XML-RPC（XML Remote Procedure Call）</code> 协议是一套允许运行在不同操作系统、不同环境的程序实现基于 Internet 过程调用的规范和一系列的实现。这种远程过程调用使用 HTTP 作为传输协议，XML 作为传送信息的编码格式。</p><p>典型的 <code>XML-RPC</code> 请求是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST http://www.example.com HTTP/1.1 </span><br><span class="line">Content-Type: text/xml</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;methodCall&gt;</span><br><span class="line">    &lt;methodName&gt;examples.getStateName&lt;/methodName&gt;</span><br><span class="line">    &lt;params&gt;</span><br><span class="line">        &lt;param&gt;</span><br><span class="line">            &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt;</span><br><span class="line">        &lt;/param&gt;</span><br><span class="line">    &lt;/params&gt;</span><br><span class="line">&lt;/methodCall&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2616.txt&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HTTP/1.1协议&lt;/a&gt; 规定的 HTTP 请求方法有 OPTIONS、GET、HEAD、POST、PUT、DELE
      
    
    </summary>
    
      <category term="HTTP" scheme="http://runnerliu.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://runnerliu.github.io/tags/HTTP/"/>
    
      <category term="POST" scheme="http://runnerliu.github.io/tags/POST/"/>
    
  </entry>
  
  <entry>
    <title>分布式锁</title>
    <link href="http://runnerliu.github.io/2018/05/06/distlock/"/>
    <id>http://runnerliu.github.io/2018/05/06/distlock/</id>
    <published>2018-05-06T05:28:07.000Z</published>
    <updated>2020-11-15T02:24:39.465Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>进入正题之前，先来说说问题的产生背景。目前绝大多数的业务都跑在高并发的情境下，而数据库（大多数是mysql）数据一致性的问题是不可避免的，笔者同样遇到了这种问题：</p><blockquote><p>高并发情境下数据库的数据重复写入问题</p></blockquote><p>数据的重复写入实际上就是对共享资源的竞争操作，导致数据出现不一致，给线上业务带来影响。解决这种问题，最直接的思路是在数据库层面寻求解决方案，借助数据库的锁机制，或者在业务上通过数据库语句的限制避免重复数据，如：</p><ul><li>insert ignore into 语句；</li><li>on duplicate key update 语句；</li><li>insert … select … where not exist 语句；</li><li>replace into 语句。</li></ul><p>以上语句在简单业务中避免mysql插入重复数据是有一定效果的，但是在复杂场景下并不能满足需求。因为高并发业务除了要求数据一致性外，对性能、稳定性的要求也较高，单纯使用数据库语句很难达到预期效果，因此，从单机锁发展而来的分布式锁提供了一种新的解决方案。</p><h3 id="SQL语句解决方案"><a href="#SQL语句解决方案" class="headerlink" title="SQL语句解决方案"></a>SQL语句解决方案</h3><p>insert ignore into</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">INSERT [LOW_PRIORITY | HIGH_PRIORITY] [IGNORE]</span><br><span class="line">    [INTO] tbl_name</span><br><span class="line">    [PARTITION (partition_name [, partition_name] ...)]</span><br><span class="line">    [(col_name [, col_name] ...)]</span><br><span class="line">    SELECT ...</span><br><span class="line">    [ON DUPLICATE KEY UPDATE assignment_list]</span><br><span class="line"></span><br><span class="line">value:</span><br><span class="line">    &#123;expr | DEFAULT&#125;</span><br><span class="line"></span><br><span class="line">assignment:</span><br><span class="line">    col_name = value</span><br><span class="line"></span><br><span class="line">assignment_list:</span><br><span class="line">    assignment [, assignment] ...</span><br></pre></td></tr></table></figure><blockquote><p>Specify <strong>IGNORE</strong> to ignore rows that would cause duplicate-key violations. </p></blockquote><p>通过mysql给出的官方解释：IGNORE 关键字会忽略重复键的行。当插入数据时，如出现错误（重复数据），将不返回错误，只以警告形式返回。所以使用 IGNORE 请确保语句本身没有问题，否则语句的其他错误也会被忽略掉。如果使用 IGNORE 关键字，则插入的字段必须是主键或唯一索引。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show tables;</span><br><span class="line">+----------------------------+</span><br><span class="line">| Tables_in_openlivedb       |</span><br><span class="line">+----------------------------+</span><br><span class="line">| admin                      |</span><br><span class="line">| auth_group                 |</span><br><span class="line">| auth_group_permissions     |</span><br><span class="line">| auth_permission            |</span><br><span class="line">| auth_user                  |</span><br><span class="line">| auth_user_groups           |</span><br><span class="line">| auth_user_user_permissions |</span><br><span class="line">| cmd_template               |</span><br><span class="line">| cutter_node                |</span><br><span class="line">| django_admin_log           |</span><br><span class="line">| django_content_type        |</span><br><span class="line">| django_migrations          |</span><br><span class="line">| django_session             |</span><br><span class="line">| flv_slice                  |</span><br><span class="line">| mp4_slice                  |</span><br><span class="line">| test_table                 |</span><br><span class="line">| ts_slice                   |</span><br><span class="line">+----------------------------+</span><br><span class="line">17 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from admin;</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">| id | username          | password                         |</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">|  1 | liuxiaoyang       | 96e79218965eb72c92a549dd5a330112 |</span><br><span class="line">|  4 | liuxiaoyang_test2 |                                  |</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT IGNORE INTO admin (username) VALUES (&apos;liuxiaoyang_test2&apos;);</span><br><span class="line">Query OK, 0 rows affected, 2 warnings (0.09 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from admin;</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">| id | username          | password                         |</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">|  1 | liuxiaoyang       | 96e79218965eb72c92a549dd5a330112 |</span><br><span class="line">|  4 | liuxiaoyang_test2 |                                  |</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT IGNORE INTO admin (username) VALUES (&apos;liuxiaoyang_test3&apos;);</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.11 sec)</span><br></pre></td></tr></table></figure><p>以上操作可以看出，插入重复数据时，显示 <code>Query OK, 0 rows affected, 2 warnings (0.09 sec)</code> 表明出现了警告，当在业务中直接执行时：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">am = AdminManager()</span><br><span class="line">r = am.execute(&quot;select * from admin&quot;)</span><br><span class="line">for i in r:</span><br><span class="line">    print(i.username)</span><br><span class="line">r2 = am.execute(&quot;INSERT IGNORE INTO admin (username, password) VALUES (&apos;liuxiaoyang_test2&apos;, &apos;123&apos;)&quot;)</span><br></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">liuxiaoyang</span><br><span class="line">liuxiaoyang_test2</span><br><span class="line">/usr/local/lib/python3.5/dist-packages/pymysql/cursors.py:165: Warning: (1062, &quot;Duplicate entry &apos;liuxiaoyang_test2&apos; for key &apos;username_unique&apos;&quot;)</span><br><span class="line">  result = self._query(query)</span><br></pre></td></tr></table></figure><p>同样返回了警告信息。</p><p>on duplicate key update</p><blockquote><p>If you specify an <strong>ON DUPLICATE KEY UPDATE</strong> clause and a row to be inserted would cause a duplicate value in a UNIQUE index or PRIMARY KEY, an UPDATE of the old row occurs.</p></blockquote><p>当遇到重复键时，对旧行执行 UPDATE 语句，否则插入新行。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from admin;</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">| id | username          | password                         |</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">|  1 | liuxiaoyang       | 96e79218965eb72c92a549dd5a330112 |</span><br><span class="line">|  4 | liuxiaoyang_test2 | 123                              |</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">2 rows in set (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT IGNORE INTO admin (username) VALUES (&apos;liuxiaoyang_test2&apos;) ON DUPLICATE KEY UPDATE password=&apos;345&apos;;</span><br><span class="line">Query OK, 2 rows affected, 1 warning (0.09 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from admin;</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">| id | username          | password                         |</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">|  1 | liuxiaoyang       | 96e79218965eb72c92a549dd5a330112 |</span><br><span class="line">|  4 | liuxiaoyang_test2 | 345                              |</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>对于on duplicate key update语句，必需主键或唯一索引。</p><p>insert … select … where not exist</p><p>该方法利用了子查询，写法比较繁琐，性能较差，不推荐使用。</p><p>replace into </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">REPLACE [LOW_PRIORITY | DELAYED]</span><br><span class="line">    [INTO] tbl_name</span><br><span class="line">    [PARTITION (partition_name [, partition_name] ...)]</span><br><span class="line">    [(col_name [, col_name] ...)]</span><br><span class="line">    &#123;VALUES | VALUE&#125; (value_list) [, (value_list)] ...</span><br><span class="line"></span><br><span class="line">value:</span><br><span class="line">    &#123;expr | DEFAULT&#125;</span><br><span class="line"></span><br><span class="line">value_list:</span><br><span class="line">    value [, value] ...</span><br><span class="line"></span><br><span class="line">assignment:</span><br><span class="line">    col_name = value</span><br><span class="line"></span><br><span class="line">assignment_list:</span><br><span class="line">    assignment [, assignment] ...</span><br></pre></td></tr></table></figure><blockquote><p>REPLACE works exactly like INSERT, except that if an old row in the table has the same value as a new row for a PRIMARY KEY or a UNIQUE index, the old row is deleted before the new row is inserted. </p></blockquote><p>replace into 语句与insert语句类似，只不过它在插入时，如果存在主键或唯一键相同的记录，则会先删除，然后再插入新记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from admin;</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">| id | username          | password                         |</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">|  1 | liuxiaoyang       | 96e79218965eb72c92a549dd5a330112 |</span><br><span class="line">|  5 | liuxiaoyang_test2 | 789                              |</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; replace into admin(username, password) values(&apos;liuxiaoyang_test2&apos;, &apos;1111&apos;);</span><br><span class="line">Query OK, 2 rows affected (0.10 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from admin;</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">| id | username          | password                         |</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">|  1 | liuxiaoyang       | 96e79218965eb72c92a549dd5a330112 |</span><br><span class="line">|  6 | liuxiaoyang_test2 | 1111                             |</span><br><span class="line">+----+-------------------+----------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><blockquote><p>MySQL uses the following algorithm for REPLACE:</p><ol><li>try to insert the new row into the table        </li><li>While the insertion fails because a duplicate-key error occurs for a primary key or unique index:<ul><li>Delete from the table the conflicting row that has the duplicate key value;</li><li>try again to insert the new row into the table.</li></ul></li></ol></blockquote><p>以上方法也会有些限制，如目前大多数业务的删除只是逻辑删除，并不做物理删除，在这种场景下就需要寻找其他方案。除了以上方法，mysql还提供了共享锁、排他锁等机制，mysql的锁机制会单独进行介绍，在此就不赘述。</p><h3 id="分布式锁解决方案"><a href="#分布式锁解决方案" class="headerlink" title="分布式锁解决方案"></a>分布式锁解决方案</h3><h4 id="何为锁"><a href="#何为锁" class="headerlink" title="何为锁"></a>何为锁</h4><p>在单进程的系统中，当存在多个线程可以同时改变某个变量（可变共享变量）时，就需要对变量或代码块做同步，使其在修改这种变量时能够线性执行消除并发修改变量；</p><p>而同步的本质是通过锁来实现的。为了实现多个线程在一个时刻同一个代码块只能有一个线程可执行，那么需要在某个地方做个标记，这个标记必须每个线程都能看到，当标记不存在时可以设置该标记，其余后续线程发现已经有标记了则等待拥有标记的线程结束同步代码块取消标记后再去尝试设置标记。这个标记可以理解为锁，不同地方实现锁的方式也不一样，只要能满足所有线程都能看得到标记即可；</p><p>除了利用内存数据做锁，其实任何互斥的都能做锁（只考虑互斥情况），如流水表中流水号与时间结合做幂等校验可以看作是一个不会释放的锁，或者使用某个文件是否存在作为锁等。只需要满足在对标记进行修改能保证原子性和内存可见性即可。</p><h4 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式"></a>什么是分布式</h4><p>分布式的 CAP 理论告诉我们：</p><blockquote><p>任何一个分布式系统都无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance），最多只能同时满足两项。</p></blockquote><p>目前很多大型网站及应用都是分布式部署的，分布式场景中的数据一致性问题一直是一个比较重要的话题。基于 CAP理论，很多系统在设计之初就要对这三者做出取舍。在互联网领域的绝大多数的场景中，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证最终一致性。</p><p>分布式场景</p><blockquote><p>此处主要指集群模式下，多个相同服务同时运行</p></blockquote><p>在许多的场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如<strong>分布式事务</strong>、<strong>分布式锁</strong>等。很多时候我们需要保证一个方法在同一时间内只能被同一个线程执行。在单机环境中，通过线程安全队列或者其他方式解决，但是在分布式环境下，这并不是一件容易的事儿。</p><ul><li>分布式与单机情况下最大的不同在于其不是多线程而是<strong>多进程</strong>；</li><li>多线程由于可以共享堆内存，因此可以简单的采取内存作为标记存储位置。而进程之间甚至可能都不在同一台物理机上，因此需要将标记存储在一个所有进程都能看到的地方。</li></ul><p>分布式锁</p><ul><li>当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数；</li><li>与单机模式下的锁不仅需要保证进程可见，还需要考虑进程与锁之间的网络问题；</li><li>分布式锁还是可以将标记存在内存，只是该内存不是某个进程分配的内存而是公共内存如 Redis、Memcache。至于利用数据库、文件等做锁与单机的实现是一样的，只要保证标记能互斥就行。</li></ul><h4 id="我们需要怎样的分布式锁"><a href="#我们需要怎样的分布式锁" class="headerlink" title="我们需要怎样的分布式锁"></a>我们需要怎样的分布式锁</h4><ul><li>在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行； </li><li>高可用的获取锁与释放锁； </li><li>高性能的获取锁与释放锁； </li><li>具备可重入特性； </li><li>具备锁失效机制，防止死锁； </li><li>具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。</li></ul><h4 id="分布式锁-基于数据库"><a href="#分布式锁-基于数据库" class="headerlink" title="分布式锁-基于数据库"></a>分布式锁-基于数据库</h4><p>乐观锁 - 基于表主键唯一做分布式锁</p><p>利用主键唯一的特性，如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，当方法执行完毕之后，想要释放锁的话，删除这条数据库记录即可。</p><p>这种简单的实现有以下几个问题：</p><ul><li>这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用；</li><li>这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁；</li><li>这把锁只能是非阻塞的，因为数据的 insert 操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作；</li><li>这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了；</li><li>这把锁是非公平锁，所有等待锁的线程凭运气去争夺锁；</li><li>在 mysql 数据库中采用主键冲突防重，在大并发情况下有可能会造成锁表现象。</li></ul><p>当然，我们也可以有其他方式解决上面的问题。</p><ul><li>数据库是单点？搞两个数据库，数据之前双向同步，一旦挂掉快速切换到备库上；</li><li>没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍；</li><li>非阻塞的？搞一个 while 循环，直到 insert 成功再返回成功；</li><li>非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了；</li><li>非公平的？再建一张中间表，将等待锁的线程全记录下来，并根据创建时间排序，只有最先创建的允许获取锁；</li><li>比较好的办法是在程序中生产主键进行防重。</li></ul><p>乐观锁 - 基于表字段版本号做分布式锁</p><p>这个策略源于 mysql 的 mvcc 机制，使用这个策略其实本身没有什么问题，唯一的问题就是对数据表侵入较大，我们要为每个表设计一个版本号字段，然后写一条判断 sql 每次进行判断，增加了数据库操作的次数，在高并发的要求下，对数据库连接的开销也是无法忍受的。</p><p>悲观锁 - 基于数据库排他锁做分布式锁</p><p>在查询语句后面增加 <code>for update</code>，数据库会在查询过程中给数据库表增加排他锁 （注意： InnoDB 引擎在加锁的时候，只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。这里我们希望使用行级锁，就要给要执行的方法字段名添加索引，值得注意的是，这个索引一定要创建成唯一索引，否则会出现多个重载方法之间无法同时被访问的问题。重载方法的话建议把参数类型也加上）。当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。</p><p>我们可以认为获得排他锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，通过 <code>connection.commit()</code> 操作来释放锁。</p><p>这种方法可以有效的解决上面提到的无法释放锁和阻塞锁的问题。</p><ul><li>阻塞锁？ <code>for update</code>语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功；</li><li>锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉。</li></ul><p>但是还是无法直接解决数据库单点和可重入问题。虽然我们对方法字段名使用了唯一索引，并且显示使用 <code>for update</code>来使用行级锁。但是，MySQL 会对查询进行优化，即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同执行计划的代价来决定的，如果 MySQL 认为全表扫效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。</p><p>还有一个问题，就是我们要使用排他锁来进行分布式锁的 lock，那么一个排他锁长时间不提交，就会占用数据库连接。一旦类似的连接变得多了，就可能把数据库连接池撑爆。</p><h4 id="分布式锁-基于Redis"><a href="#分布式锁-基于Redis" class="headerlink" title="分布式锁-基于Redis"></a>分布式锁-基于Redis</h4><p>Redis分布式锁主要使用其SETNX()、EXPIRE() 方法实现。</p><blockquote><p>SETNX key value : 将 <code>key</code> 的值设为 <code>value</code> ，当且仅当 <code>key</code> 不存在。若给定的 <code>key</code> 已经存在，则 ＳETNX 不做任何动作。SETNX 是『SET if Not eXists』(如果不存在，则 SET)的简写。</p><p>EXPIRE key seconds : 为给定 <code>key</code> 设置生存时间，当 <code>key</code> 过期时(生存时间为 <code>0</code> )，它会被自动删除。</p></blockquote><p>但是从 Redis 2.6.12 版本开始， SET 命令的行为可以通过一系列参数来修改：</p><ul><li><code>EX second</code> ：设置键的过期时间为 <code>second</code> 秒。 <code>SET key value EX second</code> 效果等同于 <code>SETEX key second value</code> 。</li><li><code>PX millisecond</code> ：设置键的过期时间为 <code>millisecond</code> 毫秒。 <code>SET key value PX millisecond</code> 效果等同于 <code>PSETEX key millisecondvalue</code> 。</li><li><code>NX</code> ：只在键不存在时，才对键进行设置操作。 <code>SET key value NX</code> 效果等同于 <code>SETNX key value</code> 。</li><li><code>XX</code> ：只在键已经存在时，才对键进行设置操作。</li></ul><p>所以SETNX()、EXPIRE() 方法被融合进了SET方法，而<a href="http://redisdoc.com/string/set.html" target="_blank" rel="noopener">官网</a> 给出</p><blockquote><p>因为 <a href="http://redisdoc.com/string/set.html#set" target="_blank" rel="noopener">SET</a> 命令可以通过参数来实现和 <a href="http://redisdoc.com/string/setnx.html#setnx" target="_blank" rel="noopener">SETNX</a> 、 <a href="http://redisdoc.com/string/setex.html#setex" target="_blank" rel="noopener">SETEX</a> 和 <a href="http://redisdoc.com/string/psetex.html#psetex" target="_blank" rel="noopener">PSETEX</a> 三个命令的效果，所以将来的 Redis 版本可能会废弃并最终移除<a href="http://redisdoc.com/string/setnx.html#setnx" target="_blank" rel="noopener">SETNX</a> 、 <a href="http://redisdoc.com/string/setex.html#setex" target="_blank" rel="noopener">SETEX</a> 和 <a href="http://redisdoc.com/string/psetex.html#psetex" target="_blank" rel="noopener">PSETEX</a> 这三个命令。</p></blockquote><p>在使用Redis实现分布式锁时，我们可以通过SET来实现。</p><p>设计思路</p><blockquote><p>获取锁：</p><ul><li>调用 set 尝试获取锁，如果设置成功，表示获取到了锁；</li><li>设置失败，<ul><li>等待一定时间后，再次尝试获取锁；</li><li>若已达到最大获取锁时间未获取到锁，获取锁失败。</li></ul></li></ul><p>释放锁：</p><ul><li>确保每个客户端释放的是自己的锁；</li><li>确保释放锁操作的原子性。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import traceback</span><br><span class="line"></span><br><span class="line">from contextlib import contextmanager</span><br><span class="line">from lib.utils import get_logger</span><br><span class="line">from tornado import gen</span><br><span class="line"></span><br><span class="line">DEFAULT_EXPIRES = 3</span><br><span class="line">ACQUIRE_TIMEOUT = 1</span><br><span class="line"></span><br><span class="line">lock_logger = get_logger(&quot;redis_netlock&quot;)</span><br><span class="line"></span><br><span class="line">@contextmanager</span><br><span class="line">def dist_lock(key, client, unique_id acquire_timeout=ACQUIRE_TIMEOUT):</span><br><span class="line">    key = &apos;lock_%s&apos; % key</span><br><span class="line">    try:</span><br><span class="line">        t = _acquire_lock(key, client, unique_id, acquire_timeout)</span><br><span class="line">        yield t</span><br><span class="line">    finally:</span><br><span class="line">        _release_lock(key, client, t)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def _acquire_lock(key, client, unique_id, acquire_timeout):</span><br><span class="line">    end = time.time() + acquire_timeout</span><br><span class="line">    while time.time() &lt; end:</span><br><span class="line">        if client.set(key, unique_id, ex=DEFAULT_EXPIRES, nx=True):</span><br><span class="line">            return unique_id</span><br><span class="line">        else:</span><br><span class="line">            gen.sleep(.01)</span><br><span class="line">    return None</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def _release_lock(key, client, t):</span><br><span class="line">    try:</span><br><span class="line">        lua_command = &quot;&quot;&quot;</span><br><span class="line">            if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1]</span><br><span class="line">            then</span><br><span class="line">                return redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line">            else</span><br><span class="line">                return 0</span><br><span class="line">            end</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        lua_script = client.register_script(lua_command)</span><br><span class="line">        lock_logger.debug(lua_script(keys=[key], args=[t]))</span><br><span class="line">    except Exception as e:</span><br><span class="line">        lock_logger.error(traceback.format_exc())</span><br></pre></td></tr></table></figure><p>unique_id：uuid1() 提供的全球唯一值，保证每个客户端释放的是自己的锁。</p><p>使用lua脚本释放锁是为了保证释放锁操作的原子性：</p><blockquote><p><strong>Atomicity of scripts</strong></p><p>Redis uses the same Lua interpreter to run all the commands. Also Redis guarantees that a script is executed in an atomic way: no other script or Redis command will be executed while a script is being executed. This semantic is similar to the one of MULTI / EXEC. From the point of view of all the other clients the effects of a script are either still not visible or already completed.</p><p>However this also means that executing slow scripts is not a good idea. It is not hard to create fast scripts, as the script overhead is very low, but if you are going to use slow scripts you should be aware that while the script is running no other client can execute commands.</p></blockquote><p>获取锁时，给定超时时间是１s，避免出现死锁现象。</p><p>使用redis分布式锁的问题是，失效时间的设置。如果设置的失效时间太短，方法没等执行完，锁就自动释放了，那么就会产生并发问题。</p><h4 id="分布式锁-基于RedLock"><a href="#分布式锁-基于RedLock" class="headerlink" title="分布式锁-基于RedLock"></a>分布式锁-基于RedLock</h4><p>Redlock 是 Redis 的作者 antirez 给出的集群模式的 Redis 分布式锁，它基于 N 个完全独立的 Redis 节点（通常情况下 N 可以设置成 5）。</p><p>算法的步骤如下：</p><ol><li>客户端获取当前时间，以毫秒为单位；</li><li>客户端尝试获取 N 个节点的锁，（每个节点获取锁的方式和前面说的缓存锁一样），N 个节点以相同的 key 和 value 获取锁。客户端需要设置接口访问超时，接口超时时间需要远远小于锁超时时间，比如锁自动释放的时间是 10s，那么接口超时大概设置 5-50ms。这样可以在有 redis 节点宕机后，访问该节点时能尽快超时，而减小锁的正常使用；</li><li>客户端计算在获得锁的时候花费了多少时间，方法是用当前时间减去在步骤一获取的时间，只有客户端获得了超过 3 个节点的锁，而且获取锁的时间小于锁的超时时间，客户端才获得了分布式锁；</li><li>客户端获取的锁的时间为设置的锁超时时间减去步骤三计算出的获取锁花费时间；</li><li>如果客户端获取锁失败了，客户端会依次删除所有的锁。</li></ol><p>使用 Redlock 算法，可以保证在挂掉最多 2 个节点的时候，分布式锁服务仍然能工作，这相比之前的数据库锁和缓存锁大大提高了可用性，由于 redis 的高效性能，分布式缓存锁性能并不比数据库锁差。</p><h4 id="分布式锁-基于Zookeeper"><a href="#分布式锁-基于Zookeeper" class="headerlink" title="分布式锁-基于Zookeeper"></a>分布式锁-基于Zookeeper</h4><p>ZooKeeper的架构通过冗余服务实现高可用性。因此，如果第一次无应答，客户端就可以询问另一台ZooKeeper主机。ZooKeeper节点将它们的数据存储于一个分层的命名空间，非常类似于一个文件系统或一个前缀树结构。客户端可以在节点读写，从而以这种方式拥有一个共享的配置服务，更新是全序的。</p><p> <img src="/images/2018-05-06T184140.png" alt="2018-05-06T184140"></p><p>上图为系统架构，左边区域表示一个ZooKeeper集群，locker是ZooKeeper的一个持久节点，node_1、node_2、node_3是locker这个持久节点下面的临时顺序节点。client_1、client_2、client_3表示多个客户端，Share_Service表示需要互斥访问的共享资源。</p><p>Zookeeper实现分布式锁的思路：</p><ol><li>多个客户端竞争创建 lock 临时节点；</li><li>其中某个客户端成功创建 lock 节点，其他客户端对 lock 节点设置 watcher；</li><li>持有锁的客户端删除 lock 节点或该客户端崩溃，由 Zookeeper 删除 lock 节点；</li><li>其他客户端获得 lock 节点被删除的通知；</li><li><p>重复上述4个步骤，直至无客户端在等待获取锁了。</p><p><img src="/images/2018-05-06T190223.png" alt="2018-05-06T190223"></p></li></ol><p>Zookeeper方式性能上可能并没有缓存服务那么高，因为每次在创建锁和释放锁的过程中，都要动态创建、销毁临时节点来实现锁功能。ZK 中创建和删除节点只能通过 Leader 服务器来执行，然后将数据同步到所有的 Follower 机器上。</p><p>由于目前理解有限，一些细节需要进一步确定和实践，不当之处请指正。</p><p>Read More:</p><blockquote><p><a href="https://www.cnblogs.com/austinspark-jessylu/p/8043726.html" target="_blank" rel="noopener">分布式锁的几种实现方式</a> <a href="http://www.importnew.com/27477.html" target="_blank" rel="noopener">Redis分布式锁的正确实现方式（Java版）</a> <a href="https://mp.weixin.qq.com/s/JTsJCDuasgIJ0j95K8Ay8w" target="_blank" rel="noopener">基于Redis的分布式锁到底安全吗（上）？</a> <a href="http://www.54tianzhisheng.cn/2018/04/24/Distributed_lock/#%E5%9F%BA%E4%BA%8E-Redlock-%E5%81%9A%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81" target="_blank" rel="noopener">分布式锁看这篇就够了</a> <a href="https://segmentfault.com/a/1190000010895869" target="_blank" rel="noopener">基于 Zookeeper 的分布式锁实现</a> <a href="http://redisdoc.com/" target="_blank" rel="noopener">Redis命令参考</a> <a href="https://redis.io/commands/eval" target="_blank" rel="noopener">Redis Lua scripting</a> <a href="https://dev.mysql.com/doc/" target="_blank" rel="noopener">mysql document</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;进入正题之前，先来说说问题的产生背景。目前绝大多数的业务都跑在高并发的情境下，而数据库（大多数是mysql）数据一致性的问题是不可避免的，笔
      
    
    </summary>
    
      <category term="分布式锁" scheme="http://runnerliu.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
    
      <category term="数据库" scheme="http://runnerliu.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="分布式锁" scheme="http://runnerliu.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
      <category term="redis" scheme="http://runnerliu.github.io/tags/redis/"/>
    
      <category term="zookeeper" scheme="http://runnerliu.github.io/tags/zookeeper/"/>
    
  </entry>
  
</feed>
