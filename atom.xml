<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LiuYang&#39;s BLOG</title>
  
  <subtitle>On the way to become a Software Architect</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://runnerliu.github.io/"/>
  <updated>2021-05-23T07:42:28.083Z</updated>
  <id>http://runnerliu.github.io/</id>
  
  <author>
    <name>william</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mysql的锁</title>
    <link href="http://runnerliu.github.io/2021/05/23/mysql-lock/"/>
    <id>http://runnerliu.github.io/2021/05/23/mysql-lock/</id>
    <published>2021-05-23T06:28:06.000Z</published>
    <updated>2021-05-23T07:42:28.083Z</updated>
    
    <content type="html"><![CDATA[<p>我们都知道事务的ACID性质（参考<a href="https://runnerliu.github.io/2017/08/28/mysqltransaction/">Mysql系列 - 事务</a>），数据库为了维护这些性质，尤其是一致性(C)和隔离性(I)，一般使用加锁这种方式，同时数据库又是个高并发的应用，同一时间会有大量的并发访问，如果加锁过度，会极大的降低并发处理能力。所以对于加锁的处理，可以说就是数据库对于事务处理的精髓所在。</p><h4 id="一次封锁or两段锁"><a href="#一次封锁or两段锁" class="headerlink" title="一次封锁or两段锁"></a>一次封锁or两段锁</h4><p>因为有大量的并发访问，为了预防死锁，一般应用中推荐使用一次封锁法，就是在方法的开始阶段，已经预先知道会用到哪些数据，然后全部锁住，在方法运行之后，再全部解锁。这种方式可以有效的避免循环死锁，但在数据库中却不适用，因为在事务开始阶段，数据库并不知道会用到哪些数据。</p><p>数据库遵循的是两段锁协议，将事务分成两个阶段，加锁阶段和解锁阶段（所以叫两段锁）：</p><ul><li>加锁阶段：在该阶段可以进行加锁操作。在对任何数据进行读操作之前要申请并获得S锁（共享锁，其它事务可以继续加共享锁，但不能加排它锁），在进行写操作之前要申请并获得X锁（排它锁，其它事务不能再获得任何锁）。加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。</li><li>解锁阶段：当事务释放了一个封锁以后，事务进入解锁阶段，在该阶段只能进行解锁操作不能再进行加锁操作。</li></ul><p>两段锁虽然无法避免死锁，但是可以保证事务的并发调度是串行化（串行化很重要，尤其是在数据恢复和备份的时候）的。</p><h4 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h4><p>从锁定资源的角度来看，MySQL 中的锁分为：</p><ul><li>表级锁：对整张表加锁。开销小，加锁快，不会出现死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低。适合以查询为主。</li><li>行级锁：对行记录加锁。开销大，加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率最低，并发度也最高。适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用。</li><li>页面锁：开销和加锁时间界于表锁和行锁之间，会出现死锁，锁定粒度界于表锁和行锁之间，并发度一般</li></ul><h5 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h5><p>InnoDB加行锁时通过给索引上的索引项加锁来实现，这种行锁实现特点意味着，只有通过索引条件检索条件数据，InnoDB才使用行锁，否则InnoDB将使用表锁。</p><p>行锁的加锁算法：</p><ul><li>记录锁 Record Locks：对单个记录的索引项加锁，即使表没有建立索引，InnoDB也会创建一个隐藏的聚簇索引(隐藏的递增主键索引)，并使用此索引进行记录锁定。</li><li>间隙锁 Gap Locks：锁定一个范围，但不包含记录本身，间隙锁作用在索引记录之间的间隔，又或者作用在第一个索引之前，最后一个索引之后的间隙。</li><li>Next-key锁：Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身。当查询的索引含有唯一属性时，InnoDB存储引擎会对Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</li></ul><h5 id="意向共享锁"><a href="#意向共享锁" class="headerlink" title="意向共享锁"></a>意向共享锁</h5><p>一个事务给一个数据行加共享锁时，必须先获得表的意向共享锁</p><h5 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h5><p>共享锁又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁，共享锁可以同时加上多个。</p><p>加了共享锁后，该事务只能对数据进行读取而不能修改，并且其它事务只能加共享锁，不能加排他锁。</p><p>加锁方式：在执行语句后面加上 <code>lock in share mode</code> 就代表对某些资源加上共享锁了。</p><h5 id="意向排它锁"><a href="#意向排它锁" class="headerlink" title="意向排它锁"></a>意向排它锁</h5><p>一个事务给一个数据行加排他锁时，必须先获得表的意向排他锁</p><h5 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h5><p>排他锁又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，和其他的排他锁、共享锁都相斥。</p><p>事务对数据加上排他锁时，只允许此事务读取和修改此数据，并且其它事务不能对该数据加任何锁。</p><h5 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h5><p>悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p><p>悲观锁认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其它事务读取或修改数据（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程），应用于数据更新比较频繁的场景。</p><p>悲观锁的实现方式：</p><ul><li>实现悲观锁时，我们必须先使用<code>set autocommit=0;</code>，关闭mysql的AutoCommit属性。因为我们查询出数据之后就要将该数据锁定，关闭自动提交后，我们需要手动开启事务。</li></ul><p>悲观锁的优点：</p><ul><li>悲观锁保证了数据处理时的安全性。</li></ul><p>悲观锁的缺点：</p><ul><li>加锁造成了开销增加，并且增加了死锁的机会。降低了并发性。</li></ul><h5 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h5><p>乐观锁不是数据库自带的，需要我们自己去实现。乐观锁是指操作数据库时（更新操作），想法很乐观，认为这次的操作不会导致冲突，在操作数据时，并不进行任何其他的特殊处理（也就是不加锁），而在进行更新后，再去判断是否有冲突，适用于读多写少的场景。</p><p>乐观锁的实现方式：</p><ul><li>版本号机制：加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段。一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。</li><li>CAS算法：Compare And Swap（比较与交换），是一种有名的无锁算法。先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新。一般情况下是一个自旋操作，即不断的重试。</li></ul><p>乐观锁的优点：</p><ul><li>乐观锁机制避免了长事务中的数据库加锁开销，大大提升了大并发量下的系统整体性能表现。</li></ul><p>乐观锁的缺点：</p><ul><li>ABA问题：如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 “ABA”问题。</li><li>循环时间长开销大：自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。</li></ul><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁是指两个或两个以上事务在执行过程中因争抢锁资源而造成的互相等待（形成环路）的现象。<strong>表级锁不会产生死锁</strong>，所以解决死锁主要还是针对于最常用的InnoDB。</p><p>死锁的解决：</p><ul><li><p>查出阻塞的进程，将其kill掉，将资源释放</p></li><li><p>设置锁的超时时间：InnoDB 行锁的等待时间，单位秒。可在会话级别设置，RDS 实例该参数的默认值为 50s。生产环境不推荐使用过大的 <code>innodb_lock_wait_timeout</code> 参数值该参数支持在会话级别修改，方便应用在会话级别单独设置某些特殊操作的行锁等待超时时</p></li><li><p>如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会</p></li><li><p>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率</p></li><li><p>对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率，<strong>不推荐</strong></p></li></ul><p>Read More:</p><p>Read More:</p><blockquote><p><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener">Innodb中的事务隔离级别和锁的关系</a></p><p><a href="https://www.jianshu.com/p/4f2311f38040" target="_blank" rel="noopener">深入理解MySQL数据库各种锁（总结）</a></p><p><a href="https://segmentfault.com/a/1190000022839728" target="_blank" rel="noopener">面试官：小伙子，给我说一下mysql 乐观锁和悲观锁吧</a></p><p><a href="https://zhuanlan.zhihu.com/p/29150809" target="_blank" rel="noopener">MySQL锁总结</a></p><p><a href="https://learnku.com/articles/39212?order_by=vote_count&amp;" target="_blank" rel="noopener">一张图彻底搞懂 MySQL 的锁机制</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们都知道事务的ACID性质（参考&lt;a href=&quot;https://runnerliu.github.io/2017/08/28/mysqltransaction/&quot;&gt;Mysql系列 - 事务&lt;/a&gt;），数据库为了维护这些性质，尤其是一致性(C)和隔离性(I)，一般使用加锁
      
    
    </summary>
    
      <category term="Mysql" scheme="http://runnerliu.github.io/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://runnerliu.github.io/tags/Mysql/"/>
    
      <category term="Lock" scheme="http://runnerliu.github.io/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ如何处理消息丢失</title>
    <link href="http://runnerliu.github.io/2021/05/18/rocketmq-msglost/"/>
    <id>http://runnerliu.github.io/2021/05/18/rocketmq-msglost/</id>
    <published>2021-05-18T14:28:36.000Z</published>
    <updated>2021-05-18T14:42:13.173Z</updated>
    
    <content type="html"><![CDATA[<h4 id="消息的发送过程"><a href="#消息的发送过程" class="headerlink" title="消息的发送过程"></a>消息的发送过程</h4><p><img src="/images/2021-5-18T223009.png" alt="2021-5-18T223009.png"></p><ul><li><p>生产阶段：Producer 新建消息，然后通过网络将消息投递给 MQ Broker</p></li><li><p>存储阶段：消息将会存储在 Broker 端磁盘中</p></li><li><p>消费阶段：Consumer 将会从 Broker 拉取消息</p></li></ul><p>以上任一阶段都可能会丢失消息，我们只要找到这三个阶段丢失消息原因，采用合理的办法避免丢失，就可以彻底解决消息丢失的问题。</p><h4 id="生产阶段"><a href="#生产阶段" class="headerlink" title="生产阶段"></a>生产阶段</h4><p>生产者（Producer） 通过网络发送消息给 Broker，当 Broker 收到之后，将会返回确认响应信息给 Producer。所以生产者只要接收到返回的确认响应，就代表消息在生产阶段未丢失。</p><h5 id="同步发送"><a href="#同步发送" class="headerlink" title="同步发送"></a>同步发送</h5><p>有三种Send方法，同步发送、异步发送、单向发送。我们可以采取同步发送的方式进行发送消息，发消息的时候会同步阻塞等待broker返回的结果，如果没成功，则不会收到SendResult，这种是最可靠的。其次是异步发送，在回调方法里可以得知是否发送成功。单向发送是最不靠谱的一种发送方式，我们无法保证消息真正可达。</p><h5 id="失败重试"><a href="#失败重试" class="headerlink" title="失败重试"></a>失败重试</h5><p>发送消息如果失败或者超时了，则会自动重试。默认是重试三次，可以根据API进行更改，比如改为10次：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">producer.setRetryTimesWhenSendFailed(10);</span><br></pre></td></tr></table></figure><h4 id="存储阶段"><a href="#存储阶段" class="headerlink" title="存储阶段"></a>存储阶段</h4><p>MQ持久化消息分为两种：同步刷盘和异步刷盘。</p><h5 id="同步刷盘"><a href="#同步刷盘" class="headerlink" title="同步刷盘"></a>同步刷盘</h5><p>默认情况是异步刷盘，Broker收到消息后会先存到Cache里然后立马通知Producer成功，然后Broker启动异步线程的去持久化到磁盘中，但是Broker还没持久化到磁盘就宕机的话，消息就丢失了。同步刷盘的话是收到消息存到Cache后并不会通知Producer说消息已经OK了，而是会等到持久化到磁盘中后才会通知Producer说消息完事了。这也保障了消息不会丢失，但是性能不如异步高。看业务场景取舍。</p><h5 id="主从同步复制"><a href="#主从同步复制" class="headerlink" title="主从同步复制"></a>主从同步复制</h5><p>即使Broker设置了同步刷盘策略，但是Broker刷完盘后磁盘坏了，这会导致盘上的消息全TM丢了。但是如果即使是1主1从了，但是Master刷完盘后还没来得及同步给Slave就磁盘坏了，也会导致消息丢失。所以我们还可以配置不仅是等Master刷完盘就通知Producer，而是等Master和Slave都刷完盘后才去通知Producer说消息OK了。</p><h4 id="消费阶段"><a href="#消费阶段" class="headerlink" title="消费阶段"></a>消费阶段</h4><p>消费者从 broker 拉取消息，然后执行相应的业务逻辑。一旦执行成功，将会返回 <code>ConsumeConcurrentlyStatus.CONSUME_SUCCESS</code> 状态给 Broker。如果 Broker 未收到消费确认响应或收到其他状态，消费者下次还会再次拉取到该条消息，进行重试。这样的方式有效避免了消费者消费过程发生异常，或者消息在网络传输中丢失的情况。</p><p>Read More:</p><blockquote><p><a href="https://www.cnblogs.com/goodAndyxublog/p/12563813.html" target="_blank" rel="noopener">面试官再问我如何保证 RocketMQ 不丢失消息,这回我笑了！</a></p><p><a href="https://blog.csdn.net/weixin_39601088/article/details/111343167" target="_blank" rel="noopener">udp怎么保证不丢包_从入门到入土（三）RocketMQ 怎么保证的消息不丢失？</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;消息的发送过程&quot;&gt;&lt;a href=&quot;#消息的发送过程&quot; class=&quot;headerlink&quot; title=&quot;消息的发送过程&quot;&gt;&lt;/a&gt;消息的发送过程&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/images/2021-5-18T223009.png&quot; alt=&quot;2021-
      
    
    </summary>
    
      <category term="MQ" scheme="http://runnerliu.github.io/categories/MQ/"/>
    
    
      <category term="RocketMQ" scheme="http://runnerliu.github.io/tags/RocketMQ/"/>
    
      <category term="MQ" scheme="http://runnerliu.github.io/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>Websocket与Socket的区别</title>
    <link href="http://runnerliu.github.io/2021/05/18/websocket-socket/"/>
    <id>http://runnerliu.github.io/2021/05/18/websocket-socket/</id>
    <published>2021-05-18T14:01:07.000Z</published>
    <updated>2021-05-18T14:19:42.425Z</updated>
    
    <content type="html"><![CDATA[<p>WebSocket protocol 是HTML5一种新的协议，同HTTP一样也是应用层的协议，是建立在TCP之上的，它实现了浏览器与服务器全双工通信。客户端与服务端的握手需要借助HTTP请求完成。</p><p>Socket其实并不是一个协议，而是为了方便使用TCP或UDP而抽象出来的一层，是位于应用层和传输控制层之间的一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>Socket是传输控制层协议，WebSocket是应用层协议</li><li>Socket是一组接口，WebSocket是一个与HTTP属于同一层次的应用层协议，可与服务端进行全双工通信</li></ul><p>欢迎阅读 <a href="http://localhost:4000/2021/05/15/websocket-socketio/" target="_blank" rel="noopener">聊聊WebSocket与Socket.IO</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;WebSocket protocol 是HTML5一种新的协议，同HTTP一样也是应用层的协议，是建立在TCP之上的，它实现了浏览器与服务器全双工通信。客户端与服务端的握手需要借助HTTP请求完成。&lt;/p&gt;
&lt;p&gt;Socket其实并不是一个协议，而是为了方便使用TCP或UD
      
    
    </summary>
    
      <category term="WebSocket" scheme="http://runnerliu.github.io/categories/WebSocket/"/>
    
    
      <category term="WebSocket" scheme="http://runnerliu.github.io/tags/WebSocket/"/>
    
      <category term="Socket" scheme="http://runnerliu.github.io/tags/Socket/"/>
    
  </entry>
  
  <entry>
    <title>聊聊WebSocket与Socket.IO</title>
    <link href="http://runnerliu.github.io/2021/05/15/websocket-socketio/"/>
    <id>http://runnerliu.github.io/2021/05/15/websocket-socketio/</id>
    <published>2021-05-15T05:16:30.000Z</published>
    <updated>2021-05-15T09:41:43.405Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是WebSocket"><a href="#什么是WebSocket" class="headerlink" title="什么是WebSocket"></a>什么是WebSocket</h4><p><a href="https://zh.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">WebSocket</a> 是与HTTP不同的一种网络传输协议，是HTML5新增加的一种通信协议，目前流行的浏览器都支持该协议，例如 Chrome，Safrie，Firefox，Opera，IE等等。WebSocket的产生背景主要是为了方便客户端与服务器之间的双向通信，是一种全双工的数据通信机制。</p><h4 id="早期客户端与服务端通信方式"><a href="#早期客户端与服务端通信方式" class="headerlink" title="早期客户端与服务端通信方式"></a>早期客户端与服务端通信方式</h4><h5 id="Polling（短轮询）"><a href="#Polling（短轮询）" class="headerlink" title="Polling（短轮询）"></a>Polling（短轮询）</h5><p><img src="/images/2021-5-15T171622.png" alt="2021-5-15T171622.png"></p><p>这种方式下，Client 每隔一段时间都会向 Server 发送 HTTP 请求，服务器收到请求后，将最新的数据发回给 Client。一开始必须通过提交表单的形式，这样的后果就是传输很多冗余的数据，浪费了带宽。后来 Ajax 出现，减少了传输数据量。</p><p>如图所示，在 Client 向 Server 发送一个请求活动结束后，Server 中的数据发生了改变，所以 Client 向 Server 发送的第二次请求中，Server 会将最新的数据返回给 Client。</p><p>但这种方式也存在弊端。比如在某个时间段 Server 没有更新数据，但 Client 仍然每隔一段时间发送请求来询问，所以这段时间内的询问都是无效的，这样浪费了网络带宽。将发送请求的间隔时间加大会缓解这种浪费，但如果 Server 更新数据很快时，这样又不能满足数据的实时性。</p><h5 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h5><p>鉴于（短）轮询的弊端，一种基于 HTTP 长连接的 “服务器推” 的技术产生了，这种技术被命名为 Comet。其与（短）轮询主要区别就是，在轮询方式下，要想取得数据，必须首先发送请求，在实时性要求较高的情况下，只能增加向 Server 请求的频率；而 Comet 则不同，Client 与 Server 端保持一个长连接，只有数据发生改变时，Server 才主动将数据推送给 Client。Comet 又可以被细分为两种实现方式，一种是长轮询机制，一种是流技术。</p><h6 id="Long-Polling（长轮询）"><a href="#Long-Polling（长轮询）" class="headerlink" title="Long-Polling（长轮询）"></a>Long-Polling（长轮询）</h6><p><img src="/images/2021-5-15T171920.png" alt="2021-5-15T171920.png"></p><p>Client 向 Server 发出请求，Server 接收到请求后，Server 并不一定立即发送回应给 Client，而是看数据是否更新，如果数据已经更新了的话，那就立即将数据返回给 Client；但如果数据没有更新，那就把这个请求保持住，等待有新的数据到来时，才将数据返回给 Client。</p><p>当然了，如果 Server 的数据长时间没有更新，一段时间后，请求便会超时，Client 收到超时信息后，再立即发送一个新的请求给 Server。</p><p>如图所示，在长轮询机制下，Client 向 Server 发送了请求后，Server会等数据更新完才会将数据返回，而不是像（短）轮询一样不管数据有没有更新然后立即返回。</p><p>这种方式也有弊端。当 Server 向 Client 发送数据后，必须等待下一次请求才能将新的数据发送出去，这样 Client 接收到新数据的间隔最短时间便是 2 * RTT（往返时间），这样便无法应对 server 端数据更新频率较快的情况。</p><h6 id="HTTP-Streaming"><a href="#HTTP-Streaming" class="headerlink" title="HTTP Streaming"></a>HTTP Streaming</h6><p><img src="/images/2021-5-15T172057.png" alt="2021-5-15T172057.png"></p><p>流技术基于 Iframe。Iframe 是 HTML 标记，这个标记的 src 属性会保持对指定 Server 的长连接请求，Server 就可以不断地向 Client 返回数据。</p><p>可以看出，流技术与长轮询的区别是长轮询本质上还是一种轮询方式，只不过连接的时间有所增加，想要向 Server 获取新的数据，Client 只能一遍遍的发送请求；而流技术是一直保持连接，不需要 Client 请求，当数据发生改变时，Server 自动的将数据发送给 Client。</p><p>如图所示，Client 与 Server 建立连接之后，便不会断开。当数据发生变化，Server 便将数据发送给 Client。</p><p>但这种方式有一个明显的不足之处，网页会一直显示未加载完成的状态，虽然我没有强迫症，但这点还是难以忍受。</p><h4 id="WebSocket-原理"><a href="#WebSocket-原理" class="headerlink" title="WebSocket 原理"></a>WebSocket 原理</h4><p>写到现在，大家会发现，前人推出那么多的解决方案，想要解决的唯一的问题便是怎么让 Server 将最新的数据以最快的速度发送给 Client。但 HTTP 是个懒惰的协议，Server 只有收到请求才会做出回应，否则什么事都不干。因此，为了彻底解决这个 Server 主动向 Client 发送数据的问题，WebSocket应运而生。<strong>WebSocket 是一个全新的、独立的协议，基于 TCP 协议，与 HTTP 协议兼容却不会融入 HTTP 协议，仅仅作为 HTML5 的一部分</strong>。</p><p><img src="/images/2021-5-15T172947.png" alt="2021-5-15T172947.png"></p><p>那 WebSocket 与 HTTP 什么关系呢？简单来说，WebSocket 是一种协议，是一种与 HTTP 同等的网络协议，两者都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 Server 与 Client 都能主动向对方发送或接收数据。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 Client 与 Server 之间的双向通信就与 HTTP 无关了。</p><p><img src="/images/2021-5-15T172730.png" alt="2021-5-15T172730.png"></p><p>相比于传统 HTTP 的每次“请求-应答”都要 Client 与 Server 建立连接的模式，WebSocket 是一种长连接的模式。一旦 WebSocket 连接建立后，除非 Client 或者 Server 中有一端主动断开连接，否则每次数据传输之前都不需要 HTTP 那样请求数据。从上面的图可以看出，Client 第一次需要与 Server 建立连接，当 Server 确认连接之后，两者便一直处于连接状态。直到一方断开连接，WebSocket 连接才断开。</p><h4 id="WebSocket的优势"><a href="#WebSocket的优势" class="headerlink" title="WebSocket的优势"></a>WebSocket的优势</h4><ul><li>较少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。</li><li>更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。</li><li>保持连接状态。与HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。</li><li>更好的二进制支持。Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容。</li><li>可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等。</li><li>更好的压缩效果。相对于HTTP压缩，Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率。</li></ul><h4 id="什么是Socket-IO"><a href="#什么是Socket-IO" class="headerlink" title="什么是Socket.IO"></a>什么是Socket.IO</h4><p><a href="https://zh.wikipedia.org/wiki/Socket.IO" target="_blank" rel="noopener">Socket.IO</a> 是一个封装了 Websocket、基于 Node 的 JavaScript 框架，包含 Client 的 JavaScript 和 Server 的 Node。其屏蔽了所有底层细节，让顶层调用非常简单。其不仅支持 WebSocket，还支持许多种轮询机制以及其他实时通信方式，并封装了通用的接口。这些方式包含 Adobe Flash Socket、Ajax 长轮询、Ajax multipart streaming 、持久 Iframe、JSONP 轮询等。换句话说，当 Socket.IO 检测到当前环境不支持 WebSocket 时，能够自动地选择最佳的方式来实现网络的实时通信。</p><p>Read More:</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/23467317" target="_blank" rel="noopener">WebSocket 与 Socket.IO</a></p><p><a href="https://www.jianshu.com/p/144b997e57b4" target="_blank" rel="noopener">（一）websocket和socket.io介绍</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是WebSocket&quot;&gt;&lt;a href=&quot;#什么是WebSocket&quot; class=&quot;headerlink&quot; title=&quot;什么是WebSocket&quot;&gt;&lt;/a&gt;什么是WebSocket&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.
      
    
    </summary>
    
      <category term="WebSocket" scheme="http://runnerliu.github.io/categories/WebSocket/"/>
    
    
      <category term="WebSocket" scheme="http://runnerliu.github.io/tags/WebSocket/"/>
    
      <category term="Socket.IO" scheme="http://runnerliu.github.io/tags/Socket-IO/"/>
    
  </entry>
  
  <entry>
    <title>Mysql系列 - 索引</title>
    <link href="http://runnerliu.github.io/2021/02/20/mysql-index/"/>
    <id>http://runnerliu.github.io/2021/02/20/mysql-index/</id>
    <published>2021-02-20T08:54:14.000Z</published>
    <updated>2021-02-20T09:47:25.831Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 索引是存储引擎用于快速找到记录的一种数据结构</p></blockquote><p>这是MySQL官方对于索引的定义，可以看到索引是一种数据结构，那么我们应该怎样理解索引呢？一个常见的例子就是书的目录。我们都已经养成了看目录的习惯，拿到一本书时，我们首先会先去查看他的目录，并且当我们要查找某个内容时，我们会在目录中查找，然后找到该片段对应的页码，再根据相应的页码去书中查找。如果没有索引(目录)的话，我们就只能一页一页的去查找了。</p><h3 id="索引优缺点"><a href="#索引优缺点" class="headerlink" title="索引优缺点"></a>索引优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>减少查询需要扫描的数据量(加快了查询速度)</li><li>减少服务器的排序操作和创建临时表的操作(加快了groupby和orderby等操作)</li><li>将服务器的随机IO变为顺序IO(加快查询速度)</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>索引占用磁盘或者内存空间</li><li>减慢了插入更新操作的速度</li></ul><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><p>从存储结构划分</p><ul><li>Btree索引（B+tree，B-tree)</li><li>哈希索引</li><li>全文索引 </li><li>RTree</li></ul><p>从应用层次划分</p><ul><li>普通索引：即一个索引只包含单个列，一个表可以有多个单列索引。<code>ALTER TABLE table_name ADD INDEX index_name (column)</code></li><li>唯一索引：索引列的值必须唯一，但允许有空值。<code>ALTER TABLE table_name ADD UNIQUE (column)</code></li><li>主键索引：特殊的唯一索引，不允许为空，只能有一个，一般是在建表时指定。<code>ALTER TABLE table_name ADD PRIMARY KEY (column)</code></li><li>组合索引：在多个字段上创建索引，遵循<strong>最左前缀原则</strong>。<code>ALTER TABLE table_name ADD INDEX index_name (column1,column2,column3)</code></li></ul><p>从表记录的排列顺序和索引的排列顺序是否一致划分</p><ul><li>聚集索引：表记录的排列顺序和索引的排列顺序一致，查询效率快，因为只要找到第一个索引值记录，其余的连续性的记录在物理表中也会连续存放，一起就可以查询到。</li><li>非聚集索引：表记录的排列顺序和索引的排列顺序不一致，非聚集索引在叶子节点存储的是主键和索引列，当我们使用非聚集索引查询数据时，需要拿到叶子上的主键再去表中查到想要查找的数据。这个过程就是回表。</li></ul><p>聚集索引和非聚集索引区别：</p><blockquote><p>聚集索引在叶子节点存储的是表中的数据，非聚集索引在叶子节点存储的是主键和索引列。</p></blockquote><p>比如汉语字典，想要查「阿」字，只需要翻到字典前几页，a开头的位置，接着「啊」「爱」都会出来。也就是说，字典的正文部分本身就是一个目录，不需要再去查其他目录来找到需要找的内容。我们把这种正文内容本身就是一种按照一定规则排列的目录称为聚集索引。</p><p>比如要查“玉”字，我们可以看到在查部首之后的检字表中“玉”的页码是587页，然后是珏，是251页。很显然，在字典中这两个字并没有挨着，现在看到的连续的“玉、珏、莹”三字实际上就是他们在非聚集索引中的排序，是字典正文中的字在非聚集索引中的映射。我们可以通过这种方式来找到所需要的字，但它需要两个过程，先找到目录中的结果，然后再翻到结果所对应的页码。我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为非聚集索引。</p><h3 id="索引建立原则"><a href="#索引建立原则" class="headerlink" title="索引建立原则"></a>索引建立原则</h3><ul><li><strong>索引并非越多越好</strong>，大量索引不仅占用磁盘空间，而且会影响INSERT、DELETE、UPDATE等语句的性能，表数据更改的同时，索引也会进行调整和更新</li><li><strong>避免对经常更新的表进行过多的索引</strong>，并且索引中的列尽可能少。而对经常用于查询的字段应该创建索引，但要避免添加不必要的字段</li><li><strong>数据量小的表最好不要使用索引</strong>，由于数据较少，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果</li><li><strong>在条件表达式中经常用到的不同值较多的列上建立索引，在不同值很少的列上不要建立索引</strong>。比如在学生表的“性别”字段上只有“男”与“女”两个不同值，因此就无须建立索引。如果建立索引，不但不会提高查询效率，反而会严重降低数据更新速度</li><li><strong>当唯一性是某种数据本身的特征时，指定唯一索引</strong>。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度</li><li><strong>在频繁进行排序或分组（即进行group by或order by操作）的列上建立索引</strong>，如果待排序的列有多个，可以在这些列上建立组合索引</li><li><strong>搜索的索引列，不一定是所要选择的列</strong>。换句话说，最适合索引的列是出现在WHERE子句中的列，或连接子句中指定的列，而不是出现在SELECT关键字后的选择列表中的列</li><li><strong>使用短索引</strong>。如果对字符串列进行索引，应该指定一个前缀长度，只要有可能就应该这样做。例如，有一个CHAR(200)列，如果在前10个或20个字符内，多数值是唯一的，那么就不要对整个列进行索引。对前10个或20个字符进行索引能够节省大量索引空间，也可能会使查询更快。较小的索引涉及的磁盘 IO 较少，较短的值比较起来更快。更为重要的是，对于较短的键值，索引高速缓存中的块能容纳更多的键值，因此，MySQL 也可以在内存中容纳更多的值。这样就增加了找到行而不用读取索引中较多块的可能性</li><li><strong>利用最左前缀</strong>。在创建一个n列的索引时，实际是创建了MySQL可利用的n个索引。多列索引可起几个索引的作用，因为可利用索引中最左边的列集来匹配行。这样的列集称为最左前缀</li><li>对于InnoDB存储引擎的表，记录默认会按照一定的顺序保存，如果有明确定义的主键，则按照主键顺序保存。如果没有主键，但是有唯一索引，那么就是按照唯一索引的顺序保存。如果既没有主键又没有唯一索引，那么表中会自动生成一个内部列，按照这个列的顺序保存。按照主键或者内部列进行的访问是最快的，所以<strong>InnoDB表尽量自己指定主键</strong>，当表中同时有几个列都是唯一的，都可以作为主键的时候，要选择最常作为访问条件的列作为主键，提高查询的效率。另外，还需要注意，InnoDB 表的普通索引都会保存主键的键值，所以主键要尽可能选择较短的数据类型，可以有效地减少索引的磁盘占用，提高索引的缓存效果</li></ul><h3 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h3><ul><li>使用!=、&lt;&gt; 导致索引失效</li><li>类型不一致导致的索引失效：查询时字段值类型必须与表字段类型一致，避免进行类型转换</li><li>函数导致的索引失效：避免查询语句中使用函数</li><li>运算符导致的索引失效：如果对列进行<code>+，-，*，/，!</code>运算，则索引失效</li><li>OR引起的索引失效：OR导致索引是在特定情况下的，并不是所有的OR都是使索引失效，如果OR连接的是同一个字段，那么索引不会失效，反之索引失效</li><li>模糊搜索导致的索引失效：like语句使用”xxx%”会走索引，使用”%xxx”或”%xxx%”不走索引</li><li>尽量少用is null、is not null</li></ul><h3 id="慢查询优化"><a href="#慢查询优化" class="headerlink" title="慢查询优化"></a>慢查询优化</h3><ul><li>先运行看看是否真的很慢，注意设置SQL_NO_CACHE</li><li>where条件单表查，锁定最小返回记录表。把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高</li><li>explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）</li><li>order by limit 形式的sql语句让排序的表优先查</li><li>了解业务方使用场景</li><li>加索引时参照建索引的几大原则</li><li>观察结果，不符合预期继续从0分析</li></ul><p>Read More:</p><blockquote><p><a href="https://juejin.cn/post/6844903909899632654#heading-2" target="_blank" rel="noopener">详解Mysql索引原理及其优化</a></p><p><a href="https://segmentfault.com/a/1190000023911554" target="_blank" rel="noopener">导致MySQL索引失效的几种常见写法</a></p><p><a href="https://www.cnblogs.com/zsql/p/13808417.html" target="_blank" rel="noopener">Mysql索引（一篇就够le）</a></p><p><a href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank" rel="noopener">MySQL索引原理及慢查询优化</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt; 索引是存储引擎用于快速找到记录的一种数据结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是MySQL官方对于索引的定义，可以看到索引是一种数据结构，那么我们应该怎样理解索引呢？一个常见的例子就是书的目录。我们都已经养成了看目录的习惯，拿到一本书
      
    
    </summary>
    
      <category term="Mysql" scheme="http://runnerliu.github.io/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://runnerliu.github.io/tags/Mysql/"/>
    
      <category term="索引" scheme="http://runnerliu.github.io/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>Mysql系列 - explain</title>
    <link href="http://runnerliu.github.io/2021/02/20/mysql-explain/"/>
    <id>http://runnerliu.github.io/2021/02/20/mysql-explain/</id>
    <published>2021-02-20T04:04:15.000Z</published>
    <updated>2021-02-20T04:48:29.807Z</updated>
    
    <content type="html"><![CDATA[<p>通常我们在优化Mysql语句时会使用explain关键字，它是MySQL 提供的对 SELECT 语句进行分析并输出 SELECT 执行的详细信息的命令，其输出结果如下图：</p><p><img src="/images/2021-2-20T121509.png" alt="2021-2-20T121509.png"></p><h3 id="explain结果"><a href="#explain结果" class="headerlink" title="explain结果"></a>explain结果</h3><table><thead><tr><th>字段</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>SELECT 查询的标识符，每个 SELECT 都会自动分配一个唯一的标识符</td><td>id大的先执行，id相等由上到下执行</td></tr><tr><td>select_type</td><td>SELECT 查询的类型</td><td></td></tr><tr><td>table</td><td>查询的表名</td><td></td></tr><tr><td>partitions</td><td>匹配的分区</td><td>分库时使用</td></tr><tr><td>type</td><td>join 类型</td><td></td></tr><tr><td>possible_keys</td><td>此次查询中可能选用的索引</td><td></td></tr><tr><td>key</td><td>此次查询中确切使用到的索引</td><td></td></tr><tr><td>key_len</td><td>实际选择的索引的长度</td><td></td></tr><tr><td>ref</td><td>哪个字段或常数与 key 一起被使用</td><td></td></tr><tr><td>rows</td><td>显示此查询共扫描了多少行，估计值</td><td></td></tr><tr><td>filtered</td><td>表示此查询条件所过滤的数据的百分比</td><td></td></tr><tr><td>Extra</td><td>额外的信息</td></tr></tbody></table><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><table><thead><tr><th>取值</th><th>含义</th></tr></thead><tbody><tr><td>SIMPLE</td><td>此查询不包含 UNION 查询或子查询</td></tr><tr><td>PRIMARY</td><td>此查询是最外层的查询</td></tr><tr><td>UNION</td><td>此查询是 UNION 的第二或随后的查询</td></tr><tr><td>DEPENDENT UNION</td><td>UNION 中的第二个或后面的查询语句，取决于外面的查询</td></tr><tr><td>UNION RESULT</td><td>UNION 的结果</td></tr><tr><td>SUBQUERY</td><td>子查询中的第一个 SELECT</td></tr><tr><td>DEPENDENT SUBQUERY</td><td>子查询中的第一个 SELECT，取决于外面的查询，即子查询依赖于外层查询的结果</td></tr></tbody></table><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><table><thead><tr><th>取值</th><th>含义</th></tr></thead><tbody><tr><td>system</td><td>表中只有一条数据，这个类型是特殊的 <code>const</code> 类型</td></tr><tr><td>const</td><td>针对主键或唯一索引的等值查询扫描，最多只返回一行数据。const 查询速度非常快，因为它仅仅读取一次即可</td></tr><tr><td>eq_ref</td><td>此类型通常出现在多表的 join 查询，表示对于前表的每一个结果，都只能匹配到后表的一行结果，并且查询的比较操作通常是 <code>=</code>，查询效率较高</td></tr><tr><td>ref</td><td>此类型通常出现在多表的 join 查询，针对于非唯一或非主键索引，或者是使用了最左前缀规则索引的查询</td></tr><tr><td>range</td><td>使用索引范围查询，通过索引字段范围获取表中部分数据记录。这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中（当 <code>type</code> 是 <code>range</code> 时, 那么 EXPLAIN 输出的 <code>ref</code> 字段为 NULL，并且 <code>key_len</code> 字段是此次查询中使用到的索引的最长的那个）</td></tr><tr><td>index</td><td>全索引扫描(full index scan)，和 ALL 类型类似，只不过 ALL 类型是全表扫描，而 index 类型则仅仅扫描所有的索引，而不扫描数据</td></tr><tr><td>all</td><td>全表扫描, 这个类型的查询是性能最差的查询之一</td></tr></tbody></table><p>效率比较：all&lt; index &lt; range&lt; ref &lt; eq_ref &lt; const &lt; system</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示查询优化器使用了索引的字节数。这个字段可以评估组合索引是否完全被使用，或只有最左部分字段被使用到，key_len 的计算规则如下：</p><ul><li>字符串<ul><li>char(n)：n 字节长度</li><li>varchar(n)：如果是 utf8 编码, 则是 3 *n + 2字节; 如果是 utf8mb4 编码, 则是 4* n + 2 字节.</li></ul></li><li>数值类型:<ul><li>TINYINT：1字节</li><li>SMALLINT：2字节</li><li>MEDIUMINT：3字节</li><li>INT：4字节</li><li>BIGINT：8字节</li></ul></li><li>时间类型<ul><li>DATE：3字节</li><li>TIMESTAMP：4字节</li><li>DATETIME：8字节</li></ul></li><li>字段属性：NULL 属性占用一个字节，如果一个字段是 NOT NULL 的，则没有此属性。</li></ul><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>MySQL 查询优化器根据统计信息估算 SQL 要查找到结果集需要扫描读取的数据行数。这个值非常直观显示 SQL 的效率好坏，原则上 rows 越少越好。</p><p><strong>Extra</strong></p><table><thead><tr><th>取值</th><th>含义</th></tr></thead><tbody><tr><td>Using index</td><td>查询在索引树中就可查找所需数据, 不用扫描表数据文件</td></tr><tr><td>Using index condition</td><td>使用索引下推，延迟回表，且减少了需要回表的结果集</td></tr><tr><td>Using temporary</td><td>查询有使用临时表，一般出现于排序，分组和多表 join 的情况，查询效率不高</td></tr><tr><td>Using filesort</td><td>MySQL 需额外的排序操作，不能通过索引顺序达到排序效果。数量小时使用内存排序，数量大时使用磁盘排序</td></tr><tr><td>Using where</td><td>在存储引擎层检索出记录后，在server利用where条件进行过滤，并返回给客户端</td></tr></tbody></table><p>Read More:</p><blockquote><p><a href="https://segmentfault.com/a/1190000008131735" target="_blank" rel="noopener">MySQL 性能优化神器 Explain 使用分析</a></p><p><a href="http://weikeqin.com/2020/02/05/mysql-explain/" target="_blank" rel="noopener">mysql explain 详解</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常我们在优化Mysql语句时会使用explain关键字，它是MySQL 提供的对 SELECT 语句进行分析并输出 SELECT 执行的详细信息的命令，其输出结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2021-2-20T121509.png&quot; alt
      
    
    </summary>
    
      <category term="Mysql" scheme="http://runnerliu.github.io/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://runnerliu.github.io/tags/Mysql/"/>
    
      <category term="explain" scheme="http://runnerliu.github.io/tags/explain/"/>
    
  </entry>
  
  <entry>
    <title>GO垃圾回收机制</title>
    <link href="http://runnerliu.github.io/2021/02/19/gogc/"/>
    <id>http://runnerliu.github.io/2021/02/19/gogc/</id>
    <published>2021-02-19T06:32:47.000Z</published>
    <updated>2021-02-19T08:28:51.784Z</updated>
    
    <content type="html"><![CDATA[<p>在此之前，我们介绍过 <a href="https://runnerliu.github.io/2017/07/16/pythongc/">浅析Python的垃圾回收机制</a> 和 <a href="https://runnerliu.github.io/2017/04/15/phpnewgc/">PHP新的垃圾回收机制</a> ，有兴趣的话可以参考阅读，今天我们来聊聊golang是如何进行垃圾回收的。我们知道，目前各语言进行垃圾回收的方法有很多，如引用计数、标记清除、分代回收、三色标记等，各种方式都有其特点，GO语言在发展过程中， 其GC算法也是不断改进的。</p><h3 id="GO的GC里程碑"><a href="#GO的GC里程碑" class="headerlink" title="GO的GC里程碑"></a>GO的GC里程碑</h3><h4 id="v1-3以前：STW"><a href="#v1-3以前：STW" class="headerlink" title="v1.3以前：STW"></a>v1.3以前：STW</h4><p>golang的垃圾回收算法都非常简陋，其性能也广被诟病：go runtime在一定条件下（内存超过阈值或定期如2min），暂停所有任务的执行，进行mark&amp;sweep操作，操作完成后启动所有任务的执行。在内存使用较多的场景下，go程序在进行垃圾回收时会发生非常明显的卡顿现象（Stop The World）。在对响应速度要求较高的后台服务进程中，这种延迟简直是不能忍受的！这个时期国内外很多在生产环境实践go语言的团队都或多或少踩过gc的坑。当时解决这个问题比较常用的方法是尽快控制自动分配内存的内存数量以减少gc负荷，同时采用手动管理内存的方法处理需要大量及高频分配内存的场景。</p><h4 id="v1-3：Mark-STW-amp-Sweep"><a href="#v1-3：Mark-STW-amp-Sweep" class="headerlink" title="v1.3：Mark STW &amp; Sweep"></a>v1.3：Mark STW &amp; Sweep</h4><p>1.3版本中，go runtime分离了mark和sweep操作，和以前一样，也是先暂停所有任务执行并启动mark，mark完成后马上就重新启动被暂停的任务了，而是让sweep任务和普通协程任务一样并行的和其他任务一起执行。如果运行在多核处理器上，go会试图将gc任务放到单独的核心上运行而尽量不影响业务代码的执行。go team自己的说法是减少了50%-70%的暂停时间。</p><h4 id="v1-5：三色标记"><a href="#v1-5：三色标记" class="headerlink" title="v1.5：三色标记"></a>v1.5：三色标记</h4><p>go 1.5正在实现的垃圾回收器“非分代的、非移动的、并发的、三色的标记清除垃圾收集器”。这种方法的mark操作是可以渐进执行的而不需每次都扫描整个内存空间，可以减少stop the world的时间。 由此可以看到，一路走来直到1.5版本，go的垃圾回收性能也是一直在提升。</p><h4 id="v1-8：混合写屏障（hybrid-write-barrier）"><a href="#v1-8：混合写屏障（hybrid-write-barrier）" class="headerlink" title="v1.8：混合写屏障（hybrid write barrier）"></a>v1.8：混合写屏障（hybrid write barrier）</h4><p>由于标记操作和用户逻辑是并发执行的，用户逻辑会时常生成对象或者改变对象的引用。例如把⼀个对象标记为白色准备回收时，用户逻辑突然引用了它，或者又创建了新的对象。由于对象初始时都看为白色，会被 GC 回收掉，为了解决这个问题，引入了写屏障机制。</p><p>GC 对扫描过后的对象使⽤操作系统写屏障功能来监控这段内存。如果这段内存发⽣引⽤改变，写屏障会给垃圾回收期发送⼀个信号，垃圾回收器捕获到信号后就知道这个对象发⽣改变，然后重新扫描这个对象，看看它的引⽤或者被引⽤是否改变。利⽤状态的重置实现当对象状态发⽣改变的时候，依然可以再次其引用的对象。</p><h3 id="GO的GC"><a href="#GO的GC" class="headerlink" title="GO的GC"></a>GO的GC</h3><h4 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h4><p>传统的标记清除算法中，垃圾收集器从垃圾收集的根对象出发，递归遍历这些对象指向的子对象并将所有可达的对象标记成存活；标记阶段结束后，垃圾收集器会依次遍历堆中的对象并清除其中的垃圾，整个过程需要标记对象的存活状态，用户程序在垃圾收集的过程中也不能执行，我们需要用到更复杂的机制来解决 STW 的问题，这就出现了三色标记法。</p><p>三色标记算法将程序中的对象分成白色、黑色和灰色三类：</p><ul><li>白色对象：潜在的垃圾，其内存可能会被垃圾收集器回收；</li><li>黑色对象：活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象；</li><li>灰色对象：活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；</li></ul><p><img src="/images/2021-2-19T154834.png" alt="2021-2-19T154834.png"></p><p>在垃圾收集器开始工作时，程序中不存在任何的黑色对象，垃圾收集的根对象会被标记成灰色，垃圾收集器只会从灰色对象集合中取出对象开始扫描，当灰色集合中不存在任何对象时，标记阶段就会结束。</p><p><img src="/images/2021-2-19T154948.png" alt="2021-2-19T154948.png"></p><p>三色标记垃圾收集器的工作原理很简单，我们可以将其归纳成以下几个步骤：</p><ul><li>从灰色对象的集合中选择一个灰色对象并将其标记成黑色；</li><li>将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收；</li><li>重复上述两个步骤直到对象图中不存在灰色对象。</li></ul><p>当三色的标记清除的标记阶段结束之后，应用程序的堆中就不存在任何的灰色对象，我们只能看到黑色的存活对象以及白色的垃圾对象，垃圾收集器可以回收这些白色的垃圾，下面是使用三色标记垃圾收集器执行标记后的堆内存，堆中只有对象 D 为待回收的垃圾：</p><p><img src="/images/2021-2-19T155305.png" alt="2021-2-19T155305.png"></p><p>因为用户程序可能在标记执行的过程中修改对象的指针，所以三色标记清除算法本身是不可以并发或者增量执行的，它仍然需要 STW，在如下所示的三色标记过程中，用户程序建立了从 A 对象到 D 对象的引用，但是因为程序中已经不存在灰色对象了，所以 D 对象会被垃圾收集器错误地回收。</p><p><img src="/images/2021-2-19T155403.png" alt="2021-2-19T155403.png"></p><p>本来不应该被回收的对象却被回收了，这在内存管理中是非常严重的错误，我们将这种错误称为悬挂指针，即指针没有指向特定类型的合法对象，影响了内存的安全性，想要并发或者增量地标记对象还是需要使用屏障技术。</p><p>整个流程如下：</p><p><img src="/images/2021-2-19T155548.gif" alt="2021-2-19T155548.gif"></p><h4 id="混合写屏障"><a href="#混合写屏障" class="headerlink" title="混合写屏障"></a>混合写屏障</h4><p>想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性（Tri-color invariant）中的一种：</p><ul><li>强三色不变性：黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；</li><li>弱三色不变性：黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径。</li></ul><p><img src="/images/2021-2-19T160000.png" alt="2021-2-19T160000.png"></p><p>上图分别展示了遵循强三色不变性和弱三色不变性的堆内存，遵循上述两个不变性中的任意一个，我们都能保证垃圾收集算法的正确性，而屏障技术就是在并发或者增量标记过程中保证三色不变性的重要技术。</p><p>垃圾收集中的屏障技术更像是一个钩子方法，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，根据操作类型的不同，我们可以将它们分成读屏障（Read barrier）和写屏障（Write barrier）两种，因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以编程语言往往都会采用写屏障保证三色不变性。</p><p>Go 语言在 v1.8 组合 Dijkstra 插入写屏障和 Yuasa 删除写屏障构成混合写屏障，该写屏障会<strong>将被覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记成灰色</strong>。</p><p>为了移除栈的重扫描过程，除了引入混合写屏障之外，在垃圾收集的标记阶段，我们还需要<strong>将创建的所有新对象都标记成黑色</strong>，防止新分配的栈内存和堆内存中的对象被错误地回收，因为栈内存在标记阶段最终都会变为黑色，所以不再需要重新扫描栈空间。</p><h4 id="增量和并发"><a href="#增量和并发" class="headerlink" title="增量和并发"></a>增量和并发</h4><p>传统的垃圾收集算法会在垃圾收集的执行期间暂停应用程序，一旦触发垃圾收集，垃圾收集器会抢占 CPU 的使用权占据大量的计算资源以完成标记和清除工作，然而很多追求实时的应用程序无法接受长时间的 STW。</p><p>为了减少应用程序暂停的最长时间和垃圾收集的总暂停时间，我们会使用下面的策略优化现代的垃圾收集器：</p><ul><li>增量垃圾收集：增量地标记和清除垃圾，降低应用程序暂停的最长时间；</li><li>并发垃圾收集：利用多核的计算资源，在用户程序执行时并发标记和清除垃圾；</li></ul><p>因为增量和并发两种方式都可以与用户程序交替运行，所以我们需要使用屏障技术保证垃圾收集的正确性；与此同时，应用程序也不能等到内存溢出时触发垃圾收集，因为当内存不足时，应用程序已经无法分配内存，这与直接暂停程序没有什么区别，增量和并发的垃圾收集需要提前触发并在内存不足前完成整个循环，避免程序的长时间暂停。</p><h5 id="增量收集"><a href="#增量收集" class="headerlink" title="增量收集"></a>增量收集</h5><p>增量式（Incremental）的垃圾收集是减少程序最长暂停时间的一种方案，它可以将原本时间较长的暂停时间切分成多个更小的 GC 时间片，虽然从垃圾收集开始到结束的时间更长了，但是这也减少了应用程序暂停的最大时间：</p><p><img src="/images/2021-2-19T160403.png" alt="2021-2-19T160403.png"></p><p>需要注意的是，增量式的垃圾收集需要与三色标记法一起使用，为了保证垃圾收集的正确性，我们需要在垃圾收集开始前打开写屏障，这样用户程序修改内存都会先经过写屏障的处理，保证了堆内存中对象关系的强三色不变性或者弱三色不变性。虽然增量式的垃圾收集能够减少最大的程序暂停时间，但是增量式收集也会增加一次 GC 循环的总时间，在垃圾收集期间，因为写屏障的影响用户程序也需要承担额外的计算开销，所以增量式的垃圾收集也不是只带来好处的，但是总体来说还是利大于弊。</p><h5 id="并发收集"><a href="#并发收集" class="headerlink" title="并发收集"></a>并发收集</h5><p>并发（Concurrent）的垃圾收集不仅能够减少程序的最长暂停时间，还能减少整个垃圾收集阶段的时间，通过开启读写屏障、利用多核优势与用户程序并行执行，并发垃圾收集器确实能够减少垃圾收集对应用程序的影响：</p><p><img src="/images/2021-2-19T160457.png" alt="2021-2-19T160457.png"></p><p>虽然并发收集器能够与用户程序一起运行，但是并不是所有阶段都可以与用户程序一起运行，部分阶段还是需要暂停用户程序的，不过与传统的算法相比，并发的垃圾收集可以将能够并发执行的工作尽量并发执行；当然，因为读写屏障的引入，并发的垃圾收集器也一定会带来额外开销，不仅会增加垃圾收集的总时间，还会影响用户程序，这是我们在设计垃圾收集策略时必须要注意的。</p><h3 id="GC的时机"><a href="#GC的时机" class="headerlink" title="GC的时机"></a>GC的时机</h3><p>运行时会通过如下所示的 <a href="https://draveness.me/golang/tree/runtime.gcTrigger.test" target="_blank" rel="noopener"><code>runtime.gcTrigger.test</code></a> 方法决定是否需要触发垃圾收集，当满足触发垃圾收集的基本条件时 — 允许垃圾收集、程序没有崩溃并且没有处于垃圾收集循环，该方法会根据三种不同方式触发进行不同的检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func (t gcTrigger) test() bool &#123;</span><br><span class="line">if !memstats.enablegc || panicking != 0 || gcphase != _GCoff &#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">switch t.kind &#123;</span><br><span class="line">case gcTriggerHeap:</span><br><span class="line">return memstats.heap_live &gt;= memstats.gc_trigger</span><br><span class="line">case gcTriggerTime:</span><br><span class="line">if gcpercent &lt; 0 &#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">lastgc := int64(atomic.Load64(&amp;memstats.last_gc_nanotime))</span><br><span class="line">return lastgc != 0 &amp;&amp; t.now-lastgc &gt; forcegcperiod</span><br><span class="line">case gcTriggerCycle:</span><br><span class="line">return int32(t.n-work.cycles) &gt; 0</span><br><span class="line">&#125;</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>gcTriggerHeap</code> ：堆内存的分配达到达控制器计算的触发堆大小；</li><li><code>gcTriggerTime</code> ：如果一定时间内没有触发，就会触发新的循环，该出发条件由 <a href="https://draveness.me/golang/tree/runtime.forcegcperiod" target="_blank" rel="noopener"><code>runtime.forcegcperiod</code></a> 变量控制，默认为 2 分钟；</li><li><code>gcTriggerCycle</code>：如果当前没有开启垃圾收集，则触发新的循环；</li><li><a href="https://draveness.me/golang/tree/runtime.gcpercent" target="_blank" rel="noopener"><code>runtime.gcpercent</code></a> 是触发垃圾收集的内存增长百分比，默认情况下为 100，即堆内存相比上次垃圾收集增长 100% 时应该触发 GC，并行的垃圾收集器会在到达该目标前完成垃圾收集。</li></ol><p>用于开启垃圾收集的方法 <a href="https://draveness.me/golang/tree/runtime.gcStart" target="_blank" rel="noopener"><code>runtime.gcStart</code></a> 会接收一个 <a href="https://draveness.me/golang/tree/runtime.gcTrigger" target="_blank" rel="noopener"><code>runtime.gcTrigger</code></a> 类型的结构，所有出现 <a href="https://draveness.me/golang/tree/runtime.gcTrigger" target="_blank" rel="noopener"><code>runtime.gcTrigger</code></a> 结构体的位置都是触发垃圾收集的代码：</p><ul><li><a href="https://draveness.me/golang/tree/runtime.sysmon" target="_blank" rel="noopener"><code>runtime.sysmon</code></a> 和 <a href="https://draveness.me/golang/tree/runtime.forcegchelper" target="_blank" rel="noopener"><code>runtime.forcegchelper</code></a> ：后台运行定时检查和垃圾收集；</li><li><a href="https://draveness.me/golang/tree/runtime.GC" target="_blank" rel="noopener"><code>runtime.GC</code></a> ：用户程序手动触发垃圾收集；</li><li><a href="https://draveness.me/golang/tree/runtime.mallocgc" target="_blank" rel="noopener"><code>runtime.mallocgc</code></a> ：申请内存时根据堆大小触发垃圾收集。</li></ul><p><img src="/images/2021-2-19T162340.png" alt="2021-2-19T162340.png"></p><p>Read More:</p><blockquote><p><a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/" target="_blank" rel="noopener">垃圾收集器</a></p><p><a href="https://segmentfault.com/a/1190000018161588" target="_blank" rel="noopener">GO GC 垃圾回收机制</a></p><p><a href="https://juejin.cn/post/6844903917650722829" target="_blank" rel="noopener">搞懂Go垃圾回收</a></p><p><a href="https://wingsxdu.com/post/golang/gc/" target="_blank" rel="noopener">Go 语言 GC 机制 · Analyze</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在此之前，我们介绍过 &lt;a href=&quot;https://runnerliu.github.io/2017/07/16/pythongc/&quot;&gt;浅析Python的垃圾回收机制&lt;/a&gt; 和 &lt;a href=&quot;https://runnerliu.github.io/2017/04/
      
    
    </summary>
    
      <category term="GO" scheme="http://runnerliu.github.io/categories/GO/"/>
    
    
      <category term="垃圾回收" scheme="http://runnerliu.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
      <category term="GC" scheme="http://runnerliu.github.io/tags/GC/"/>
    
      <category term="golang" scheme="http://runnerliu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>聊聊WS和WSS</title>
    <link href="http://runnerliu.github.io/2021/02/18/wsandwss/"/>
    <id>http://runnerliu.github.io/2021/02/18/wsandwss/</id>
    <published>2021-02-18T03:35:50.000Z</published>
    <updated>2021-02-18T13:26:42.584Z</updated>
    
    <content type="html"><![CDATA[<h3 id="初识WS-WSS"><a href="#初识WS-WSS" class="headerlink" title="初识WS/WSS"></a>初识WS/WSS</h3><p>WebSocket （WS）是HTML5一种新的协议，它实现了浏览器与服务器全双工通信，能更好地节省服务器资源和带宽并达到实时通讯。WebSocket建立在TCP之上，同HTTP一样通过TCP来传输数据，但是它和HTTP最大不同是：WebSocket是一种双向通信协议，在建立连接后，WebSocket服务器和Browser/Client Agent都能主动的向对方发送或接收数据，就像Socket一样；WebSocket需要类似TCP的客户端和服务器端通过握手连接，连接成功后才能相互通信。</p><p>WSS（Web Socket Secure）是WebSocket的加密版本。WS一般默认是80端口，而WSS默认是443端口，大多数网站用的就是80和433端口。（在高防防护过程中，80和433端口的网站是需要备案才可以接入国内的。）当然网站也会有别的端口，这种如果做高防是方案是可以用海外高防的。WS和WSS的体现形式分别是TCP+WS AS WS ，TCP+TLS+WS AS WS。服务器网址就是 URL。</p><h3 id="为何使用WS-WSS"><a href="#为何使用WS-WSS" class="headerlink" title="为何使用WS/WSS"></a>为何使用WS/WSS</h3><p>随着互联网的蓬勃发展，各种类型的Web应用层出不穷，很多应用要求服务端有能力进行实时推送能力（例如直播间聊天室），以往很多网站为了实现推送技术，所用的技术都是轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断地向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽资源。</p><p>在这种情况下，HTML5定义了WebSocket协议，能更好地节省服务器资源和带宽，并且能够更实时地进行通讯。WebSocket实现了浏览器与服务器全双工（full-duplex）通信，允许服务器主动发送信息给客户端。</p><p>WebSocket协议的交互过程如下图所示。</p><p><img src="/images/20210218T211759.png" alt="20210218T211759.png"></p><h3 id="WS特点"><a href="#WS特点" class="headerlink" title="WS特点"></a>WS特点</h3><ul><li>建立在 TCP 协议之上，服务端实现容易；</li><li>与 HTTP 协议有良好的兼容性，握手时不容易被屏蔽，可以通过各种 HTTP 代理服务器；</li><li>数据轻量，实时通讯；</li><li>可以发送文本和二进制数据；</li><li>不限制同源，客户端可以与任意服务器端进行通讯。因此WebSocket协议的出现，为很多人解决了关于扩展以及兼容性协议的烦恼问题。</li></ul><h3 id="与http-https关系"><a href="#与http-https关系" class="headerlink" title="与http/https关系"></a>与http/https关系</h3><p>按照标准来是有如下对应关系的：</p><ul><li><p>http -&gt; new WebSocket(‘ws://xxx’)</p></li><li><p>https -&gt; new WebSocket(‘wss://xxx’)</p></li></ul><p>在https下应该使用wss协议做安全链接，且wss下不支持ip地址的写法，写成域名形式。</p><p>Read More:</p><blockquote><p><a href="https://www.alibabacloud.com/help/zh/doc-detail/63421.htm" target="_blank" rel="noopener">WS/WSS协议支持FAQ</a></p><p><a href="https://zhuanlan.zhihu.com/p/75328501" target="_blank" rel="noopener">浅谈WebSocket协议、WS协议和WSS协议原理及关系</a></p><p><a href="https://www.jianshu.com/p/72bcc74409ad" target="_blank" rel="noopener">http/https与websocket的ws/wss的关系</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;初识WS-WSS&quot;&gt;&lt;a href=&quot;#初识WS-WSS&quot; class=&quot;headerlink&quot; title=&quot;初识WS/WSS&quot;&gt;&lt;/a&gt;初识WS/WSS&lt;/h3&gt;&lt;p&gt;WebSocket （WS）是HTML5一种新的协议，它实现了浏览器与服务器全双工通信，能更
      
    
    </summary>
    
      <category term="WebSocket" scheme="http://runnerliu.github.io/categories/WebSocket/"/>
    
    
      <category term="WebSocket" scheme="http://runnerliu.github.io/tags/WebSocket/"/>
    
      <category term="WS" scheme="http://runnerliu.github.io/tags/WS/"/>
    
      <category term="WSS" scheme="http://runnerliu.github.io/tags/WSS/"/>
    
  </entry>
  
  <entry>
    <title>Tornado5.0.2翻译文档 - 模板和UI</title>
    <link href="http://runnerliu.github.io/2020/12/19/tornado502-templateui/"/>
    <id>http://runnerliu.github.io/2020/12/19/tornado502-templateui/</id>
    <published>2020-12-19T04:34:43.000Z</published>
    <updated>2020-12-19T08:39:47.550Z</updated>
    
    <content type="html"><![CDATA[<p>Tornado包含一种简单、快速、灵活的模板语言。本节描述该语言以及相关问题，如国际化。</p><p>Tornado还可以与任何其他Python模板语言一起使用，尽管没有将这些系统集成到<code>RequestHandler.render</code>中。只需将模板呈现为一个字符串并将其传递给<code>RequestHandler.write</code>即可。</p><h3 id="模板配置"><a href="#模板配置" class="headerlink" title="模板配置"></a>模板配置</h3><p>默认情况下，Tornado会在引用它们的<code>.py</code>文件的同一目录中寻找模板文件。要将模板文件放到不同的目录中，请使用<code>template_path</code>应用程序设置(或覆盖<code>RequestHandler.get_template_path</code>如果不同的处理程序有不同的模板路径)。</p><p>要从非文件系统位置加载模板，子类<code>tornado.template.BaseLoader</code>并传递一个实例作为<code>template_loader</code>应用程序设置。</p><p>编译后的模板默认缓存;要关闭此缓存并重新加载模板，以便底层文件的更改始终可见，请使用应用程序设置<code>compiled_template_cache=False</code>或<code>debug=True</code>。</p><h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><p>Tornado模板只是HTML(或任何其他基于文本的格式)，在标记中嵌入了Python控制序列和表达式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">      &lt;title&gt;&#123;&#123; title &#125;&#125;&lt;/title&gt;</span><br><span class="line">   &lt;/head&gt;</span><br><span class="line">   &lt;body&gt;</span><br><span class="line">     &lt;ul&gt;</span><br><span class="line">       &#123;% for item in items %&#125;</span><br><span class="line">         &lt;li&gt;&#123;&#123; escape(item) &#125;&#125;&lt;/li&gt;</span><br><span class="line">       &#123;% end %&#125;</span><br><span class="line">     &lt;/ul&gt;</span><br><span class="line">   &lt;/body&gt;</span><br><span class="line"> &lt;/html&gt;</span><br></pre></td></tr></table></figure><p>如果您将此模板保存为“template.html”。然后把它放在与Python文件相同的目录下，你可以用下面的方法来渲染这个模板:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class MainHandler(tornado.web.RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        items = [&quot;Item 1&quot;, &quot;Item 2&quot;, &quot;Item 3&quot;]</span><br><span class="line">        self.render(&quot;template.html&quot;, title=&quot;My title&quot;, items=items)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tornado模板支持控制语句和表达式。控制语句被&#123;%和%&#125;包围，比如：&#123;% if len(items) &gt; 2 %&#125;，表达式由&#123;&#123;和&#125;&#125;包围，比如&#123;&#123; item[0] &#125;&#125;。控制语句或多或少精确地映射到Python语句。我们支持if、for、while和try，它们都以&#123;%end%&#125;结尾，我们还支持使用extends和block语句的模板继承，这些语句都能在tornado.template找到。</span><br></pre></td></tr></table></figure><p>表达式可以是任何Python表达式，包括函数调用。模板代码在包含以下对象和函数的命名空间中执行(注意使用此列表呈现的模板<code>RequestHandler.render</code>和<code>render_string</code>。如果你使用<code>tornado.template</code>模块直接位于<code>RequestHandler</code>外部，其中许多条目不存在）</p><ul><li><p><code>escape</code>: alias for <code>tornado.escape.xhtml_escape</code></p></li><li><p><code>xhtml_escape</code>: alias for <code>tornado.escape.xhtml_escape</code></p></li><li><p><code>url_escape</code>: alias for <code>tornado.escape.url_escape</code></p></li><li><p><code>json_encode</code>: alias for <code>tornado.escape.json_encode</code></p></li><li><p><code>squeeze</code>: alias for <code>tornado.escape.squeeze</code></p></li><li><p><code>linkify</code>: alias for <code>tornado.escape.linkify</code></p></li><li><p><code>datetime</code>: the Python <code>datetime</code>module</p></li><li><p><code>handler</code>: the current <code>RequestHandler</code> object</p></li><li><p><code>request</code>: alias for <code>handler.request</code></p></li><li><p><code>current_user</code>: alias for <code>handler.current_user</code></p></li><li><p><code>locale</code>: alias for <code>handler.locale</code></p></li><li><p><code>\_</code>: alias for handler.locale.translate</p></li><li><p>static_url: alias for <code>handler.static_url</code></p></li><li><p>xsrf_form_html: alias for <code>handler.xsrf_form_html</code></p></li><li><p>reverse_url: alias for <code>Application.reverse_url</code></p></li><li><p>All entries from the <code>ui_methods</code> and <code>ui_modules</code> <code>Application</code> settings</p></li><li><p>Any keyword arguments passed to <code>render</code> or <code>render_string</code></p></li></ul><p>当您构建一个真正的应用程序时，您需要使用Tornado模板的所有特性，特别是模板继承。请阅读<code>tornado.template</code>部分（一些功能，包括<code>UIModules</code>在<code>tornado.web</code>模块）</p><p>Tornado模板直接翻译成Python。模板中包含的表达式将被逐字复制到表示模板的Python函数中。我们不试图阻止模板语言中的任何东西；我们显式地创建它是为了提供其他更严格的模板系统所阻止的灵活性。因此，如果您在模板表达式中编写随机内容，那么在执行模板时，您将得到随机的Python错误。</p><p>默认情况下，所有模板输出都是转义的，使用<code>tornado.escape.xhtml_escape</code>函数，可以传递参数 <code>autoescape=None</code> 给Application或者通过<code>tornado.template.Loader</code>来全局改变该属性，此外，在这些地方中的每一个都可以使用替代转义函数的名称来代替<code>None</code>。</p><p>请注意，虽然Tornado的自动转义有助于避免XSS漏洞，但它在所有情况下都不够。出现在某些位置（如JavaScript或CSS）中的表达式可能需要额外的转义。此外，必须注意在可能包含不可信内容的HTML属性中始终使用双引号和xhtml_escape，或者必须对属性使用单独的转义函数（参见<a href="https://wonko.com/post/html-escaping" target="_blank" rel="noopener">博客</a>）。</p><h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h3><p>参见<a href="https://www.tornadoweb.org/en/stable/guide/templates.html#internationalization" target="_blank" rel="noopener">Internationalization</a></p><h3 id="UI模块"><a href="#UI模块" class="headerlink" title="UI模块"></a>UI模块</h3><p>参见<a href="https://www.tornadoweb.org/en/stable/guide/templates.html#ui-modules" target="_blank" rel="noopener">UI modules</a></p><p>Read More:</p><blockquote><p><a href="https://www.tornadoweb.org/en/stable/guide/templates.html" target="_blank" rel="noopener">Templates and UI</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Tornado包含一种简单、快速、灵活的模板语言。本节描述该语言以及相关问题，如国际化。&lt;/p&gt;
&lt;p&gt;Tornado还可以与任何其他Python模板语言一起使用，尽管没有将这些系统集成到&lt;code&gt;RequestHandler.render&lt;/code&gt;中。只需将模板呈现
      
    
    </summary>
    
      <category term="Tornado" scheme="http://runnerliu.github.io/categories/Tornado/"/>
    
    
      <category term="Tornado" scheme="http://runnerliu.github.io/tags/Tornado/"/>
    
      <category term="翻译文档" scheme="http://runnerliu.github.io/tags/%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>Tornado5.0.2翻译文档 - Tornado web应用程序的结构</title>
    <link href="http://runnerliu.github.io/2020/12/19/tornado502-structureofweb/"/>
    <id>http://runnerliu.github.io/2020/12/19/tornado502-structureofweb/</id>
    <published>2020-12-19T02:34:43.000Z</published>
    <updated>2020-12-19T08:01:26.245Z</updated>
    
    <content type="html"><![CDATA[<p>Tornado web应用程序通常由一个或多个 <code>RequestHandler</code> 子类组成，将传入请求路由到处理程序的 <code>Application</code> 对象，和一个启动服务程序的 <code>main</code> 方法。</p><p>一个最小的“hello world”示例是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import tornado.ioloop</span><br><span class="line">import tornado.web</span><br><span class="line"></span><br><span class="line">class MainHandler(tornado.web.RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        self.write(&quot;Hello, world&quot;)</span><br><span class="line"></span><br><span class="line">def make_app():</span><br><span class="line">    return tornado.web.Application([</span><br><span class="line">        (r&quot;/&quot;, MainHandler),</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app = make_app()</span><br><span class="line">    app.listen(8888)</span><br><span class="line">    tornado.ioloop.IOLoop.current().start()</span><br></pre></td></tr></table></figure><h3 id="Application-对象"><a href="#Application-对象" class="headerlink" title="Application 对象"></a>Application 对象</h3><p><code>Application</code> 对象负责全局配置，包括将请求映射到处理程序的路由表。</p><p>路由表是 <code>URLSpec</code> 对象(或元组)的列表，每个对象都包含(至少)一个正则表达式和一个处理程序类。顺序问题：使用第一个匹配规则。如果正则表达式包含捕获组，那么这些组就是路径参数，并将被传递给处理程序的HTTP方法。如果字典作为 <code>URLSpec</code> 的第三个元素传递，它将提供初始化参数，该参数将被传递给 <code>RequestHandler.initialize</code>。<code>URLSpec</code> 对象也可自定义名称，用于 <code>RequestHandler.reverse_url</code>。</p><p>例如，在这个片段中，根URL <code>/</code> 被映射到 <code>MainHandler</code>，而形式 <code>/story/</code> 后面跟着一个数字的 <code>URL</code> 被映射到 <code>StoryHandler</code>。这个数字被传递(作为字符串)给 <code>StoryHandler.get</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class MainHandler(RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        self.write(&apos;&lt;a href=&quot;%s&quot;&gt;link to story 1&lt;/a&gt;&apos; %</span><br><span class="line">                   self.reverse_url(&quot;story&quot;, &quot;1&quot;))</span><br><span class="line"></span><br><span class="line">class StoryHandler(RequestHandler):</span><br><span class="line">    def initialize(self, db):</span><br><span class="line">        self.db = db</span><br><span class="line"></span><br><span class="line">    def get(self, story_id):</span><br><span class="line">        self.write(&quot;this is story %s&quot; % story_id)</span><br><span class="line"></span><br><span class="line">app = Application([</span><br><span class="line">    url(r&quot;/&quot;, MainHandler),</span><br><span class="line">    url(r&quot;/story/([0-9]+)&quot;, StoryHandler, dict(db=db), name=&quot;story&quot;)</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><p><code>Application</code> 构造函数接受许多关键字参数，这些参数可用于自定义应用程序的行为和启用可选特性；点击 <a href="https://www.tornadoweb.org/en/stable/web.html#tornado.web.Application.settings" target="_blank" rel="noopener">Application.settings</a>，查看完整设置。</p><h3 id="RequestHandler-子类"><a href="#RequestHandler-子类" class="headerlink" title="RequestHandler 子类"></a>RequestHandler 子类</h3><p>Tornado web应用程序的大部分工作都是在 <code>RequestHandler</code> 的子类中完成的。处理程序子类的主要入口点是以被处理的HTTP方法命名的方法: <code>get()</code>、<code>post()</code>等。每个处理程序可以定义一个或多个这样的方法来处理不同的HTTP操作。如上所述，这些方法将被调用，参数与匹配的路由规则的捕获组相对应。</p><p>在处理程序中，调用 <code>RequestHandler.render</code>、<code>RequestHandler.write</code>来产生一个响应。<code>render()</code> 按名称加载模板，并使用给定参数呈现它。<code>write()</code> 用于非基于模板的输出；它接受字符串、字节和字典(dicts将被编码为JSON)。</p><p><code>RequestHandler</code> 中的许多方法被设计成可以在子类中重写，并在整个应用程序中使用。通常定义一个 <code>BaseHandler</code> 类，覆盖 <code>write_error</code> 和 <code>get_current_user</code> 等方法，然后为所有特定的处理程序子类化你自己的 <code>BaseHandler</code> 而不是 <code>RequestHandler</code>。</p><h4 id="处理请求输入"><a href="#处理请求输入" class="headerlink" title="处理请求输入"></a>处理请求输入</h4><p>请求处理程序可以通过 <code>self.request</code> 访问表示当前请求的对象。有关属性的完整列表，请参阅 <a href="https://www.tornadoweb.org/en/stable/httputil.html#tornado.httputil.HTTPServerRequest" target="_blank" rel="noopener">HTTPServerRequest</a> 的类定义。</p><p>HTML表单使用的格式的请求数据将为您解析，并在 <code>get_query_argument</code> 和 <code>get_body_argument</code> 等方法中可用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class MyFormHandler(tornado.web.RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        self.write(&apos;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/myform&quot; method=&quot;POST&quot;&gt;&apos;</span><br><span class="line">                   &apos;&lt;input type=&quot;text&quot; name=&quot;message&quot;&gt;&apos;</span><br><span class="line">                   &apos;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&apos;</span><br><span class="line">                   &apos;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&apos;)</span><br><span class="line"></span><br><span class="line">    def post(self):</span><br><span class="line">        self.set_header(&quot;Content-Type&quot;, &quot;text/plain&quot;)</span><br><span class="line">        self.write(&quot;You wrote &quot; + self.get_body_argument(&quot;message&quot;))</span><br></pre></td></tr></table></figure><p>由于HTML表单编码对于参数是单个值还是包含一个元素的列表是模棱两可的，<code>RequestHandler</code> 提供了不同的方法，允许应用程序指示它是否需要列表。对于列表，使用 <code>get_query_arguments</code> 和 <code>get_body_arguments</code> 而不是它们的单一对应项。</p><p>通过表单上传的文件在 <code>self.request.files</code> 中可用。它将名称 <code>&lt;input type=&quot;file&quot;&gt;</code> 元素映射到一个文件列表。每个文件是一个字典形式 <code>{&quot;filename&quot;:…, &quot;content_type&quot;:……, &quot;body&quot;:…}</code>。<code>files</code> 对象只有在文件上传带有表单包装器(即 <code>multipart/form-data</code> 类型)时才存在;如果未使用此格式，则在 <code>self.request.body</code> 中可以使用原始上传数据。默认情况下，上传的文件在内存中完全缓冲;如果您需要处理太大而不能舒适地保存在内存中的文件，请参阅 <a href="https://www.tornadoweb.org/en/stable/web.html#tornado.web.stream_request_body" target="_blank" rel="noopener">stream_request_body</a> 类装饰器。</p><p>在demos目录中，<a href="https://github.com/tornadoweb/tornado/tree/master/demos/file_upload/" target="_blank" rel="noopener">file_receiver.py</a>显示了两种接收文件上传的方法。</p><p>由于HTML表单编码的奇怪之处(例如，单参数与复数参数之间的模糊性)，Tornado并不试图将表单参数与其他类型的输入统一起来。特别地，我们不解析JSON请求体。希望使用JSON而不是form-encoding的应用程序可以重写 <code>prepare</code> 来解析它们的请求:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def prepare(self):</span><br><span class="line">    if self.request.headers.get(&quot;Content-Type&quot;, &quot;&quot;).startswith(&quot;application/json&quot;):</span><br><span class="line">        self.json_args = json.loads(self.request.body)</span><br><span class="line">    else:</span><br><span class="line">        self.json_args = None</span><br></pre></td></tr></table></figure><h3 id="重写RequestHandler方法"><a href="#重写RequestHandler方法" class="headerlink" title="重写RequestHandler方法"></a>重写RequestHandler方法</h3><p>除了 <code>get()</code>/ <code>post()</code>/等，<code>RequestHandler</code> 中的某些其他方法被设计成在必要时由子类覆盖。在每个请求中，会发生以下调用序列:</p><ul><li>每个请求都会创建一个新的 <code>RequestHandler</code> 对象。</li><li><code>initialize()</code> 使用来自应用程序配置的初始化参数调用。初始化通常应该只保存传递给成员变量的实参;它可能不会产生任何输出或调用 <code>send_error</code> 之类的方法。</li><li><code>prepare()</code> 被调用。这在所有处理程序子类共享的基类中最有用，因为无论使用哪种HTTP方法都将调用 <code>prepare</code>。准备可产生产出;如果它调用<code>finish</code>(或<code>redirect</code>，等等)，处理将在此停止。</li><li>其中一个HTTP方法被调用:<code>get()</code>、<code>post()</code>、<code>put()</code>等等。如果URL正则表达式包含捕获组，则将它们作为参数传递给此方法。</li><li>当请求完成时，调用<code>on_finish()</code>。这通常是在<code>get()</code>或另一个HTTP方法返回之后。</li></ul><p>所有设计要重写的方法都在<code>RequestHandler</code>文档中有这样的说明。一些最常见的覆盖方法包括:</p><ul><li><code>write_error</code> - 输出用于错误页面的HTML。</li><li><code>on_connection_close</code> - 当客户端断开连接时调用;应用程序可以选择检测这种情况并停止进一步处理。请注意，不能保证能够迅速检测到关闭的连接。</li><li><code>get_current_user</code> - 参见<a href="https://www.tornadoweb.org/en/stable/guide/security.html#user-authentication" target="_blank" rel="noopener">User authentication</a>。</li><li><code>get_user_locale</code> - 返回用于当前用户的<code>Locale</code>对象。</li><li><code>set_default_headers</code> - 可以用于设置响应的附加标头(例如自定义<code>Server</code>头)。</li></ul><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果处理程序抛出异常，Tornado将调用<code>RequestHandler.write_error</code>生成一个错误页面。<code>tornado.web.HTTPError</code>可以用来生成指定的状态码;所有其他异常返回一个500状态。</p><p>默认的错误页面包括调试模式下的堆栈跟踪和错误的单行描述(例如:“500: Internal Server Error”)。若要生成自定义错误页面，请覆盖<code>RequestHandler.write_error</code>(可能在所有处理程序共享的基类中)。该方法可以通过<code>write</code>和<code>render</code>等方法正常生成输出。如果错误是由异常引起的，那么将传递一个<code>exc_info</code>三元组作为关键字参数(注意，这个异常不能保证是<code>sys.exc_info</code>，所以<code>write_error</code>必须使用<code>traceback.format_exception</code>代替<code>traceback.format_exc</code>)。</p><p>通过调用<code>set_status</code>编写响应并返回，也可以从常规处理程序方法而不是<code>write_error</code>生成一个错误页面。在简便返回不很方便的情况下<code>tornado.web.Finish</code> 异常会被抛出来终止处理程序而不是抛出<code>write_error</code>。</p><p>对于404错误，使用<code>default_handler_class</code> <code>Application settings</code>。这个处理程序应该覆盖<code>prepare</code>而不是像<code>get()</code>这样更具体的方法，这样它就可以与任何HTTP方法一起工作。它应该像上面描述的那样生成它的错误页面:通过调用<code>HTTPError(404)</code>并覆盖<code>write_error</code>，或者调用<code>self.set_status(404)</code>并在<code>prepare()</code>中直接生成响应。</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>在Tornado中有两种主要的重定向请求的方法:<code>RequestHandler.redirect</code> 和 <code>RedirectHandler</code>。</p><p>您可以在<code>RequestHandler</code>方法中使用<code>self.redirect()</code>将用户重定向到其他地方。还有一个可选参数<code>permanent</code>，您可以使用它来指示重定向被认为是永久性的。<code>permanent</code>的默认值是False，它生成<code>302 Found HTTP</code>响应代码，适合在成功POST请求后重定向用户。如果<code>permanent</code>为True，则使用301移动的永久HTTP响应代码，这在以面向seo的方式重定向到页面的规范URL时很有用。</p><p><code>RedirectHandler</code>允许您在应用程序路由表中直接配置重定向。例如，要配置一个静态重定向:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app = tornado.web.Application([</span><br><span class="line">    url(r&quot;/app&quot;, tornado.web.RedirectHandler,</span><br><span class="line">        dict(url=&quot;http://itunes.apple.com/my-app-id&quot;)),</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><p><code>RedirectHandler</code>也支持正则表达式替换。下面的规则将所有以<code>/pictures/</code>开头的请求重定向到前缀<code>/photos/</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app = tornado.web.Application([</span><br><span class="line">    url(r&quot;/photos/(.*)&quot;, MyPhotoHandler),</span><br><span class="line">    url(r&quot;/pictures/(.*)&quot;, tornado.web.RedirectHandler,</span><br><span class="line">        dict(url=r&quot;/photos/&#123;0&#125;&quot;)),</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><p>不像<code>RequestHandler.redirect</code>，<code>RedirectHandler</code>默认使用永久重定向。这是因为路由表在运行时不会改变，并且被认为是永久的，而在处理程序中发现的重定向很可能是其他可能改变的逻辑的结果。要使用<code>RedirectHandler</code>发送临时重定向，请在<code>RedirectHandler</code>初始化参数中添加<code>permanent=False</code>。</p><h3 id="异步处理类"><a href="#异步处理类" class="headerlink" title="异步处理类"></a>异步处理类</h3><p>某些处理程序方法(包括<code>prepare()</code>和HTTP动词方法<code>get()</code>/ <code>post()</code>/等)可能被重写为协程，以使处理程序异步。</p><p>例如，下面是一个使用协同程序的简单处理程序:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MainHandler(tornado.web.RequestHandler):</span><br><span class="line">    async def get(self):</span><br><span class="line">        http = tornado.httpclient.AsyncHTTPClient()</span><br><span class="line">        response = await http.fetch(&quot;http://friendfeed-api.com/v2/feed/bret&quot;)</span><br><span class="line">        json = tornado.escape.json_decode(response.body)</span><br><span class="line">        self.write(&quot;Fetched &quot; + str(len(json[&quot;entries&quot;])) + &quot; entries &quot;</span><br><span class="line">                   &quot;from the FriendFeed API&quot;)</span><br></pre></td></tr></table></figure><p>关于更高级的异步示例，请查看<a href="https://github.com/tornadoweb/tornado/tree/stable/demos/chat" target="_blank" rel="noopener">聊天示例应用程序</a>，该应用程序使用长轮询实现了一个AJAX聊天室。使用长轮询的用户可能希望覆盖<code>on_connection_close()</code>，以便在客户端关闭连接后进行清理(但请参阅该方法的文档字符串以了解注意事项)。</p><p>Read More:</p><blockquote><p><a href="https://www.tornadoweb.org/en/stable/guide/structure.html" target="_blank" rel="noopener">Structure of a Tornado web application</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Tornado web应用程序通常由一个或多个 &lt;code&gt;RequestHandler&lt;/code&gt; 子类组成，将传入请求路由到处理程序的 &lt;code&gt;Application&lt;/code&gt; 对象，和一个启动服务程序的 &lt;code&gt;main&lt;/code&gt; 方法。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Tornado" scheme="http://runnerliu.github.io/categories/Tornado/"/>
    
    
      <category term="Tornado" scheme="http://runnerliu.github.io/tags/Tornado/"/>
    
      <category term="翻译文档" scheme="http://runnerliu.github.io/tags/%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>学习路线-2020</title>
    <link href="http://runnerliu.github.io/2020/11/29/roadmap-2020/"/>
    <id>http://runnerliu.github.io/2020/11/29/roadmap-2020/</id>
    <published>2020-11-29T12:01:33.000Z</published>
    <updated>2020-12-19T08:46:21.331Z</updated>
    
    <content type="html"><![CDATA[<h3 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h3><p><img src="/images/2020-11-29200200.png" alt="2020-11-29200200.png"></p><p><img src="/images/2020-11-29200201.png" alt="2020-11-29200201.png"></p><p><img src="/images/2020-11-29200202.png" alt="2020-11-29200202.png"></p><p><img src="/images/2020-11-29200203.png" alt="2020-11-29200203.png"></p><h3 id="翻译版"><a href="#翻译版" class="headerlink" title="翻译版"></a>翻译版</h3><p><img src="/images/2020-11-29200200-1.png" alt="2020-11-29200200-1.png"></p><p><img src="/images/2020-11-29200201-1.png" alt="2020-11-29200201-1.png"></p><p><img src="/images/2020-11-29200202-1.png" alt="2020-11-29200202-1.png"></p><p><img src="/images/2020-11-29200203-1.png" alt="2020-11-29200203-1.png"></p><blockquote><p><a href="https://github.com/kamranahmedse/developer-roadmap" target="_blank" rel="noopener">https://github.com/kamranahmedse/developer-roadmap</a></p><p><a href="https://www.w3cschool.cn/article/3131568.html" target="_blank" rel="noopener">https://www.w3cschool.cn/article/3131568.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;英文版&quot;&gt;&lt;a href=&quot;#英文版&quot; class=&quot;headerlink&quot; title=&quot;英文版&quot;&gt;&lt;/a&gt;英文版&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/2020-11-29200200.png&quot; alt=&quot;2020-11-29200200.png&quot;
      
    
    </summary>
    
      <category term="RoadMap" scheme="http://runnerliu.github.io/categories/RoadMap/"/>
    
    
      <category term="RoadMap" scheme="http://runnerliu.github.io/tags/RoadMap/"/>
    
      <category term="学习路线" scheme="http://runnerliu.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>Python库-gevent</title>
    <link href="http://runnerliu.github.io/2020/11/29/python-lib-gevent/"/>
    <id>http://runnerliu.github.io/2020/11/29/python-lib-gevent/</id>
    <published>2020-11-29T11:32:15.000Z</published>
    <updated>2020-11-29T11:34:32.253Z</updated>
    
    <content type="html"><![CDATA[<p>Gevent是一个并发网络库。它的协程是基于greenlet的，并基于libev实现快速事件循环（Linux上是epoll，FreeBSD上是kqueue，Mac OS X上是select）。有了Gevent，协程的使用将无比简单，你根本无须像greenlet一样显式的切换，每当一个协程阻塞时，程序将自动调度，Gevent处理了所有的底层细节。让我们看个例子来感受下吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import gevent</span><br><span class="line"></span><br><span class="line">def test1():</span><br><span class="line">    print(12)</span><br><span class="line">    gevent.sleep(0)</span><br><span class="line">    print(34)</span><br><span class="line"></span><br><span class="line">def test2():</span><br><span class="line">    print(56)</span><br><span class="line">    gevent.sleep(0)</span><br><span class="line">    print(78)</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(test1),</span><br><span class="line">    gevent.spawn(test2),</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>解释下，<code>gevent.spawn()</code>方法会创建一个新的greenlet协程对象，并运行它。<code>gevent.joinall()</code>方法会等待所有传入的greenlet协程运行结束后再退出，这个方法可以接受一个<code>timeout</code>参数来设置超时时间，单位是秒。运行上面的程序，执行顺序如下： </p><ol><li>先进入协程test1，打印12</li><li>遇到<code>gevent.sleep(0)</code>时，test1被阻塞，自动切换到协程test2，打印56</li><li>之后test2被阻塞，这时test1阻塞已结束，自动切换回test1，打印34</li><li>当test1运行完毕返回后，此时test2阻塞已结束，再自动切换回test2，打印78</li><li>所有协程执行完毕，程序退出</li></ol><p>所以，程序运行下来的输出就是： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">56</span><br><span class="line">34</span><br><span class="line">78</span><br></pre></td></tr></table></figure><p>我们换一个更有意义的例子： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">urls = [<span class="string">'www.baidu.com'</span>, <span class="string">'www.gevent.org'</span>, <span class="string">'www.python.org'</span>]</span><br><span class="line">jobs = [gevent.spawn(socket.gethostbyname, url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">gevent.joinall(jobs, timeout=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print([job.value <span class="keyword">for</span> job <span class="keyword">in</span> jobs])</span><br></pre></td></tr></table></figure><p>我们通过协程分别获取三个网站的IP地址，由于打开远程地址会引起IO阻塞，所以gevent会自动调度不同的协程。另外，我们可以通过协程对象的”value”属性，来获取协程函数的返回值。 </p><h4 id="猴子补丁-Monkey-patching"><a href="#猴子补丁-Monkey-patching" class="headerlink" title="猴子补丁 Monkey patching"></a>猴子补丁 Monkey patching</h4><p>其实程序运行的时间同不用协程是一样的，是三个网站打开时间的总和。可是理论上协程是非阻塞的，那运行时间应该等于最长的那个网站打开时间呀？其实这是因为Python标准库里的socket是阻塞式的，DNS解析无法并发，包括像urllib库也一样，所以这种情况下用协程完全没意义。那怎么办？</p><p>一种方法是使用gevent下的socket模块，我们可以通过<code>from gevent import socket</code>来导入。不过更常用的方法是使用猴子布丁（Monkey patching）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from gevent import monkey; monkey.patch_socket()</span><br><span class="line">import gevent</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line">urls = [&apos;www.baidu.com&apos;, &apos;www.gevent.org&apos;, &apos;www.python.org&apos;]</span><br><span class="line">jobs = [gevent.spawn(socket.gethostbyname, url) for url in urls]</span><br><span class="line">gevent.joinall(jobs, timeout=5)</span><br><span class="line"></span><br><span class="line">print([job.value for job in jobs])</span><br></pre></td></tr></table></figure><p>上述代码的第一行就是对socket标准库打上猴子补丁，此后socket标准库中的类和方法都会被替换成非阻塞式的，所有其他的代码都不用修改，这样协程的效率就真正体现出来了。Python中其它标准库也存在阻塞的情况，gevent提供了<code>monkey.patch_all()</code>方法将所有标准库都替换。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from gevent import monkey; monkey.patch_all()</span><br></pre></td></tr></table></figure><p> 使用猴子补丁褒贬不一，但是官网上还是建议使用<code>patch_all()</code>，而且在程序的第一行就执行 。</p><h4 id="获取协程状态"><a href="#获取协程状态" class="headerlink" title="获取协程状态"></a>获取协程状态</h4><p>协程状态有已启动和已停止，分别可以用协程对象的<code>started</code>属性和<code>ready()</code>方法来判断。对于已停止的协程，可以用<code>successful()</code>方法来判断其是否成功运行且没抛异常。如果协程执行完有返回值，可以通过<code>value</code>属性来获取。另外，greenlet协程运行过程中发生的异常是不会被抛出到协程外的，因此需要用协程对象的<code>exception</code>属性来获取协程中的异常。下面的例子很好的演示了各种方法和属性的使用。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">win</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'You win!'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fail</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">'You failed!'</span>)</span><br><span class="line"></span><br><span class="line">winner = gevent.spawn(win)</span><br><span class="line">loser = gevent.spawn(fail)</span><br><span class="line"></span><br><span class="line">print(winner.started) <span class="comment"># True</span></span><br><span class="line">print(loser.started)  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在Greenlet中发生的异常，不会被抛到Greenlet外面。</span></span><br><span class="line"><span class="comment"># 控制台会打出Stacktrace，但程序不会停止</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    gevent.joinall([winner, loser])</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 这段永远不会被执行</span></span><br><span class="line">    print(<span class="string">'This will never be reached'</span>)</span><br><span class="line"></span><br><span class="line">print(winner.ready()) <span class="comment"># True</span></span><br><span class="line">print(loser.ready())  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">print(winner.value) <span class="comment"># 'You win!'</span></span><br><span class="line">print(loser.value)  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line">print(winner.successful()) <span class="comment"># True</span></span><br><span class="line">print(loser.successful())  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里可以通过raise loser.exception 或 loser.get()</span></span><br><span class="line"><span class="comment"># 来将协程中的异常抛出</span></span><br><span class="line">print(loser.exception)</span><br></pre></td></tr></table></figure><h4 id="协程运行超时"><a href="#协程运行超时" class="headerlink" title="协程运行超时"></a>协程运行超时</h4><p>之前我们讲过在<code>gevent.joinall()</code>方法中可以传入<code>timeout</code>参数来设置超时，我们也可以在全局范围内设置超时时间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> Timeout</span><br><span class="line"></span><br><span class="line">timeout = Timeout(<span class="number">2</span>)  <span class="comment"># 2 seconds</span></span><br><span class="line">timeout.start()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">()</span>:</span></span><br><span class="line">    gevent.sleep(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    gevent.spawn(wait).join()</span><br><span class="line"><span class="keyword">except</span> Timeout:</span><br><span class="line">    traceback.print_exc()</span><br><span class="line">    print(<span class="string">'Could not complete'</span>)</span><br></pre></td></tr></table></figure><p>上例中，我们将超时设为2秒，此后所有协程的运行，如果超过两秒就会抛出<code>Timeout</code>异常。我们也可以将超时设置在with语句内，这样该设置只在with语句块中有效：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> Timeout(<span class="number">1</span>):</span><br><span class="line">    gevent.sleep(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>此外，我们可以指定超时所抛出的异常，来替换默认的<code>Timeout</code>异常。比如下例中超时就会抛出我们自定义的<code>TooLong</code>异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TooLong</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Timeout(<span class="number">1</span>, TooLong):</span><br><span class="line">    gevent.sleep(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h4 id="协程间通讯"><a href="#协程间通讯" class="headerlink" title="协程间通讯"></a>协程间通讯</h4><p>greenlet协程间的异步通讯可以使用事件（Event）对象。该对象的<code>wait()</code>方法可以阻塞当前协程，而<code>set()</code>方法可以唤醒之前阻塞的协程。在下面的例子中，5个waiter协程都会等待事件evt，当setter协程在3秒后设置evt事件，所有的waiter协程即被唤醒。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent.event <span class="keyword">import</span> Event</span><br><span class="line"></span><br><span class="line">evt = Event()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setter</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Wait for me'</span>)</span><br><span class="line">    gevent.sleep(<span class="number">3</span>)  <span class="comment"># 3秒后唤醒所有在evt上等待的协程</span></span><br><span class="line">    print(<span class="string">"Ok, I'm done"</span>)</span><br><span class="line">    evt.set()  <span class="comment"># 唤醒</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">waiter</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I'll wait for you"</span>)</span><br><span class="line">    evt.wait()  <span class="comment"># 等待</span></span><br><span class="line">    print(<span class="string">'Finish waiting'</span>)</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(setter),</span><br><span class="line">    gevent.spawn(waiter),</span><br><span class="line">    gevent.spawn(waiter),</span><br><span class="line">    gevent.spawn(waiter),</span><br><span class="line">    gevent.spawn(waiter),</span><br><span class="line">    gevent.spawn(waiter)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>除了Event事件外，gevent还提供了<code>AsyncResult</code>事件，它可以在唤醒时传递消息。让我们将上例中的<code>setter</code>和<code>waiter</code>作如下改动:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent.event <span class="keyword">import</span> AsyncResult</span><br><span class="line"></span><br><span class="line">aevt = AsyncResult()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setter</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Wait for me'</span>)</span><br><span class="line">    gevent.sleep(<span class="number">3</span>)  <span class="comment"># 3秒后唤醒所有在evt上等待的协程</span></span><br><span class="line">    print(<span class="string">"Ok, I'm done"</span>)</span><br><span class="line">    aevt.set(<span class="string">'Hello!'</span>)  <span class="comment"># 唤醒，并传递消息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">waiter</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I'll wait for you"</span>)</span><br><span class="line">    message = aevt.get()  <span class="comment"># 等待，并在唤醒时获取消息</span></span><br><span class="line">    print(<span class="string">'Got wake up message: %s'</span> % message)</span><br></pre></td></tr></table></figure><h4 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 Queue</h4><p>队列Queue的概念相信大家都知道，我们可以用它的<code>put</code>和<code>get</code>方法来存取队列中的元素。gevent的队列对象可以让greenlet协程之间安全的访问。运行下面的程序，你会看到3个消费者会分别消费队列中的产品，且消费过的产品不会被另一个消费者再取到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent.queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line">products = Queue()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> products.empty():</span><br><span class="line">        print(<span class="string">'%s got product %s'</span> % (name, products.get()))</span><br><span class="line">        gevent.sleep(<span class="number">0</span>)</span><br><span class="line">    print(<span class="string">'%s Quit'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        products.put(i)</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(producer),</span><br><span class="line">    gevent.spawn(consumer, <span class="string">'steve'</span>),</span><br><span class="line">    gevent.spawn(consumer, <span class="string">'john'</span>),</span><br><span class="line">    gevent.spawn(consumer, <span class="string">'nancy'</span>),</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p><code>put</code>和<code>get</code>方法都是阻塞式的，它们都有非阻塞的版本：<code>put_nowait</code>和<code>get_nowait</code>。如果调用<code>get</code>方法时队列为空，则抛出<code>gevent.queue.Empty</code>异常。</p><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>信号量可以用来限制协程并发的个数。它有两个方法，<code>acquire</code>和<code>release</code>。顾名思义，<code>acquire</code>就是获取信号量，而<code>release</code>就是释放。当所有信号量都已被获取，那剩余的协程就只能等待任一协程释放信号量后才能得以运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent.coros <span class="keyword">import</span> BoundedSemaphore</span><br><span class="line"></span><br><span class="line">sem = BoundedSemaphore(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(n)</span>:</span></span><br><span class="line">    sem.acquire()</span><br><span class="line">    print(<span class="string">'Worker %i acquired semaphore'</span> % n)</span><br><span class="line">    gevent.sleep(<span class="number">0</span>)</span><br><span class="line">    sem.release()</span><br><span class="line">    print(<span class="string">'Worker %i released semaphore'</span> % n)</span><br><span class="line"></span><br><span class="line">gevent.joinall([gevent.spawn(worker, i) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, <span class="number">6</span>)])</span><br></pre></td></tr></table></figure><p>上面的例子中，我们初始化了<code>BoundedSemaphore</code>信号量，并将其个数定为<code>2</code>。所以同一个时间，只能有两个worker协程被调度。程序运行后的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Worker 0 acquired semaphore</span><br><span class="line">Worker 1 acquired semaphore</span><br><span class="line">Worker 0 released semaphore</span><br><span class="line">Worker 1 released semaphore</span><br><span class="line">Worker 2 acquired semaphore</span><br><span class="line">Worker 3 acquired semaphore</span><br><span class="line">Worker 2 released semaphore</span><br><span class="line">Worker 3 released semaphore</span><br><span class="line">Worker 4 acquired semaphore</span><br><span class="line">Worker 4 released semaphore</span><br><span class="line">Worker 5 acquired semaphore</span><br><span class="line">Worker 5 released semaphore</span><br></pre></td></tr></table></figure><p>如果信号量个数为1，那就等同于同步锁。</p><h4 id="协程本地变量"><a href="#协程本地变量" class="headerlink" title="协程本地变量"></a>协程本地变量</h4><p>同线程类似，协程也有本地变量，也就是只在当前协程内可被访问的变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent.local <span class="keyword">import</span> local</span><br><span class="line"></span><br><span class="line">data = local()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    data.x = <span class="number">1</span></span><br><span class="line">    print(data.x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(data.x)</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        print(<span class="string">'x is not visible'</span>)</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(f1),</span><br><span class="line">    gevent.spawn(f2)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>通过将变量存放在<code>local</code>对象中，即可将其的作用域限制在当前协程内，当其他协程要访问该变量时，就会抛出异常。不同协程间可以有重名的本地变量，而且互相不影响。因为协程本地变量的实现，就是将其存放在以的<code>greenlet.getcurrent()</code>的返回为键值的私有的命名空间内。</p><p>Read More:</p><ol><li><a href="http://www.bjhee.com/gevent.html" target="_blank" rel="noopener">基于协程的Python网络库gevent介绍</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Gevent是一个并发网络库。它的协程是基于greenlet的，并基于libev实现快速事件循环（Linux上是epoll，FreeBSD上是kqueue，Mac OS X上是select）。有了Gevent，协程的使用将无比简单，你根本无须像greenlet一样显式的切换
      
    
    </summary>
    
      <category term="Python" scheme="http://runnerliu.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://runnerliu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python库-celery</title>
    <link href="http://runnerliu.github.io/2020/11/18/python-lib-celery/"/>
    <id>http://runnerliu.github.io/2020/11/18/python-lib-celery/</id>
    <published>2020-11-18T06:31:44.000Z</published>
    <updated>2020-11-22T11:50:10.675Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个分布式异步计算框架，Celery虽然常用于Web框架中，但也可以单独使用。常规搭配的消息队列是RabbitMQ、Redis。</p><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ tree your_project</span><br><span class="line">your_project</span><br><span class="line">├── __init__.py</span><br><span class="line">├── celery.py</span><br><span class="line">├── config.py</span><br><span class="line">└── tasks.py</span><br><span class="line"></span><br><span class="line">0 directories, 4 files</span><br></pre></td></tr></table></figure><p>其中<code>celery.py</code>是主文件，定义celery app，<code>config.py</code>是celery的配置，<code>tasks.py</code> 是异步任务的具体实现。</p><p><code>celery.py</code>文件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from __funture__ import absolute_import</span><br><span class="line">from celery import Celery, platform</span><br><span class="line"></span><br><span class="line">platform.C_FORCE_ROOT = true</span><br><span class="line"></span><br><span class="line">app = Celery(&apos;your project name&apos;)</span><br><span class="line">app.config_from_object(config)</span><br></pre></td></tr></table></figure><p><code>config.py</code>文件内容可参考下一节</p><p><code>tasks.py</code>文件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from __funture__ import absolute_import</span><br><span class="line"></span><br><span class="line">from .app import app</span><br><span class="line"></span><br><span class="line">@app.task</span><br><span class="line">def add(x, y):</span><br><span class="line">    return x + y</span><br><span class="line">    </span><br><span class="line">@app.task</span><br><span class="line">def sub(x, y):</span><br><span class="line">    return x - y</span><br></pre></td></tr></table></figure><p>运行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup /usr/local/python3.6/bin/python3.6 -m celery worker --loglevel=DEBUG --app=$&#123;PROGRAM_NAME&#125; --queues=$1 --hostname=$2 --pidfile=$3 1&gt;/dev/null 2&gt;/dev/null &amp;</span><br></pre></td></tr></table></figure><p>其中运行可参考后续章节。</p><h4 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h4><p>一次Task从触发到完成，序列图如下：</p><p><img src="/images/2020-11-22194305.jpg" alt="2020-11-22194305.png"></p><p>其中，<code>main</code>代表业务代码主进程。它可能是Django、Flask这类Web服务，也可能是一个其它类型的进程。<code>worker</code>就是指Celery的Worker。</p><p><code>main</code>发送消息后，会得到一个<code>AsyncResult</code>，其中包含<code>task_id</code>。仅通过<code>task_id</code>，也可以自己构造一个<code>AsyncResult</code>，查询相关信息。其中，代表运行过程的，主要是<code>state</code>。</p><p><code>worker</code>会持续保持对Redis（或其它消息队列，如RabbitMQ）的关注，查询新的消息。如果获得新消息，将其消费后，开始运行<code>do_sth</code>。</p><p>运行完成会把返回值对应的结果，以及一些运行信息，回写到Redis（或其它backend，如Django数据库等）上。在系统的任何地方，通过对应的<code>AsyncResult(task_id)</code>就可以查询到结果。</p><h4 id="celery-task的状态"><a href="#celery-task的状态" class="headerlink" title="celery task的状态"></a>celery task的状态</h4><p><img src="/images/2020-11-22194435.jpg" alt="2020-11-22194435.png"></p><p>其中，除<code>SUCCESS</code>外，还有失败（<code>FAILURE</code>）、取消（<code>REVOKED</code>）两个结束状态。而<code>RETRY</code>则是在设置了重试机制后，进入的临时等待状态。</p><p>另外，如果保存在Redis的结果信息被清理（默认仅保存1天），那么任务状态又会变成<code>PENDING</code>。这在设计上是个巨大的问题，使用时要做对应容错。</p><h4 id="celery常用配置"><a href="#celery常用配置" class="headerlink" title="celery常用配置"></a>celery常用配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># 指定任务接受的内容类型(序列化)</span><br><span class="line"># pickle/json/yaml/msgpack</span><br><span class="line">CELERY_ACCEPT_CONTENT = [&apos;json&apos;]</span><br><span class="line"></span><br><span class="line"># 时区</span><br><span class="line">CELERY_TIMEZONE = &apos;Asia/Shanghai&apos;</span><br><span class="line"></span><br><span class="line"># 调度任务</span><br><span class="line">CELERY_INCLUDE = [&apos;celerys.task&apos;]</span><br><span class="line"></span><br><span class="line"># 调度器 </span><br><span class="line">CELERYBEAT_SCHEDULER = &apos;celery.beat:PersistentScheduler&apos;</span><br><span class="line"></span><br><span class="line"># 调度器存储最后运行定时任务的时间</span><br><span class="line">CELERYBEAT_SCHEDULE_FILENAME = &apos;log/celery.db&apos;</span><br><span class="line"></span><br><span class="line"># 消息代理</span><br><span class="line">BROKER_URL = LBT_CONFIG_OTHER[&apos;BROKER_URL&apos;]</span><br><span class="line"></span><br><span class="line"># 广播前缀设置，由仅活动的虚拟机接收任务消息</span><br><span class="line">BROKER_TRANSPORT_OPTIONS = &#123;&apos;fanout_prefix&apos;: True&#125;</span><br><span class="line"></span><br><span class="line"># 结果存储地址</span><br><span class="line">CELERY_RESULT_BACKEND = BROKER_URL</span><br><span class="line"></span><br><span class="line"># 任务执行结果序列化方式</span><br><span class="line">CELERY_RESULT_SERIALIZER = &apos;json&apos;</span><br><span class="line"></span><br><span class="line"># 结果是否持久化，默认关闭</span><br><span class="line">CELERY_RESULT_PERSISTENT = False</span><br><span class="line"></span><br><span class="line"># 任务过期时间，单位秒</span><br><span class="line">CELERY_TASK_RESULT_EXPIRES = 60 * 60</span><br><span class="line"></span><br><span class="line"># 任务序列化方式</span><br><span class="line">CELERY_TASK_SERIALIZER = &apos;json&apos;</span><br><span class="line"></span><br><span class="line"># 任务执行最大时间，单位秒，超过会将worker杀死</span><br><span class="line">CELERY_TASK_TIME_LIMIT = 60 * 60</span><br><span class="line"></span><br><span class="line"># 不关心任务执行结果，无需持久化结果</span><br><span class="line">CELERY_TASK_IGNORE_RESULT = True</span><br><span class="line"></span><br><span class="line"># 并发worker数量，默认为cpu核数</span><br><span class="line">CELERYD_CONCURRENCY = 6</span><br><span class="line"></span><br><span class="line"># worker被杀死前执行的最大任务数</span><br><span class="line">CELERYD_MAX_TASKS_PER_CHILD = 1024</span><br><span class="line"></span><br><span class="line"># redis最大连接数</span><br><span class="line">CELERY_REDIS_MAX_CONNECTIONS = 1024</span><br></pre></td></tr></table></figure><p>更多配置参数请移步<a href="https://docs.celeryproject.org/en/stable/userguide/configuration.html" target="_blank" rel="noopener">Configuration and defaults</a></p><h4 id="worker命令行参数"><a href="#worker命令行参数" class="headerlink" title="worker命令行参数"></a>worker命令行参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">Global Options:</span><br><span class="line">  -A APP, --app APP</span><br><span class="line">  -b BROKER, --broker BROKER</span><br><span class="line">  --result-backend RESULT_BACKEND</span><br><span class="line">  --loader LOADER</span><br><span class="line">  --config CONFIG</span><br><span class="line">  --workdir WORKDIR     Optional directory to change to after detaching.</span><br><span class="line">  --no-color, -C</span><br><span class="line">  --quiet, -q</span><br><span class="line"></span><br><span class="line">Worker Options:</span><br><span class="line">  -n HOSTNAME, --hostname HOSTNAME</span><br><span class="line">                        Set custom hostname (e.g., &apos;w1@%h&apos;). Expands: %h</span><br><span class="line">                        (hostname), %n (name) and %d, (domain).</span><br><span class="line">  -D, --detach          Start worker as a background process.</span><br><span class="line">  -S STATEDB, --statedb STATEDB</span><br><span class="line">                        Path to the state database. The extension &apos;.db&apos; may be</span><br><span class="line">                        appended to the filename. Default: None</span><br><span class="line">  -l LOGLEVEL, --loglevel LOGLEVEL</span><br><span class="line">                        Logging level, choose between DEBUG, INFO, WARNING,</span><br><span class="line">                        ERROR, CRITICAL, or FATAL.</span><br><span class="line">  -O OPTIMIZATION</span><br><span class="line">  --prefetch-multiplier PREFETCH_MULTIPLIER</span><br><span class="line">                        Set custom prefetch multiplier value for this worker</span><br><span class="line">                        instance.</span><br><span class="line"></span><br><span class="line">Pool Options:</span><br><span class="line">  -c CONCURRENCY, --concurrency CONCURRENCY</span><br><span class="line">                        Number of child processes processing the queue. The</span><br><span class="line">                        default is the number of CPUs available on your</span><br><span class="line">                        system.</span><br><span class="line">  -P POOL, --pool POOL  Pool implementation: prefork (default), eventlet,</span><br><span class="line">                        gevent, threads or solo. 注意：threads只能在4.4.0以上版本使用</span><br><span class="line">  -E, --task-events, --events</span><br><span class="line">                        Send task-related events that can be captured by</span><br><span class="line">                        monitors like celery events, celerymon, and others.</span><br><span class="line">  --time-limit TIME_LIMIT</span><br><span class="line">                        Enables a hard time limit (in seconds int/float) for</span><br><span class="line">                        tasks.</span><br><span class="line">  --soft-time-limit SOFT_TIME_LIMIT</span><br><span class="line">                        Enables a soft time limit (in seconds int/float) for</span><br><span class="line">                        tasks.</span><br><span class="line">  --max-tasks-per-child MAX_TASKS_PER_CHILD, --maxtasksperchild MAX_TASKS_PER_CHILD</span><br><span class="line">                        Maximum number of tasks a pool worker can execute</span><br><span class="line">                        before it&apos;s terminated and replaced by a new worker.</span><br><span class="line">  --max-memory-per-child MAX_MEMORY_PER_CHILD, --maxmemperchild MAX_MEMORY_PER_CHILD</span><br><span class="line">                        Maximum amount of resident memory, in KiB, that may be</span><br><span class="line">                        consumed by a child process before it will be replaced</span><br><span class="line">                        by a new one. If a single task causes a child process</span><br><span class="line">                        to exceed this limit, the task will be completed and</span><br><span class="line">                        the child process will be replaced afterwards.</span><br><span class="line">                        Default: no limit.</span><br><span class="line"></span><br><span class="line">Queue Options:</span><br><span class="line">  --purge, --discard    Purges all waiting tasks before the daemon is started.</span><br><span class="line">                        **WARNING**: This is unrecoverable, and the tasks will</span><br><span class="line">                        be deleted from the messaging server.</span><br><span class="line">  --queues QUEUES, -Q QUEUES</span><br><span class="line">                        List of queues to enable for this worker, separated by</span><br><span class="line">                        comma. By default all configured queues are enabled.</span><br><span class="line">                        Example: -Q video,image</span><br><span class="line">  --exclude-queues EXCLUDE_QUEUES, -X EXCLUDE_QUEUES</span><br><span class="line">                        List of queues to disable for this worker, separated</span><br><span class="line">                        by comma. By default all configured queues are</span><br><span class="line">                        enabled. Example: -X video,image.</span><br><span class="line">  --include INCLUDE, -I INCLUDE</span><br><span class="line">                        Comma separated list of additional modules to import.</span><br><span class="line">                        Example: -I foo.tasks,bar.tasks</span><br><span class="line"></span><br><span class="line">Features:</span><br><span class="line">  --without-gossip      Don&apos;t subscribe to other workers events.</span><br><span class="line">  --without-mingle      Don&apos;t synchronize with other workers at start-up.</span><br><span class="line">  --without-heartbeat   Don&apos;t send event heartbeats.</span><br><span class="line">  --heartbeat-interval HEARTBEAT_INTERVAL</span><br><span class="line">                        Interval in seconds at which to send worker heartbeat</span><br><span class="line">  --autoscale AUTOSCALE</span><br><span class="line">                        Enable autoscaling by providing max_concurrency,</span><br><span class="line">                        min_concurrency. Example:: --autoscale=10,3 (always</span><br><span class="line">                        keep 3 processes, but grow to 10 if necessary)</span><br><span class="line"></span><br><span class="line">Daemonization Options:</span><br><span class="line">  -f LOGFILE, --logfile LOGFILE</span><br><span class="line">                        Path to log file. If no logfile is specified, stderr</span><br><span class="line">                        is used.</span><br><span class="line">  --pidfile PIDFILE     Optional file used to store the process pid. The</span><br><span class="line">                        program won&apos;t start if this file already exists and</span><br><span class="line">                        the pid is still alive.</span><br><span class="line">  --uid UID             User id, or user name of the user to run as after</span><br><span class="line">                        detaching.</span><br><span class="line">  --gid GID             Group id, or group name of the main group to change to</span><br><span class="line">                        after detaching.</span><br><span class="line">  --umask UMASK         Effective umask(1) (in octal) of the process after</span><br><span class="line">                        detaching. Inherits the umask(1) of the parent process</span><br><span class="line">                        by default.</span><br><span class="line">  --executable EXECUTABLE</span><br><span class="line">                        Executable to use for the detached process.</span><br><span class="line"></span><br><span class="line">Embedded Beat Options:</span><br><span class="line">  -B, --beat            Also run the celery beat periodic task scheduler.</span><br><span class="line">                        Please note that there must only be one instance of</span><br><span class="line">                        this service. .. note:: -B is meant to be used for</span><br><span class="line">                        development purposes. For production environment, you</span><br><span class="line">                        need to start celery beat separately.</span><br><span class="line">  -s SCHEDULE_FILENAME, --schedule-filename SCHEDULE_FILENAME, --schedule SCHEDULE_FILENAME</span><br><span class="line">                        Path to the schedule database if running with the -B</span><br><span class="line">                        option. Defaults to celerybeat-schedule. The extension</span><br><span class="line">                        &quot;.db&quot; may be appended to the filename. Apply</span><br><span class="line">                        optimization profile. Supported: default, fair</span><br><span class="line">  --scheduler SCHEDULER</span><br><span class="line">                        Scheduler class to use. Default is</span><br><span class="line">                        celery.beat.PersistentScheduler</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一个分布式异步计算框架，Celery虽然常用于Web框架中，但也可以单独使用。常规搭配的消息队列是RabbitMQ、Redis。&lt;/p&gt;
&lt;h4 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Python" scheme="http://runnerliu.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://runnerliu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令-jq</title>
    <link href="http://runnerliu.github.io/2020/11/12/linuxjq/"/>
    <id>http://runnerliu.github.io/2020/11/12/linuxjq/</id>
    <published>2020-11-12T11:31:04.000Z</published>
    <updated>2020-11-15T03:16:40.077Z</updated>
    
    <content type="html"><![CDATA[<p>jq可以对json数据进行分片、过滤、映射和转换，和sed、awk、grep等命令一样，都可以让你轻松地把玩文本。它能轻松地把你拥有的数据转换成你期望的格式，而且需要写的程序通常也比你期望的更加简短。github地址：<a href="https://stedolan.github.io/jq/" target="_blank" rel="noopener">https://stedolan.github.io/jq/</a></p><p>json示例文件jq.txt为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;&quot;name&quot;:&quot;站长工具&quot;,&quot;url&quot;:&quot;http://tool.chinaz.com&quot;,&quot;address&quot;:&#123;&quot;city&quot;:&quot;厦门&quot;,&quot;country&quot;:&quot;中国&quot;&#125;,&quot;arrayBrowser&quot;:[&#123;&quot;name&quot;:&quot;Google&quot;,&quot;url&quot;:&quot;http://www.google.com&quot;&#125;,&#123;&quot;name&quot;:&quot;Baidu&quot;,&quot;url&quot;&quot;http://www.baidu.com&quot;&#125;]&#125;,&#123;&quot;name&quot;:&quot;站长之家&quot;,&quot;url&quot;:&quot;http://tool.zzhome.com&quot;,&quot;address&quot;:&#123;&quot;city&quot;:&quot;大连&quot;,&quot;country&quot;:&quot;中国&quot;&#125;,&quot;arrayBrowser&quot;:[&#123;&quot;name&quot;:&quot;360&quot;,&quot;url&quot;:&quot;http://www.so.com&quot;&#125;,&#123;&quot;nme&quot;:&quot;bing&quot;,&quot;url&quot;:&quot;http://www.bing.com&quot;&#125;]&#125;]</span><br></pre></td></tr></table></figure><p>命令：<code>cat jq.txt|jq &#39;.&#39;</code></p><p>效果如下：</p><p><img src="/images/2020-11-15T103330.png" alt="2020-11-15T103330.png"></p><p>输出列表中的第一个元素，可以使用[index]：</p><p>命令：<code>cat jq.txt|jq &#39;.[0]&#39;</code></p><p>效果如下：</p><p><img src="/images/2020-11-15T103331.png" alt="2020-11-15T103331.png"></p><p>jq支持管道线<code>|</code>，它如同linux命令中的管道线——把前面命令的输出当作是后面命令的输入。如下命令把<code>.[0]</code>作为<code>{...}</code>的输入，进而访问嵌套的属性，如<code>.name</code>和<code>.address.city</code>。</p><p>命令：<code>cat jq.txt |jq &#39;.[0] | {name:.name,address:.address}&#39;</code></p><p>效果如下：</p><p><img src="/images/2020-11-15T103332.png" alt="2020-11-15T103332.png"></p><p>命令：<code>cat jq.txt |jq &#39;.[0] | {name:.name,city:.address.city}&#39;</code></p><p>效果如下：</p><p><img src="/images/2020-11-15T103333.png" alt="2020-11-15T103333.png"></p><p>命令：<code>cat jq.txt |jq &#39;.[0] | {name:.arrayBrowser[1],city:.address.city}&#39;</code></p><p>效果如下：</p><p><img src="/images/2020-11-15T103334.png" alt="2020-11-15T103334.png"></p><p>如果希望把jq的输出当作一个数组，可以在前后加上<code>[]</code>：</p><p>命令：<code>cat jq.txt |jq &quot;[.[] |{name:.arrayBrowser[1].name,city:.address.city}]&quot;</code></p><p>效果如下：</p><p><img src="/images/2020-11-15T103336.png" alt="2020-11-15T103336.png"></p><p>在{}中，冒号前面的名字是映射的名称，你可以任意修改，如： </p><p>命令：<code>cat jq.txt |jq &quot;[.[] |{name_001:.arrayBrowser[1].name,city_002:.address.city}]&quot;</code></p><p>效果如下：</p><p><img src="/images/2020-11-15T103335.png" alt="2020-11-15T103335.png"></p><p>参考：</p><blockquote><p><a href="https://www.jianshu.com/p/6de3cfdbdb0e" target="_blank" rel="noopener">给力的linux命令–jq简易教程</a></p><p><a href="http://einverne.github.io/post/2018/12/jq-command-line-json-processor.html" target="_blank" rel="noopener">每天学习一个命令：jq 命令行下处理 JSON</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;jq可以对json数据进行分片、过滤、映射和转换，和sed、awk、grep等命令一样，都可以让你轻松地把玩文本。它能轻松地把你拥有的数据转换成你期望的格式，而且需要写的程序通常也比你期望的更加简短。github地址：&lt;a href=&quot;https://stedolan.gi
      
    
    </summary>
    
      <category term="Linux/Unix" scheme="http://runnerliu.github.io/categories/Linux-Unix/"/>
    
    
      <category term="命令" scheme="http://runnerliu.github.io/tags/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Linux" scheme="http://runnerliu.github.io/tags/Linux/"/>
    
      <category term="jq" scheme="http://runnerliu.github.io/tags/jq/"/>
    
  </entry>
  
  <entry>
    <title>Python库-watchdog</title>
    <link href="http://runnerliu.github.io/2020/11/11/python-lib-watchdog/"/>
    <id>http://runnerliu.github.io/2020/11/11/python-lib-watchdog/</id>
    <published>2020-11-11T01:56:04.000Z</published>
    <updated>2020-11-15T02:26:10.629Z</updated>
    
    <content type="html"><![CDATA[<p>库地址：<a href="https://pypi.org/project/watchdog/" target="_blank" rel="noopener">pypi</a> <a href="https://github.com/gorakhargosh/watchdog" target="_blank" rel="noopener">github</a></p><p>库功能：文件监控</p><p>使用示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">from watchdog.events import FileSystemEventHandler</span><br><span class="line">from watchdog.observers import Observer</span><br><span class="line"></span><br><span class="line">class FileEventHandler(FileSystemEventHandler):</span><br><span class="line">    </span><br><span class="line">    def __init__(self, callback_func):</span><br><span class="line">        super(FileEventHandler, self).__init__()</span><br><span class="line">        self.callback_func = callback_func</span><br><span class="line"></span><br><span class="line">def on_moved(self, event):</span><br><span class="line">        what = &apos;directory&apos; if event.is_directory else &apos;file&apos;</span><br><span class="line">        self.callback_func(src_path, what)</span><br><span class="line"></span><br><span class="line">    def on_created(self, event):</span><br><span class="line">        what = &apos;directory&apos; if event.is_directory else &apos;file&apos;</span><br><span class="line">        self.callback_func(src_path, what)</span><br><span class="line"></span><br><span class="line">    def on_deleted(self, event):</span><br><span class="line">        what = &apos;directory&apos; if event.is_directory else &apos;file&apos;</span><br><span class="line">        self.callback_func(src_path, what)</span><br><span class="line"></span><br><span class="line">    def on_modified(self, event):</span><br><span class="line">        what = &apos;directory&apos; if event.is_directory else &apos;file&apos;</span><br><span class="line">        self.callback_func(src_path, what)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TaskHandler(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.file_observer = None</span><br><span class="line">        self.file_observer_path = None</span><br><span class="line"></span><br><span class="line">    def observer_start(self):</span><br><span class="line">        if not os.path.exists(self.file_observer_path):</span><br><span class="line">            os.makedirs(self.file_observer_path)</span><br><span class="line">        event_handler = FileEventHandler(self.callback)</span><br><span class="line">        self.file_observer = Observer()</span><br><span class="line">        self.file_observer.schedule(event_handler, self.file_observer_path)</span><br><span class="line">        self.file_observer.start()</span><br><span class="line"></span><br><span class="line">    def observer_stop(self):</span><br><span class="line">        if self.file_observer:</span><br><span class="line">            self.file_observer.stop()</span><br><span class="line">            self.file_observer.join()</span><br><span class="line">    </span><br><span class="line">    def observer_restart(self):</span><br><span class="line">        self.observer_stop()</span><br><span class="line">        self.observer_start()</span><br><span class="line"></span><br><span class="line">    def callback(self, src_path):</span><br><span class="line">        self.logger.debug(&apos;file changed. &#123;&#125;&apos;.format(src_path))</span><br><span class="line">        </span><br><span class="line">    def run(self):</span><br><span class="line">        self.observer_start()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;库地址：&lt;a href=&quot;https://pypi.org/project/watchdog/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pypi&lt;/a&gt; &lt;a href=&quot;https://github.com/gorakhargosh/watchdo
      
    
    </summary>
    
      <category term="Python" scheme="http://runnerliu.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://runnerliu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python常见异常</title>
    <link href="http://runnerliu.github.io/2020/11/10/python-except-enum/"/>
    <id>http://runnerliu.github.io/2020/11/10/python-except-enum/</id>
    <published>2020-11-10T09:19:12.000Z</published>
    <updated>2020-11-15T02:24:39.477Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TypeError"><a href="#TypeError" class="headerlink" title="TypeError"></a>TypeError</h4><p><code>&#39;builtin_function_or_method&#39; object is not subscriptable</code></p><p>此异常一般是上下文代码中有语法错误，缺少()。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;TypeError&quot;&gt;&lt;a href=&quot;#TypeError&quot; class=&quot;headerlink&quot; title=&quot;TypeError&quot;&gt;&lt;/a&gt;TypeError&lt;/h4&gt;&lt;p&gt;&lt;code&gt;&amp;#39;builtin_function_or_method&amp;#39;
      
    
    </summary>
    
      <category term="Python" scheme="http://runnerliu.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://runnerliu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Linux CentOS 系统时间校对</title>
    <link href="http://runnerliu.github.io/2020/10/27/linux-centos-sys-time/"/>
    <id>http://runnerliu.github.io/2020/10/27/linux-centos-sys-time/</id>
    <published>2020-10-27T14:28:58.000Z</published>
    <updated>2020-11-15T02:24:39.470Z</updated>
    
    <content type="html"><![CDATA[<h4 id="CentOS系统时间、时区查看"><a href="#CentOS系统时间、时区查看" class="headerlink" title="CentOS系统时间、时区查看"></a>CentOS系统时间、时区查看</h4><p>查看系统时间：date</p><p>查看硬件时间：hwclock</p><p>查看系统详细时间：timedatectl</p><p>查看系统所有时区：timedatectl list-timezones</p><p>将硬件时钟调整为与本地时钟一致：timedatectl set-local-rtc 1（其中 0 表示UTC时间）</p><p>设置系统时区为上海：timedatectl set-timezone Asia/Shanghai</p><h4 id="校正系统时间"><a href="#校正系统时间" class="headerlink" title="校正系统时间"></a>校正系统时间</h4><p>确认是否安装utpdate工具：<code>yum list installed|grep ntpdate</code></p><p>如未安装，需执行 <code>yum -y install ntpdate</code> </p><p>执行 <code>ntpdate -u  pool.ntp.org</code> 进行时间校正</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;CentOS系统时间、时区查看&quot;&gt;&lt;a href=&quot;#CentOS系统时间、时区查看&quot; class=&quot;headerlink&quot; title=&quot;CentOS系统时间、时区查看&quot;&gt;&lt;/a&gt;CentOS系统时间、时区查看&lt;/h4&gt;&lt;p&gt;查看系统时间：date&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="Linux" scheme="http://runnerliu.github.io/categories/Linux/"/>
    
    
      <category term="CentOS" scheme="http://runnerliu.github.io/tags/CentOS/"/>
    
      <category term="系统时间" scheme="http://runnerliu.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/"/>
    
      <category term="Linux" scheme="http://runnerliu.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>GF-CLI学习系列</title>
    <link href="http://runnerliu.github.io/2020/10/27/gf-cli-series-0-md/"/>
    <id>http://runnerliu.github.io/2020/10/27/gf-cli-series-0-md/</id>
    <published>2020-10-27T07:13:50.000Z</published>
    <updated>2020-11-15T02:24:39.465Z</updated>
    
    <content type="html"><![CDATA[<h4 id="gen"><a href="#gen" class="headerlink" title="gen"></a>gen</h4><p>该命令用以自动化从数据库直接生成模型文件。</p><p>该命令将会根据数据表名（注意：所以要先在数据里建好表）生成对应的目录，该目录名称即数据表包名。</p><p>目录下自动生成3个文件：</p><ul><li>数据表名.go 自定义文件，开发者可以自由定义填充的代码文件，仅会生成一次，每一次模型生成不会覆盖</li><li>数据表名_entity.go 表结构文件，根据数据表结构生成的结构体定义文件，包含字段注释。数据表在外部变更后，可使用gen命令重复生成更新该文件</li><li>数据表名_model.go 表模型文件，为数据表提供了许多便捷的CURD操作方法，并可直接查询返回该表的结构体对象。数据表在外部变更后，可使用gen命令重复生成更新该文件</li></ul><p>使用方式：<code>gf gen model ./app/model -c config/config.toml -p sys_ -t sys_users</code></p><p>命令说明：</p><ul><li>./app/model：在model生成的路径</li><li>-c config/config.toml：在这个配置里找database数据库连接配置 需要写好mysql的配置信息</li><li>-p sys_：去除生成文件目录的sys前缀 如果不加这个参数就会按数据库名生成目录和文件名 如：sys_users</li><li>-t sys_users：要生成model的数据表文件名</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;gen&quot;&gt;&lt;a href=&quot;#gen&quot; class=&quot;headerlink&quot; title=&quot;gen&quot;&gt;&lt;/a&gt;gen&lt;/h4&gt;&lt;p&gt;该命令用以自动化从数据库直接生成模型文件。&lt;/p&gt;
&lt;p&gt;该命令将会根据数据表名（注意：所以要先在数据里建好表）生成对应的目录，该目
      
    
    </summary>
    
      <category term="gf-cli" scheme="http://runnerliu.github.io/categories/gf-cli/"/>
    
    
      <category term="gf" scheme="http://runnerliu.github.io/tags/gf/"/>
    
      <category term="gf-cli" scheme="http://runnerliu.github.io/tags/gf-cli/"/>
    
  </entry>
  
  <entry>
    <title>GO学习系列0 - 学习资料</title>
    <link href="http://runnerliu.github.io/2020/10/26/go-series-0/"/>
    <id>http://runnerliu.github.io/2020/10/26/go-series-0/</id>
    <published>2020-10-26T10:31:25.000Z</published>
    <updated>2020-11-15T02:24:39.466Z</updated>
    
    <content type="html"><![CDATA[<h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p><a href="https://github.com/golang/go" target="_blank" rel="noopener">github.com/golang/go</a></p><p><a href="https://learnku.com/docs/gobyexample/2020" target="_blank" rel="noopener">Go 编程实例 Go by Example</a></p><p><a href="https://learnku.com/docs/the-way-to-go" target="_blank" rel="noopener">Go 入门指南</a></p><h4 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h4><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><h5 id="Go-Frame"><a href="#Go-Frame" class="headerlink" title="Go Frame"></a>Go Frame</h5><ul><li><a href="https://goframe.org/index" target="_blank" rel="noopener">框架介绍</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;文档&quot;&gt;&lt;a href=&quot;#文档&quot; class=&quot;headerlink&quot; title=&quot;文档&quot;&gt;&lt;/a&gt;文档&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/golang/go&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
      
    
    </summary>
    
      <category term="GO" scheme="http://runnerliu.github.io/categories/GO/"/>
    
    
      <category term="GO" scheme="http://runnerliu.github.io/tags/GO/"/>
    
  </entry>
  
  <entry>
    <title>HTTP1.0、HTTP1.1、HTTP2.0的区别</title>
    <link href="http://runnerliu.github.io/2020/10/25/tcpdiff/"/>
    <id>http://runnerliu.github.io/2020/10/25/tcpdiff/</id>
    <published>2020-10-25T06:52:48.000Z</published>
    <updated>2020-11-15T02:24:39.480Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP发展史"><a href="#HTTP发展史" class="headerlink" title="HTTP发展史"></a>HTTP发展史</h3><p><img src="/images/2020-10-25T150500.png" alt="2020-10-25T150500.png"></p><h3 id="HTTP的优化"><a href="#HTTP的优化" class="headerlink" title="HTTP的优化"></a>HTTP的优化</h3><p>影响一个HTTP网络请求的因素主要有两个：带宽和延迟。</p><p><strong>带宽</strong></p><p>现在的网络基础建设已使得带宽得到极大的提升，在影响网速的因素中，带宽所占比重越来越少。</p><p><strong>延迟</strong></p><p>浏览器阻塞：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。</p><p>DNS 解析：浏览器需要知道目标服务器的 IP 才能建立连接。此过程为DNS解析，可参考<a href="https://runnerliu.github.io/2017/06/22/urlrequestprocess/">从输入 URL 到页面展示到底发生了什么</a>，这个通常可以利用DNS缓存结果来达到减少这个时间的目的。</p><p>建立连接：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能携带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</p><h3 id="HTTP1-0、HTTP1-1"><a href="#HTTP1-0、HTTP1-1" class="headerlink" title="HTTP1.0、HTTP1.1"></a>HTTP1.0、HTTP1.1</h3><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别体现在：</p><p><strong>缓存处理</strong></p><p>在HTTP1.0中主要使用header里的If-Modified-Since、Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag、If-Unmodified-Since、If-Match、If-None-Match等更多可供选择的缓存头来控制缓存策略。</p><p><strong>带宽优化及网络连接</strong></p><p>HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p><p><strong>错误通知的管理</strong></p><p>在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突、410（Gone）表示服务器上的某个资源被永久性的删除。</p><p><strong>Host头处理</strong></p><p>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p><p><strong>长连接</strong></p><p>HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection: keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p><h3 id="HTTPS、HTTP的区别"><a href="#HTTPS、HTTP的区别" class="headerlink" title="HTTPS、HTTP的区别"></a>HTTPS、HTTP的区别</h3><ul><li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费</li><li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的</li><li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443</li><li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题</li></ul><p><img src="/images/2020-10-25T152300.png" alt="2020-10-25T152300.png"></p><h3 id="说说SPDY"><a href="#说说SPDY" class="headerlink" title="说说SPDY"></a>说说SPDY</h3><p>其实 SPDY 并不是新的一种协议，而是在 HTTP 之前做了一层会话层。</p><p><img src="/images/2020-10-25T152800.png" alt="2020-10-25T152800.png"></p><p>SPDY是一个由 Google 主导的研究项目发明的HTTP替代协议。SPDY位于HTTP之下、TCP/SSL之上，这样可以轻松兼容老版本的HTTP协议，同时可以使用已有的SSL功能。SPDY优化了HTTP1.X的请求延迟，解决了HTTP1.X的安全性，具体如下：</p><p><strong>降低延迟</strong></p><p>针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。</p><p><strong>请求优先级</strong></p><p>多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。</p><p><strong>header压缩</strong></p><p>前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</p><p><strong>传输协议</strong></p><p>基于HTTPS的加密协议传输，大大提高了传输数据的可靠性。</p><p><strong>服务端推送</strong></p><p>采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。</p><h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><p>HTTP2.0是基于SPDY设计的，但与SPDY 仍有不同的地方，如下：</p><ul><li>HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</li><li>HTTP2.0 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE</li></ul><h4 id="HTTP2-0的新特性"><a href="#HTTP2-0的新特性" class="headerlink" title="HTTP2.0的新特性"></a>HTTP2.0的新特性</h4><h5 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h5><p>HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</p><p><img src="/images/2020-10-25T154700.png" alt="2020-10-25T154700.png"></p><p>在应用层与传输层之间增加一个二进制分帧层，以此达到在不改动 HTTP 的语义，HTTP 方法、状态码、URI 及首部字段的情况下，突破HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。在二进制分帧层上，HTTP2.0 会将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，其中 HTTP1.x 的首部信息会被封装到 Headers 帧，而我们的 request body 则封装到 Data 帧里面。</p><h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><p>即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</p><p><img src="/images/2020-10-25T154800.png" alt="2020-10-25T154800.png"></p><h5 id="header压缩"><a href="#header压缩" class="headerlink" title="header压缩"></a>header压缩</h5><p>如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p><p><img src="/images/2020-10-25T154900.png" alt="2020-10-25T154900.png"></p><h5 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h5><p>同SPDY一样，HTTP2.0也具有server push功能。</p><p>客户端请求的过程：</p><p><img src="/images/2020-10-25T155200.png" alt="2020-10-25T155200.png"></p><p>服务端推送的过程：</p><p><img src="/images/2020-10-25T155300.png" alt="2020-10-25T155300.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>HTTP1.0到HTTP1.1，是无连接到长连接的发展</p></li><li><p>HTTP1.x到HTTP2.0，是二进制分帧、多路复用的发展</p></li></ul><p>参考：</p><blockquote><p><a href="https://www.jianshu.com/p/be29d679cbff" target="_blank" rel="noopener">HTTP1.0、HTTP1.1和HTTP2.0的区别</a></p><p><a href="https://juejin.im/post/6844903824390537230" target="_blank" rel="noopener">HTTP1.0，HTTP1.1，HTTPS和HTTP2.0的区别</a></p><p><a href="https://juejin.im/post/6844903712113360903" target="_blank" rel="noopener">HTTP 的前世今生：一次性搞懂 HTTP、HTTPS、SPDY、HTTP2</a></p><p><a href="https://zh.wikipedia.org/wiki/HTTP/2" target="_blank" rel="noopener">HTTP/2</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;HTTP发展史&quot;&gt;&lt;a href=&quot;#HTTP发展史&quot; class=&quot;headerlink&quot; title=&quot;HTTP发展史&quot;&gt;&lt;/a&gt;HTTP发展史&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/2020-10-25T150500.png&quot; alt=&quot;2020
      
    
    </summary>
    
      <category term="HTTP" scheme="http://runnerliu.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://runnerliu.github.io/tags/HTTP/"/>
    
  </entry>
  
</feed>
