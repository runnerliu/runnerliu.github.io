<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LiuYang&#39;s BLOG</title>
  
  <subtitle>On the way to become a Software Architect</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://runnerliu.github.io/"/>
  <updated>2021-02-20T04:48:29.807Z</updated>
  <id>http://runnerliu.github.io/</id>
  
  <author>
    <name>william</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mysql系列 - explain</title>
    <link href="http://runnerliu.github.io/2021/02/20/mysql-explain/"/>
    <id>http://runnerliu.github.io/2021/02/20/mysql-explain/</id>
    <published>2021-02-20T04:04:15.000Z</published>
    <updated>2021-02-20T04:48:29.807Z</updated>
    
    <content type="html"><![CDATA[<p>通常我们在优化Mysql语句时会使用explain关键字，它是MySQL 提供的对 SELECT 语句进行分析并输出 SELECT 执行的详细信息的命令，其输出结果如下图：</p><p><img src="/images/2021-2-20T121509.png" alt="2021-2-20T121509.png"></p><h3 id="explain结果"><a href="#explain结果" class="headerlink" title="explain结果"></a>explain结果</h3><table><thead><tr><th>字段</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>id</td><td>SELECT 查询的标识符，每个 SELECT 都会自动分配一个唯一的标识符</td><td>id大的先执行，id相等由上到下执行</td></tr><tr><td>select_type</td><td>SELECT 查询的类型</td><td></td></tr><tr><td>table</td><td>查询的表名</td><td></td></tr><tr><td>partitions</td><td>匹配的分区</td><td>分库时使用</td></tr><tr><td>type</td><td>join 类型</td><td></td></tr><tr><td>possible_keys</td><td>此次查询中可能选用的索引</td><td></td></tr><tr><td>key</td><td>此次查询中确切使用到的索引</td><td></td></tr><tr><td>key_len</td><td>实际选择的索引的长度</td><td></td></tr><tr><td>ref</td><td>哪个字段或常数与 key 一起被使用</td><td></td></tr><tr><td>rows</td><td>显示此查询共扫描了多少行，估计值</td><td></td></tr><tr><td>filtered</td><td>表示此查询条件所过滤的数据的百分比</td><td></td></tr><tr><td>Extra</td><td>额外的信息</td></tr></tbody></table><h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><table><thead><tr><th>取值</th><th>含义</th></tr></thead><tbody><tr><td>SIMPLE</td><td>此查询不包含 UNION 查询或子查询</td></tr><tr><td>PRIMARY</td><td>此查询是最外层的查询</td></tr><tr><td>UNION</td><td>此查询是 UNION 的第二或随后的查询</td></tr><tr><td>DEPENDENT UNION</td><td>UNION 中的第二个或后面的查询语句，取决于外面的查询</td></tr><tr><td>UNION RESULT</td><td>UNION 的结果</td></tr><tr><td>SUBQUERY</td><td>子查询中的第一个 SELECT</td></tr><tr><td>DEPENDENT SUBQUERY</td><td>子查询中的第一个 SELECT，取决于外面的查询，即子查询依赖于外层查询的结果</td></tr></tbody></table><h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><table><thead><tr><th>取值</th><th>含义</th></tr></thead><tbody><tr><td>system</td><td>表中只有一条数据，这个类型是特殊的 <code>const</code> 类型</td></tr><tr><td>const</td><td>针对主键或唯一索引的等值查询扫描，最多只返回一行数据。const 查询速度非常快，因为它仅仅读取一次即可</td></tr><tr><td>eq_ref</td><td>此类型通常出现在多表的 join 查询，表示对于前表的每一个结果，都只能匹配到后表的一行结果，并且查询的比较操作通常是 <code>=</code>，查询效率较高</td></tr><tr><td>ref</td><td>此类型通常出现在多表的 join 查询，针对于非唯一或非主键索引，或者是使用了最左前缀规则索引的查询</td></tr><tr><td>range</td><td>使用索引范围查询，通过索引字段范围获取表中部分数据记录。这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中（当 <code>type</code> 是 <code>range</code> 时, 那么 EXPLAIN 输出的 <code>ref</code> 字段为 NULL，并且 <code>key_len</code> 字段是此次查询中使用到的索引的最长的那个）</td></tr><tr><td>index</td><td>全索引扫描(full index scan)，和 ALL 类型类似，只不过 ALL 类型是全表扫描，而 index 类型则仅仅扫描所有的索引，而不扫描数据</td></tr><tr><td>all</td><td>全表扫描, 这个类型的查询是性能最差的查询之一</td></tr></tbody></table><p>效率比较：all&lt; index &lt; range&lt; ref &lt; eq_ref &lt; const &lt; system</p><h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p>表示查询优化器使用了索引的字节数。这个字段可以评估组合索引是否完全被使用，或只有最左部分字段被使用到，key_len 的计算规则如下：</p><ul><li>字符串<ul><li>char(n)：n 字节长度</li><li>varchar(n)：如果是 utf8 编码, 则是 3 *n + 2字节; 如果是 utf8mb4 编码, 则是 4* n + 2 字节.</li></ul></li><li>数值类型:<ul><li>TINYINT：1字节</li><li>SMALLINT：2字节</li><li>MEDIUMINT：3字节</li><li>INT：4字节</li><li>BIGINT：8字节</li></ul></li><li>时间类型<ul><li>DATE：3字节</li><li>TIMESTAMP：4字节</li><li>DATETIME：8字节</li></ul></li><li>字段属性：NULL 属性占用一个字节，如果一个字段是 NOT NULL 的，则没有此属性。</li></ul><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>MySQL 查询优化器根据统计信息估算 SQL 要查找到结果集需要扫描读取的数据行数。这个值非常直观显示 SQL 的效率好坏，原则上 rows 越少越好。</p><p><strong>Extra</strong></p><table><thead><tr><th>取值</th><th>含义</th></tr></thead><tbody><tr><td>Using index</td><td>查询在索引树中就可查找所需数据, 不用扫描表数据文件</td></tr><tr><td>Using index condition</td><td>使用索引下推，延迟回表，且减少了需要回表的结果集</td></tr><tr><td>Using temporary</td><td>查询有使用临时表，一般出现于排序，分组和多表 join 的情况，查询效率不高</td></tr><tr><td>Using filesort</td><td>MySQL 需额外的排序操作，不能通过索引顺序达到排序效果。数量小时使用内存排序，数量大时使用磁盘排序</td></tr><tr><td>Using where</td><td>在存储引擎层检索出记录后，在server利用where条件进行过滤，并返回给客户端</td></tr></tbody></table><p>Read More:</p><blockquote><p><a href="https://segmentfault.com/a/1190000008131735" target="_blank" rel="noopener">MySQL 性能优化神器 Explain 使用分析</a></p><p><a href="http://weikeqin.com/2020/02/05/mysql-explain/" target="_blank" rel="noopener">mysql explain 详解</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常我们在优化Mysql语句时会使用explain关键字，它是MySQL 提供的对 SELECT 语句进行分析并输出 SELECT 执行的详细信息的命令，其输出结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2021-2-20T121509.png&quot; alt
      
    
    </summary>
    
      <category term="Mysql" scheme="http://runnerliu.github.io/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="http://runnerliu.github.io/tags/Mysql/"/>
    
      <category term="explain" scheme="http://runnerliu.github.io/tags/explain/"/>
    
  </entry>
  
  <entry>
    <title>GO垃圾回收机制</title>
    <link href="http://runnerliu.github.io/2021/02/19/gogc/"/>
    <id>http://runnerliu.github.io/2021/02/19/gogc/</id>
    <published>2021-02-19T06:32:47.000Z</published>
    <updated>2021-02-19T08:28:51.784Z</updated>
    
    <content type="html"><![CDATA[<p>在此之前，我们介绍过 <a href="https://runnerliu.github.io/2017/07/16/pythongc/">浅析Python的垃圾回收机制</a> 和 <a href="https://runnerliu.github.io/2017/04/15/phpnewgc/">PHP新的垃圾回收机制</a> ，有兴趣的话可以参考阅读，今天我们来聊聊golang是如何进行垃圾回收的。我们知道，目前各语言进行垃圾回收的方法有很多，如引用计数、标记清除、分代回收、三色标记等，各种方式都有其特点，GO语言在发展过程中， 其GC算法也是不断改进的。</p><h3 id="GO的GC里程碑"><a href="#GO的GC里程碑" class="headerlink" title="GO的GC里程碑"></a>GO的GC里程碑</h3><h4 id="v1-3以前：STW"><a href="#v1-3以前：STW" class="headerlink" title="v1.3以前：STW"></a>v1.3以前：STW</h4><p>golang的垃圾回收算法都非常简陋，其性能也广被诟病：go runtime在一定条件下（内存超过阈值或定期如2min），暂停所有任务的执行，进行mark&amp;sweep操作，操作完成后启动所有任务的执行。在内存使用较多的场景下，go程序在进行垃圾回收时会发生非常明显的卡顿现象（Stop The World）。在对响应速度要求较高的后台服务进程中，这种延迟简直是不能忍受的！这个时期国内外很多在生产环境实践go语言的团队都或多或少踩过gc的坑。当时解决这个问题比较常用的方法是尽快控制自动分配内存的内存数量以减少gc负荷，同时采用手动管理内存的方法处理需要大量及高频分配内存的场景。</p><h4 id="v1-3：Mark-STW-amp-Sweep"><a href="#v1-3：Mark-STW-amp-Sweep" class="headerlink" title="v1.3：Mark STW &amp; Sweep"></a>v1.3：Mark STW &amp; Sweep</h4><p>1.3版本中，go runtime分离了mark和sweep操作，和以前一样，也是先暂停所有任务执行并启动mark，mark完成后马上就重新启动被暂停的任务了，而是让sweep任务和普通协程任务一样并行的和其他任务一起执行。如果运行在多核处理器上，go会试图将gc任务放到单独的核心上运行而尽量不影响业务代码的执行。go team自己的说法是减少了50%-70%的暂停时间。</p><h4 id="v1-5：三色标记"><a href="#v1-5：三色标记" class="headerlink" title="v1.5：三色标记"></a>v1.5：三色标记</h4><p>go 1.5正在实现的垃圾回收器“非分代的、非移动的、并发的、三色的标记清除垃圾收集器”。这种方法的mark操作是可以渐进执行的而不需每次都扫描整个内存空间，可以减少stop the world的时间。 由此可以看到，一路走来直到1.5版本，go的垃圾回收性能也是一直在提升。</p><h4 id="v1-8：混合写屏障（hybrid-write-barrier）"><a href="#v1-8：混合写屏障（hybrid-write-barrier）" class="headerlink" title="v1.8：混合写屏障（hybrid write barrier）"></a>v1.8：混合写屏障（hybrid write barrier）</h4><p>由于标记操作和用户逻辑是并发执行的，用户逻辑会时常生成对象或者改变对象的引用。例如把⼀个对象标记为白色准备回收时，用户逻辑突然引用了它，或者又创建了新的对象。由于对象初始时都看为白色，会被 GC 回收掉，为了解决这个问题，引入了写屏障机制。</p><p>GC 对扫描过后的对象使⽤操作系统写屏障功能来监控这段内存。如果这段内存发⽣引⽤改变，写屏障会给垃圾回收期发送⼀个信号，垃圾回收器捕获到信号后就知道这个对象发⽣改变，然后重新扫描这个对象，看看它的引⽤或者被引⽤是否改变。利⽤状态的重置实现当对象状态发⽣改变的时候，依然可以再次其引用的对象。</p><h3 id="GO的GC"><a href="#GO的GC" class="headerlink" title="GO的GC"></a>GO的GC</h3><h4 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h4><p>传统的标记清除算法中，垃圾收集器从垃圾收集的根对象出发，递归遍历这些对象指向的子对象并将所有可达的对象标记成存活；标记阶段结束后，垃圾收集器会依次遍历堆中的对象并清除其中的垃圾，整个过程需要标记对象的存活状态，用户程序在垃圾收集的过程中也不能执行，我们需要用到更复杂的机制来解决 STW 的问题，这就出现了三色标记法。</p><p>三色标记算法将程序中的对象分成白色、黑色和灰色三类：</p><ul><li>白色对象：潜在的垃圾，其内存可能会被垃圾收集器回收；</li><li>黑色对象：活跃的对象，包括不存在任何引用外部指针的对象以及从根对象可达的对象；</li><li>灰色对象：活跃的对象，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象；</li></ul><p><img src="/images/2021-2-19T154834.png" alt="2021-2-19T154834.png"></p><p>在垃圾收集器开始工作时，程序中不存在任何的黑色对象，垃圾收集的根对象会被标记成灰色，垃圾收集器只会从灰色对象集合中取出对象开始扫描，当灰色集合中不存在任何对象时，标记阶段就会结束。</p><p><img src="/images/2021-2-19T154948.png" alt="2021-2-19T154948.png"></p><p>三色标记垃圾收集器的工作原理很简单，我们可以将其归纳成以下几个步骤：</p><ul><li>从灰色对象的集合中选择一个灰色对象并将其标记成黑色；</li><li>将黑色对象指向的所有对象都标记成灰色，保证该对象和被该对象引用的对象都不会被回收；</li><li>重复上述两个步骤直到对象图中不存在灰色对象。</li></ul><p>当三色的标记清除的标记阶段结束之后，应用程序的堆中就不存在任何的灰色对象，我们只能看到黑色的存活对象以及白色的垃圾对象，垃圾收集器可以回收这些白色的垃圾，下面是使用三色标记垃圾收集器执行标记后的堆内存，堆中只有对象 D 为待回收的垃圾：</p><p><img src="/images/2021-2-19T155305.png" alt="2021-2-19T155305.png"></p><p>因为用户程序可能在标记执行的过程中修改对象的指针，所以三色标记清除算法本身是不可以并发或者增量执行的，它仍然需要 STW，在如下所示的三色标记过程中，用户程序建立了从 A 对象到 D 对象的引用，但是因为程序中已经不存在灰色对象了，所以 D 对象会被垃圾收集器错误地回收。</p><p><img src="/images/2021-2-19T155403.png" alt="2021-2-19T155403.png"></p><p>本来不应该被回收的对象却被回收了，这在内存管理中是非常严重的错误，我们将这种错误称为悬挂指针，即指针没有指向特定类型的合法对象，影响了内存的安全性，想要并发或者增量地标记对象还是需要使用屏障技术。</p><p>整个流程如下：</p><p><img src="/images/2021-2-19T155548.gif" alt="2021-2-19T155548.gif"></p><h4 id="混合写屏障"><a href="#混合写屏障" class="headerlink" title="混合写屏障"></a>混合写屏障</h4><p>想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性（Tri-color invariant）中的一种：</p><ul><li>强三色不变性：黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；</li><li>弱三色不变性：黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径。</li></ul><p><img src="/images/2021-2-19T160000.png" alt="2021-2-19T160000.png"></p><p>上图分别展示了遵循强三色不变性和弱三色不变性的堆内存，遵循上述两个不变性中的任意一个，我们都能保证垃圾收集算法的正确性，而屏障技术就是在并发或者增量标记过程中保证三色不变性的重要技术。</p><p>垃圾收集中的屏障技术更像是一个钩子方法，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，根据操作类型的不同，我们可以将它们分成读屏障（Read barrier）和写屏障（Write barrier）两种，因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以编程语言往往都会采用写屏障保证三色不变性。</p><p>Go 语言在 v1.8 组合 Dijkstra 插入写屏障和 Yuasa 删除写屏障构成混合写屏障，该写屏障会<strong>将被覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记成灰色</strong>。</p><p>为了移除栈的重扫描过程，除了引入混合写屏障之外，在垃圾收集的标记阶段，我们还需要<strong>将创建的所有新对象都标记成黑色</strong>，防止新分配的栈内存和堆内存中的对象被错误地回收，因为栈内存在标记阶段最终都会变为黑色，所以不再需要重新扫描栈空间。</p><h4 id="增量和并发"><a href="#增量和并发" class="headerlink" title="增量和并发"></a>增量和并发</h4><p>传统的垃圾收集算法会在垃圾收集的执行期间暂停应用程序，一旦触发垃圾收集，垃圾收集器会抢占 CPU 的使用权占据大量的计算资源以完成标记和清除工作，然而很多追求实时的应用程序无法接受长时间的 STW。</p><p>为了减少应用程序暂停的最长时间和垃圾收集的总暂停时间，我们会使用下面的策略优化现代的垃圾收集器：</p><ul><li>增量垃圾收集：增量地标记和清除垃圾，降低应用程序暂停的最长时间；</li><li>并发垃圾收集：利用多核的计算资源，在用户程序执行时并发标记和清除垃圾；</li></ul><p>因为增量和并发两种方式都可以与用户程序交替运行，所以我们需要使用屏障技术保证垃圾收集的正确性；与此同时，应用程序也不能等到内存溢出时触发垃圾收集，因为当内存不足时，应用程序已经无法分配内存，这与直接暂停程序没有什么区别，增量和并发的垃圾收集需要提前触发并在内存不足前完成整个循环，避免程序的长时间暂停。</p><h5 id="增量收集"><a href="#增量收集" class="headerlink" title="增量收集"></a>增量收集</h5><p>增量式（Incremental）的垃圾收集是减少程序最长暂停时间的一种方案，它可以将原本时间较长的暂停时间切分成多个更小的 GC 时间片，虽然从垃圾收集开始到结束的时间更长了，但是这也减少了应用程序暂停的最大时间：</p><p><img src="/images/2021-2-19T160403.png" alt="2021-2-19T160403.png"></p><p>需要注意的是，增量式的垃圾收集需要与三色标记法一起使用，为了保证垃圾收集的正确性，我们需要在垃圾收集开始前打开写屏障，这样用户程序修改内存都会先经过写屏障的处理，保证了堆内存中对象关系的强三色不变性或者弱三色不变性。虽然增量式的垃圾收集能够减少最大的程序暂停时间，但是增量式收集也会增加一次 GC 循环的总时间，在垃圾收集期间，因为写屏障的影响用户程序也需要承担额外的计算开销，所以增量式的垃圾收集也不是只带来好处的，但是总体来说还是利大于弊。</p><h5 id="并发收集"><a href="#并发收集" class="headerlink" title="并发收集"></a>并发收集</h5><p>并发（Concurrent）的垃圾收集不仅能够减少程序的最长暂停时间，还能减少整个垃圾收集阶段的时间，通过开启读写屏障、利用多核优势与用户程序并行执行，并发垃圾收集器确实能够减少垃圾收集对应用程序的影响：</p><p><img src="/images/2021-2-19T160457.png" alt="2021-2-19T160457.png"></p><p>虽然并发收集器能够与用户程序一起运行，但是并不是所有阶段都可以与用户程序一起运行，部分阶段还是需要暂停用户程序的，不过与传统的算法相比，并发的垃圾收集可以将能够并发执行的工作尽量并发执行；当然，因为读写屏障的引入，并发的垃圾收集器也一定会带来额外开销，不仅会增加垃圾收集的总时间，还会影响用户程序，这是我们在设计垃圾收集策略时必须要注意的。</p><h3 id="GC的时机"><a href="#GC的时机" class="headerlink" title="GC的时机"></a>GC的时机</h3><p>运行时会通过如下所示的 <a href="https://draveness.me/golang/tree/runtime.gcTrigger.test" target="_blank" rel="noopener"><code>runtime.gcTrigger.test</code></a> 方法决定是否需要触发垃圾收集，当满足触发垃圾收集的基本条件时 — 允许垃圾收集、程序没有崩溃并且没有处于垃圾收集循环，该方法会根据三种不同方式触发进行不同的检查：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func (t gcTrigger) test() bool &#123;</span><br><span class="line">if !memstats.enablegc || panicking != 0 || gcphase != _GCoff &#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">switch t.kind &#123;</span><br><span class="line">case gcTriggerHeap:</span><br><span class="line">return memstats.heap_live &gt;= memstats.gc_trigger</span><br><span class="line">case gcTriggerTime:</span><br><span class="line">if gcpercent &lt; 0 &#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">lastgc := int64(atomic.Load64(&amp;memstats.last_gc_nanotime))</span><br><span class="line">return lastgc != 0 &amp;&amp; t.now-lastgc &gt; forcegcperiod</span><br><span class="line">case gcTriggerCycle:</span><br><span class="line">return int32(t.n-work.cycles) &gt; 0</span><br><span class="line">&#125;</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>gcTriggerHeap</code> ：堆内存的分配达到达控制器计算的触发堆大小；</li><li><code>gcTriggerTime</code> ：如果一定时间内没有触发，就会触发新的循环，该出发条件由 <a href="https://draveness.me/golang/tree/runtime.forcegcperiod" target="_blank" rel="noopener"><code>runtime.forcegcperiod</code></a> 变量控制，默认为 2 分钟；</li><li><code>gcTriggerCycle</code>：如果当前没有开启垃圾收集，则触发新的循环；</li><li><a href="https://draveness.me/golang/tree/runtime.gcpercent" target="_blank" rel="noopener"><code>runtime.gcpercent</code></a> 是触发垃圾收集的内存增长百分比，默认情况下为 100，即堆内存相比上次垃圾收集增长 100% 时应该触发 GC，并行的垃圾收集器会在到达该目标前完成垃圾收集。</li></ol><p>用于开启垃圾收集的方法 <a href="https://draveness.me/golang/tree/runtime.gcStart" target="_blank" rel="noopener"><code>runtime.gcStart</code></a> 会接收一个 <a href="https://draveness.me/golang/tree/runtime.gcTrigger" target="_blank" rel="noopener"><code>runtime.gcTrigger</code></a> 类型的结构，所有出现 <a href="https://draveness.me/golang/tree/runtime.gcTrigger" target="_blank" rel="noopener"><code>runtime.gcTrigger</code></a> 结构体的位置都是触发垃圾收集的代码：</p><ul><li><a href="https://draveness.me/golang/tree/runtime.sysmon" target="_blank" rel="noopener"><code>runtime.sysmon</code></a> 和 <a href="https://draveness.me/golang/tree/runtime.forcegchelper" target="_blank" rel="noopener"><code>runtime.forcegchelper</code></a> ：后台运行定时检查和垃圾收集；</li><li><a href="https://draveness.me/golang/tree/runtime.GC" target="_blank" rel="noopener"><code>runtime.GC</code></a> ：用户程序手动触发垃圾收集；</li><li><a href="https://draveness.me/golang/tree/runtime.mallocgc" target="_blank" rel="noopener"><code>runtime.mallocgc</code></a> ：申请内存时根据堆大小触发垃圾收集。</li></ul><p><img src="/images/2021-2-19T162340.png" alt="2021-2-19T162340.png"></p><p>Read More:</p><blockquote><p><a href="https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/" target="_blank" rel="noopener">垃圾收集器</a></p><p><a href="https://segmentfault.com/a/1190000018161588" target="_blank" rel="noopener">GO GC 垃圾回收机制</a></p><p><a href="https://juejin.cn/post/6844903917650722829" target="_blank" rel="noopener">搞懂Go垃圾回收</a></p><p><a href="https://wingsxdu.com/post/golang/gc/" target="_blank" rel="noopener">Go 语言 GC 机制 · Analyze</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在此之前，我们介绍过 &lt;a href=&quot;https://runnerliu.github.io/2017/07/16/pythongc/&quot;&gt;浅析Python的垃圾回收机制&lt;/a&gt; 和 &lt;a href=&quot;https://runnerliu.github.io/2017/04/
      
    
    </summary>
    
      <category term="GO" scheme="http://runnerliu.github.io/categories/GO/"/>
    
    
      <category term="垃圾回收" scheme="http://runnerliu.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
      <category term="GC" scheme="http://runnerliu.github.io/tags/GC/"/>
    
      <category term="golang" scheme="http://runnerliu.github.io/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>聊聊WS和WSS</title>
    <link href="http://runnerliu.github.io/2021/02/18/wsandwss/"/>
    <id>http://runnerliu.github.io/2021/02/18/wsandwss/</id>
    <published>2021-02-18T03:35:50.000Z</published>
    <updated>2021-02-18T13:26:42.584Z</updated>
    
    <content type="html"><![CDATA[<h3 id="初识WS-WSS"><a href="#初识WS-WSS" class="headerlink" title="初识WS/WSS"></a>初识WS/WSS</h3><p>WebSocket （WS）是HTML5一种新的协议，它实现了浏览器与服务器全双工通信，能更好地节省服务器资源和带宽并达到实时通讯。WebSocket建立在TCP之上，同HTTP一样通过TCP来传输数据，但是它和HTTP最大不同是：WebSocket是一种双向通信协议，在建立连接后，WebSocket服务器和Browser/Client Agent都能主动的向对方发送或接收数据，就像Socket一样；WebSocket需要类似TCP的客户端和服务器端通过握手连接，连接成功后才能相互通信。</p><p>WSS（Web Socket Secure）是WebSocket的加密版本。WS一般默认是80端口，而WSS默认是443端口，大多数网站用的就是80和433端口。（在高防防护过程中，80和433端口的网站是需要备案才可以接入国内的。）当然网站也会有别的端口，这种如果做高防是方案是可以用海外高防的。WS和WSS的体现形式分别是TCP+WS AS WS ，TCP+TLS+WS AS WS。服务器网址就是 URL。</p><h3 id="为何使用WS-WSS"><a href="#为何使用WS-WSS" class="headerlink" title="为何使用WS/WSS"></a>为何使用WS/WSS</h3><p>随着互联网的蓬勃发展，各种类型的Web应用层出不穷，很多应用要求服务端有能力进行实时推送能力（例如直播间聊天室），以往很多网站为了实现推送技术，所用的技术都是轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断地向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽资源。</p><p>在这种情况下，HTML5定义了WebSocket协议，能更好地节省服务器资源和带宽，并且能够更实时地进行通讯。WebSocket实现了浏览器与服务器全双工（full-duplex）通信，允许服务器主动发送信息给客户端。</p><p>WebSocket协议的交互过程如下图所示。</p><p><img src="/images/20210218T211759.png" alt="20210218T211759.png"></p><h3 id="WS特点"><a href="#WS特点" class="headerlink" title="WS特点"></a>WS特点</h3><ul><li>建立在 TCP 协议之上，服务端实现容易；</li><li>与 HTTP 协议有良好的兼容性，握手时不容易被屏蔽，可以通过各种 HTTP 代理服务器；</li><li>数据轻量，实时通讯；</li><li>可以发送文本和二进制数据；</li><li>不限制同源，客户端可以与任意服务器端进行通讯。因此WebSocket协议的出现，为很多人解决了关于扩展以及兼容性协议的烦恼问题。</li></ul><h3 id="与http-https关系"><a href="#与http-https关系" class="headerlink" title="与http/https关系"></a>与http/https关系</h3><p>按照标准来是有如下对应关系的：</p><ul><li><p>http -&gt; new WebSocket(‘ws://xxx’)</p></li><li><p>https -&gt; new WebSocket(‘wss://xxx’)</p></li></ul><p>在https下应该使用wss协议做安全链接，且wss下不支持ip地址的写法，写成域名形式。</p><p>Read More:</p><blockquote><p><a href="https://www.alibabacloud.com/help/zh/doc-detail/63421.htm" target="_blank" rel="noopener">WS/WSS协议支持FAQ</a></p><p><a href="https://zhuanlan.zhihu.com/p/75328501" target="_blank" rel="noopener">浅谈WebSocket协议、WS协议和WSS协议原理及关系</a></p><p><a href="https://www.jianshu.com/p/72bcc74409ad" target="_blank" rel="noopener">http/https与websocket的ws/wss的关系</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;初识WS-WSS&quot;&gt;&lt;a href=&quot;#初识WS-WSS&quot; class=&quot;headerlink&quot; title=&quot;初识WS/WSS&quot;&gt;&lt;/a&gt;初识WS/WSS&lt;/h3&gt;&lt;p&gt;WebSocket （WS）是HTML5一种新的协议，它实现了浏览器与服务器全双工通信，能更
      
    
    </summary>
    
      <category term="WebSocket" scheme="http://runnerliu.github.io/categories/WebSocket/"/>
    
    
      <category term="WS" scheme="http://runnerliu.github.io/tags/WS/"/>
    
      <category term="WSS" scheme="http://runnerliu.github.io/tags/WSS/"/>
    
      <category term="WebSocket" scheme="http://runnerliu.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>Tornado5.0.2翻译文档 - 模板和UI</title>
    <link href="http://runnerliu.github.io/2020/12/19/tornado502-templateui/"/>
    <id>http://runnerliu.github.io/2020/12/19/tornado502-templateui/</id>
    <published>2020-12-19T04:34:43.000Z</published>
    <updated>2020-12-19T08:39:47.550Z</updated>
    
    <content type="html"><![CDATA[<p>Tornado包含一种简单、快速、灵活的模板语言。本节描述该语言以及相关问题，如国际化。</p><p>Tornado还可以与任何其他Python模板语言一起使用，尽管没有将这些系统集成到<code>RequestHandler.render</code>中。只需将模板呈现为一个字符串并将其传递给<code>RequestHandler.write</code>即可。</p><h3 id="模板配置"><a href="#模板配置" class="headerlink" title="模板配置"></a>模板配置</h3><p>默认情况下，Tornado会在引用它们的<code>.py</code>文件的同一目录中寻找模板文件。要将模板文件放到不同的目录中，请使用<code>template_path</code>应用程序设置(或覆盖<code>RequestHandler.get_template_path</code>如果不同的处理程序有不同的模板路径)。</p><p>要从非文件系统位置加载模板，子类<code>tornado.template.BaseLoader</code>并传递一个实例作为<code>template_loader</code>应用程序设置。</p><p>编译后的模板默认缓存;要关闭此缓存并重新加载模板，以便底层文件的更改始终可见，请使用应用程序设置<code>compiled_template_cache=False</code>或<code>debug=True</code>。</p><h3 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h3><p>Tornado模板只是HTML(或任何其他基于文本的格式)，在标记中嵌入了Python控制序列和表达式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">   &lt;head&gt;</span><br><span class="line">      &lt;title&gt;&#123;&#123; title &#125;&#125;&lt;/title&gt;</span><br><span class="line">   &lt;/head&gt;</span><br><span class="line">   &lt;body&gt;</span><br><span class="line">     &lt;ul&gt;</span><br><span class="line">       &#123;% for item in items %&#125;</span><br><span class="line">         &lt;li&gt;&#123;&#123; escape(item) &#125;&#125;&lt;/li&gt;</span><br><span class="line">       &#123;% end %&#125;</span><br><span class="line">     &lt;/ul&gt;</span><br><span class="line">   &lt;/body&gt;</span><br><span class="line"> &lt;/html&gt;</span><br></pre></td></tr></table></figure><p>如果您将此模板保存为“template.html”。然后把它放在与Python文件相同的目录下，你可以用下面的方法来渲染这个模板:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class MainHandler(tornado.web.RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        items = [&quot;Item 1&quot;, &quot;Item 2&quot;, &quot;Item 3&quot;]</span><br><span class="line">        self.render(&quot;template.html&quot;, title=&quot;My title&quot;, items=items)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tornado模板支持控制语句和表达式。控制语句被&#123;%和%&#125;包围，比如：&#123;% if len(items) &gt; 2 %&#125;，表达式由&#123;&#123;和&#125;&#125;包围，比如&#123;&#123; item[0] &#125;&#125;。控制语句或多或少精确地映射到Python语句。我们支持if、for、while和try，它们都以&#123;%end%&#125;结尾，我们还支持使用extends和block语句的模板继承，这些语句都能在tornado.template找到。</span><br></pre></td></tr></table></figure><p>表达式可以是任何Python表达式，包括函数调用。模板代码在包含以下对象和函数的命名空间中执行(注意使用此列表呈现的模板<code>RequestHandler.render</code>和<code>render_string</code>。如果你使用<code>tornado.template</code>模块直接位于<code>RequestHandler</code>外部，其中许多条目不存在）</p><ul><li><p><code>escape</code>: alias for <code>tornado.escape.xhtml_escape</code></p></li><li><p><code>xhtml_escape</code>: alias for <code>tornado.escape.xhtml_escape</code></p></li><li><p><code>url_escape</code>: alias for <code>tornado.escape.url_escape</code></p></li><li><p><code>json_encode</code>: alias for <code>tornado.escape.json_encode</code></p></li><li><p><code>squeeze</code>: alias for <code>tornado.escape.squeeze</code></p></li><li><p><code>linkify</code>: alias for <code>tornado.escape.linkify</code></p></li><li><p><code>datetime</code>: the Python <code>datetime</code>module</p></li><li><p><code>handler</code>: the current <code>RequestHandler</code> object</p></li><li><p><code>request</code>: alias for <code>handler.request</code></p></li><li><p><code>current_user</code>: alias for <code>handler.current_user</code></p></li><li><p><code>locale</code>: alias for <code>handler.locale</code></p></li><li><p><code>\_</code>: alias for handler.locale.translate</p></li><li><p>static_url: alias for <code>handler.static_url</code></p></li><li><p>xsrf_form_html: alias for <code>handler.xsrf_form_html</code></p></li><li><p>reverse_url: alias for <code>Application.reverse_url</code></p></li><li><p>All entries from the <code>ui_methods</code> and <code>ui_modules</code> <code>Application</code> settings</p></li><li><p>Any keyword arguments passed to <code>render</code> or <code>render_string</code></p></li></ul><p>当您构建一个真正的应用程序时，您需要使用Tornado模板的所有特性，特别是模板继承。请阅读<code>tornado.template</code>部分（一些功能，包括<code>UIModules</code>在<code>tornado.web</code>模块）</p><p>Tornado模板直接翻译成Python。模板中包含的表达式将被逐字复制到表示模板的Python函数中。我们不试图阻止模板语言中的任何东西；我们显式地创建它是为了提供其他更严格的模板系统所阻止的灵活性。因此，如果您在模板表达式中编写随机内容，那么在执行模板时，您将得到随机的Python错误。</p><p>默认情况下，所有模板输出都是转义的，使用<code>tornado.escape.xhtml_escape</code>函数，可以传递参数 <code>autoescape=None</code> 给Application或者通过<code>tornado.template.Loader</code>来全局改变该属性，此外，在这些地方中的每一个都可以使用替代转义函数的名称来代替<code>None</code>。</p><p>请注意，虽然Tornado的自动转义有助于避免XSS漏洞，但它在所有情况下都不够。出现在某些位置（如JavaScript或CSS）中的表达式可能需要额外的转义。此外，必须注意在可能包含不可信内容的HTML属性中始终使用双引号和xhtml_escape，或者必须对属性使用单独的转义函数（参见<a href="https://wonko.com/post/html-escaping" target="_blank" rel="noopener">博客</a>）。</p><h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h3><p>参见<a href="https://www.tornadoweb.org/en/stable/guide/templates.html#internationalization" target="_blank" rel="noopener">Internationalization</a></p><h3 id="UI模块"><a href="#UI模块" class="headerlink" title="UI模块"></a>UI模块</h3><p>参见<a href="https://www.tornadoweb.org/en/stable/guide/templates.html#ui-modules" target="_blank" rel="noopener">UI modules</a></p><p>Read More:</p><blockquote><p><a href="https://www.tornadoweb.org/en/stable/guide/templates.html" target="_blank" rel="noopener">Templates and UI</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Tornado包含一种简单、快速、灵活的模板语言。本节描述该语言以及相关问题，如国际化。&lt;/p&gt;
&lt;p&gt;Tornado还可以与任何其他Python模板语言一起使用，尽管没有将这些系统集成到&lt;code&gt;RequestHandler.render&lt;/code&gt;中。只需将模板呈现
      
    
    </summary>
    
      <category term="Tornado" scheme="http://runnerliu.github.io/categories/Tornado/"/>
    
    
      <category term="Tornado" scheme="http://runnerliu.github.io/tags/Tornado/"/>
    
      <category term="翻译文档" scheme="http://runnerliu.github.io/tags/%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>Tornado5.0.2翻译文档 - Tornado web应用程序的结构</title>
    <link href="http://runnerliu.github.io/2020/12/19/tornado502-structureofweb/"/>
    <id>http://runnerliu.github.io/2020/12/19/tornado502-structureofweb/</id>
    <published>2020-12-19T02:34:43.000Z</published>
    <updated>2020-12-19T08:01:26.245Z</updated>
    
    <content type="html"><![CDATA[<p>Tornado web应用程序通常由一个或多个 <code>RequestHandler</code> 子类组成，将传入请求路由到处理程序的 <code>Application</code> 对象，和一个启动服务程序的 <code>main</code> 方法。</p><p>一个最小的“hello world”示例是这样的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import tornado.ioloop</span><br><span class="line">import tornado.web</span><br><span class="line"></span><br><span class="line">class MainHandler(tornado.web.RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        self.write(&quot;Hello, world&quot;)</span><br><span class="line"></span><br><span class="line">def make_app():</span><br><span class="line">    return tornado.web.Application([</span><br><span class="line">        (r&quot;/&quot;, MainHandler),</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app = make_app()</span><br><span class="line">    app.listen(8888)</span><br><span class="line">    tornado.ioloop.IOLoop.current().start()</span><br></pre></td></tr></table></figure><h3 id="Application-对象"><a href="#Application-对象" class="headerlink" title="Application 对象"></a>Application 对象</h3><p><code>Application</code> 对象负责全局配置，包括将请求映射到处理程序的路由表。</p><p>路由表是 <code>URLSpec</code> 对象(或元组)的列表，每个对象都包含(至少)一个正则表达式和一个处理程序类。顺序问题：使用第一个匹配规则。如果正则表达式包含捕获组，那么这些组就是路径参数，并将被传递给处理程序的HTTP方法。如果字典作为 <code>URLSpec</code> 的第三个元素传递，它将提供初始化参数，该参数将被传递给 <code>RequestHandler.initialize</code>。<code>URLSpec</code> 对象也可自定义名称，用于 <code>RequestHandler.reverse_url</code>。</p><p>例如，在这个片段中，根URL <code>/</code> 被映射到 <code>MainHandler</code>，而形式 <code>/story/</code> 后面跟着一个数字的 <code>URL</code> 被映射到 <code>StoryHandler</code>。这个数字被传递(作为字符串)给 <code>StoryHandler.get</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class MainHandler(RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        self.write(&apos;&lt;a href=&quot;%s&quot;&gt;link to story 1&lt;/a&gt;&apos; %</span><br><span class="line">                   self.reverse_url(&quot;story&quot;, &quot;1&quot;))</span><br><span class="line"></span><br><span class="line">class StoryHandler(RequestHandler):</span><br><span class="line">    def initialize(self, db):</span><br><span class="line">        self.db = db</span><br><span class="line"></span><br><span class="line">    def get(self, story_id):</span><br><span class="line">        self.write(&quot;this is story %s&quot; % story_id)</span><br><span class="line"></span><br><span class="line">app = Application([</span><br><span class="line">    url(r&quot;/&quot;, MainHandler),</span><br><span class="line">    url(r&quot;/story/([0-9]+)&quot;, StoryHandler, dict(db=db), name=&quot;story&quot;)</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><p><code>Application</code> 构造函数接受许多关键字参数，这些参数可用于自定义应用程序的行为和启用可选特性；点击 <a href="https://www.tornadoweb.org/en/stable/web.html#tornado.web.Application.settings" target="_blank" rel="noopener">Application.settings</a>，查看完整设置。</p><h3 id="RequestHandler-子类"><a href="#RequestHandler-子类" class="headerlink" title="RequestHandler 子类"></a>RequestHandler 子类</h3><p>Tornado web应用程序的大部分工作都是在 <code>RequestHandler</code> 的子类中完成的。处理程序子类的主要入口点是以被处理的HTTP方法命名的方法: <code>get()</code>、<code>post()</code>等。每个处理程序可以定义一个或多个这样的方法来处理不同的HTTP操作。如上所述，这些方法将被调用，参数与匹配的路由规则的捕获组相对应。</p><p>在处理程序中，调用 <code>RequestHandler.render</code>、<code>RequestHandler.write</code>来产生一个响应。<code>render()</code> 按名称加载模板，并使用给定参数呈现它。<code>write()</code> 用于非基于模板的输出；它接受字符串、字节和字典(dicts将被编码为JSON)。</p><p><code>RequestHandler</code> 中的许多方法被设计成可以在子类中重写，并在整个应用程序中使用。通常定义一个 <code>BaseHandler</code> 类，覆盖 <code>write_error</code> 和 <code>get_current_user</code> 等方法，然后为所有特定的处理程序子类化你自己的 <code>BaseHandler</code> 而不是 <code>RequestHandler</code>。</p><h4 id="处理请求输入"><a href="#处理请求输入" class="headerlink" title="处理请求输入"></a>处理请求输入</h4><p>请求处理程序可以通过 <code>self.request</code> 访问表示当前请求的对象。有关属性的完整列表，请参阅 <a href="https://www.tornadoweb.org/en/stable/httputil.html#tornado.httputil.HTTPServerRequest" target="_blank" rel="noopener">HTTPServerRequest</a> 的类定义。</p><p>HTML表单使用的格式的请求数据将为您解析，并在 <code>get_query_argument</code> 和 <code>get_body_argument</code> 等方法中可用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class MyFormHandler(tornado.web.RequestHandler):</span><br><span class="line">    def get(self):</span><br><span class="line">        self.write(&apos;&lt;html&gt;&lt;body&gt;&lt;form action=&quot;/myform&quot; method=&quot;POST&quot;&gt;&apos;</span><br><span class="line">                   &apos;&lt;input type=&quot;text&quot; name=&quot;message&quot;&gt;&apos;</span><br><span class="line">                   &apos;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&apos;</span><br><span class="line">                   &apos;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&apos;)</span><br><span class="line"></span><br><span class="line">    def post(self):</span><br><span class="line">        self.set_header(&quot;Content-Type&quot;, &quot;text/plain&quot;)</span><br><span class="line">        self.write(&quot;You wrote &quot; + self.get_body_argument(&quot;message&quot;))</span><br></pre></td></tr></table></figure><p>由于HTML表单编码对于参数是单个值还是包含一个元素的列表是模棱两可的，<code>RequestHandler</code> 提供了不同的方法，允许应用程序指示它是否需要列表。对于列表，使用 <code>get_query_arguments</code> 和 <code>get_body_arguments</code> 而不是它们的单一对应项。</p><p>通过表单上传的文件在 <code>self.request.files</code> 中可用。它将名称 <code>&lt;input type=&quot;file&quot;&gt;</code> 元素映射到一个文件列表。每个文件是一个字典形式 <code>{&quot;filename&quot;:…, &quot;content_type&quot;:……, &quot;body&quot;:…}</code>。<code>files</code> 对象只有在文件上传带有表单包装器(即 <code>multipart/form-data</code> 类型)时才存在;如果未使用此格式，则在 <code>self.request.body</code> 中可以使用原始上传数据。默认情况下，上传的文件在内存中完全缓冲;如果您需要处理太大而不能舒适地保存在内存中的文件，请参阅 <a href="https://www.tornadoweb.org/en/stable/web.html#tornado.web.stream_request_body" target="_blank" rel="noopener">stream_request_body</a> 类装饰器。</p><p>在demos目录中，<a href="https://github.com/tornadoweb/tornado/tree/master/demos/file_upload/" target="_blank" rel="noopener">file_receiver.py</a>显示了两种接收文件上传的方法。</p><p>由于HTML表单编码的奇怪之处(例如，单参数与复数参数之间的模糊性)，Tornado并不试图将表单参数与其他类型的输入统一起来。特别地，我们不解析JSON请求体。希望使用JSON而不是form-encoding的应用程序可以重写 <code>prepare</code> 来解析它们的请求:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def prepare(self):</span><br><span class="line">    if self.request.headers.get(&quot;Content-Type&quot;, &quot;&quot;).startswith(&quot;application/json&quot;):</span><br><span class="line">        self.json_args = json.loads(self.request.body)</span><br><span class="line">    else:</span><br><span class="line">        self.json_args = None</span><br></pre></td></tr></table></figure><h3 id="重写RequestHandler方法"><a href="#重写RequestHandler方法" class="headerlink" title="重写RequestHandler方法"></a>重写RequestHandler方法</h3><p>除了 <code>get()</code>/ <code>post()</code>/等，<code>RequestHandler</code> 中的某些其他方法被设计成在必要时由子类覆盖。在每个请求中，会发生以下调用序列:</p><ul><li>每个请求都会创建一个新的 <code>RequestHandler</code> 对象。</li><li><code>initialize()</code> 使用来自应用程序配置的初始化参数调用。初始化通常应该只保存传递给成员变量的实参;它可能不会产生任何输出或调用 <code>send_error</code> 之类的方法。</li><li><code>prepare()</code> 被调用。这在所有处理程序子类共享的基类中最有用，因为无论使用哪种HTTP方法都将调用 <code>prepare</code>。准备可产生产出;如果它调用<code>finish</code>(或<code>redirect</code>，等等)，处理将在此停止。</li><li>其中一个HTTP方法被调用:<code>get()</code>、<code>post()</code>、<code>put()</code>等等。如果URL正则表达式包含捕获组，则将它们作为参数传递给此方法。</li><li>当请求完成时，调用<code>on_finish()</code>。这通常是在<code>get()</code>或另一个HTTP方法返回之后。</li></ul><p>所有设计要重写的方法都在<code>RequestHandler</code>文档中有这样的说明。一些最常见的覆盖方法包括:</p><ul><li><code>write_error</code> - 输出用于错误页面的HTML。</li><li><code>on_connection_close</code> - 当客户端断开连接时调用;应用程序可以选择检测这种情况并停止进一步处理。请注意，不能保证能够迅速检测到关闭的连接。</li><li><code>get_current_user</code> - 参见<a href="https://www.tornadoweb.org/en/stable/guide/security.html#user-authentication" target="_blank" rel="noopener">User authentication</a>。</li><li><code>get_user_locale</code> - 返回用于当前用户的<code>Locale</code>对象。</li><li><code>set_default_headers</code> - 可以用于设置响应的附加标头(例如自定义<code>Server</code>头)。</li></ul><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>如果处理程序抛出异常，Tornado将调用<code>RequestHandler.write_error</code>生成一个错误页面。<code>tornado.web.HTTPError</code>可以用来生成指定的状态码;所有其他异常返回一个500状态。</p><p>默认的错误页面包括调试模式下的堆栈跟踪和错误的单行描述(例如:“500: Internal Server Error”)。若要生成自定义错误页面，请覆盖<code>RequestHandler.write_error</code>(可能在所有处理程序共享的基类中)。该方法可以通过<code>write</code>和<code>render</code>等方法正常生成输出。如果错误是由异常引起的，那么将传递一个<code>exc_info</code>三元组作为关键字参数(注意，这个异常不能保证是<code>sys.exc_info</code>，所以<code>write_error</code>必须使用<code>traceback.format_exception</code>代替<code>traceback.format_exc</code>)。</p><p>通过调用<code>set_status</code>编写响应并返回，也可以从常规处理程序方法而不是<code>write_error</code>生成一个错误页面。在简便返回不很方便的情况下<code>tornado.web.Finish</code> 异常会被抛出来终止处理程序而不是抛出<code>write_error</code>。</p><p>对于404错误，使用<code>default_handler_class</code> <code>Application settings</code>。这个处理程序应该覆盖<code>prepare</code>而不是像<code>get()</code>这样更具体的方法，这样它就可以与任何HTTP方法一起工作。它应该像上面描述的那样生成它的错误页面:通过调用<code>HTTPError(404)</code>并覆盖<code>write_error</code>，或者调用<code>self.set_status(404)</code>并在<code>prepare()</code>中直接生成响应。</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>在Tornado中有两种主要的重定向请求的方法:<code>RequestHandler.redirect</code> 和 <code>RedirectHandler</code>。</p><p>您可以在<code>RequestHandler</code>方法中使用<code>self.redirect()</code>将用户重定向到其他地方。还有一个可选参数<code>permanent</code>，您可以使用它来指示重定向被认为是永久性的。<code>permanent</code>的默认值是False，它生成<code>302 Found HTTP</code>响应代码，适合在成功POST请求后重定向用户。如果<code>permanent</code>为True，则使用301移动的永久HTTP响应代码，这在以面向seo的方式重定向到页面的规范URL时很有用。</p><p><code>RedirectHandler</code>允许您在应用程序路由表中直接配置重定向。例如，要配置一个静态重定向:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app = tornado.web.Application([</span><br><span class="line">    url(r&quot;/app&quot;, tornado.web.RedirectHandler,</span><br><span class="line">        dict(url=&quot;http://itunes.apple.com/my-app-id&quot;)),</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><p><code>RedirectHandler</code>也支持正则表达式替换。下面的规则将所有以<code>/pictures/</code>开头的请求重定向到前缀<code>/photos/</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app = tornado.web.Application([</span><br><span class="line">    url(r&quot;/photos/(.*)&quot;, MyPhotoHandler),</span><br><span class="line">    url(r&quot;/pictures/(.*)&quot;, tornado.web.RedirectHandler,</span><br><span class="line">        dict(url=r&quot;/photos/&#123;0&#125;&quot;)),</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><p>不像<code>RequestHandler.redirect</code>，<code>RedirectHandler</code>默认使用永久重定向。这是因为路由表在运行时不会改变，并且被认为是永久的，而在处理程序中发现的重定向很可能是其他可能改变的逻辑的结果。要使用<code>RedirectHandler</code>发送临时重定向，请在<code>RedirectHandler</code>初始化参数中添加<code>permanent=False</code>。</p><h3 id="异步处理类"><a href="#异步处理类" class="headerlink" title="异步处理类"></a>异步处理类</h3><p>某些处理程序方法(包括<code>prepare()</code>和HTTP动词方法<code>get()</code>/ <code>post()</code>/等)可能被重写为协程，以使处理程序异步。</p><p>例如，下面是一个使用协同程序的简单处理程序:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MainHandler(tornado.web.RequestHandler):</span><br><span class="line">    async def get(self):</span><br><span class="line">        http = tornado.httpclient.AsyncHTTPClient()</span><br><span class="line">        response = await http.fetch(&quot;http://friendfeed-api.com/v2/feed/bret&quot;)</span><br><span class="line">        json = tornado.escape.json_decode(response.body)</span><br><span class="line">        self.write(&quot;Fetched &quot; + str(len(json[&quot;entries&quot;])) + &quot; entries &quot;</span><br><span class="line">                   &quot;from the FriendFeed API&quot;)</span><br></pre></td></tr></table></figure><p>关于更高级的异步示例，请查看<a href="https://github.com/tornadoweb/tornado/tree/stable/demos/chat" target="_blank" rel="noopener">聊天示例应用程序</a>，该应用程序使用长轮询实现了一个AJAX聊天室。使用长轮询的用户可能希望覆盖<code>on_connection_close()</code>，以便在客户端关闭连接后进行清理(但请参阅该方法的文档字符串以了解注意事项)。</p><p>Read More:</p><blockquote><p><a href="https://www.tornadoweb.org/en/stable/guide/structure.html" target="_blank" rel="noopener">Structure of a Tornado web application</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Tornado web应用程序通常由一个或多个 &lt;code&gt;RequestHandler&lt;/code&gt; 子类组成，将传入请求路由到处理程序的 &lt;code&gt;Application&lt;/code&gt; 对象，和一个启动服务程序的 &lt;code&gt;main&lt;/code&gt; 方法。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Tornado" scheme="http://runnerliu.github.io/categories/Tornado/"/>
    
    
      <category term="Tornado" scheme="http://runnerliu.github.io/tags/Tornado/"/>
    
      <category term="翻译文档" scheme="http://runnerliu.github.io/tags/%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>学习路线-2020</title>
    <link href="http://runnerliu.github.io/2020/11/29/roadmap-2020/"/>
    <id>http://runnerliu.github.io/2020/11/29/roadmap-2020/</id>
    <published>2020-11-29T12:01:33.000Z</published>
    <updated>2020-12-19T08:46:21.331Z</updated>
    
    <content type="html"><![CDATA[<h3 id="英文版"><a href="#英文版" class="headerlink" title="英文版"></a>英文版</h3><p><img src="/images/2020-11-29200200.png" alt="2020-11-29200200.png"></p><p><img src="/images/2020-11-29200201.png" alt="2020-11-29200201.png"></p><p><img src="/images/2020-11-29200202.png" alt="2020-11-29200202.png"></p><p><img src="/images/2020-11-29200203.png" alt="2020-11-29200203.png"></p><h3 id="翻译版"><a href="#翻译版" class="headerlink" title="翻译版"></a>翻译版</h3><p><img src="/images/2020-11-29200200-1.png" alt="2020-11-29200200-1.png"></p><p><img src="/images/2020-11-29200201-1.png" alt="2020-11-29200201-1.png"></p><p><img src="/images/2020-11-29200202-1.png" alt="2020-11-29200202-1.png"></p><p><img src="/images/2020-11-29200203-1.png" alt="2020-11-29200203-1.png"></p><blockquote><p><a href="https://github.com/kamranahmedse/developer-roadmap" target="_blank" rel="noopener">https://github.com/kamranahmedse/developer-roadmap</a></p><p><a href="https://www.w3cschool.cn/article/3131568.html" target="_blank" rel="noopener">https://www.w3cschool.cn/article/3131568.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;英文版&quot;&gt;&lt;a href=&quot;#英文版&quot; class=&quot;headerlink&quot; title=&quot;英文版&quot;&gt;&lt;/a&gt;英文版&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/2020-11-29200200.png&quot; alt=&quot;2020-11-29200200.png&quot;
      
    
    </summary>
    
      <category term="RoadMap" scheme="http://runnerliu.github.io/categories/RoadMap/"/>
    
    
      <category term="RoadMap" scheme="http://runnerliu.github.io/tags/RoadMap/"/>
    
      <category term="学习路线" scheme="http://runnerliu.github.io/tags/%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>Python库-gevent</title>
    <link href="http://runnerliu.github.io/2020/11/29/python-lib-gevent/"/>
    <id>http://runnerliu.github.io/2020/11/29/python-lib-gevent/</id>
    <published>2020-11-29T11:32:15.000Z</published>
    <updated>2020-11-29T11:34:32.253Z</updated>
    
    <content type="html"><![CDATA[<p>Gevent是一个并发网络库。它的协程是基于greenlet的，并基于libev实现快速事件循环（Linux上是epoll，FreeBSD上是kqueue，Mac OS X上是select）。有了Gevent，协程的使用将无比简单，你根本无须像greenlet一样显式的切换，每当一个协程阻塞时，程序将自动调度，Gevent处理了所有的底层细节。让我们看个例子来感受下吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import gevent</span><br><span class="line"></span><br><span class="line">def test1():</span><br><span class="line">    print(12)</span><br><span class="line">    gevent.sleep(0)</span><br><span class="line">    print(34)</span><br><span class="line"></span><br><span class="line">def test2():</span><br><span class="line">    print(56)</span><br><span class="line">    gevent.sleep(0)</span><br><span class="line">    print(78)</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(test1),</span><br><span class="line">    gevent.spawn(test2),</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>解释下，<code>gevent.spawn()</code>方法会创建一个新的greenlet协程对象，并运行它。<code>gevent.joinall()</code>方法会等待所有传入的greenlet协程运行结束后再退出，这个方法可以接受一个<code>timeout</code>参数来设置超时时间，单位是秒。运行上面的程序，执行顺序如下： </p><ol><li>先进入协程test1，打印12</li><li>遇到<code>gevent.sleep(0)</code>时，test1被阻塞，自动切换到协程test2，打印56</li><li>之后test2被阻塞，这时test1阻塞已结束，自动切换回test1，打印34</li><li>当test1运行完毕返回后，此时test2阻塞已结束，再自动切换回test2，打印78</li><li>所有协程执行完毕，程序退出</li></ol><p>所以，程序运行下来的输出就是： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">56</span><br><span class="line">34</span><br><span class="line">78</span><br></pre></td></tr></table></figure><p>我们换一个更有意义的例子： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">urls = [<span class="string">'www.baidu.com'</span>, <span class="string">'www.gevent.org'</span>, <span class="string">'www.python.org'</span>]</span><br><span class="line">jobs = [gevent.spawn(socket.gethostbyname, url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">gevent.joinall(jobs, timeout=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print([job.value <span class="keyword">for</span> job <span class="keyword">in</span> jobs])</span><br></pre></td></tr></table></figure><p>我们通过协程分别获取三个网站的IP地址，由于打开远程地址会引起IO阻塞，所以gevent会自动调度不同的协程。另外，我们可以通过协程对象的”value”属性，来获取协程函数的返回值。 </p><h4 id="猴子补丁-Monkey-patching"><a href="#猴子补丁-Monkey-patching" class="headerlink" title="猴子补丁 Monkey patching"></a>猴子补丁 Monkey patching</h4><p>其实程序运行的时间同不用协程是一样的，是三个网站打开时间的总和。可是理论上协程是非阻塞的，那运行时间应该等于最长的那个网站打开时间呀？其实这是因为Python标准库里的socket是阻塞式的，DNS解析无法并发，包括像urllib库也一样，所以这种情况下用协程完全没意义。那怎么办？</p><p>一种方法是使用gevent下的socket模块，我们可以通过<code>from gevent import socket</code>来导入。不过更常用的方法是使用猴子布丁（Monkey patching）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from gevent import monkey; monkey.patch_socket()</span><br><span class="line">import gevent</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line">urls = [&apos;www.baidu.com&apos;, &apos;www.gevent.org&apos;, &apos;www.python.org&apos;]</span><br><span class="line">jobs = [gevent.spawn(socket.gethostbyname, url) for url in urls]</span><br><span class="line">gevent.joinall(jobs, timeout=5)</span><br><span class="line"></span><br><span class="line">print([job.value for job in jobs])</span><br></pre></td></tr></table></figure><p>上述代码的第一行就是对socket标准库打上猴子补丁，此后socket标准库中的类和方法都会被替换成非阻塞式的，所有其他的代码都不用修改，这样协程的效率就真正体现出来了。Python中其它标准库也存在阻塞的情况，gevent提供了<code>monkey.patch_all()</code>方法将所有标准库都替换。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from gevent import monkey; monkey.patch_all()</span><br></pre></td></tr></table></figure><p> 使用猴子补丁褒贬不一，但是官网上还是建议使用<code>patch_all()</code>，而且在程序的第一行就执行 。</p><h4 id="获取协程状态"><a href="#获取协程状态" class="headerlink" title="获取协程状态"></a>获取协程状态</h4><p>协程状态有已启动和已停止，分别可以用协程对象的<code>started</code>属性和<code>ready()</code>方法来判断。对于已停止的协程，可以用<code>successful()</code>方法来判断其是否成功运行且没抛异常。如果协程执行完有返回值，可以通过<code>value</code>属性来获取。另外，greenlet协程运行过程中发生的异常是不会被抛出到协程外的，因此需要用协程对象的<code>exception</code>属性来获取协程中的异常。下面的例子很好的演示了各种方法和属性的使用。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">win</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'You win!'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fail</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">raise</span> Exception(<span class="string">'You failed!'</span>)</span><br><span class="line"></span><br><span class="line">winner = gevent.spawn(win)</span><br><span class="line">loser = gevent.spawn(fail)</span><br><span class="line"></span><br><span class="line">print(winner.started) <span class="comment"># True</span></span><br><span class="line">print(loser.started)  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在Greenlet中发生的异常，不会被抛到Greenlet外面。</span></span><br><span class="line"><span class="comment"># 控制台会打出Stacktrace，但程序不会停止</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    gevent.joinall([winner, loser])</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 这段永远不会被执行</span></span><br><span class="line">    print(<span class="string">'This will never be reached'</span>)</span><br><span class="line"></span><br><span class="line">print(winner.ready()) <span class="comment"># True</span></span><br><span class="line">print(loser.ready())  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">print(winner.value) <span class="comment"># 'You win!'</span></span><br><span class="line">print(loser.value)  <span class="comment"># None</span></span><br><span class="line"></span><br><span class="line">print(winner.successful()) <span class="comment"># True</span></span><br><span class="line">print(loser.successful())  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里可以通过raise loser.exception 或 loser.get()</span></span><br><span class="line"><span class="comment"># 来将协程中的异常抛出</span></span><br><span class="line">print(loser.exception)</span><br></pre></td></tr></table></figure><h4 id="协程运行超时"><a href="#协程运行超时" class="headerlink" title="协程运行超时"></a>协程运行超时</h4><p>之前我们讲过在<code>gevent.joinall()</code>方法中可以传入<code>timeout</code>参数来设置超时，我们也可以在全局范围内设置超时时间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> Timeout</span><br><span class="line"></span><br><span class="line">timeout = Timeout(<span class="number">2</span>)  <span class="comment"># 2 seconds</span></span><br><span class="line">timeout.start()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait</span><span class="params">()</span>:</span></span><br><span class="line">    gevent.sleep(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    gevent.spawn(wait).join()</span><br><span class="line"><span class="keyword">except</span> Timeout:</span><br><span class="line">    traceback.print_exc()</span><br><span class="line">    print(<span class="string">'Could not complete'</span>)</span><br></pre></td></tr></table></figure><p>上例中，我们将超时设为2秒，此后所有协程的运行，如果超过两秒就会抛出<code>Timeout</code>异常。我们也可以将超时设置在with语句内，这样该设置只在with语句块中有效：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> Timeout(<span class="number">1</span>):</span><br><span class="line">    gevent.sleep(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>此外，我们可以指定超时所抛出的异常，来替换默认的<code>Timeout</code>异常。比如下例中超时就会抛出我们自定义的<code>TooLong</code>异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TooLong</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Timeout(<span class="number">1</span>, TooLong):</span><br><span class="line">    gevent.sleep(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h4 id="协程间通讯"><a href="#协程间通讯" class="headerlink" title="协程间通讯"></a>协程间通讯</h4><p>greenlet协程间的异步通讯可以使用事件（Event）对象。该对象的<code>wait()</code>方法可以阻塞当前协程，而<code>set()</code>方法可以唤醒之前阻塞的协程。在下面的例子中，5个waiter协程都会等待事件evt，当setter协程在3秒后设置evt事件，所有的waiter协程即被唤醒。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf8</span></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent.event <span class="keyword">import</span> Event</span><br><span class="line"></span><br><span class="line">evt = Event()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setter</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Wait for me'</span>)</span><br><span class="line">    gevent.sleep(<span class="number">3</span>)  <span class="comment"># 3秒后唤醒所有在evt上等待的协程</span></span><br><span class="line">    print(<span class="string">"Ok, I'm done"</span>)</span><br><span class="line">    evt.set()  <span class="comment"># 唤醒</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">waiter</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I'll wait for you"</span>)</span><br><span class="line">    evt.wait()  <span class="comment"># 等待</span></span><br><span class="line">    print(<span class="string">'Finish waiting'</span>)</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(setter),</span><br><span class="line">    gevent.spawn(waiter),</span><br><span class="line">    gevent.spawn(waiter),</span><br><span class="line">    gevent.spawn(waiter),</span><br><span class="line">    gevent.spawn(waiter),</span><br><span class="line">    gevent.spawn(waiter)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>除了Event事件外，gevent还提供了<code>AsyncResult</code>事件，它可以在唤醒时传递消息。让我们将上例中的<code>setter</code>和<code>waiter</code>作如下改动:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent.event <span class="keyword">import</span> AsyncResult</span><br><span class="line"></span><br><span class="line">aevt = AsyncResult()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setter</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Wait for me'</span>)</span><br><span class="line">    gevent.sleep(<span class="number">3</span>)  <span class="comment"># 3秒后唤醒所有在evt上等待的协程</span></span><br><span class="line">    print(<span class="string">"Ok, I'm done"</span>)</span><br><span class="line">    aevt.set(<span class="string">'Hello!'</span>)  <span class="comment"># 唤醒，并传递消息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">waiter</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I'll wait for you"</span>)</span><br><span class="line">    message = aevt.get()  <span class="comment"># 等待，并在唤醒时获取消息</span></span><br><span class="line">    print(<span class="string">'Got wake up message: %s'</span> % message)</span><br></pre></td></tr></table></figure><h4 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 Queue</h4><p>队列Queue的概念相信大家都知道，我们可以用它的<code>put</code>和<code>get</code>方法来存取队列中的元素。gevent的队列对象可以让greenlet协程之间安全的访问。运行下面的程序，你会看到3个消费者会分别消费队列中的产品，且消费过的产品不会被另一个消费者再取到：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent.queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line">products = Queue()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> products.empty():</span><br><span class="line">        print(<span class="string">'%s got product %s'</span> % (name, products.get()))</span><br><span class="line">        gevent.sleep(<span class="number">0</span>)</span><br><span class="line">    print(<span class="string">'%s Quit'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">        products.put(i)</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(producer),</span><br><span class="line">    gevent.spawn(consumer, <span class="string">'steve'</span>),</span><br><span class="line">    gevent.spawn(consumer, <span class="string">'john'</span>),</span><br><span class="line">    gevent.spawn(consumer, <span class="string">'nancy'</span>),</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p><code>put</code>和<code>get</code>方法都是阻塞式的，它们都有非阻塞的版本：<code>put_nowait</code>和<code>get_nowait</code>。如果调用<code>get</code>方法时队列为空，则抛出<code>gevent.queue.Empty</code>异常。</p><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>信号量可以用来限制协程并发的个数。它有两个方法，<code>acquire</code>和<code>release</code>。顾名思义，<code>acquire</code>就是获取信号量，而<code>release</code>就是释放。当所有信号量都已被获取，那剩余的协程就只能等待任一协程释放信号量后才能得以运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent.coros <span class="keyword">import</span> BoundedSemaphore</span><br><span class="line"></span><br><span class="line">sem = BoundedSemaphore(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(n)</span>:</span></span><br><span class="line">    sem.acquire()</span><br><span class="line">    print(<span class="string">'Worker %i acquired semaphore'</span> % n)</span><br><span class="line">    gevent.sleep(<span class="number">0</span>)</span><br><span class="line">    sem.release()</span><br><span class="line">    print(<span class="string">'Worker %i released semaphore'</span> % n)</span><br><span class="line"></span><br><span class="line">gevent.joinall([gevent.spawn(worker, i) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, <span class="number">6</span>)])</span><br></pre></td></tr></table></figure><p>上面的例子中，我们初始化了<code>BoundedSemaphore</code>信号量，并将其个数定为<code>2</code>。所以同一个时间，只能有两个worker协程被调度。程序运行后的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Worker 0 acquired semaphore</span><br><span class="line">Worker 1 acquired semaphore</span><br><span class="line">Worker 0 released semaphore</span><br><span class="line">Worker 1 released semaphore</span><br><span class="line">Worker 2 acquired semaphore</span><br><span class="line">Worker 3 acquired semaphore</span><br><span class="line">Worker 2 released semaphore</span><br><span class="line">Worker 3 released semaphore</span><br><span class="line">Worker 4 acquired semaphore</span><br><span class="line">Worker 4 released semaphore</span><br><span class="line">Worker 5 acquired semaphore</span><br><span class="line">Worker 5 released semaphore</span><br></pre></td></tr></table></figure><p>如果信号量个数为1，那就等同于同步锁。</p><h4 id="协程本地变量"><a href="#协程本地变量" class="headerlink" title="协程本地变量"></a>协程本地变量</h4><p>同线程类似，协程也有本地变量，也就是只在当前协程内可被访问的变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">from</span> gevent.local <span class="keyword">import</span> local</span><br><span class="line"></span><br><span class="line">data = local()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    data.x = <span class="number">1</span></span><br><span class="line">    print(data.x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(data.x)</span><br><span class="line">    <span class="keyword">except</span> AttributeError:</span><br><span class="line">        print(<span class="string">'x is not visible'</span>)</span><br><span class="line"></span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(f1),</span><br><span class="line">    gevent.spawn(f2)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>通过将变量存放在<code>local</code>对象中，即可将其的作用域限制在当前协程内，当其他协程要访问该变量时，就会抛出异常。不同协程间可以有重名的本地变量，而且互相不影响。因为协程本地变量的实现，就是将其存放在以的<code>greenlet.getcurrent()</code>的返回为键值的私有的命名空间内。</p><p>Read More:</p><ol><li><a href="http://www.bjhee.com/gevent.html" target="_blank" rel="noopener">基于协程的Python网络库gevent介绍</a> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Gevent是一个并发网络库。它的协程是基于greenlet的，并基于libev实现快速事件循环（Linux上是epoll，FreeBSD上是kqueue，Mac OS X上是select）。有了Gevent，协程的使用将无比简单，你根本无须像greenlet一样显式的切换
      
    
    </summary>
    
      <category term="Python" scheme="http://runnerliu.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://runnerliu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python库-celery</title>
    <link href="http://runnerliu.github.io/2020/11/18/python-lib-celery/"/>
    <id>http://runnerliu.github.io/2020/11/18/python-lib-celery/</id>
    <published>2020-11-18T06:31:44.000Z</published>
    <updated>2020-11-22T11:50:10.675Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个分布式异步计算框架，Celery虽然常用于Web框架中，但也可以单独使用。常规搭配的消息队列是RabbitMQ、Redis。</p><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ tree your_project</span><br><span class="line">your_project</span><br><span class="line">├── __init__.py</span><br><span class="line">├── celery.py</span><br><span class="line">├── config.py</span><br><span class="line">└── tasks.py</span><br><span class="line"></span><br><span class="line">0 directories, 4 files</span><br></pre></td></tr></table></figure><p>其中<code>celery.py</code>是主文件，定义celery app，<code>config.py</code>是celery的配置，<code>tasks.py</code> 是异步任务的具体实现。</p><p><code>celery.py</code>文件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from __funture__ import absolute_import</span><br><span class="line">from celery import Celery, platform</span><br><span class="line"></span><br><span class="line">platform.C_FORCE_ROOT = true</span><br><span class="line"></span><br><span class="line">app = Celery(&apos;your project name&apos;)</span><br><span class="line">app.config_from_object(config)</span><br></pre></td></tr></table></figure><p><code>config.py</code>文件内容可参考下一节</p><p><code>tasks.py</code>文件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from __funture__ import absolute_import</span><br><span class="line"></span><br><span class="line">from .app import app</span><br><span class="line"></span><br><span class="line">@app.task</span><br><span class="line">def add(x, y):</span><br><span class="line">    return x + y</span><br><span class="line">    </span><br><span class="line">@app.task</span><br><span class="line">def sub(x, y):</span><br><span class="line">    return x - y</span><br></pre></td></tr></table></figure><p>运行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup /usr/local/python3.6/bin/python3.6 -m celery worker --loglevel=DEBUG --app=$&#123;PROGRAM_NAME&#125; --queues=$1 --hostname=$2 --pidfile=$3 1&gt;/dev/null 2&gt;/dev/null &amp;</span><br></pre></td></tr></table></figure><p>其中运行可参考后续章节。</p><h4 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h4><p>一次Task从触发到完成，序列图如下：</p><p><img src="/images/2020-11-22194305.jpg" alt="2020-11-22194305.png"></p><p>其中，<code>main</code>代表业务代码主进程。它可能是Django、Flask这类Web服务，也可能是一个其它类型的进程。<code>worker</code>就是指Celery的Worker。</p><p><code>main</code>发送消息后，会得到一个<code>AsyncResult</code>，其中包含<code>task_id</code>。仅通过<code>task_id</code>，也可以自己构造一个<code>AsyncResult</code>，查询相关信息。其中，代表运行过程的，主要是<code>state</code>。</p><p><code>worker</code>会持续保持对Redis（或其它消息队列，如RabbitMQ）的关注，查询新的消息。如果获得新消息，将其消费后，开始运行<code>do_sth</code>。</p><p>运行完成会把返回值对应的结果，以及一些运行信息，回写到Redis（或其它backend，如Django数据库等）上。在系统的任何地方，通过对应的<code>AsyncResult(task_id)</code>就可以查询到结果。</p><h4 id="celery-task的状态"><a href="#celery-task的状态" class="headerlink" title="celery task的状态"></a>celery task的状态</h4><p><img src="/images/2020-11-22194435.jpg" alt="2020-11-22194435.png"></p><p>其中，除<code>SUCCESS</code>外，还有失败（<code>FAILURE</code>）、取消（<code>REVOKED</code>）两个结束状态。而<code>RETRY</code>则是在设置了重试机制后，进入的临时等待状态。</p><p>另外，如果保存在Redis的结果信息被清理（默认仅保存1天），那么任务状态又会变成<code>PENDING</code>。这在设计上是个巨大的问题，使用时要做对应容错。</p><h4 id="celery常用配置"><a href="#celery常用配置" class="headerlink" title="celery常用配置"></a>celery常用配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># 指定任务接受的内容类型(序列化)</span><br><span class="line"># pickle/json/yaml/msgpack</span><br><span class="line">CELERY_ACCEPT_CONTENT = [&apos;json&apos;]</span><br><span class="line"></span><br><span class="line"># 时区</span><br><span class="line">CELERY_TIMEZONE = &apos;Asia/Shanghai&apos;</span><br><span class="line"></span><br><span class="line"># 调度任务</span><br><span class="line">CELERY_INCLUDE = [&apos;celerys.task&apos;]</span><br><span class="line"></span><br><span class="line"># 调度器 </span><br><span class="line">CELERYBEAT_SCHEDULER = &apos;celery.beat:PersistentScheduler&apos;</span><br><span class="line"></span><br><span class="line"># 调度器存储最后运行定时任务的时间</span><br><span class="line">CELERYBEAT_SCHEDULE_FILENAME = &apos;log/celery.db&apos;</span><br><span class="line"></span><br><span class="line"># 消息代理</span><br><span class="line">BROKER_URL = LBT_CONFIG_OTHER[&apos;BROKER_URL&apos;]</span><br><span class="line"></span><br><span class="line"># 广播前缀设置，由仅活动的虚拟机接收任务消息</span><br><span class="line">BROKER_TRANSPORT_OPTIONS = &#123;&apos;fanout_prefix&apos;: True&#125;</span><br><span class="line"></span><br><span class="line"># 结果存储地址</span><br><span class="line">CELERY_RESULT_BACKEND = BROKER_URL</span><br><span class="line"></span><br><span class="line"># 任务执行结果序列化方式</span><br><span class="line">CELERY_RESULT_SERIALIZER = &apos;json&apos;</span><br><span class="line"></span><br><span class="line"># 结果是否持久化，默认关闭</span><br><span class="line">CELERY_RESULT_PERSISTENT = False</span><br><span class="line"></span><br><span class="line"># 任务过期时间，单位秒</span><br><span class="line">CELERY_TASK_RESULT_EXPIRES = 60 * 60</span><br><span class="line"></span><br><span class="line"># 任务序列化方式</span><br><span class="line">CELERY_TASK_SERIALIZER = &apos;json&apos;</span><br><span class="line"></span><br><span class="line"># 任务执行最大时间，单位秒，超过会将worker杀死</span><br><span class="line">CELERY_TASK_TIME_LIMIT = 60 * 60</span><br><span class="line"></span><br><span class="line"># 不关心任务执行结果，无需持久化结果</span><br><span class="line">CELERY_TASK_IGNORE_RESULT = True</span><br><span class="line"></span><br><span class="line"># 并发worker数量，默认为cpu核数</span><br><span class="line">CELERYD_CONCURRENCY = 6</span><br><span class="line"></span><br><span class="line"># worker被杀死前执行的最大任务数</span><br><span class="line">CELERYD_MAX_TASKS_PER_CHILD = 1024</span><br><span class="line"></span><br><span class="line"># redis最大连接数</span><br><span class="line">CELERY_REDIS_MAX_CONNECTIONS = 1024</span><br></pre></td></tr></table></figure><p>更多配置参数请移步<a href="https://docs.celeryproject.org/en/stable/userguide/configuration.html" target="_blank" rel="noopener">Configuration and defaults</a></p><h4 id="worker命令行参数"><a href="#worker命令行参数" class="headerlink" title="worker命令行参数"></a>worker命令行参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">Global Options:</span><br><span class="line">  -A APP, --app APP</span><br><span class="line">  -b BROKER, --broker BROKER</span><br><span class="line">  --result-backend RESULT_BACKEND</span><br><span class="line">  --loader LOADER</span><br><span class="line">  --config CONFIG</span><br><span class="line">  --workdir WORKDIR     Optional directory to change to after detaching.</span><br><span class="line">  --no-color, -C</span><br><span class="line">  --quiet, -q</span><br><span class="line"></span><br><span class="line">Worker Options:</span><br><span class="line">  -n HOSTNAME, --hostname HOSTNAME</span><br><span class="line">                        Set custom hostname (e.g., &apos;w1@%h&apos;). Expands: %h</span><br><span class="line">                        (hostname), %n (name) and %d, (domain).</span><br><span class="line">  -D, --detach          Start worker as a background process.</span><br><span class="line">  -S STATEDB, --statedb STATEDB</span><br><span class="line">                        Path to the state database. The extension &apos;.db&apos; may be</span><br><span class="line">                        appended to the filename. Default: None</span><br><span class="line">  -l LOGLEVEL, --loglevel LOGLEVEL</span><br><span class="line">                        Logging level, choose between DEBUG, INFO, WARNING,</span><br><span class="line">                        ERROR, CRITICAL, or FATAL.</span><br><span class="line">  -O OPTIMIZATION</span><br><span class="line">  --prefetch-multiplier PREFETCH_MULTIPLIER</span><br><span class="line">                        Set custom prefetch multiplier value for this worker</span><br><span class="line">                        instance.</span><br><span class="line"></span><br><span class="line">Pool Options:</span><br><span class="line">  -c CONCURRENCY, --concurrency CONCURRENCY</span><br><span class="line">                        Number of child processes processing the queue. The</span><br><span class="line">                        default is the number of CPUs available on your</span><br><span class="line">                        system.</span><br><span class="line">  -P POOL, --pool POOL  Pool implementation: prefork (default), eventlet,</span><br><span class="line">                        gevent, threads or solo. 注意：threads只能在4.4.0以上版本使用</span><br><span class="line">  -E, --task-events, --events</span><br><span class="line">                        Send task-related events that can be captured by</span><br><span class="line">                        monitors like celery events, celerymon, and others.</span><br><span class="line">  --time-limit TIME_LIMIT</span><br><span class="line">                        Enables a hard time limit (in seconds int/float) for</span><br><span class="line">                        tasks.</span><br><span class="line">  --soft-time-limit SOFT_TIME_LIMIT</span><br><span class="line">                        Enables a soft time limit (in seconds int/float) for</span><br><span class="line">                        tasks.</span><br><span class="line">  --max-tasks-per-child MAX_TASKS_PER_CHILD, --maxtasksperchild MAX_TASKS_PER_CHILD</span><br><span class="line">                        Maximum number of tasks a pool worker can execute</span><br><span class="line">                        before it&apos;s terminated and replaced by a new worker.</span><br><span class="line">  --max-memory-per-child MAX_MEMORY_PER_CHILD, --maxmemperchild MAX_MEMORY_PER_CHILD</span><br><span class="line">                        Maximum amount of resident memory, in KiB, that may be</span><br><span class="line">                        consumed by a child process before it will be replaced</span><br><span class="line">                        by a new one. If a single task causes a child process</span><br><span class="line">                        to exceed this limit, the task will be completed and</span><br><span class="line">                        the child process will be replaced afterwards.</span><br><span class="line">                        Default: no limit.</span><br><span class="line"></span><br><span class="line">Queue Options:</span><br><span class="line">  --purge, --discard    Purges all waiting tasks before the daemon is started.</span><br><span class="line">                        **WARNING**: This is unrecoverable, and the tasks will</span><br><span class="line">                        be deleted from the messaging server.</span><br><span class="line">  --queues QUEUES, -Q QUEUES</span><br><span class="line">                        List of queues to enable for this worker, separated by</span><br><span class="line">                        comma. By default all configured queues are enabled.</span><br><span class="line">                        Example: -Q video,image</span><br><span class="line">  --exclude-queues EXCLUDE_QUEUES, -X EXCLUDE_QUEUES</span><br><span class="line">                        List of queues to disable for this worker, separated</span><br><span class="line">                        by comma. By default all configured queues are</span><br><span class="line">                        enabled. Example: -X video,image.</span><br><span class="line">  --include INCLUDE, -I INCLUDE</span><br><span class="line">                        Comma separated list of additional modules to import.</span><br><span class="line">                        Example: -I foo.tasks,bar.tasks</span><br><span class="line"></span><br><span class="line">Features:</span><br><span class="line">  --without-gossip      Don&apos;t subscribe to other workers events.</span><br><span class="line">  --without-mingle      Don&apos;t synchronize with other workers at start-up.</span><br><span class="line">  --without-heartbeat   Don&apos;t send event heartbeats.</span><br><span class="line">  --heartbeat-interval HEARTBEAT_INTERVAL</span><br><span class="line">                        Interval in seconds at which to send worker heartbeat</span><br><span class="line">  --autoscale AUTOSCALE</span><br><span class="line">                        Enable autoscaling by providing max_concurrency,</span><br><span class="line">                        min_concurrency. Example:: --autoscale=10,3 (always</span><br><span class="line">                        keep 3 processes, but grow to 10 if necessary)</span><br><span class="line"></span><br><span class="line">Daemonization Options:</span><br><span class="line">  -f LOGFILE, --logfile LOGFILE</span><br><span class="line">                        Path to log file. If no logfile is specified, stderr</span><br><span class="line">                        is used.</span><br><span class="line">  --pidfile PIDFILE     Optional file used to store the process pid. The</span><br><span class="line">                        program won&apos;t start if this file already exists and</span><br><span class="line">                        the pid is still alive.</span><br><span class="line">  --uid UID             User id, or user name of the user to run as after</span><br><span class="line">                        detaching.</span><br><span class="line">  --gid GID             Group id, or group name of the main group to change to</span><br><span class="line">                        after detaching.</span><br><span class="line">  --umask UMASK         Effective umask(1) (in octal) of the process after</span><br><span class="line">                        detaching. Inherits the umask(1) of the parent process</span><br><span class="line">                        by default.</span><br><span class="line">  --executable EXECUTABLE</span><br><span class="line">                        Executable to use for the detached process.</span><br><span class="line"></span><br><span class="line">Embedded Beat Options:</span><br><span class="line">  -B, --beat            Also run the celery beat periodic task scheduler.</span><br><span class="line">                        Please note that there must only be one instance of</span><br><span class="line">                        this service. .. note:: -B is meant to be used for</span><br><span class="line">                        development purposes. For production environment, you</span><br><span class="line">                        need to start celery beat separately.</span><br><span class="line">  -s SCHEDULE_FILENAME, --schedule-filename SCHEDULE_FILENAME, --schedule SCHEDULE_FILENAME</span><br><span class="line">                        Path to the schedule database if running with the -B</span><br><span class="line">                        option. Defaults to celerybeat-schedule. The extension</span><br><span class="line">                        &quot;.db&quot; may be appended to the filename. Apply</span><br><span class="line">                        optimization profile. Supported: default, fair</span><br><span class="line">  --scheduler SCHEDULER</span><br><span class="line">                        Scheduler class to use. Default is</span><br><span class="line">                        celery.beat.PersistentScheduler</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一个分布式异步计算框架，Celery虽然常用于Web框架中，但也可以单独使用。常规搭配的消息队列是RabbitMQ、Redis。&lt;/p&gt;
&lt;h4 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Python" scheme="http://runnerliu.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://runnerliu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Linux命令-jq</title>
    <link href="http://runnerliu.github.io/2020/11/12/linuxjq/"/>
    <id>http://runnerliu.github.io/2020/11/12/linuxjq/</id>
    <published>2020-11-12T11:31:04.000Z</published>
    <updated>2020-11-15T03:16:40.077Z</updated>
    
    <content type="html"><![CDATA[<p>jq可以对json数据进行分片、过滤、映射和转换，和sed、awk、grep等命令一样，都可以让你轻松地把玩文本。它能轻松地把你拥有的数据转换成你期望的格式，而且需要写的程序通常也比你期望的更加简短。github地址：<a href="https://stedolan.github.io/jq/" target="_blank" rel="noopener">https://stedolan.github.io/jq/</a></p><p>json示例文件jq.txt为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;&quot;name&quot;:&quot;站长工具&quot;,&quot;url&quot;:&quot;http://tool.chinaz.com&quot;,&quot;address&quot;:&#123;&quot;city&quot;:&quot;厦门&quot;,&quot;country&quot;:&quot;中国&quot;&#125;,&quot;arrayBrowser&quot;:[&#123;&quot;name&quot;:&quot;Google&quot;,&quot;url&quot;:&quot;http://www.google.com&quot;&#125;,&#123;&quot;name&quot;:&quot;Baidu&quot;,&quot;url&quot;&quot;http://www.baidu.com&quot;&#125;]&#125;,&#123;&quot;name&quot;:&quot;站长之家&quot;,&quot;url&quot;:&quot;http://tool.zzhome.com&quot;,&quot;address&quot;:&#123;&quot;city&quot;:&quot;大连&quot;,&quot;country&quot;:&quot;中国&quot;&#125;,&quot;arrayBrowser&quot;:[&#123;&quot;name&quot;:&quot;360&quot;,&quot;url&quot;:&quot;http://www.so.com&quot;&#125;,&#123;&quot;nme&quot;:&quot;bing&quot;,&quot;url&quot;:&quot;http://www.bing.com&quot;&#125;]&#125;]</span><br></pre></td></tr></table></figure><p>命令：<code>cat jq.txt|jq &#39;.&#39;</code></p><p>效果如下：</p><p><img src="/images/2020-11-15T103330.png" alt="2020-11-15T103330.png"></p><p>输出列表中的第一个元素，可以使用[index]：</p><p>命令：<code>cat jq.txt|jq &#39;.[0]&#39;</code></p><p>效果如下：</p><p><img src="/images/2020-11-15T103331.png" alt="2020-11-15T103331.png"></p><p>jq支持管道线<code>|</code>，它如同linux命令中的管道线——把前面命令的输出当作是后面命令的输入。如下命令把<code>.[0]</code>作为<code>{...}</code>的输入，进而访问嵌套的属性，如<code>.name</code>和<code>.address.city</code>。</p><p>命令：<code>cat jq.txt |jq &#39;.[0] | {name:.name,address:.address}&#39;</code></p><p>效果如下：</p><p><img src="/images/2020-11-15T103332.png" alt="2020-11-15T103332.png"></p><p>命令：<code>cat jq.txt |jq &#39;.[0] | {name:.name,city:.address.city}&#39;</code></p><p>效果如下：</p><p><img src="/images/2020-11-15T103333.png" alt="2020-11-15T103333.png"></p><p>命令：<code>cat jq.txt |jq &#39;.[0] | {name:.arrayBrowser[1],city:.address.city}&#39;</code></p><p>效果如下：</p><p><img src="/images/2020-11-15T103334.png" alt="2020-11-15T103334.png"></p><p>如果希望把jq的输出当作一个数组，可以在前后加上<code>[]</code>：</p><p>命令：<code>cat jq.txt |jq &quot;[.[] |{name:.arrayBrowser[1].name,city:.address.city}]&quot;</code></p><p>效果如下：</p><p><img src="/images/2020-11-15T103336.png" alt="2020-11-15T103336.png"></p><p>在{}中，冒号前面的名字是映射的名称，你可以任意修改，如： </p><p>命令：<code>cat jq.txt |jq &quot;[.[] |{name_001:.arrayBrowser[1].name,city_002:.address.city}]&quot;</code></p><p>效果如下：</p><p><img src="/images/2020-11-15T103335.png" alt="2020-11-15T103335.png"></p><p>参考：</p><blockquote><p><a href="https://www.jianshu.com/p/6de3cfdbdb0e" target="_blank" rel="noopener">给力的linux命令–jq简易教程</a></p><p><a href="http://einverne.github.io/post/2018/12/jq-command-line-json-processor.html" target="_blank" rel="noopener">每天学习一个命令：jq 命令行下处理 JSON</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;jq可以对json数据进行分片、过滤、映射和转换，和sed、awk、grep等命令一样，都可以让你轻松地把玩文本。它能轻松地把你拥有的数据转换成你期望的格式，而且需要写的程序通常也比你期望的更加简短。github地址：&lt;a href=&quot;https://stedolan.gi
      
    
    </summary>
    
      <category term="Linux/Unix" scheme="http://runnerliu.github.io/categories/Linux-Unix/"/>
    
    
      <category term="命令" scheme="http://runnerliu.github.io/tags/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="Linux" scheme="http://runnerliu.github.io/tags/Linux/"/>
    
      <category term="jq" scheme="http://runnerliu.github.io/tags/jq/"/>
    
  </entry>
  
  <entry>
    <title>Python库-watchdog</title>
    <link href="http://runnerliu.github.io/2020/11/11/python-lib-watchdog/"/>
    <id>http://runnerliu.github.io/2020/11/11/python-lib-watchdog/</id>
    <published>2020-11-11T01:56:04.000Z</published>
    <updated>2020-11-15T02:26:10.629Z</updated>
    
    <content type="html"><![CDATA[<p>库地址：<a href="https://pypi.org/project/watchdog/" target="_blank" rel="noopener">pypi</a> <a href="https://github.com/gorakhargosh/watchdog" target="_blank" rel="noopener">github</a></p><p>库功能：文件监控</p><p>使用示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">from watchdog.events import FileSystemEventHandler</span><br><span class="line">from watchdog.observers import Observer</span><br><span class="line"></span><br><span class="line">class FileEventHandler(FileSystemEventHandler):</span><br><span class="line">    </span><br><span class="line">    def __init__(self, callback_func):</span><br><span class="line">        super(FileEventHandler, self).__init__()</span><br><span class="line">        self.callback_func = callback_func</span><br><span class="line"></span><br><span class="line">def on_moved(self, event):</span><br><span class="line">        what = &apos;directory&apos; if event.is_directory else &apos;file&apos;</span><br><span class="line">        self.callback_func(src_path, what)</span><br><span class="line"></span><br><span class="line">    def on_created(self, event):</span><br><span class="line">        what = &apos;directory&apos; if event.is_directory else &apos;file&apos;</span><br><span class="line">        self.callback_func(src_path, what)</span><br><span class="line"></span><br><span class="line">    def on_deleted(self, event):</span><br><span class="line">        what = &apos;directory&apos; if event.is_directory else &apos;file&apos;</span><br><span class="line">        self.callback_func(src_path, what)</span><br><span class="line"></span><br><span class="line">    def on_modified(self, event):</span><br><span class="line">        what = &apos;directory&apos; if event.is_directory else &apos;file&apos;</span><br><span class="line">        self.callback_func(src_path, what)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TaskHandler(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.file_observer = None</span><br><span class="line">        self.file_observer_path = None</span><br><span class="line"></span><br><span class="line">    def observer_start(self):</span><br><span class="line">        if not os.path.exists(self.file_observer_path):</span><br><span class="line">            os.makedirs(self.file_observer_path)</span><br><span class="line">        event_handler = FileEventHandler(self.callback)</span><br><span class="line">        self.file_observer = Observer()</span><br><span class="line">        self.file_observer.schedule(event_handler, self.file_observer_path)</span><br><span class="line">        self.file_observer.start()</span><br><span class="line"></span><br><span class="line">    def observer_stop(self):</span><br><span class="line">        if self.file_observer:</span><br><span class="line">            self.file_observer.stop()</span><br><span class="line">            self.file_observer.join()</span><br><span class="line">    </span><br><span class="line">    def observer_restart(self):</span><br><span class="line">        self.observer_stop()</span><br><span class="line">        self.observer_start()</span><br><span class="line"></span><br><span class="line">    def callback(self, src_path):</span><br><span class="line">        self.logger.debug(&apos;file changed. &#123;&#125;&apos;.format(src_path))</span><br><span class="line">        </span><br><span class="line">    def run(self):</span><br><span class="line">        self.observer_start()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;库地址：&lt;a href=&quot;https://pypi.org/project/watchdog/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pypi&lt;/a&gt; &lt;a href=&quot;https://github.com/gorakhargosh/watchdo
      
    
    </summary>
    
      <category term="Python" scheme="http://runnerliu.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://runnerliu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python常见异常</title>
    <link href="http://runnerliu.github.io/2020/11/10/python-except-enum/"/>
    <id>http://runnerliu.github.io/2020/11/10/python-except-enum/</id>
    <published>2020-11-10T09:19:12.000Z</published>
    <updated>2020-11-15T02:24:39.477Z</updated>
    
    <content type="html"><![CDATA[<h4 id="TypeError"><a href="#TypeError" class="headerlink" title="TypeError"></a>TypeError</h4><p><code>&#39;builtin_function_or_method&#39; object is not subscriptable</code></p><p>此异常一般是上下文代码中有语法错误，缺少()。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;TypeError&quot;&gt;&lt;a href=&quot;#TypeError&quot; class=&quot;headerlink&quot; title=&quot;TypeError&quot;&gt;&lt;/a&gt;TypeError&lt;/h4&gt;&lt;p&gt;&lt;code&gt;&amp;#39;builtin_function_or_method&amp;#39;
      
    
    </summary>
    
      <category term="Python" scheme="http://runnerliu.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="http://runnerliu.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Linux CentOS 系统时间校对</title>
    <link href="http://runnerliu.github.io/2020/10/27/linux-centos-sys-time/"/>
    <id>http://runnerliu.github.io/2020/10/27/linux-centos-sys-time/</id>
    <published>2020-10-27T14:28:58.000Z</published>
    <updated>2020-11-15T02:24:39.470Z</updated>
    
    <content type="html"><![CDATA[<h4 id="CentOS系统时间、时区查看"><a href="#CentOS系统时间、时区查看" class="headerlink" title="CentOS系统时间、时区查看"></a>CentOS系统时间、时区查看</h4><p>查看系统时间：date</p><p>查看硬件时间：hwclock</p><p>查看系统详细时间：timedatectl</p><p>查看系统所有时区：timedatectl list-timezones</p><p>将硬件时钟调整为与本地时钟一致：timedatectl set-local-rtc 1（其中 0 表示UTC时间）</p><p>设置系统时区为上海：timedatectl set-timezone Asia/Shanghai</p><h4 id="校正系统时间"><a href="#校正系统时间" class="headerlink" title="校正系统时间"></a>校正系统时间</h4><p>确认是否安装utpdate工具：<code>yum list installed|grep ntpdate</code></p><p>如未安装，需执行 <code>yum -y install ntpdate</code> </p><p>执行 <code>ntpdate -u  pool.ntp.org</code> 进行时间校正</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;CentOS系统时间、时区查看&quot;&gt;&lt;a href=&quot;#CentOS系统时间、时区查看&quot; class=&quot;headerlink&quot; title=&quot;CentOS系统时间、时区查看&quot;&gt;&lt;/a&gt;CentOS系统时间、时区查看&lt;/h4&gt;&lt;p&gt;查看系统时间：date&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="Linux" scheme="http://runnerliu.github.io/categories/Linux/"/>
    
    
      <category term="CentOS" scheme="http://runnerliu.github.io/tags/CentOS/"/>
    
      <category term="系统时间" scheme="http://runnerliu.github.io/tags/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4/"/>
    
      <category term="Linux" scheme="http://runnerliu.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>GF-CLI学习系列</title>
    <link href="http://runnerliu.github.io/2020/10/27/gf-cli-series-0-md/"/>
    <id>http://runnerliu.github.io/2020/10/27/gf-cli-series-0-md/</id>
    <published>2020-10-27T07:13:50.000Z</published>
    <updated>2020-11-15T02:24:39.465Z</updated>
    
    <content type="html"><![CDATA[<h4 id="gen"><a href="#gen" class="headerlink" title="gen"></a>gen</h4><p>该命令用以自动化从数据库直接生成模型文件。</p><p>该命令将会根据数据表名（注意：所以要先在数据里建好表）生成对应的目录，该目录名称即数据表包名。</p><p>目录下自动生成3个文件：</p><ul><li>数据表名.go 自定义文件，开发者可以自由定义填充的代码文件，仅会生成一次，每一次模型生成不会覆盖</li><li>数据表名_entity.go 表结构文件，根据数据表结构生成的结构体定义文件，包含字段注释。数据表在外部变更后，可使用gen命令重复生成更新该文件</li><li>数据表名_model.go 表模型文件，为数据表提供了许多便捷的CURD操作方法，并可直接查询返回该表的结构体对象。数据表在外部变更后，可使用gen命令重复生成更新该文件</li></ul><p>使用方式：<code>gf gen model ./app/model -c config/config.toml -p sys_ -t sys_users</code></p><p>命令说明：</p><ul><li>./app/model：在model生成的路径</li><li>-c config/config.toml：在这个配置里找database数据库连接配置 需要写好mysql的配置信息</li><li>-p sys_：去除生成文件目录的sys前缀 如果不加这个参数就会按数据库名生成目录和文件名 如：sys_users</li><li>-t sys_users：要生成model的数据表文件名</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;gen&quot;&gt;&lt;a href=&quot;#gen&quot; class=&quot;headerlink&quot; title=&quot;gen&quot;&gt;&lt;/a&gt;gen&lt;/h4&gt;&lt;p&gt;该命令用以自动化从数据库直接生成模型文件。&lt;/p&gt;
&lt;p&gt;该命令将会根据数据表名（注意：所以要先在数据里建好表）生成对应的目录，该目
      
    
    </summary>
    
      <category term="gf-cli" scheme="http://runnerliu.github.io/categories/gf-cli/"/>
    
    
      <category term="gf" scheme="http://runnerliu.github.io/tags/gf/"/>
    
      <category term="gf-cli" scheme="http://runnerliu.github.io/tags/gf-cli/"/>
    
  </entry>
  
  <entry>
    <title>GO学习系列0 - 学习资料</title>
    <link href="http://runnerliu.github.io/2020/10/26/go-series-0/"/>
    <id>http://runnerliu.github.io/2020/10/26/go-series-0/</id>
    <published>2020-10-26T10:31:25.000Z</published>
    <updated>2020-11-15T02:24:39.466Z</updated>
    
    <content type="html"><![CDATA[<h4 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h4><p><a href="https://github.com/golang/go" target="_blank" rel="noopener">github.com/golang/go</a></p><p><a href="https://learnku.com/docs/gobyexample/2020" target="_blank" rel="noopener">Go 编程实例 Go by Example</a></p><p><a href="https://learnku.com/docs/the-way-to-go" target="_blank" rel="noopener">Go 入门指南</a></p><h4 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h4><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><h5 id="Go-Frame"><a href="#Go-Frame" class="headerlink" title="Go Frame"></a>Go Frame</h5><ul><li><a href="https://goframe.org/index" target="_blank" rel="noopener">框架介绍</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;文档&quot;&gt;&lt;a href=&quot;#文档&quot; class=&quot;headerlink&quot; title=&quot;文档&quot;&gt;&lt;/a&gt;文档&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/golang/go&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
      
    
    </summary>
    
      <category term="GO" scheme="http://runnerliu.github.io/categories/GO/"/>
    
    
      <category term="GO" scheme="http://runnerliu.github.io/tags/GO/"/>
    
  </entry>
  
  <entry>
    <title>HTTP1.0、HTTP1.1、HTTP2.0的区别</title>
    <link href="http://runnerliu.github.io/2020/10/25/tcpdiff/"/>
    <id>http://runnerliu.github.io/2020/10/25/tcpdiff/</id>
    <published>2020-10-25T06:52:48.000Z</published>
    <updated>2020-11-15T02:24:39.480Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP发展史"><a href="#HTTP发展史" class="headerlink" title="HTTP发展史"></a>HTTP发展史</h3><p><img src="/images/2020-10-25T150500.png" alt="2020-10-25T150500.png"></p><h3 id="HTTP的优化"><a href="#HTTP的优化" class="headerlink" title="HTTP的优化"></a>HTTP的优化</h3><p>影响一个HTTP网络请求的因素主要有两个：带宽和延迟。</p><p><strong>带宽</strong></p><p>现在的网络基础建设已使得带宽得到极大的提升，在影响网速的因素中，带宽所占比重越来越少。</p><p><strong>延迟</strong></p><p>浏览器阻塞：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。</p><p>DNS 解析：浏览器需要知道目标服务器的 IP 才能建立连接。此过程为DNS解析，可参考<a href="https://runnerliu.github.io/2017/06/22/urlrequestprocess/">从输入 URL 到页面展示到底发生了什么</a>，这个通常可以利用DNS缓存结果来达到减少这个时间的目的。</p><p>建立连接：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能携带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。</p><h3 id="HTTP1-0、HTTP1-1"><a href="#HTTP1-0、HTTP1-1" class="headerlink" title="HTTP1.0、HTTP1.1"></a>HTTP1.0、HTTP1.1</h3><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别体现在：</p><p><strong>缓存处理</strong></p><p>在HTTP1.0中主要使用header里的If-Modified-Since、Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag、If-Unmodified-Since、If-Match、If-None-Match等更多可供选择的缓存头来控制缓存策略。</p><p><strong>带宽优化及网络连接</strong></p><p>HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p><p><strong>错误通知的管理</strong></p><p>在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突、410（Gone）表示服务器上的某个资源被永久性的删除。</p><p><strong>Host头处理</strong></p><p>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p><p><strong>长连接</strong></p><p>HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection: keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</p><h3 id="HTTPS、HTTP的区别"><a href="#HTTPS、HTTP的区别" class="headerlink" title="HTTPS、HTTP的区别"></a>HTTPS、HTTP的区别</h3><ul><li>HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费</li><li>HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的</li><li>HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443</li><li>HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题</li></ul><p><img src="/images/2020-10-25T152300.png" alt="2020-10-25T152300.png"></p><h3 id="说说SPDY"><a href="#说说SPDY" class="headerlink" title="说说SPDY"></a>说说SPDY</h3><p>其实 SPDY 并不是新的一种协议，而是在 HTTP 之前做了一层会话层。</p><p><img src="/images/2020-10-25T152800.png" alt="2020-10-25T152800.png"></p><p>SPDY是一个由 Google 主导的研究项目发明的HTTP替代协议。SPDY位于HTTP之下、TCP/SSL之上，这样可以轻松兼容老版本的HTTP协议，同时可以使用已有的SSL功能。SPDY优化了HTTP1.X的请求延迟，解决了HTTP1.X的安全性，具体如下：</p><p><strong>降低延迟</strong></p><p>针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。</p><p><strong>请求优先级</strong></p><p>多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。</p><p><strong>header压缩</strong></p><p>前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</p><p><strong>传输协议</strong></p><p>基于HTTPS的加密协议传输，大大提高了传输数据的可靠性。</p><p><strong>服务端推送</strong></p><p>采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。</p><h3 id="HTTP2-0"><a href="#HTTP2-0" class="headerlink" title="HTTP2.0"></a>HTTP2.0</h3><p>HTTP2.0是基于SPDY设计的，但与SPDY 仍有不同的地方，如下：</p><ul><li>HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS</li><li>HTTP2.0 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DEFLATE</li></ul><h4 id="HTTP2-0的新特性"><a href="#HTTP2-0的新特性" class="headerlink" title="HTTP2.0的新特性"></a>HTTP2.0的新特性</h4><h5 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h5><p>HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</p><p><img src="/images/2020-10-25T154700.png" alt="2020-10-25T154700.png"></p><p>在应用层与传输层之间增加一个二进制分帧层，以此达到在不改动 HTTP 的语义，HTTP 方法、状态码、URI 及首部字段的情况下，突破HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。在二进制分帧层上，HTTP2.0 会将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，其中 HTTP1.x 的首部信息会被封装到 Headers 帧，而我们的 request body 则封装到 Data 帧里面。</p><h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><p>即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</p><p><img src="/images/2020-10-25T154800.png" alt="2020-10-25T154800.png"></p><h5 id="header压缩"><a href="#header压缩" class="headerlink" title="header压缩"></a>header压缩</h5><p>如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p><p><img src="/images/2020-10-25T154900.png" alt="2020-10-25T154900.png"></p><h5 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h5><p>同SPDY一样，HTTP2.0也具有server push功能。</p><p>客户端请求的过程：</p><p><img src="/images/2020-10-25T155200.png" alt="2020-10-25T155200.png"></p><p>服务端推送的过程：</p><p><img src="/images/2020-10-25T155300.png" alt="2020-10-25T155300.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>HTTP1.0到HTTP1.1，是无连接到长连接的发展</p></li><li><p>HTTP1.x到HTTP2.0，是二进制分帧、多路复用的发展</p></li></ul><p>参考：</p><blockquote><p><a href="https://www.jianshu.com/p/be29d679cbff" target="_blank" rel="noopener">HTTP1.0、HTTP1.1和HTTP2.0的区别</a></p><p><a href="https://juejin.im/post/6844903824390537230" target="_blank" rel="noopener">HTTP1.0，HTTP1.1，HTTPS和HTTP2.0的区别</a></p><p><a href="https://juejin.im/post/6844903712113360903" target="_blank" rel="noopener">HTTP 的前世今生：一次性搞懂 HTTP、HTTPS、SPDY、HTTP2</a></p><p><a href="https://zh.wikipedia.org/wiki/HTTP/2" target="_blank" rel="noopener">HTTP/2</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;HTTP发展史&quot;&gt;&lt;a href=&quot;#HTTP发展史&quot; class=&quot;headerlink&quot; title=&quot;HTTP发展史&quot;&gt;&lt;/a&gt;HTTP发展史&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/2020-10-25T150500.png&quot; alt=&quot;2020
      
    
    </summary>
    
      <category term="HTTP" scheme="http://runnerliu.github.io/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://runnerliu.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>CentOS编译安装Python3</title>
    <link href="http://runnerliu.github.io/2018/06/26/centosinstallpython3/"/>
    <id>http://runnerliu.github.io/2018/06/26/centosinstallpython3/</id>
    <published>2018-06-26T14:25:22.000Z</published>
    <updated>2020-11-15T02:24:39.464Z</updated>
    
    <content type="html"><![CDATA[<p>Linux 下大部分系统默认自带 python2.x 的版本，最常见的是 python2.6 或 python2.7 版本，默认的python 被系统很多程序所依赖，比如 CentOS 下的 yum 就是 python2.x 写的，所以默认版本不要轻易删除，否则会有一些问题。如果需要使用最新的 Python3 那么我们可以编译安装源码包到独立目录，这和系统默认环境之间是没有任何影响的，Python3 和 Python2 两个环境并存即可。</p><p>首先去 Python 官网下载 Python3 的源码包，<a href="https://www.python.org/" target="_blank" rel="noopener">传送门</a> </p><p>进去之后点击导航栏的 Downloads，也可以鼠标放到 Downloads 上弹出菜单选择 Source code，表示源码包，这里选择最新版本 3.6.5，当然下面也有很多其他历史版本，点进去之后页面下方可以看到下载链接，包括源码包、Mac OSX 安装包、Windows 安装包等。Linux 系统可以直接使用以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz</span><br></pre></td></tr></table></figure><p>接下来，如果是全新的 Linux 系统，可能需要安装一些 Python 的依赖，如 openssl、readline等模块。需要的依赖主要如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yum -y install zlib zlib-devel</span><br><span class="line">yum -y install bzip2 bzip2-devel</span><br><span class="line">yum -y install ncurses ncurses-devel</span><br><span class="line">yum -y install readline readline-devel</span><br><span class="line">yum -y install openssl openssl-devel</span><br><span class="line">yum -y install openssl-static</span><br><span class="line">yum -y install xz lzma xz-devel</span><br><span class="line">yum -y install sqlite sqlite-devel</span><br><span class="line">yum -y install gdbm gdbm-devel</span><br><span class="line">yum -y install tk tk-devel</span><br></pre></td></tr></table></figure><p>如果不是全新的 Linux 系统，可以查看是否安装了以上依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum list installed | grep zlib</span><br><span class="line">yum list installed | grep zlib-devel</span><br><span class="line">yum list installed | grep bzip2</span><br><span class="line">yum list installed | grep bzip2-devel</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>解压文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf Python-3.6.5.tgz</span><br></pre></td></tr></table></figure><p>进入目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd Python-3.6.5/</span><br></pre></td></tr></table></figure><p>配置编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/usr/local/python3.6.5 --enable-shared CFLAGS=-fPIC</span><br></pre></td></tr></table></figure><p>因为上面依赖包是用 yum 安装而不是自己编译的，所以都是安装在系统默认目录下，因此各种选项不用加默认即可生效。<code>--enable-shared</code> 和 <code>-fPIC</code> 之后可以将 Python3 的动态链接库编译出来，默认情况编译完 lib 下面只有 Python3.xm.a 这样的文件，python本身可以正常使用，但是如果编译第三方库需要python 接口的比如 caffe 等，则会报错；所以这里建议按照上面的方式配置。</p><p>然后编译并安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>整个过程大约5分钟，安装成功之后，安装目录就在 <code>/usr/local/python3.6.5/</code> 。</p><p>一般为了系统环境的干净，不需要将 python3、pip3 加入到系统环境变量中，使用全路径运行 Python 文件或安装第三方库即可，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/python3.6.5/bin/python3.6 xxx.py</span><br><span class="line">/usr/local/python3.6.5/bin/pip3.6 install twisted</span><br></pre></td></tr></table></figure><p>但是一般在开发机上时，加入环境变量会更加方便，建立软连接如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/python3.6.5/bin/python3.6 /usr/bin/python36</span><br><span class="line">ln -s /usr/python3.6.5/bin/pip3 /usr/bin/pip3</span><br></pre></td></tr></table></figure><p>然后可以直接使用软连接运行 Python 文件或安装第三方库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python36 xxx.py</span><br><span class="line">pip3 install twisted</span><br></pre></td></tr></table></figure><p>如上在 CentOS 上安装 Python3 就完成了，安装其他版本的 Python 解释器同理。</p><p>Read More:</p><blockquote><p><a href="https://www.cnblogs.com/freeweb/p/5181764.html" target="_blank" rel="noopener">Linux下编译安装python3</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux 下大部分系统默认自带 python2.x 的版本，最常见的是 python2.6 或 python2.7 版本，默认的python 被系统很多程序所依赖，比如 CentOS 下的 yum 就是 python2.x 写的，所以默认版本不要轻易删除，否则会有一些问题
      
    
    </summary>
    
      <category term="Linux/Unix" scheme="http://runnerliu.github.io/categories/Linux-Unix/"/>
    
    
      <category term="Linux/Unix" scheme="http://runnerliu.github.io/tags/Linux-Unix/"/>
    
      <category term="Python3" scheme="http://runnerliu.github.io/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Tornado5.0.2翻译文档 - Queue示例:一个并发网络爬虫</title>
    <link href="http://runnerliu.github.io/2018/06/18/tornado502-concurrentwebspider/"/>
    <id>http://runnerliu.github.io/2018/06/18/tornado502-concurrentwebspider/</id>
    <published>2018-06-18T06:59:43.000Z</published>
    <updated>2020-11-15T02:24:39.481Z</updated>
    
    <content type="html"><![CDATA[<p>Tornado的 <a href="http://tornado-zh.readthedocs.io/zh/latest/queues.html#module-tornado.queues" target="_blank" rel="noopener"><code>tornado.queues</code></a> 模块实现了异步生产者/消费者模式的协程，类似于通过Python 标准库的 <a href="https://docs.python.org/3.4/library/queue.html#module-queue" target="_blank" rel="noopener"><code>queue</code></a> 实现线程模式。</p><p>一个yields <a href="http://tornado-zh.readthedocs.io/zh/latest/queues.html#tornado.queues.Queue.get" target="_blank" rel="noopener"><code>Queue.get</code></a> 的协程直到队列中有值的时候才会暂停。如果队列设置了最大长度，yields <a href="http://tornado-zh.readthedocs.io/zh/latest/queues.html#tornado.queues.Queue.put" target="_blank" rel="noopener"><code>Queue.put</code></a> 的协程直到队列中有空间才会暂停。</p><p>一个 <a href="http://tornado-zh.readthedocs.io/zh/latest/queues.html#tornado.queues.Queue" target="_blank" rel="noopener"><code>Queue</code></a> 从0开始对未完成的任务进行计数， <a href="http://tornado-zh.readthedocs.io/zh/latest/queues.html#tornado.queues.Queue.put" target="_blank" rel="noopener"><code>put</code></a> 加计数； <a href="http://tornado-zh.readthedocs.io/zh/latest/queues.html#tornado.queues.Queue.task_done" target="_blank" rel="noopener"><code>task_done</code></a> 减少计数。</p><p>这里的网络爬虫的例子，队列开始的时候只包含 base_url。当一个 worker 抓取到一个页面它会解析链接并把它添加到队列中，然后调用 <a href="http://tornado-zh.readthedocs.io/zh/latest/queues.html#tornado.queues.Queue.task_done" target="_blank" rel="noopener"><code>task_done</code></a> 减少计数一次。最后，当一个 worker 抓取到的页面 URL 都是之前抓取到过的并且队列中没有任务了。于是 worker 调用 <a href="http://tornado-zh.readthedocs.io/zh/latest/queues.html#tornado.queues.Queue.task_done" target="_blank" rel="noopener"><code>task_done</code></a> 把计数减到0。等待 <a href="http://tornado-zh.readthedocs.io/zh/latest/queues.html#tornado.queues.Queue.join" target="_blank" rel="noopener"><code>join</code></a> 的主协程取消暂停并且完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">import time</span><br><span class="line">from datetime import timedelta</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    from HTMLParser import HTMLParser</span><br><span class="line">    from urlparse import urljoin, urldefrag</span><br><span class="line">except ImportError:</span><br><span class="line">    from html.parser import HTMLParser</span><br><span class="line">    from urllib.parse import urljoin, urldefrag</span><br><span class="line"></span><br><span class="line">from tornado import httpclient, gen, ioloop, queues</span><br><span class="line"></span><br><span class="line">base_url = &apos;http://www.tornadoweb.org/en/stable/&apos;</span><br><span class="line">concurrency = 10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@gen.coroutine</span><br><span class="line">def get_links_from_url(url):</span><br><span class="line">    &quot;&quot;&quot;Download the page at `url` and parse it for links.</span><br><span class="line"></span><br><span class="line">    Returned links have had the fragment after `#` removed, and have been made</span><br><span class="line">    absolute so, e.g. the URL &apos;gen.html#tornado.gen.coroutine&apos; becomes</span><br><span class="line">    &apos;http://www.tornadoweb.org/en/stable/gen.html&apos;.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    try:</span><br><span class="line">        response = yield httpclient.AsyncHTTPClient().fetch(url)</span><br><span class="line">        print(&apos;fetched %s&apos; % url)</span><br><span class="line"></span><br><span class="line">        html = response.body if isinstance(response.body, str) \</span><br><span class="line">            else response.body.decode(errors=&apos;ignore&apos;)</span><br><span class="line">        urls = [urljoin(url, remove_fragment(new_url))</span><br><span class="line">                for new_url in get_links(html)]</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(&apos;Exception: %s %s&apos; % (e, url))</span><br><span class="line">        raise gen.Return([])</span><br><span class="line"></span><br><span class="line">    raise gen.Return(urls)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def remove_fragment(url):</span><br><span class="line">    pure_url, frag = urldefrag(url)</span><br><span class="line">    return pure_url</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def get_links(html):</span><br><span class="line">    class URLSeeker(HTMLParser):</span><br><span class="line">        def __init__(self):</span><br><span class="line">            HTMLParser.__init__(self)</span><br><span class="line">            self.urls = []</span><br><span class="line"></span><br><span class="line">        def handle_starttag(self, tag, attrs):</span><br><span class="line">            href = dict(attrs).get(&apos;href&apos;)</span><br><span class="line">            if href and tag == &apos;a&apos;:</span><br><span class="line">                self.urls.append(href)</span><br><span class="line"></span><br><span class="line">    url_seeker = URLSeeker()</span><br><span class="line">    url_seeker.feed(html)</span><br><span class="line">    return url_seeker.urls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@gen.coroutine</span><br><span class="line">def main():</span><br><span class="line">    q = queues.Queue()</span><br><span class="line">    start = time.time()</span><br><span class="line">    fetching, fetched = set(), set()</span><br><span class="line"></span><br><span class="line">    @gen.coroutine</span><br><span class="line">    def fetch_url():</span><br><span class="line">        current_url = yield q.get()</span><br><span class="line">        try:</span><br><span class="line">            if current_url in fetching:</span><br><span class="line">                return</span><br><span class="line"></span><br><span class="line">            print(&apos;fetching %s&apos; % current_url)</span><br><span class="line">            fetching.add(current_url)</span><br><span class="line">            urls = yield get_links_from_url(current_url)</span><br><span class="line">            fetched.add(current_url)</span><br><span class="line"></span><br><span class="line">            for new_url in urls:</span><br><span class="line">                # Only follow links beneath the base URL</span><br><span class="line">                if new_url.startswith(base_url):</span><br><span class="line">                    yield q.put(new_url)</span><br><span class="line"></span><br><span class="line">        finally:</span><br><span class="line">            q.task_done()</span><br><span class="line"></span><br><span class="line">    @gen.coroutine</span><br><span class="line">    def worker():</span><br><span class="line">        while True:</span><br><span class="line">            yield fetch_url()</span><br><span class="line"></span><br><span class="line">    q.put(base_url)</span><br><span class="line"></span><br><span class="line">    # Start workers, then wait for the work queue to be empty.</span><br><span class="line">    for _ in range(concurrency):</span><br><span class="line">        worker()</span><br><span class="line">    yield q.join(timeout=timedelta(seconds=300))</span><br><span class="line">    assert fetching == fetched</span><br><span class="line">    print(&apos;Done in %d seconds, fetched %s URLs.&apos; % (</span><br><span class="line">        time.time() - start, len(fetched)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    io_loop = ioloop.IOLoop.current()</span><br><span class="line">    io_loop.run_sync(main)</span><br></pre></td></tr></table></figure><p>Read More:</p><blockquote><p><a href="http://www.tornadoweb.org/en/stable/guide/queues.html" target="_blank" rel="noopener"><code>Queue</code> example - a concurrent web spider</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Tornado的 &lt;a href=&quot;http://tornado-zh.readthedocs.io/zh/latest/queues.html#module-tornado.queues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;torn
      
    
    </summary>
    
      <category term="Tornado" scheme="http://runnerliu.github.io/categories/Tornado/"/>
    
    
      <category term="Tornado" scheme="http://runnerliu.github.io/tags/Tornado/"/>
    
      <category term="翻译文档" scheme="http://runnerliu.github.io/tags/%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3/"/>
    
      <category term="并发网络爬虫" scheme="http://runnerliu.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Tornado5.0.2翻译文档 - 协程</title>
    <link href="http://runnerliu.github.io/2018/06/18/tornado502-coroutines/"/>
    <id>http://runnerliu.github.io/2018/06/18/tornado502-coroutines/</id>
    <published>2018-06-18T05:36:42.000Z</published>
    <updated>2020-11-15T02:24:39.482Z</updated>
    
    <content type="html"><![CDATA[<p>Tornado中推荐使用 <strong>协程</strong> 编写异步代码，协程使用了Python的 <code>yield</code> 关键字代替链式回调来将程序挂起和恢复执行(像在 <a href="http://www.gevent.org/" target="_blank" rel="noopener">gevent</a> 中出现的轻量级线程合作方式有时也被称为协程，但是在Tornado中所有的协程使用明确的上下文切换，并被称为异步函数)。</p><p>使用协程几乎像写同步代码一样简单，并且不需要浪费额外的线程。它们还通过减少上下文切换来 <a href="https://glyph.twistedmatrix.com/2014/02/unyielding.html" target="_blank" rel="noopener">使并发编程更简单</a> 。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from tornado import gen</span><br><span class="line"></span><br><span class="line">@gen.coroutine</span><br><span class="line">def fetch_coroutine(url):</span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    response = yield http_client.fetch(url)</span><br><span class="line">    # In Python versions prior to 3.3, returning a value from</span><br><span class="line">    # a generator is not allowed and you must use</span><br><span class="line">    #   raise gen.Return(response.body)</span><br><span class="line">    # instead.</span><br><span class="line">    return response.body</span><br></pre></td></tr></table></figure><h3 id="Python-3-5-async-和-await"><a href="#Python-3-5-async-和-await" class="headerlink" title="Python 3.5: async 和 await"></a>Python 3.5: <code>async</code> 和 <code>await</code></h3><p>Python 3.5 引入了 <code>async</code> 和 <code>await</code> 关键字(使用这些关键字的函数也被称为”原生协程”)。从Tornado 4.3，你可以用它们代替 <code>yield</code> 为基础的协程。只需要简单的使用 <code>async def foo()</code> 在函数定义的时候代替 <a href="mailto:`@gen.coroutine" target="_blank" rel="noopener">`@gen.coroutine</a><code>装饰器，用</code>await<code>代替 yield。本文档的其他部分会继续使用</code>yield<code>的风格来和旧版本的Python兼容，但是如果</code>async<code>和</code>await` 可用的话，它们运行起来会更快：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async def fetch_coroutine(url):</span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    response = await http_client.fetch(url)</span><br><span class="line">    return response.body</span><br></pre></td></tr></table></figure><p><code>await</code> 关键字比 <code>yield</code> 关键字功能要少一些。例如，在一个使用 <code>yield</code> 的协程中，你可以得到 <code>Futures</code> 列表，但是在原生协程中，你必须把列表用 <a href="http://tornado-zh.readthedocs.io/zh/latest/gen.html#tornado.gen.multi" target="_blank" rel="noopener"><code>tornado.gen.multi</code></a> 包起来。同时也去掉了与 <a href="https://docs.python.org/3.6/library/concurrent.futures.html#module-concurrent.futures" target="_blank" rel="noopener"><code>concurrent.futures</code></a> 的集成。你也可以使用 <a href="http://tornado-zh.readthedocs.io/zh/latest/gen.html#tornado.gen.convert_yielded" target="_blank" rel="noopener"><code>tornado.gen.convert_yielded</code></a> 来把任何使用 <code>yield</code> 工作的代码转换成使用 <code>await</code> 的形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">async def f():</span><br><span class="line">    executor = concurrent.futures.ThreadPoolExecutor()</span><br><span class="line">    await tornado.gen.convert_yielded(executor.submit(g))</span><br></pre></td></tr></table></figure><h3 id="它如何工作"><a href="#它如何工作" class="headerlink" title="它如何工作"></a>它如何工作</h3><p>包含了 <code>yield</code> 关键字的函数是一个 <strong>生成器(generator)</strong> 。所有的生成器都是异步的；当调用它们的时候，会返回一个生成器对象，而不是一个执行完的结果。 <a href="mailto:`@gen.coroutine" target="_blank" rel="noopener">`@gen.coroutine</a><code>装饰器通过</code>yield<code>表达式和生成器进行交流，而且通过返回一个 [</code>Future`](<a href="http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future" target="_blank" rel="noopener">http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future</a>) 与协程的调用方进行交互。</p><p>下面是一个协程装饰器内部循环的简单版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Simplified inner loop of tornado.gen.Runner</span><br><span class="line">def run(self):</span><br><span class="line">    # send(x) makes the current yield return x.</span><br><span class="line">    # It returns when the next yield is reached</span><br><span class="line">    future = self.gen.send(self.next)</span><br><span class="line">    def callback(f):</span><br><span class="line">        self.next = f.result()</span><br><span class="line">        self.run()</span><br><span class="line">    future.add_done_callback(callback)</span><br></pre></td></tr></table></figure><p>装饰器从生成器接收一个 <a href="http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future" target="_blank" rel="noopener"><code>Future</code></a> 对象，等待(非阻塞的)这个 <a href="http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future" target="_blank" rel="noopener"><code>Future</code></a> 对象执行完成，然后“解开(unwraps)” 这个 <a href="http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future" target="_blank" rel="noopener"><code>Future</code></a> 对象，并把结果作为 <code>yield</code> 表达式的结果传回给生成器。大多数异步代码从来不会直接接触 <a href="http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future" target="_blank" rel="noopener"><code>Future</code></a> 类 除非 <a href="http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future" target="_blank" rel="noopener"><code>Future</code></a> 立即通过异步函数返回给 <code>yield</code> 表达式。</p><h3 id="如何调用协程"><a href="#如何调用协程" class="headerlink" title="如何调用协程"></a>如何调用协程</h3><p>协程一般不会抛出异常：它们抛出的任何异常将被 <a href="http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future" target="_blank" rel="noopener"><code>Future</code></a> 捕获直到它被得到，这意味着用正确的方式调用协程是重要的，否则你可能有被忽略的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@gen.coroutine</span><br><span class="line">def divide(x, y):</span><br><span class="line">    return x / y</span><br><span class="line"></span><br><span class="line">def bad_call():</span><br><span class="line">    # This should raise a ZeroDivisionError, but it won&apos;t because</span><br><span class="line">    # the coroutine is called incorrectly.</span><br><span class="line">    divide(1, 0)</span><br></pre></td></tr></table></figure><p>几乎所有的情况下，任何一个调用协程的函数都必须是协程它自身，并且在调用的时候使用 <code>yield</code> 关键字。当你重写超类中的方法，请参阅文档，看看协程是否支持(文档应该会写该方法 “可能是一个协程” 或者 “可能返回 一个 <a href="http://tornado-zh.readthedocs.io/zh/latest/concurrent.html#tornado.concurrent.Future" target="_blank" rel="noopener"><code>Future</code></a> ”)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@gen.coroutine</span><br><span class="line">def good_call():</span><br><span class="line">    # yield will unwrap the Future returned by divide() and raise</span><br><span class="line">    # the exception.</span><br><span class="line">    yield divide(1, 0)</span><br></pre></td></tr></table></figure><p>有时你可能想要对一个协程”一劳永逸”而且不等待它的结果。在这种情况下，建议使用 <a href="http://tornado-zh.readthedocs.io/zh/latest/ioloop.html#tornado.ioloop.IOLoop.spawn_callback" target="_blank" rel="noopener"><code>IOLoop.spawn_callback</code></a> ，它使得 <a href="http://tornado-zh.readthedocs.io/zh/latest/ioloop.html#tornado.ioloop.IOLoop" target="_blank" rel="noopener"><code>IOLoop</code></a> 负责调用。如果它失败了， <a href="http://tornado-zh.readthedocs.io/zh/latest/ioloop.html#tornado.ioloop.IOLoop" target="_blank" rel="noopener"><code>IOLoop</code></a> 会在日志中把调用栈记录下来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># The IOLoop will catch the exception and print a stack trace in</span><br><span class="line"># the logs. Note that this doesn&apos;t look like a normal call, since</span><br><span class="line"># we pass the function object to be called by the IOLoop.</span><br><span class="line">IOLoop.current().spawn_callback(divide, 1, 0)</span><br></pre></td></tr></table></figure><p>如果函数使用了 <a href="mailto:`@gen.coroutine" target="_blank" rel="noopener">`@gen.coroutine</a><code>，则推荐以上方式使用 [</code>IOLoop.spawn_callback<code>](http://www.tornadoweb.org/en/stable/ioloop.html#tornado.ioloop.IOLoop.spawn_callback) ，但如果函数使用</code>async def` ，则必须使用以上方式(否则协程不会运行)。</p><p>最后，在程序顶层，如果 IOLoop 尚未运行，你可以启动 <a href="http://tornado-zh.readthedocs.io/zh/latest/ioloop.html#tornado.ioloop.IOLoop" target="_blank" rel="noopener"><code>IOLoop</code></a> 执行协程，然后使用 <a href="http://tornado-zh.readthedocs.io/zh/latest/ioloop.html#tornado.ioloop.IOLoop.run_sync" target="_blank" rel="noopener"><code>IOLoop.run_sync</code></a> 方法停止 <a href="http://tornado-zh.readthedocs.io/zh/latest/ioloop.html#tornado.ioloop.IOLoop" target="_blank" rel="noopener"><code>IOLoop</code></a> 。这通常被用来启动面向批处理程序的 <code>main</code> 函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># run_sync() doesn&apos;t take arguments, so we must wrap the</span><br><span class="line"># call in a lambda.</span><br><span class="line">IOLoop.current().run_sync(lambda: divide(1, 0))</span><br></pre></td></tr></table></figure><h3 id="协程模式"><a href="#协程模式" class="headerlink" title="协程模式"></a>协程模式</h3><h4 id="调用阻塞函数"><a href="#调用阻塞函数" class="headerlink" title="调用阻塞函数"></a>调用阻塞函数</h4><p>从一个协程调用阻塞函数最简单的方式是使用 <code>IOLoop.run_in_executor</code> ，它将返回和协程兼容的<code>Futures</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@gen.coroutine</span><br><span class="line">def call_blocking():</span><br><span class="line">    yield IOLoop.current().run_in_executor(blocking_func, args)</span><br></pre></td></tr></table></figure><h4 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h4><p>协程装饰器能识别列表或者字典对象中各自的 <code>Futures</code> ，并且并行的等待这些 <code>Futures</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@gen.coroutine</span><br><span class="line">def parallel_fetch(url1, url2):</span><br><span class="line">    resp1, resp2 = yield [http_client.fetch(url1),</span><br><span class="line">                          http_client.fetch(url2)]</span><br><span class="line"></span><br><span class="line">@gen.coroutine</span><br><span class="line">def parallel_fetch_many(urls):</span><br><span class="line">    responses = yield [http_client.fetch(url) for url in urls]</span><br><span class="line">    # responses is a list of HTTPResponses in the same order</span><br><span class="line"></span><br><span class="line">@gen.coroutine</span><br><span class="line">def parallel_fetch_dict(urls):</span><br><span class="line">    responses = yield &#123;url: http_client.fetch(url)</span><br><span class="line">                        for url in urls&#125;</span><br><span class="line">    # responses is a dict &#123;url: HTTPResponse&#125;</span><br></pre></td></tr></table></figure><p>如果使用 <code>await</code> 关键字，列表和字典必须使用 <a href="http://www.tornadoweb.org/en/stable/gen.html#tornado.gen.multi" target="_blank" rel="noopener"><code>tornado.gen.multi</code></a> 包装起来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">async def parallel_fetch(url1, url2):</span><br><span class="line">    resp1, resp2 = await gen.multi([http_client.fetch(url1),</span><br><span class="line">                                    http_client.fetch(url2)])</span><br></pre></td></tr></table></figure><h4 id="交叉存取"><a href="#交叉存取" class="headerlink" title="交叉存取"></a>交叉存取</h4><p>有时候我们需要保存<code>Future</code> 而不是立即返回，所以可以在等待之前执行其他操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@gen.coroutine</span><br><span class="line">def get(self):</span><br><span class="line">    fetch_future = self.fetch_next_chunk()</span><br><span class="line">    while True:</span><br><span class="line">        chunk = yield fetch_future</span><br><span class="line">        if chunk is None: break</span><br><span class="line">        self.write(chunk)</span><br><span class="line">        fetch_future = self.fetch_next_chunk()</span><br><span class="line">        yield self.flush()</span><br></pre></td></tr></table></figure><p>这种模式最适用于 <a href="mailto:`@gen.coroutine" target="_blank" rel="noopener">`@gen.coroutine</a><code>，如果</code>fetch_next_chunk()<code>使用</code>async def<code>，则必须如下调用：</code>fetch_future = tornado.gen.convert_yielded(self.fetch_next_chunk())`才能启动后台进程。</p><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>在原生协程中，可以使用<code>aysnc for</code> 。在老版本的Python中，协程的循环是棘手的，因为没有办法在 <code>for</code> 循环或者 <code>while</code> 循环 <code>yield</code> 迭代器，并且捕获 yield 的结果。相反，你需要将循环条件从访问结果中分离出来，下面是一个使用 <a href="http://motor.readthedocs.org/en/stable/" target="_blank" rel="noopener">Motor</a> 的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import motor</span><br><span class="line">db = motor.MotorClient().test</span><br><span class="line"></span><br><span class="line">@gen.coroutine</span><br><span class="line">def loop_example(collection):</span><br><span class="line">    cursor = db.collection.find()</span><br><span class="line">    while (yield cursor.fetch_next):</span><br><span class="line">        doc = cursor.next_object()</span><br></pre></td></tr></table></figure><h4 id="在后台运行"><a href="#在后台运行" class="headerlink" title="在后台运行"></a>在后台运行</h4><p><a href="http://tornado-zh.readthedocs.io/zh/latest/ioloop.html#tornado.ioloop.PeriodicCallback" target="_blank" rel="noopener"><code>PeriodicCallback</code></a> 通常不使用协程。相反，一个协程可以包含一个 <code>while True:</code> 循环并使用<a href="http://tornado-zh.readthedocs.io/zh/latest/gen.html#tornado.gen.sleep" target="_blank" rel="noopener"><code>tornado.gen.sleep</code></a> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@gen.coroutine</span><br><span class="line">def minute_loop():</span><br><span class="line">    while True:</span><br><span class="line">        yield do_something()</span><br><span class="line">        yield gen.sleep(60)</span><br><span class="line"></span><br><span class="line"># Coroutines that loop forever are generally started with</span><br><span class="line"># spawn_callback().</span><br><span class="line">IOLoop.current().spawn_callback(minute_loop)</span><br></pre></td></tr></table></figure><p>有时可能会遇到一个更复杂的循环。例如，上一个循环运行每次花费 <code>60+N</code> 秒，其中 <code>N</code> 是 <code>do_something()</code> 花费的时间。为了 准确的每60秒运行，使用上面的交叉模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@gen.coroutine</span><br><span class="line">def minute_loop2():</span><br><span class="line">    while True:</span><br><span class="line">        nxt = gen.sleep(60)   # Start the clock.</span><br><span class="line">        yield do_something()  # Run while the clock is ticking.</span><br><span class="line">        yield nxt             # Wait for the timer to run out.</span><br></pre></td></tr></table></figure><p>Read More:</p><blockquote><p><a href="http://www.tornadoweb.org/en/stable/guide/coroutines.html" target="_blank" rel="noopener">Coroutines</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Tornado中推荐使用 &lt;strong&gt;协程&lt;/strong&gt; 编写异步代码，协程使用了Python的 &lt;code&gt;yield&lt;/code&gt; 关键字代替链式回调来将程序挂起和恢复执行(像在 &lt;a href=&quot;http://www.gevent.org/&quot; target=&quot;
      
    
    </summary>
    
      <category term="Tornado" scheme="http://runnerliu.github.io/categories/Tornado/"/>
    
    
      <category term="Tornado" scheme="http://runnerliu.github.io/tags/Tornado/"/>
    
      <category term="翻译文档" scheme="http://runnerliu.github.io/tags/%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3/"/>
    
      <category term="协程" scheme="http://runnerliu.github.io/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Requests库 - 会话对象</title>
    <link href="http://runnerliu.github.io/2018/06/10/requests-session/"/>
    <id>http://runnerliu.github.io/2018/06/10/requests-session/</id>
    <published>2018-06-10T14:01:44.000Z</published>
    <updated>2020-11-15T02:24:39.479Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>一个简单的需求是，向一个 host 地址+端口定时 post 一定量数据，程序使用 <a href="http://www.python-requests.org/en/master/" target="_blank" rel="noopener">requests</a> 的 post 方式，傻瓜式同步执行，因为没有时间限制。但是在执行后出现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TimeoutError: [Errno 110] Connection timed out</span><br></pre></td></tr></table></figure><p>显示连接超时了，程序每次运行 post 了大概500条数据，而这个错误只会出现一次，猜测可能是 HTTP 短连接的问题。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>其实对于     向同一主机发送多个请求 这种场景，使用 HTTP 的长连接效率会更高，复用底层的 TCP 连接。Requests 库同样提供了这样的方式，即会话对象 - <a href="http://www.python-requests.org/en/master/user/advanced/#session-objects" target="_blank" rel="noopener">Session</a> ，使用方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = requests.Session()</span><br><span class="line">r = s.get(&apos;http://www.baidu.com&apos;)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure><p><a href="http://docs.python-requests.org/en/master/_modules/requests/adapters/?highlight=HTTPAdapter" target="_blank" rel="noopener">源码</a>如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Session(SessionRedirectMixin):</span><br><span class="line"> </span><br><span class="line">    def __init__(self):</span><br><span class="line">        ...</span><br><span class="line">        self.max_redirects = DEFAULT_REDIRECT_LIMIT</span><br><span class="line">        self.cookies = cookiejar_from_dict(&#123;&#125;)</span><br><span class="line">        self.adapters = OrderedDict()</span><br><span class="line">        self.mount(&apos;https://&apos;, HTTPAdapter())</span><br><span class="line">        self.mount(&apos;http://&apos;, HTTPAdapter())</span><br><span class="line">        self.redirect_cache = RecentlyUsedContainer(REDIRECT_CACHE_SIZE)</span><br><span class="line"> </span><br><span class="line">class HTTPAdapter(BaseAdapter):</span><br><span class="line"> </span><br><span class="line">    def __init__(self, pool_connections=DEFAULT_POOLSIZE,</span><br><span class="line">                 pool_maxsize=DEFAULT_POOLSIZE, max_retries=DEFAULT_RETRIES,</span><br><span class="line">                 pool_block=DEFAULT_POOLBLOCK):</span><br><span class="line">        if max_retries == DEFAULT_RETRIES:</span><br><span class="line">            self.max_retries = Retry(0, read=False)</span><br><span class="line">        else:</span><br><span class="line">            self.max_retries = Retry.from_int(max_retries)</span><br><span class="line">        self.config = &#123;&#125;</span><br><span class="line">        self.proxy_manager = &#123;&#125;</span><br><span class="line"> </span><br><span class="line">        super(HTTPAdapter, self).__init__()</span><br><span class="line"> </span><br><span class="line">        self._pool_connections = pool_connections</span><br><span class="line">        self._pool_maxsize = pool_maxsize</span><br><span class="line">        self._pool_block = pool_block</span><br><span class="line">        self.init_poolmanager(pool_connections, pool_maxsize, block=pool_block) </span><br><span class="line"> </span><br><span class="line">DEFAULT_POOLBLOCK = False  #是否阻塞连接池</span><br><span class="line">DEFAULT_POOLSIZE = 10  # 默认连接池</span><br><span class="line">DEFAULT_RETRIES = 0   # 默认重试次数</span><br><span class="line">DEFAULT_POOL_TIMEOUT = None  # 超时时间</span><br></pre></td></tr></table></figure><p>默认情况下，Session 连接池大小为10，请求失败重试次数为0，但是一般情况下我们会需要稍大容量的连接池，从源码中可以看到，session 绑定了 <code>HTTPAdapter</code> 对象，所以我们可以自定义一个符合预期参数的 <code>HTTPAdapter</code> 对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def get_http_session(self, pool_connections, pool_maxsize, max_retries):</span><br><span class="line">    session = requests.Session()</span><br><span class="line">    # 创建一个适配器，连接池的数量pool_connections, 最大数量pool_maxsize, 失败重试的次数max_retries</span><br><span class="line">    adapter = requests.adapters.HTTPAdapter(pool_connections = pool_connections,</span><br><span class="line">            pool_maxsize = pool_maxsize, max_retries = max_retries)</span><br><span class="line">    # 告诉requests，http协议和https协议都使用这个适配器</span><br><span class="line">    session.mount(&apos;http://&apos;, adapter)</span><br><span class="line">    session.mount(&apos;https://&apos;, adapter)</span><br><span class="line">    return session</span><br></pre></td></tr></table></figure><p>然后就可以使用 session 的各个功能了。So Easy!</p><p>Read More:</p><blockquote><p><a href="http://www.python-requests.org/en/master/user/advanced/#session-objects" target="_blank" rel="noopener">Advanced Usage</a> </p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题背景&quot;&gt;&lt;a href=&quot;#问题背景&quot; class=&quot;headerlink&quot; title=&quot;问题背景&quot;&gt;&lt;/a&gt;问题背景&lt;/h3&gt;&lt;p&gt;一个简单的需求是，向一个 host 地址+端口定时 post 一定量数据，程序使用 &lt;a href=&quot;http://www.
      
    
    </summary>
    
      <category term="requests" scheme="http://runnerliu.github.io/categories/requests/"/>
    
    
      <category term="requests" scheme="http://runnerliu.github.io/tags/requests/"/>
    
      <category term="session" scheme="http://runnerliu.github.io/tags/session/"/>
    
      <category term="会话对象" scheme="http://runnerliu.github.io/tags/%E4%BC%9A%E8%AF%9D%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Tornado5.0.2翻译文档 - 异步和非阻塞I/O</title>
    <link href="http://runnerliu.github.io/2018/06/10/tornado502-asnon/"/>
    <id>http://runnerliu.github.io/2018/06/10/tornado502-asnon/</id>
    <published>2018-06-10T13:09:37.000Z</published>
    <updated>2020-11-15T02:24:39.481Z</updated>
    
    <content type="html"><![CDATA[<p>实时web功能需要为每个用户提供一个多数时间被闲置的长连接，在传统的同步 web 服务器中，这意味着要为每个用户提供一个线程，当然每个线程的开销都是很昂贵的。</p><p>为了尽量减少并发连接造成的开销，Tornado 使用了一种单线程事件循环的方式。这就意味着所有的应用代码都应该是异步非阻塞的，因为在同一时间只有一个操作是有效的。</p><p>异步和非阻塞是非常相关的并且这两个术语经常交换使用，但它们不是完全相同的事情。</p><h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>一个函数在等待某些事情返回值的时候会被阻塞，导致函数阻塞的原因有很多：网络 I/O，磁盘 I/O，互斥锁等。事实上每个函数在运行和使用 CPU 的时候都或多或少被阻塞(举个极端的例子来说明为什么对待 CPU 阻塞要和对待一般阻塞一样的严肃：比如密码哈希函数 <a href="http://bcrypt.sourceforge.net/" target="_blank" rel="noopener">bcrypt</a> ，需要消耗几百毫秒的 CPU 时间，这已 经远远超过了一般的网络或者磁盘请求时间了)。</p><p>一个函数可以在某个方面被阻塞但在其他方面不被阻塞，在 Tornado 的上下文中，我们一般讨论网络 I/O 上下文的阻塞，尽管各种阻塞已经被最小化。</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>异步函数在会在其完成之前返回，在应用中触发下一个动作之前通常会在后台执行一些工作(和正常的同步函数在返回前就执行完所有的事情不同)。这里列举了几种不同的异步接口：</p><ul><li>回调参数；</li><li>返回一个占位符(<a href><code>Future</code></a> <a href><code>Promise</code></a> <a href><code>Deferred</code></a>)；</li><li>传送给一个队列；</li><li>回调注册表(POSIX 信号)。</li></ul><p>不论使用哪种类型的接口，按照定义，异步函数与他们的调用者都有着不同的交互方式；也没有什么对调用者透明的方式使得同步函数变得异步(类似 <a href="http://www.gevent.org/" target="_blank" rel="noopener">gevent</a> 使用轻量级线程的系统性能虽然堪比异步系统，但它们并没有真正的让事情异步)。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>这是一个简单的同步函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from tornado.httpclient import HTTPClient</span><br><span class="line"></span><br><span class="line">def synchronous_fetch(url):</span><br><span class="line">    http_client = HTTPClient()</span><br><span class="line">    response = http_client.fetch(url)</span><br><span class="line">    return response.body</span><br></pre></td></tr></table></figure><p>下面是使用回调参数重写的具有同样功能的异步函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from tornado.httpclient import AsyncHTTPClient</span><br><span class="line"></span><br><span class="line">def asynchronous_fetch(url, callback):</span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    def handle_response(response):</span><br><span class="line">        callback(response.body)</span><br><span class="line">    http_client.fetch(url, callback=handle_response)</span><br></pre></td></tr></table></figure><p>使用 <a href><code>Future</code></a> 代替回调：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from tornado.concurrent import Future</span><br><span class="line">from tornado.httpclient import AsyncHTTPClient</span><br><span class="line"></span><br><span class="line">def async_fetch_future(url):</span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    my_future = Future()</span><br><span class="line">    fetch_future = http_client.fetch(url)</span><br><span class="line">    fetch_future.add_done_callback(</span><br><span class="line">        lambda f: my_future.set_result(f.result()))</span><br><span class="line">    return my_future</span><br></pre></td></tr></table></figure><p><a href><code>Future</code></a> 版本更加复杂，但是 <a href><code>Futures</code></a> 却是 Tornado 中推荐的写法，因为它有两个主要的优势：一是错误处理更加一致，<a href><code>Future.result</code></a> 方法可以简单的抛出异常(相较于常见的回调函数接口中需特别指定错误处理方式)，二是 <a href><code>Futures</code></a> 很适合与协程一起使用。我们稍后会更加深入的讨论协程，以下是例子的协程版本，类似原始的同步版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from tornado import gen</span><br><span class="line"></span><br><span class="line">@gen.coroutine</span><br><span class="line">def fetch_coroutine(url):</span><br><span class="line">    http_client = AsyncHTTPClient()</span><br><span class="line">    response = yield http_client.fetch(url)</span><br><span class="line">    raise gen.Return(response.body)</span><br></pre></td></tr></table></figure><p><code>raise gen.Return(response.body)</code> 声明是在 Python 2 环境下人为执行的，因为生成器不允许有返回值，为了解决这个问题，Tornado 的协程抛出了一种称为 <code>Return</code> 的异常，协程捕获这个异常并将其作为返回值。在 Python 3.3+版本，使用 <code>return response.body</code> 可以得到相同的结果。</p><p>Read More:</p><blockquote><p><a href="http://www.tornadoweb.org/en/stable/guide/async.html" target="_blank" rel="noopener">Asynchronous and non-Blocking I/O</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实时web功能需要为每个用户提供一个多数时间被闲置的长连接，在传统的同步 web 服务器中，这意味着要为每个用户提供一个线程，当然每个线程的开销都是很昂贵的。&lt;/p&gt;
&lt;p&gt;为了尽量减少并发连接造成的开销，Tornado 使用了一种单线程事件循环的方式。这就意味着所有的应用
      
    
    </summary>
    
      <category term="Tornado" scheme="http://runnerliu.github.io/categories/Tornado/"/>
    
    
      <category term="Tornado" scheme="http://runnerliu.github.io/tags/Tornado/"/>
    
      <category term="翻译文档" scheme="http://runnerliu.github.io/tags/%E7%BF%BB%E8%AF%91%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
</feed>
